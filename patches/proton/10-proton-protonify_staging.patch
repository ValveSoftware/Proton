From 1091eaf13692b16ed66328ceeebfc587075fec6c Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 25 Oct 2018 12:50:45 -0500
Subject: [PATCH] HACK: wined3d: Fake an AMD card in place of Nvidia cards

Some games assume they can load the nvapi library if the hardware is an
nvidia card. This obviously fails in Wine. So fake that all nvidia
hardware is actually an AMD card, so they don't try to load nvapi.
---
 dlls/wined3d/adapter_gl.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index b8a2060cf46..8259d92ebac 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -1009,6 +1009,14 @@ static const struct wined3d_gpu_description *query_gpu_description(const struct
         vendor = wined3d_settings.pci_vendor_id;
         TRACE("Overriding vendor PCI ID with 0x%04x.\n", vendor);
     }
+    else if(vendor == HW_VENDOR_NVIDIA)
+    {
+        /* XXX: Fake having an AMD card in order to avoid games trying to load
+         * the Windows-only nvapi library. */
+        WARN("Nvidia card detected. Faking an AMD RX 480!\n");
+        vendor = HW_VENDOR_AMD;
+        device = CARD_AMD_RADEON_RX_480;
+    }

     if (wined3d_settings.pci_device_id != PCI_DEVICE_NONE)
     {

From aa7fa7ce94bd4e49e3843a8ea398d29882518e43 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 6 Aug 2018 08:06:03 -0500
Subject: [PATCH] server: Set default timeout to 0

The Steam client will be waiting for the wineserver to exit to set up
some environment variables, so make it wait as short as possible.
---
 server/main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/main.c b/server/main.c
index 20d3c48c4d9..aca8738c4c0 100644
--- a/server/main.c
+++ b/server/main.c
@@ -42,7 +42,7 @@
 /* command-line options */
 int debug_level = 0;
 int foreground = 0;
-timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
+timeout_t master_socket_timeout = 0; /* master socket timeout, default is 3 seconds */
 const char *server_argv0;

 /* parse-line args */

From ba15ba1c9b8ee40e13ef1bd7f018924259f36c1b Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 18 Jun 2018 07:56:35 -0500
Subject: [PATCH] ntdll: Notice THREADNAME_INFO exceptions and set thread name
 on Linux

Patch by Zeb.
---
 dlls/ntdll/unix/thread.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 3b451a22577..ca5dac43bb0 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -43,6 +43,9 @@
 #ifdef HAVE_SYS_SYSCALL_H
 #include <sys/syscall.h>
 #endif
+#ifdef HAVE_PRCTL
+#include <sys/prctl.h>
+#endif

 #define NONAMELESSUNION
 #include "ntstatus.h"
@@ -344,6 +347,16 @@ void wait_suspend( CONTEXT *context )
 }


+/* "How to: Set a Thread Name in Native Code"
+ * https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx */
+typedef struct tagTHREADNAME_INFO
+{
+   DWORD   dwType;     /* Must be 0x1000 */
+   LPCSTR  szName;     /* Pointer to name - limited to 9 bytes (8 characters + terminator) */
+   DWORD   dwThreadID; /* Thread ID (-1 = caller thread) */
+   DWORD   dwFlags;    /* Reserved for future use.  Must be zero. */
+} THREADNAME_INFO;
+
 /**********************************************************************
  *           send_debug_event
  *
@@ -366,6 +379,21 @@ NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_c
     for (i = 0; i < min( rec->NumberParameters, EXCEPTION_MAXIMUM_PARAMETERS ); i++)
         params[i] = rec->ExceptionInformation[i];

+    if (rec->ExceptionCode == 0x406d1388)
+    {
+        const THREADNAME_INFO *threadname = (const THREADNAME_INFO *)rec->ExceptionInformation;
+
+        if (threadname->dwThreadID == -1)
+        {
+#ifdef HAVE_PRCTL
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+            prctl( PR_SET_NAME, threadname->szName );
+#endif
+        }
+    }
+
     SERVER_START_REQ( queue_exception_event )
     {
         req->first   = first_chance;
From 90e3616c89ef7ed38763a3e3af3e9f0cd59697da Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Mar 2017 20:15:40 +0300
Subject: [PATCH] HACK: dwrite: Don't recommend outline rendering mode

---
 dlls/dwrite/font.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/dwrite/font.c b/dlls/dwrite/font.c
index e22559912c3..41ec809b727 100644
--- a/dlls/dwrite/font.c
+++ b/dlls/dwrite/font.c
@@ -740,7 +740,8 @@ static HRESULT WINAPI dwritefontface_GetRecommendedRenderingMode(IDWriteFontFace

     ppem = emSize * ppdip;

-    if (ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
+    /* HACK: disable outline rendering mode to workaround d2d issue */
+    if (0 && ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
         *mode = DWRITE_RENDERING_MODE_OUTLINE;
         return S_OK;
     }
From 5c59517008697ce74becddb59a3e6702a963bb49 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Fri, 16 Aug 2019 09:46:25 +0000
Subject: [PATCH] msctf: Use list to keep thread managers.

Thread managers were stored in thread local storage,
which have a major flaw that they can't not be released
by another thread.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/msctf/msctf.c          | 46 +++++++----------------
 dlls/msctf/msctf_internal.h |  1 -
 dlls/msctf/threadmgr.c      | 73 ++++++++++++++++++++++++++++++++-----
 3 files changed, 76 insertions(+), 44 deletions(-)

diff --git a/dlls/msctf/msctf.c b/dlls/msctf/msctf.c
index c6e3a2ca597..fd919295c5a 100644
--- a/dlls/msctf/msctf.c
+++ b/dlls/msctf/msctf.c
@@ -69,7 +69,6 @@ static UINT array_size;
 static struct list AtsList = LIST_INIT(AtsList);
 static UINT activated = 0;

-DWORD tlsIndex = 0;
 TfClientId processId = 0;
 ITfCompartmentMgr *globalCompartmentMgr = NULL;

@@ -397,23 +396,19 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
     ActivatedTextService *actsvr;
     ITfCategoryMgr *catmgr;
     AtsEntry *entry;
-    ITfThreadMgrEx *tm = TlsGetValue(tlsIndex);
+    ITfThreadMgr *tm;
     ITfClientId *clientid;

-    if (!tm) return E_UNEXPECTED;
+    if (FAILED(TF_GetThreadMgr(&tm))) return E_UNEXPECTED;

     actsvr = HeapAlloc(GetProcessHeap(),0,sizeof(ActivatedTextService));
-    if (!actsvr) return E_OUTOFMEMORY;
+    if (!actsvr) goto fail;

-    ITfThreadMgrEx_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
+    ITfThreadMgr_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
     ITfClientId_GetClientId(clientid, &lp->clsid, &actsvr->tid);
     ITfClientId_Release(clientid);

-    if (!actsvr->tid)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!actsvr->tid) goto fail;

     actsvr->pITfTextInputProcessor = NULL;
     actsvr->LanguageProfile = *lp;
@@ -440,20 +435,21 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
         deactivate_remove_conflicting_ts(&actsvr->LanguageProfile.catid);

     if (activated > 0)
-        activate_given_ts(actsvr, tm);
+        activate_given_ts(actsvr, (ITfThreadMgrEx *)tm);

     entry = HeapAlloc(GetProcessHeap(),0,sizeof(AtsEntry));
-
-    if (!entry)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!entry) goto fail;

     entry->ats = actsvr;
     list_add_head(&AtsList, &entry->entry);

+    ITfThreadMgr_Release(tm);
     return S_OK;
+
+fail:
+    ITfThreadMgr_Release(tm);
+    HeapFree(GetProcessHeap(), 0, actsvr);
+    return E_OUTOFMEMORY;
 }

 BOOL get_active_textservice(REFCLSID rclsid, TF_LANGUAGEPROFILE *profile)
@@ -560,11 +556,9 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD fdwReason, LPVOID fImpLoad)
     switch (fdwReason)
     {
         case DLL_PROCESS_ATTACH:
-            tlsIndex = TlsAlloc();
             break;
         case DLL_PROCESS_DETACH:
             if (fImpLoad) break;
-            TlsFree(tlsIndex);
             break;
     }
     return TRUE;
@@ -622,20 +616,6 @@ HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim)
     return ThreadMgr_Constructor(NULL,(IUnknown**)pptim);
 }

-/***********************************************************************
- *              TF_GetThreadMgr (MSCTF.@)
- */
-HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
-{
-    TRACE("\n");
-    *pptim = TlsGetValue(tlsIndex);
-
-    if (*pptim)
-        ITfThreadMgr_AddRef(*pptim);
-
-    return S_OK;
-}
-
 /***********************************************************************
  *              SetInputScope(MSCTF.@)
  */
diff --git a/dlls/msctf/msctf_internal.h b/dlls/msctf/msctf_internal.h
index 584bb1044ed..ace2bee23d9 100644
--- a/dlls/msctf/msctf_internal.h
+++ b/dlls/msctf/msctf_internal.h
@@ -35,7 +35,6 @@
 #define COOKIE_MAGIC_UIELEMENTSINK 0x00a0
 #define COOKIE_MAGIC_INPUTPROCESSORPROFILEACTIVATIONSINK 0x00b0

-extern DWORD tlsIndex DECLSPEC_HIDDEN;
 extern TfClientId processId DECLSPEC_HIDDEN;
 extern ITfCompartmentMgr *globalCompartmentMgr DECLSPEC_HIDDEN;

diff --git a/dlls/msctf/threadmgr.c b/dlls/msctf/threadmgr.c
index 2c208fbc04f..2119ea2193b 100644
--- a/dlls/msctf/threadmgr.c
+++ b/dlls/msctf/threadmgr.c
@@ -37,6 +37,17 @@

 WINE_DEFAULT_DEBUG_CHANNEL(msctf);

+static CRITICAL_SECTION ThreadMgrCs;
+static CRITICAL_SECTION_DEBUG ThreadMgrCsDebug =
+{
+    0, 0, &ThreadMgrCs,
+    {&ThreadMgrCsDebug.ProcessLocksList,
+     &ThreadMgrCsDebug.ProcessLocksList },
+     0, 0, {(DWORD_PTR)(__FILE__ ": ThreadMgrCs")}
+};
+static CRITICAL_SECTION ThreadMgrCs = {&ThreadMgrCsDebug, -1, 0, 0, 0, 0};
+struct list ThreadMgrList = LIST_INIT(ThreadMgrList);
+
 typedef struct tagPreservedKey
 {
     struct list     entry;
@@ -98,6 +109,9 @@ typedef struct tagACLMulti {
     struct list     ThreadMgrEventSink;
     struct list     UIElementSink;
     struct list     InputProcessorProfileActivationSink;
+
+    DWORD threadId;
+    struct list entry;
 } ThreadMgr;

 typedef struct tagEnumTfDocumentMgr {
@@ -110,6 +124,11 @@ typedef struct tagEnumTfDocumentMgr {

 static HRESULT EnumTfDocumentMgr_Constructor(struct list* head, IEnumTfDocumentMgrs **ppOut);

+static inline ThreadMgr *impl_from_ITfThreadMgr(ITfThreadMgr *iface)
+{
+    return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
+}
+
 static inline ThreadMgr *impl_from_ITfThreadMgrEx(ITfThreadMgrEx *iface)
 {
     return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
@@ -155,6 +174,35 @@ static inline EnumTfDocumentMgr *impl_from_IEnumTfDocumentMgrs(IEnumTfDocumentMg
     return CONTAINING_RECORD(iface, EnumTfDocumentMgr, IEnumTfDocumentMgrs_iface);
 }

+/***********************************************************************
+ *              TF_GetThreadMgr (MSCTF.@)
+ */
+HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
+{
+    DWORD id = GetCurrentThreadId();
+    ThreadMgr *cursor;
+
+    TRACE("%p\n", pptim);
+
+    if (!pptim)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&ThreadMgrCs);
+    LIST_FOR_EACH_ENTRY(cursor, &ThreadMgrList, ThreadMgr, entry)
+    {
+        if (cursor->threadId == id)
+        {
+            ITfThreadMgrEx_AddRef(&cursor->ITfThreadMgrEx_iface);
+            *pptim = (ITfThreadMgr *)&cursor->ITfThreadMgrEx_iface;
+            LeaveCriticalSection(&ThreadMgrCs);
+            return S_OK;
+        }
+    }
+    LeaveCriticalSection(&ThreadMgrCs);
+    *pptim = NULL;
+    return E_FAIL;
+}
+
 static void ThreadMgr_Destructor(ThreadMgr *This)
 {
     struct list *cursor, *cursor2;
@@ -163,7 +211,9 @@ static void ThreadMgr_Destructor(ThreadMgr *This)
     if (This->focusHook)
         UnhookWindowsHookEx(This->focusHook);

-    TlsSetValue(tlsIndex,NULL);
+    EnterCriticalSection(&ThreadMgrCs);
+    list_remove(&This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
     TRACE("destroying %p\n", This);
     if (This->focus)
         ITfDocumentMgr_Release(This->focus);
@@ -386,17 +436,20 @@ static HRESULT WINAPI ThreadMgr_SetFocus(ITfThreadMgrEx *iface, ITfDocumentMgr *

 static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lParam)
 {
+    ITfThreadMgr *ThreadMgr_iface;
     ThreadMgr *This;

-    This = TlsGetValue(tlsIndex);
-    if (!This)
+    if (FAILED(TF_GetThreadMgr(&ThreadMgr_iface)))
     {
         ERR("Hook proc but no ThreadMgr for this thread. Serious Error\n");
         return 0;
     }
+
+    This = impl_from_ITfThreadMgr(ThreadMgr_iface);
     if (!This->focusHook)
     {
         ERR("Hook proc but no ThreadMgr focus Hook. Serious Error\n");
+        ITfThreadMgr_Release(ThreadMgr_iface);
         return 0;
     }

@@ -417,6 +470,7 @@ static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lPa
         }
     }

+    ITfThreadMgr_Release(ThreadMgr_iface);
     return CallNextHookEx(This->focusHook, nCode, wParam, lParam);
 }

@@ -1338,13 +1392,8 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
         return CLASS_E_NOAGGREGATION;

     /* Only 1 ThreadMgr is created per thread */
-    This = TlsGetValue(tlsIndex);
-    if (This)
-    {
-        ThreadMgr_AddRef(&This->ITfThreadMgrEx_iface);
-        *ppOut = (IUnknown*)&This->ITfThreadMgrEx_iface;
+    if (SUCCEEDED(TF_GetThreadMgr((ITfThreadMgr **)ppOut)))
         return S_OK;
-    }

     This = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(ThreadMgr));
     if (This == NULL)
@@ -1359,7 +1408,6 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     This->ITfUIElementMgr_iface.lpVtbl = &ThreadMgrUIElementMgrVtbl;
     This->ITfSourceSingle_iface.lpVtbl = &SourceSingleVtbl;
     This->refCount = 1;
-    TlsSetValue(tlsIndex,This);

     CompartmentMgr_Constructor((IUnknown*)&This->ITfThreadMgrEx_iface, &IID_IUnknown, (IUnknown**)&This->CompartmentMgr);

@@ -1376,6 +1424,11 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     list_init(&This->UIElementSink);
     list_init(&This->InputProcessorProfileActivationSink);

+    This->threadId = GetCurrentThreadId();
+    EnterCriticalSection(&ThreadMgrCs);
+    list_add_tail(&ThreadMgrList, &This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
+
     TRACE("returning %p\n", This);
     *ppOut = (IUnknown *)&This->ITfThreadMgrEx_iface;
     return S_OK;
From ed04e35d3f7af02267fb4e21578b3ccb27703836 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 23 Sep 2019 13:29:16 -0500
Subject: [PATCH] dxdiag: Dump to stdout if no filename is given

---
 programs/dxdiag/main.c   |  8 +++++++-
 programs/dxdiag/output.c | 10 +++++++---
 2 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/programs/dxdiag/main.c b/programs/dxdiag/main.c
index 4533236f0f5..353e9f50fb9 100644
--- a/programs/dxdiag/main.c
+++ b/programs/dxdiag/main.c
@@ -71,7 +71,13 @@ static BOOL process_file_name(const WCHAR *cmdline, enum output_type output_type
         endptr = cmdline + lstrlenW(cmdline);

     len = endptr - cmdline;
-    if (len == 0 || len >= filename_len)
+    if (len == 0)
+    {
+        *filename = 0;
+        return TRUE;
+    }
+
+    if (len >= filename_len)
         return FALSE;

     memcpy(filename, cmdline, len * sizeof(WCHAR));
diff --git a/programs/dxdiag/output.c b/programs/dxdiag/output.c
index 50240fb2860..f0f6a6da0c3 100644
--- a/programs/dxdiag/output.c
+++ b/programs/dxdiag/output.c
@@ -169,8 +169,12 @@ static BOOL output_text_information(struct dxdiag_information *dxdiag_info, cons

     fill_system_text_output_table(dxdiag_info, output_table[0].fields);

-    hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
-                        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (filename && *filename)
+        hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    else
+        hFile = GetStdHandle(STD_OUTPUT_HANDLE);
+
     if (hFile == INVALID_HANDLE_VALUE)
     {
         WINE_ERR("File creation failed, last error %u\n", GetLastError());
@@ -227,7 +231,7 @@ static HRESULT save_xml_document(IXMLDOMDocument *xmldoc, const WCHAR *filename)
     VARIANT destVar;
     HRESULT hr;

-    if (!bstr)
+    if (!bstr || !filename || !*filename)
         return E_OUTOFMEMORY;

     V_VT(&destVar) = VT_BSTR;
From e485252dfad51a7e463643d56fe138129597e4b6 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 23 Sep 2019 08:56:04 -0500
Subject: [PATCH] ntdll: Always add a tail to heap allocations.

Fixes the Rockstar Games Launcher installer (and possibly other
NSIS-based installers) from crashing due to passing a too-small buffer
to GetWindowInfo().
---
 dlls/ntdll/heap.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index 6344157f384..6fefe5d6d80 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -118,9 +118,8 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
 #define HEAP_MIN_SHRINK_SIZE  (HEAP_MIN_DATA_SIZE+sizeof(ARENA_FREE))
 /* minimum size to start allocating large blocks */
 #define HEAP_MIN_LARGE_BLOCK_SIZE  0x7f000
-/* extra size to add at the end of block for tail checking */
-#define HEAP_TAIL_EXTRA_SIZE(flags) \
-    ((flags & HEAP_TAIL_CHECKING_ENABLED) || RUNNING_ON_VALGRIND ? ALIGNMENT : 0)
+/* extra size to add at the end of block to mitigate overruns and allow tail checking */
+#define HEAP_TAIL_EXTRA_SIZE ALIGNMENT

 /* size of the blocks on the free lists */
 #define HEAP_FREELIST_SIZE(index) \
@@ -800,7 +799,7 @@ static void HEAP_ShrinkBlock(SUBHEAP *subheap, ARENA_INUSE *pArena, SIZE_T size)
 static void *allocate_large_block( HEAP *heap, DWORD flags, SIZE_T size )
 {
     ARENA_LARGE *arena;
-    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     LPVOID address = NULL;

     if (block_size < size) return NULL;  /* overflow */
@@ -1814,7 +1813,7 @@ void * WINAPI DECLSPEC_HOTPATCH RtlAllocateHeap( HANDLE heap, ULONG flags, SIZE_
     if (!heapPtr) return NULL;
     flags &= HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY;
     flags |= heapPtr->flags;
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE( flags );
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size)  /* overflow */
     {
         if (flags & HEAP_GENERATE_EXCEPTIONS) RtlRaiseStatus( STATUS_NO_MEMORY );
@@ -1968,7 +1967,7 @@ PVOID WINAPI RtlReAllocateHeap( HANDLE heap, ULONG flags, PVOID ptr, SIZE_T size
     flags |= heapPtr->flags;
     if (!(flags & HEAP_NO_SERIALIZE)) RtlEnterCriticalSection( &heapPtr->critSection );

-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size) goto oom;  /* overflow */
     if (rounded_size < HEAP_MIN_DATA_SIZE) rounded_size = HEAP_MIN_DATA_SIZE;

From 5cd65deffffad9073538acf4fd8e794ac07824a5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 9 Oct 2019 09:47:12 +0200
Subject: [PATCH] makedep: Align PE sections so they can be directly mmaped.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This should help linux perf tool match the binary files on disk with the
code regions in memory.

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
---
 tools/makedep.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/tools/makedep.c b/tools/makedep.c
index 6079d1fe28b..18e7b8a913e 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -3245,6 +3245,7 @@ static void output_module( struct makefile *make )
     output_filenames_obj_dir( make, make->res_files );
     output_filenames( all_libs );
     output_filename( make->is_cross ? "$(CROSSLDFLAGS)" : "$(LDFLAGS)" );
+    output_filename( make->is_cross ? "-Wl,--file-alignment,4096" : "" );
     output( "\n" );

     if (spec_file && make->importlib)
From 213905a322620eb326b655ab89fbca07316e6357 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 19 Nov 2019 09:59:17 -0600
Subject: [PATCH] HACK: dxgi: Return empty GPU string for Crazy Machines 3

If the GPU string is long enough, the game will crash trying to
dereference part of it. Probably this is due to missing Media Foundation
support. Try to remove this hack after the game's videos successfully
play back.
---
 dlls/dxgi/adapter.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/dlls/dxgi/adapter.c b/dlls/dxgi/adapter.c
index d2fc629c843..5a97590dbce 100644
--- a/dlls/dxgi/adapter.c
+++ b/dlls/dxgi/adapter.c
@@ -161,12 +161,32 @@ static HRESULT dxgi_adapter_get_desc(struct dxgi_adapter *adapter, DXGI_ADAPTER_
     if (FAILED(hr = wined3d_get_adapter_identifier(adapter->factory->wined3d, adapter->ordinal, 0, &adapter_id)))
         return hr;

+    {
+        /* HACK for Proton issue #3204
+         *
+         * Due to reading uninitialized memory, the game tries to dereference
+         * part of the GPU Description string if it is long enough. So return
+         * an empty string instead.
+         *
+         * See the bug report for the full description, but we may be able to
+         * remove this hack after implementing enough of Media Foundation for
+         * this game's videos to play back.
+         */
+        const char *sgi = getenv("SteamGameId");
+        if(sgi && !strcmp(sgi, "351920"))
+        {
+            desc->Description[0] = 0;
+            goto skip_description;
+        }
+    }
+
     if (!MultiByteToWideChar(CP_ACP, 0, description, -1, desc->Description, ARRAY_SIZE(description)))
     {
         DWORD err = GetLastError();
         ERR("Failed to translate description %s (%#x).\n", debugstr_a(description), err);
         hr = E_FAIL;
     }
+skip_description:

     desc->VendorId = adapter_id.vendor_id;
     desc->DeviceId = adapter_id.device_id;
From 4aa052e0c8ae276fc07afcd93d6e290a88214837 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 15 Jan 2020 10:17:23 -0600
Subject: [PATCH] dsound: Initialize primary buffer with device's channel
 layout

Fixes surround sound in some games, like Borderlands GOTY and Dead
Space.
---
 dlls/dsound/dsound.c         | 77 +-----------------------------------
 dlls/dsound/dsound_private.h |  1 -
 dlls/dsound/primary.c        | 75 ++++++++++++++++++++++++++++++++++-
 3 files changed, 76 insertions(+), 77 deletions(-)

diff --git a/dlls/dsound/dsound.c b/dlls/dsound/dsound.c
index 8e2b839fe89..630d8c7e16a 100644
--- a/dlls/dsound/dsound.c
+++ b/dlls/dsound/dsound.c
@@ -23,7 +23,6 @@
 #include <assert.h>
 #include <stdarg.h>
 #include <stdio.h>
-#include <math.h>

 #define COBJMACROS

@@ -138,9 +137,9 @@ static HRESULT DirectSoundDevice_Create(DirectSoundDevice ** ppDevice)
     device->ref            = 1;
     device->priolevel      = DSSCL_NORMAL;
     device->stopped        = 1;
-    device->speaker_config = DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_WIDE);

-    DSOUND_ParseSpeakerConfig(device);
+    device->speaker_config = 0;
+    device->num_speakers = 0;

     /* 3D listener initial parameters */
     device->ds3dl.dwSize   = sizeof(DS3DLISTENER);
@@ -1127,75 +1126,3 @@ HRESULT WINAPI DirectSoundCreate8(

     return hr;
 }
-
-void DSOUND_ParseSpeakerConfig(DirectSoundDevice *device)
-{
-    switch (DSSPEAKER_CONFIG(device->speaker_config)) {
-        case DSSPEAKER_MONO:
-            device->speaker_angles[0] = M_PI/180.0f * 0.0f;
-            device->speaker_num[0] = 0;
-            device->num_speakers = 1;
-            device->lfe_channel = -1;
-        break;
-
-        case DSSPEAKER_STEREO:
-        case DSSPEAKER_HEADPHONE:
-            device->speaker_angles[0] = M_PI/180.0f * -90.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  90.0f;
-            device->speaker_num[0] = 0; /* Left */
-            device->speaker_num[1] = 1; /* Right */
-            device->num_speakers = 2;
-            device->lfe_channel = -1;
-        break;
-
-        case DSSPEAKER_QUAD:
-            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
-            device->speaker_angles[2] = M_PI/180.0f *   45.0f;
-            device->speaker_angles[3] = M_PI/180.0f *  135.0f;
-            device->speaker_num[0] = 2; /* Rear left */
-            device->speaker_num[1] = 0; /* Front left */
-            device->speaker_num[2] = 1; /* Front right */
-            device->speaker_num[3] = 3; /* Rear right */
-            device->num_speakers = 4;
-            device->lfe_channel = -1;
-        break;
-
-        case DSSPEAKER_5POINT1_BACK:
-            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
-            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
-            device->speaker_angles[3] = M_PI/180.0f *   45.0f;
-            device->speaker_angles[4] = M_PI/180.0f *  135.0f;
-            device->speaker_angles[5] = 9999.0f;
-            device->speaker_num[0] = 4; /* Rear left */
-            device->speaker_num[1] = 0; /* Front left */
-            device->speaker_num[2] = 2; /* Front centre */
-            device->speaker_num[3] = 1; /* Front right */
-            device->speaker_num[4] = 5; /* Rear right */
-            device->speaker_num[5] = 3; /* LFE */
-            device->num_speakers = 6;
-            device->lfe_channel = 3;
-        break;
-
-        case DSSPEAKER_5POINT1_SURROUND:
-            device->speaker_angles[0] = M_PI/180.0f *  -90.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  -30.0f;
-            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
-            device->speaker_angles[3] = M_PI/180.0f *   30.0f;
-            device->speaker_angles[4] = M_PI/180.0f *   90.0f;
-            device->speaker_angles[5] = 9999.0f;
-            device->speaker_num[0] = 4; /* Rear left */
-            device->speaker_num[1] = 0; /* Front left */
-            device->speaker_num[2] = 2; /* Front centre */
-            device->speaker_num[3] = 1; /* Front right */
-            device->speaker_num[4] = 5; /* Rear right */
-            device->speaker_num[5] = 3; /* LFE */
-            device->num_speakers = 6;
-            device->lfe_channel = 3;
-        break;
-
-        default:
-            WARN("unknown speaker_config %u\n", device->speaker_config);
-    }
-}
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 69c4a2f3902..1a3e88a0d29 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -202,7 +202,6 @@ HRESULT IKsPrivatePropertySetImpl_Create(REFIID riid, void **ppv) DECLSPEC_HIDDE
 HRESULT DSOUND_Create(REFIID riid, void **ppv) DECLSPEC_HIDDEN;
 HRESULT DSOUND_Create8(REFIID riid, void **ppv) DECLSPEC_HIDDEN;
 HRESULT IDirectSoundImpl_Create(IUnknown *outer_unk, REFIID riid, void **ppv, BOOL has_ds8) DECLSPEC_HIDDEN;
-void DSOUND_ParseSpeakerConfig(DirectSoundDevice *device) DECLSPEC_HIDDEN;

 /* primary.c */

diff --git a/dlls/dsound/primary.c b/dlls/dsound/primary.c
index 852ec51b7ff..fdbbc00cd33 100644
--- a/dlls/dsound/primary.c
+++ b/dlls/dsound/primary.c
@@ -24,6 +24,7 @@
  */

 #include <stdarg.h>
+#include <math.h>

 #define COBJMACROS
 #define NONAMELESSUNION
@@ -110,6 +111,78 @@ static DWORD DSOUND_FindSpeakerConfig(IMMDevice *mmdevice, int channels)
     return def;
 }

+static void DSOUND_ParseSpeakerConfig(DirectSoundDevice *device)
+{
+    switch (DSSPEAKER_CONFIG(device->speaker_config)) {
+        case DSSPEAKER_MONO:
+            device->speaker_angles[0] = M_PI/180.0f * 0.0f;
+            device->speaker_num[0] = 0;
+            device->num_speakers = 1;
+            device->lfe_channel = -1;
+        break;
+
+        case DSSPEAKER_STEREO:
+        case DSSPEAKER_HEADPHONE:
+            device->speaker_angles[0] = M_PI/180.0f * -90.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  90.0f;
+            device->speaker_num[0] = 0; /* Left */
+            device->speaker_num[1] = 1; /* Right */
+            device->num_speakers = 2;
+            device->lfe_channel = -1;
+        break;
+
+        case DSSPEAKER_QUAD:
+            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
+            device->speaker_angles[2] = M_PI/180.0f *   45.0f;
+            device->speaker_angles[3] = M_PI/180.0f *  135.0f;
+            device->speaker_num[0] = 2; /* Rear left */
+            device->speaker_num[1] = 0; /* Front left */
+            device->speaker_num[2] = 1; /* Front right */
+            device->speaker_num[3] = 3; /* Rear right */
+            device->num_speakers = 4;
+            device->lfe_channel = -1;
+        break;
+
+        case DSSPEAKER_5POINT1_BACK:
+            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
+            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
+            device->speaker_angles[3] = M_PI/180.0f *   45.0f;
+            device->speaker_angles[4] = M_PI/180.0f *  135.0f;
+            device->speaker_angles[5] = 9999.0f;
+            device->speaker_num[0] = 4; /* Rear left */
+            device->speaker_num[1] = 0; /* Front left */
+            device->speaker_num[2] = 2; /* Front centre */
+            device->speaker_num[3] = 1; /* Front right */
+            device->speaker_num[4] = 5; /* Rear right */
+            device->speaker_num[5] = 3; /* LFE */
+            device->num_speakers = 6;
+            device->lfe_channel = 3;
+        break;
+
+        case DSSPEAKER_5POINT1_SURROUND:
+            device->speaker_angles[0] = M_PI/180.0f *  -90.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  -30.0f;
+            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
+            device->speaker_angles[3] = M_PI/180.0f *   30.0f;
+            device->speaker_angles[4] = M_PI/180.0f *   90.0f;
+            device->speaker_angles[5] = 9999.0f;
+            device->speaker_num[0] = 4; /* Rear left */
+            device->speaker_num[1] = 0; /* Front left */
+            device->speaker_num[2] = 2; /* Front centre */
+            device->speaker_num[3] = 1; /* Front right */
+            device->speaker_num[4] = 5; /* Rear right */
+            device->speaker_num[5] = 3; /* LFE */
+            device->num_speakers = 6;
+            device->lfe_channel = 3;
+        break;
+
+        default:
+            WARN("unknown speaker_config %u\n", device->speaker_config);
+    }
+}
+
 static HRESULT DSOUND_WaveFormat(DirectSoundDevice *device, IAudioClient *client,
 				 BOOL forcewave, WAVEFORMATEX **wfx)
 {
@@ -124,7 +197,7 @@ static HRESULT DSOUND_WaveFormat(DirectSoundDevice *device, IAudioClient *client
         if (FAILED(hr))
             return hr;

-        if (mixwfe->Format.nChannels < device->num_speakers) {
+        if (device->num_speakers == 0 || mixwfe->Format.nChannels < device->num_speakers) {
             device->speaker_config = DSOUND_FindSpeakerConfig(device->mmdevice, mixwfe->Format.nChannels);
             DSOUND_ParseSpeakerConfig(device);
         } else if (mixwfe->Format.nChannels > device->num_speakers) {
From 749bf5fcd5f41a39301428a7fccd1e4febcd6f90 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 13 Dec 2019 15:54:28 +0200
Subject: [PATCH] dwmapi: Improve DwmGetWindowAttribute stub.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 dlls/dwmapi/dwmapi_main.c | 26 ++++++++++++++++++++++++--
 1 file changed, 24 insertions(+), 2 deletions(-)

diff --git a/dlls/dwmapi/dwmapi_main.c b/dlls/dwmapi/dwmapi_main.c
index 6378a091f0b..e976fda77f2 100644
--- a/dlls/dwmapi/dwmapi_main.c
+++ b/dlls/dwmapi/dwmapi_main.c
@@ -205,9 +205,31 @@ BOOL WINAPI DwmDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam,
  */
 HRESULT WINAPI DwmGetWindowAttribute(HWND hwnd, DWORD attribute, PVOID pv_attribute, DWORD size)
 {
-    FIXME("(%p %d %p %d) stub\n", hwnd, attribute, pv_attribute, size);
+    if (!hwnd) return E_HANDLE;
+    if (!pv_attribute) return E_INVALIDARG;

-    return E_NOTIMPL;
+    switch (attribute)
+    {
+    case DWMWA_NCRENDERING_ENABLED:
+        if (size < sizeof(BOOL)) return E_INVALIDARG;
+
+        WARN("DWMWA_NCRENDERING_ENABLED: always returning FALSE.\n");
+        *(BOOL*)(pv_attribute) = FALSE;
+        break;
+
+    case DWMWA_CLOAKED:
+        if (size < sizeof(DWORD)) return E_INVALIDARG;
+
+        WARN("DWMWA_CLOAKED: always returning 0.\n");
+        *(DWORD*)(pv_attribute) = 0;
+        break;
+
+    default:
+        FIXME("unimplemented attribute %d, size %u, for hwnd %p.\n", attribute, size, hwnd);
+        return E_INVALIDARG;
+    }
+
+    return S_OK;
 }

 /**********************************************************************
From 1a2e600a9c35a9558b32e7986668d7dc81c8b5ae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 13 Dec 2019 15:54:30 +0200
Subject: [PATCH] dwmapi: Add partial implementation of
 DWMWA_EXTENDED_FRAME_BOUNDS.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 dlls/dwmapi/Makefile.in    |  1 +
 dlls/dwmapi/dwmapi_main.c  |  7 +++++++
 dlls/dwmapi/tests/dwmapi.c | 14 ++++++++++++++
 3 files changed, 22 insertions(+)

diff --git a/dlls/dwmapi/Makefile.in b/dlls/dwmapi/Makefile.in
index 3a3691326f8..d273a22c8f3 100644
--- a/dlls/dwmapi/Makefile.in
+++ b/dlls/dwmapi/Makefile.in
@@ -1,5 +1,6 @@
 MODULE    = dwmapi.dll
 IMPORTLIB = dwmapi
+IMPORTS   = user32

 EXTRADLLFLAGS = -mno-cygwin

diff --git a/dlls/dwmapi/dwmapi_main.c b/dlls/dwmapi/dwmapi_main.c
index e976fda77f2..212c88c5a02 100644
--- a/dlls/dwmapi/dwmapi_main.c
+++ b/dlls/dwmapi/dwmapi_main.c
@@ -217,6 +217,13 @@ HRESULT WINAPI DwmGetWindowAttribute(HWND hwnd, DWORD attribute, PVOID pv_attrib
         *(BOOL*)(pv_attribute) = FALSE;
         break;

+    case DWMWA_EXTENDED_FRAME_BOUNDS:
+        if (size < sizeof(RECT)) return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
+
+        WARN("DWMWA_EXTENDED_FRAME_BOUNDS: returning window rect.\n");
+        GetWindowRect(hwnd, pv_attribute);
+        break;
+
     case DWMWA_CLOAKED:
         if (size < sizeof(DWORD)) return E_INVALIDARG;

From b739d48093cce805b7b4f48fdbd9d0bb62bc8013 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 13 Apr 2020 16:25:47 -0700
Subject: [PATCH] HACK: dxgi: Swap around memory sizes for GTA IV

GTA IV ends up using its "Intel integrated" codepath for determining
VRAM size (since nvapi/atiadlxx fail), but this requires that
DedicatedVideoMemory is a very small dummy value, and SharedSystemMemory
is the actual VRAM size.
Swap the memory values around so this works.
---
 dlls/dxgi/adapter.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/dxgi/adapter.c b/dlls/dxgi/adapter.c
index 5a97590dbce..a5563498cdd 100644
--- a/dlls/dxgi/adapter.c
+++ b/dlls/dxgi/adapter.c
@@ -200,6 +200,25 @@ static HRESULT dxgi_adapter_get_desc(struct dxgi_adapter *adapter, DXGI_ADAPTER_
     desc->GraphicsPreemptionGranularity = 0; /* FIXME */
     desc->ComputePreemptionGranularity = 0; /* FIXME */

+    {
+        /* HACK
+         *
+         * Grand Theft Auto IV first tries to get VRAM size using nvapi/atiadlxx,
+         * after that fails it falls back to the Intel integrated codepath which
+         * uses DXGI.
+         *
+         * DedicatedVideoMemory must be a dummy value less than 200 MB, then
+         * SharedSystemMemory will be used as the VRAM size.
+         * In case of failure, the game will just use 512 MB as VRAM size.
+         */
+        const char *sgi = getenv("SteamGameId");
+        if(sgi && !strcmp(sgi, "12210"))
+        {
+            desc->SharedSystemMemory = adapter_id.video_memory;
+            desc->DedicatedVideoMemory = 32 * 1024 * 1024;
+        }
+    }
+
     return hr;
 }

From c619409f235cf660cdd4fd3295d5e04ec628daa1 Mon Sep 17 00:00:00 2001
From: Alexey Prokhin <alexey@prokhin.ru>
Date: Thu, 23 Apr 2020 12:29:55 +0300
Subject: [PATCH] kernelbase: Set the proper error code in
 GetQueuedCompletionStatus{Ex} when the handle is closed.

Planet Zoo relies on it being ERROR_ABANDONED_WAIT_0.
---
 dlls/kernelbase/sync.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernelbase/sync.c b/dlls/kernelbase/sync.c
index 0ae3aadde92..e95ede8aed5 100644
--- a/dlls/kernelbase/sync.c
+++ b/dlls/kernelbase/sync.c
@@ -960,6 +960,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetQueuedCompletionStatus( HANDLE port, LPDWORD co
     }

     if (status == STATUS_TIMEOUT) SetLastError( WAIT_TIMEOUT );
+    else if (status == ERROR_WAIT_NO_CHILDREN) SetLastError( ERROR_ABANDONED_WAIT_0 );
     else SetLastError( RtlNtStatusToDosError(status) );
     return FALSE;
 }
@@ -981,6 +982,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetQueuedCompletionStatusEx( HANDLE port, OVERLAPP
     if (ret == STATUS_SUCCESS) return TRUE;
     else if (ret == STATUS_TIMEOUT) SetLastError( WAIT_TIMEOUT );
     else if (ret == STATUS_USER_APC) SetLastError( WAIT_IO_COMPLETION );
+    else if (ret == ERROR_WAIT_NO_CHILDREN) SetLastError( ERROR_ABANDONED_WAIT_0 );
     else SetLastError( RtlNtStatusToDosError(ret) );
     return FALSE;
 }

From 0255dbc3afd3ff673fa701e7802474483252fcb2 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 13 Jul 2020 10:21:49 -0500
Subject: [PATCH] ntdll: Handle NULL object name buffer in
 nt_to_unix_file_name_attr().

---
 dlls/ntdll/tests/file.c | 22 +++++++++++++++++++++-
 dlls/ntdll/unix/file.c  |  8 ++++++++
 2 files changed, 29 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 20eb6a05922..d99c6b462b2 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -3593,12 +3593,20 @@ NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret,
     const WCHAR *name;
     char *unix_name;
     int name_len, unix_len;
     NTSTATUS status;

+    if (!attr->ObjectName->Buffer && attr->ObjectName->Length)
+        return STATUS_ACCESS_VIOLATION;
+
     if (!attr->RootDirectory)  /* without root dir fall back to normal lookup */
+    {
+        if (!attr->ObjectName->Buffer)
+            return STATUS_OBJECT_PATH_SYNTAX_BAD;
+
         return nt_to_unix_file_name_no_root( attr->ObjectName, name_ret, disposition );
+    }

     name     = attr->ObjectName->Buffer;
     name_len = attr->ObjectName->Length / sizeof(WCHAR);

     if (name_len && name[0] == '\\') return STATUS_INVALID_PARAMETER;
From 514d3e11c999b11a95ab35df5b4ab454d34fe791 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 13 May 2020 13:55:55 +0300
Subject: [PATCH] ntdll: Add WINE_DISABLE_WRITE_WATCH env var to disable write
 watch support.

Massively improves performance for corert games (Streets of Rage 4).
Could be fixed properly with Linux kernel changes.
---
 dlls/ntdll/unix/virtual.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index 7ea80852090..272e1c5b176 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -3425,6 +3425,22 @@ NTSTATUS WINAPI NtAllocateVirtualMemory( HANDLE process, PVOID *ret, ULONG_PTR z
     if (zero_bits > 21 && zero_bits < 32) return STATUS_INVALID_PARAMETER_3;
     if (!is_win64 && !is_wow64 && zero_bits >= 32) return STATUS_INVALID_PARAMETER_3;

+    if (type & MEM_WRITE_WATCH)
+    {
+        static int disable = -1;
+
+        if (disable == -1)
+        {
+            const char *env_var;
+
+            if ((disable = (env_var = getenv("WINE_DISABLE_WRITE_WATCH")) && atoi(env_var)))
+                FIXME("Disabling write watch support.\n");
+        }
+
+        if (disable)
+            return STATUS_NOT_SUPPORTED;
+    }
+
     if (process != NtCurrentProcess())
     {
         apc_call_t call;
From 912701cb515acdc8e0ff263552f656cd49f60714 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 13:01:26 +0200
Subject: [PATCH] d3d10core: Implement D3D10CoreRegisterLayers.

---
 dlls/d3d10core/d3d10core_main.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/d3d10core/d3d10core_main.c b/dlls/d3d10core/d3d10core_main.c
index d364be90d6d..5a9a4a211c1 100644
--- a/dlls/d3d10core/d3d10core_main.c
+++ b/dlls/d3d10core/d3d10core_main.c
@@ -29,11 +29,13 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d10core);
 HRESULT WINAPI D3D11CoreCreateDevice(IDXGIFactory *factory, IDXGIAdapter *adapter, unsigned int flags,
         const D3D_FEATURE_LEVEL *feature_levels, unsigned int level_count, ID3D11Device **device);

+HRESULT WINAPI D3D11CoreRegisterLayers(void);
+
 HRESULT WINAPI D3D10CoreRegisterLayers(void)
 {
     TRACE("\n");

-    return E_NOTIMPL;
+    return D3D11CoreRegisterLayers();
 }

 HRESULT WINAPI D3D10CoreCreateDevice(IDXGIFactory *factory, IDXGIAdapter *adapter,

From 376a037ce1391e071835a0bf30ebf1fcec43c367 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 12:59:44 +0200
Subject: [PATCH] dxgi: Add fallback to D3D10CoreRegisterLayers.

If D3D11CoreRegisterLayers is not found in module.
---
 dlls/dxgi/dxgi_main.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/dlls/dxgi/dxgi_main.c b/dlls/dxgi/dxgi_main.c
index 83c3f3734a7..006ab370844 100644
--- a/dlls/dxgi/dxgi_main.c
+++ b/dlls/dxgi/dxgi_main.c
@@ -106,8 +106,8 @@ static HRESULT register_d3d10core_layers(HMODULE d3d10core)

     if (!dxgi_main.d3d10core)
     {
-        HRESULT hr;
-        HRESULT (WINAPI *d3d11core_register_layers)(void);
+        HRESULT hr = E_FAIL;
+        HRESULT (WINAPI *register_layers)(void);
         HMODULE mod;
         BOOL ret;

@@ -117,8 +117,10 @@ static HRESULT register_d3d10core_layers(HMODULE d3d10core)
             return E_FAIL;
         }

-        d3d11core_register_layers = (void *)GetProcAddress(mod, "D3D11CoreRegisterLayers");
-        hr = d3d11core_register_layers();
+        if ((register_layers = (void *)GetProcAddress(mod, "D3D11CoreRegisterLayers")) ||
+            (register_layers = (void *)GetProcAddress(mod, "D3D10CoreRegisterLayers")))
+            hr = register_layers();
+
         if (FAILED(hr))
         {
             ERR("Failed to register d3d11 layers, returning %#x.\n", hr);

From 5b00ca69a1927e1d0df4cf26160228e460568c51 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 9 Jun 2020 14:16:22 +0300
Subject: [PATCH] kernelbase: HACK Add an option to blacklist files.

---
 dlls/kernelbase/file.c | 76 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 75 insertions(+), 1 deletion(-)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index eb2ef57c7d6..c7881fe4516 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -41,6 +41,8 @@
 #include "wine/exception.h"
 #include "wine/debug.h"

+#include "wine/heap.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(file);

 /* info structure for FindFirstFile handle */
@@ -432,6 +434,72 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileA( LPCSTR name, DWORD access, DWORD sh
     return CreateFileW( nameW, access, sharing, sa, creation, attributes, template );
 }

+#define MAX_BLACKLISTED_FILENAMES 32
+
+static struct
+{
+    const WCHAR *name;
+    size_t name_len;
+}
+blacklist_filenames[MAX_BLACKLISTED_FILENAMES];
+
+static unsigned int blacklist_filename_count;
+
+static BOOL CALLBACK init_file_blacklist(PINIT_ONCE init_once, PVOID parameter, PVOID *context)
+{
+    const WCHAR separators[] = L",; ";
+    WCHAR *buffer, *token;
+    DWORD size;
+
+    if (!(size = GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", NULL, 0)))
+        return TRUE;
+
+    if (!(buffer = heap_alloc(sizeof(*buffer) * size)))
+    {
+        ERR("No memory.\n");
+        return FALSE;
+    }
+
+    if (GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", buffer, size) != size - 1)
+    {
+        ERR("Error getting WINE_BLACKLIST_FILES env variable.\n");
+        return FALSE;
+    }
+
+    blacklist_filename_count = 0;
+    token = wcstok(buffer, separators);
+    while (token && blacklist_filename_count < MAX_BLACKLISTED_FILENAMES)
+    {
+        FIXME("Blacklisting %s file.\n", debugstr_w(token));
+        blacklist_filenames[blacklist_filename_count].name = token;
+        blacklist_filenames[blacklist_filename_count++].name_len = wcslen(token);
+        token = wcstok(NULL, separators);
+    }
+
+    if (token && blacklist_filename_count == MAX_BLACKLISTED_FILENAMES)
+        ERR("File black list is too long.\n");
+
+    return TRUE;
+}
+
+static BOOL is_file_blacklisted(LPCWSTR filename)
+{
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+    unsigned int i;
+    size_t len;
+
+    if (!InitOnceExecuteOnce(&init_once, init_file_blacklist, NULL, NULL))
+        return FALSE;
+
+    len = wcslen(filename);
+
+    for (i = 0; i < blacklist_filename_count; ++i)
+        if (blacklist_filenames[i].name_len <= len
+                && !wcsicmp(blacklist_filenames[i].name, filename + len - blacklist_filenames[i].name_len))
+            return TRUE;
+
+    return FALSE;
+}

 /*************************************************************************
  *	CreateFileW   (kernelbase.@)
@@ -460,7 +528,6 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileW( LPCWSTR filename, DWORD access, DWO
         FILE_OVERWRITE      /* TRUNCATE_EXISTING */
     };

-
     /* sanity checks */

     if (!filename || !filename[0])
@@ -479,6 +546,13 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileW( LPCWSTR filename, DWORD access, DWO
            (sharing & FILE_SHARE_DELETE) ? "FILE_SHARE_DELETE " : "",
            creation, attributes);

+    if (is_file_blacklisted(filename))
+    {
+        FIXME("\"%s\" is blacklisted.\n", debugstr_w(filename));
+        SetLastError( ERROR_FILE_NOT_FOUND );
+        return INVALID_HANDLE_VALUE;
+    }
+
     if ((GetVersion() & 0x80000000) && !wcsncmp( filename, L"\\\\.\\", 4 ) &&
         !RtlIsDosDeviceName_U( filename + 4 ) &&
         wcsnicmp( filename + 4, L"PIPE\\", 5 ) &&

From 2409bd1f74be116172688a25df725290637c255a Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 10 Jun 2020 16:18:29 -0500
Subject: [PATCH] kernelbase: Apply blacklist automatically to Origin
 executables

---
 dlls/kernelbase/file.c | 54 ++++++++++++++++++++++++++++++++++--------
 1 file changed, 44 insertions(+), 10 deletions(-)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index c7881fe4516..bb4be45da5d 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -447,23 +447,57 @@ static unsigned int blacklist_filename_count;

 static BOOL CALLBACK init_file_blacklist(PINIT_ONCE init_once, PVOID parameter, PVOID *context)
 {
+    static WCHAR origin_blacklist[] = L"kernel32.dll;user32.dll";
+
     const WCHAR separators[] = L",; ";
     WCHAR *buffer, *token;
     DWORD size;

-    if (!(size = GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", NULL, 0)))
-        return TRUE;
-
-    if (!(buffer = heap_alloc(sizeof(*buffer) * size)))
+    if ((size = GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", NULL, 0)))
     {
-        ERR("No memory.\n");
-        return FALSE;
-    }
+        if (!(buffer = heap_alloc(sizeof(*buffer) * size)))
+        {
+            ERR("No memory.\n");
+            return FALSE;
+        }

-    if (GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", buffer, size) != size - 1)
+        if (GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", buffer, size) != size - 1)
+        {
+            ERR("Error getting WINE_BLACKLIST_FILES env variable.\n");
+            return FALSE;
+        }
+    }
+    else
     {
-        ERR("Error getting WINE_BLACKLIST_FILES env variable.\n");
-        return FALSE;
+        static const WCHAR *origin_names[] = {
+            L"igoproxy64.exe",
+            L"igoproxy.exe",
+            L"origin.exe",
+            L"easteamproxy.exe"
+        };
+
+        WCHAR cur_exe[MAX_PATH];
+        DWORD cur_exe_len, i;
+
+        if (!(cur_exe_len = GetModuleFileNameW(NULL, cur_exe, ARRAY_SIZE(cur_exe))))
+            return TRUE;
+
+        buffer = NULL;
+
+        for (i = 0; i < ARRAY_SIZE(origin_names); ++i)
+        {
+            DWORD origin_name_len = wcslen(origin_names[i]);
+            if (cur_exe_len >= origin_name_len &&
+                    wcsicmp(cur_exe + cur_exe_len - origin_name_len, origin_names[i]) == 0)
+            {
+                FIXME("using origin file blacklist for %s\n", debugstr_w(cur_exe));
+                buffer = origin_blacklist;
+                break;
+            }
+        }
+
+        if (!buffer)
+            return TRUE;
     }

     blacklist_filename_count = 0;
From ff790e8d99f2026af9b8569355fc1df5e6f0c639 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Sat, 5 Sep 2020 01:09:37 +0300
Subject: [PATCH] wbemprox: HACK: Make Bloons TD6 happy so it does not exit
 after getting string Wine from bios info.

---
 dlls/wbemprox/builtin.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/dlls/wbemprox/builtin.c b/dlls/wbemprox/builtin.c
index 43268221936..f39d6f0cd7b 100644
--- a/dlls/wbemprox/builtin.c
+++ b/dlls/wbemprox/builtin.c
@@ -1181,7 +1181,7 @@ static WCHAR *get_bios_string( BYTE id, const char *buf, UINT len )
 static WCHAR *get_bios_manufacturer( const char *buf, UINT len )
 {
     WCHAR *ret = get_bios_string( 1, buf, len );
-    if (!ret) return heap_strdupW( L"The Wine Project" );
+    if (!ret) return heap_strdupW( L"The Proton Project" );
     return ret;
 }

@@ -1227,7 +1227,7 @@ static WCHAR *get_bios_releasedate( const char *buf, UINT len )
 static WCHAR *get_bios_smbiosbiosversion( const char *buf, UINT len )
 {
     WCHAR *ret = get_bios_string( 2, buf, len );
-    if (!ret) return heap_strdupW( L"Wine" );
+    if (!ret) return heap_strdupW( L"Proton" );
     return ret;
 }

@@ -1307,7 +1307,7 @@ static enum fill_status fill_bios( struct table *table, const struct expr *cond
     rec->smbiosminorversion     = get_bios_smbiosminorversion( buf, len );
     rec->systembiosmajorversion = get_bios_system_bios_major_release( buf, len );
     rec->systembiosminorversion = get_bios_system_bios_minor_release( buf, len );
-    rec->version                = L"WINE   - 1";
+    rec->version                = L"PROTON - 1";
     if (!match_row( table, row, cond, &status )) free_row_values( table, row );
     else row++;

@@ -1468,8 +1468,8 @@ static enum fill_status fill_compsys( struct table *table, const struct expr *co
     rec->description            = L"AT/AT COMPATIBLE";
     rec->domain                 = L"WORKGROUP";
     rec->domainrole             = 0; /* standalone workstation */
-    rec->manufacturer           = L"The Wine Project";
-    rec->model                  = L"Wine";
+    rec->manufacturer           = L"The Proton Project";
+    rec->model                  = L"Proton";
     rec->name                   = get_computername();
     rec->num_logical_processors = get_logical_processor_count( NULL, &rec->num_processors );
     rec->total_physical_memory  = get_total_physical_memory();
@@ -1505,7 +1505,7 @@ static WCHAR *get_compsysproduct_identifyingnumber( const char *buf, UINT len )
 static WCHAR *get_compsysproduct_name( const char *buf, UINT len )
 {
     WCHAR *ret = get_compsysproduct_string( 2, buf, len );
-    if (!ret) return heap_strdupW( L"Wine" );
+    if (!ret) return heap_strdupW( L"Proton" );
     return ret;
 }

@@ -1533,7 +1533,7 @@ done:
 static WCHAR *get_compsysproduct_vendor( const char *buf, UINT len )
 {
     WCHAR *ret = get_compsysproduct_string( 1, buf, len );
-    if (!ret) return heap_strdupW( L"The Wine Project" );
+    if (!ret) return heap_strdupW( L"The Proton Project" );
     return ret;
 }

@@ -2652,7 +2652,7 @@ static enum fill_status fill_networkadapter( struct table *table, const struct e
         rec->index                = aa->u.s.IfIndex;
         rec->interface_index      = aa->u.s.IfIndex;
         rec->mac_address          = get_mac_address( aa->PhysicalAddress, aa->PhysicalAddressLength );
-        rec->manufacturer         = L"The Wine Project";
+        rec->manufacturer         = L"The Proton Project";
         rec->name                 = heap_strdupW( aa->FriendlyName );
         rec->netconnection_status = get_connection_status( aa->OperStatus );
         rec->physicaladapter      = physical;
@@ -3475,7 +3475,7 @@ static enum fill_status fill_operatingsystem( struct table *table, const struct
     rec->lastbootuptime         = get_lastbootuptime();
     rec->localdatetime          = get_localdatetime();
     rec->locale                 = get_locale();
-    rec->manufacturer           = L"The Wine Project";
+    rec->manufacturer           = L"The Proton Project";
     rec->name                   = get_osname( rec->caption );
     rec->operatingsystemsku     = get_operatingsystemsku();
     rec->osarchitecture         = get_osarchitecture();
@@ -3740,7 +3740,7 @@ static WCHAR *get_systemenclosure_string( BYTE id, const char *buf, UINT len )
 static WCHAR *get_systemenclosure_manufacturer( const char *buf, UINT len )
 {
     WCHAR *ret = get_systemenclosure_string( 1, buf, len );
-    if (!ret) return heap_strdupW( L"Wine" );
+    if (!ret) return heap_strdupW( L"Proton" );
     return ret;
 }

@@ -3955,7 +3955,7 @@ static enum fill_status fill_sounddevice( struct table *table, const struct expr

     rec = (struct record_sounddevice *)table->data;
     rec->deviceid = get_sounddevice_pnpdeviceid( &desc );
-    rec->manufacturer = L"The Wine Project";
+    rec->manufacturer = L"The Proton Project";
     rec->name = L"Wine Audio Device";
     rec->pnpdeviceid = get_sounddevice_pnpdeviceid( &desc );
     rec->productname = L"Wine Audio Device";
--
2.26.2

From c9a5fcb0966ab0ca0722c8c07476c131844f98e1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 16 Oct 2020 23:37:09 +0200
Subject: [PATCH] dotnetfx35.exe: Add stub program.

This makes it possible to override native dotnetfx35 installer, which
is broken in an unfixable way. Recent Windows versions also bypass its
execution somehow.
---
 configure                       |  2 ++
 configure.ac                    |  1 +
 programs/dotnetfx35/Makefile.in |  7 +++++++
 programs/dotnetfx35/main.c      | 32 ++++++++++++++++++++++++++++++++
 4 files changed, 42 insertions(+)
 create mode 100644 programs/dotnetfx35/Makefile.in
 create mode 100644 programs/dotnetfx35/main.c

diff --git a/configure b/configure
index 848323bb057..d676b1c82ee 100755
--- a/configure
+++ b/configure
@@ -1766,6 +1766,7 @@ enable_conhost
 enable_control
 enable_cscript
 enable_dism
+enable_dotnetfx35
 enable_dplaysvr
 enable_dpnsvr
 enable_dpvsetup
@@ -21579,6 +21580,7 @@ wine_fn_config_makefile programs/conhost enable_conhost
 wine_fn_config_makefile programs/control enable_control
 wine_fn_config_makefile programs/cscript enable_cscript
 wine_fn_config_makefile programs/dism enable_dism
+wine_fn_config_makefile programs/dotnetfx35 enable_dotnetfx35
 wine_fn_config_makefile programs/dplaysvr enable_dplaysvr
 wine_fn_config_makefile programs/dpnsvr enable_dpnsvr
 wine_fn_config_makefile programs/dpvsetup enable_dpvsetup
diff --git a/configure.ac b/configure.ac
index 130dbeb8530..63d26ff123c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3997,6 +3997,7 @@ WINE_CONFIG_MAKEFILE(programs/conhost)
 WINE_CONFIG_MAKEFILE(programs/control)
 WINE_CONFIG_MAKEFILE(programs/cscript)
 WINE_CONFIG_MAKEFILE(programs/dism)
+WINE_CONFIG_MAKEFILE(programs/dotnetfx35)
 WINE_CONFIG_MAKEFILE(programs/dplaysvr)
 WINE_CONFIG_MAKEFILE(programs/dpnsvr)
 WINE_CONFIG_MAKEFILE(programs/dpvsetup)
diff --git a/programs/dotnetfx35/Makefile.in b/programs/dotnetfx35/Makefile.in
new file mode 100644
index 00000000000..e50ed37f700
--- /dev/null
+++ b/programs/dotnetfx35/Makefile.in
@@ -0,0 +1,7 @@
+MODULE    = dotnetfx35.exe
+IMPORTS   =
+
+EXTRADLLFLAGS = -mwindows -mno-cygwin
+
+C_SRCS = \
+	main.c
diff --git a/programs/dotnetfx35/main.c b/programs/dotnetfx35/main.c
new file mode 100644
index 00000000000..cd6df5bcf41
--- /dev/null
+++ b/programs/dotnetfx35/main.c
@@ -0,0 +1,32 @@
+/*
+ * Fake dotnetfx35.exe installer
+ *
+ * Copyright 2020 Rémi Bernon
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdio.h>
+#include <windows.h>
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dotnetfx);
+
+int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
+{
+    FIXME("stub!");
+    return 0;
+}
From 2452b57e7fed9ac5036df9bcace5c28366a8eb41 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 8 Jan 2021 13:47:39 -0600
Subject: [PATCH] HACK: kernelbase: Add NFS EXE to Origin file blacklist hack

---
 dlls/kernelbase/file.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index a33440107b6..397aa64dce2 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -741,7 +741,8 @@ static BOOL CALLBACK init_file_blacklist(PINIT_ONCE init_once, PVOID parameter,
             L"igoproxy64.exe",
             L"igoproxy.exe",
             L"origin.exe",
-            L"easteamproxy.exe"
+            L"easteamproxy.exe",
+            L"NFS11Remastered.exe"
         };

         WCHAR cur_exe[MAX_PATH];
From e6c7aa8bc42fea042c3d504009ad8a0fb70a6c0c Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 21 Jan 2021 11:54:10 -0600
Subject: [PATCH] vulkan-1: Prefer builtin

Games that ship their own vulkan-1 will be broken with your VR wrappers.
---
 dlls/vulkan-1/Makefile.in | 2 --
 1 file changed, 2 deletions(-)

diff --git a/dlls/vulkan-1/Makefile.in b/dlls/vulkan-1/Makefile.in
index a4a10bc8e93..551ef146cd7 100644
--- a/dlls/vulkan-1/Makefile.in
+++ b/dlls/vulkan-1/Makefile.in
@@ -2,6 +2,4 @@ MODULE    = vulkan-1.dll
 IMPORTS   = winevulkan
 IMPORTLIB = vulkan-1

-EXTRADLLFLAGS = -Wb,--prefer-native
-
 RC_SRCS = version.rc
From 07461415f4399934a3c03c8dd6e146167bd67dfd Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 25 Mar 2021 17:53:37 +0300
Subject: [PATCH 07/16] wine.inf: Create package repository for VCLibs.140.

---
 loader/wine.inf.in | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 4df88d1f386..1506a73573b 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -67,6 +67,7 @@ AddReg=\
     Misc,\
     Nls,\
     OLE,\
+    Packages,\
     Printing,\
     Services, \
     SessionMgr,\
@@ -95,6 +96,7 @@ AddReg=\
     Misc,\
     Nls,\
     OLE,\
+    Packages.ntamd64,\
     Printing,\
     Services, \
     SessionMgr,\
@@ -123,6 +125,7 @@ AddReg=\
     Misc,\
     Nls,\
     OLE,\
+    Packages.ntarm64,\
     Printing,\
     Services, \
     SessionMgr,\
@@ -142,6 +145,7 @@ AddReg=\
     DirectX,\
     MCI,\
     Misc,\
+    Packages.wow64,\
     Tapi,\
     VersionInfo.ntamd64,\
     LicenseInformation, \
@@ -234,6 +238,7 @@ CurrentVersionNT="Software\Microsoft\Windows NT\CurrentVersion"
 CurrentVersionNT="Software\Microsoft\Windows NT\CurrentVersion"
 FontSubStr="Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes"
 Control="System\CurrentControlSet\Control"
+Packages="Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Packages"

 [Classes]
 HKCR,.chm,,2,"chm.file"
@@ -1129,6 +1134,18 @@ HKLM,System\CurrentControlSet\Control\Nls\Locale\Alternate Sorts,"00030404",,"9"
 HKLM,"Software\Microsoft\OLE","EnableDCOM",,"Y"
 HKLM,"Software\Microsoft\OLE","EnableRemoteConnect",,"N"

+[Packages]
+HKLM,"%Packages%\Microsoft.VCLibs.140.00_14.0.29231.0_x86__8wekyb3d8bbwe","Path",0x00020002,"%SystemRoot%\system32"
+
+[Packages.ntamd64]
+HKLM,"%Packages%\Microsoft.VCLibs.140.00_14.0.29231.0_x64__8wekyb3d8bbwe","Path",0x00020002,"%SystemRoot%\system32"
+
+[Packages.wow64]
+HKLM,"%Packages%\Microsoft.VCLibs.140.00_14.0.29231.0_x86__8wekyb3d8bbwe","Path",0x00020002,"%SystemRoot%\syswow64"
+
+[Packages.arm64]
+HKLM,"%Packages%\Microsoft.VCLibs.140.00_14.0.29231.0_arm64__8wekyb3d8bbwe","Path",0x00020002,"%SystemRoot%\system32"
+
 [Printing]
 HKLM,%Control%\Print\Monitors\Local Port,"Driver",2,"localspl.dll"
 HKLM,%Control%\Print\Printers,"DefaultSpoolDirectory",2,"%11%\spool\printers"
--
2.30.2

From 4a2ca2d4e87c84a57dde064296822860701fc877 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 15 Mar 2021 21:59:00 +0300
Subject: [PATCH 08/16] kernel32: Implement GetPackagesByPackageFamily().

---
 .../api-ms-win-appmodel-runtime-l1-1-1.spec   |   2 +-
 .../ext-ms-win-kernel32-package-l1-1-1.spec   |   2 +-
 dlls/kernel32/kernel32.spec                   |   1 +
 dlls/kernel32/tests/version.c                 | 131 ++++++++++++++++++
 dlls/kernelbase/kernelbase.spec               |   2 +-
 dlls/kernelbase/version.c                     | 115 +++++++++++++++
 include/appmodel.h                            |   2 +
 7 files changed, 252 insertions(+), 3 deletions(-)

diff --git a/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec b/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec
index 99d1d9f3835..696bb75be30 100644
--- a/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec
+++ b/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec
@@ -15,7 +15,7 @@
 @ stub GetPackageInfo
 @ stub GetPackagePath
 @ stub GetPackagePathByFullName
-@ stub GetPackagesByPackageFamily
+@ stdcall GetPackagesByPackageFamily(wstr ptr ptr ptr ptr) kernel32.GetPackagesByPackageFamily
 @ stub GetStagedPackageOrigin
 @ stub GetStagedPackagePathByFullName
 @ stub OpenPackageInfoByFullName
diff --git a/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec b/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec
index 61fd115cca7..ff5118049e2 100644
--- a/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec
+++ b/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec
@@ -12,7 +12,7 @@
 @ stub GetPackageId
 @ stub GetPackageInfo
 @ stub GetPackagePath
-@ stub GetPackagesByPackageFamily
+@ stdcall GetPackagesByPackageFamily(wstr ptr ptr ptr ptr) kernel32.GetPackagesByPackageFamily
 @ stub GetStagedPackageOrigin
 @ stub OpenPackageInfoByFullName
 @ stub PackageFamilyNameFromFullName
diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index bcaf2512990..59785a6de24 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -765,6 +765,7 @@
 @ stdcall -import GetOverlappedResultEx(long ptr ptr long long)
 @ stdcall -import GetUserDefaultGeoName(ptr long)
 @ stdcall -import GetUserPreferredUILanguages(long ptr ptr ptr)
+@ stdcall -import GetPackagesByPackageFamily(wstr ptr ptr ptr ptr)
 @ stdcall GetPackageFamilyName(long ptr ptr) kernelbase.GetPackageFamilyName
 @ stdcall GetPackageFullName(long ptr ptr) kernelbase.GetPackageFullName
 @ stdcall -import GetPhysicallyInstalledSystemMemory(ptr)
diff --git a/dlls/kernel32/tests/version.c b/dlls/kernel32/tests/version.c
index 835c5398685..9a35d679323 100644
--- a/dlls/kernel32/tests/version.c
+++ b/dlls/kernel32/tests/version.c
@@ -23,6 +23,7 @@
 #include "winternl.h"
 #include "appmodel.h"

+static LONG (WINAPI * pGetPackagesByPackageFamily)(const WCHAR *, UINT32 *, WCHAR **, UINT32 *, WCHAR *);
 static BOOL (WINAPI * pGetProductInfo)(DWORD, DWORD, DWORD, DWORD, DWORD *);
 static UINT (WINAPI * pGetSystemFirmwareTable)(DWORD, DWORD, void *, DWORD);
 static LONG (WINAPI * pPackageIdFromFullName)(const WCHAR *, UINT32, UINT32 *, BYTE *);
@@ -43,6 +44,7 @@ static void init_function_pointers(void)

     hmod = GetModuleHandleA("kernel32.dll");

+    GET_PROC(GetPackagesByPackageFamily);
     GET_PROC(GetProductInfo);
     GET_PROC(GetSystemFirmwareTable);
     GET_PROC(PackageIdFromFullName);
@@ -918,6 +920,134 @@ static void test_PackageIdFromFullName(void)
     ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
 }

+static void test_package_info(void)
+{
+    static const WCHAR package_family_msvc140[] = L"Microsoft.VCLibs.140.00_8wekyb3d8bbwe";
+    UINT32 count, length, curr_length, size;
+    WCHAR *full_names[32];
+    BYTE id_buffer[512];
+    WCHAR buffer[2048];
+    BOOL arch_found;
+    SYSTEM_INFO si;
+    unsigned int i;
+    PACKAGE_ID *id;
+    DWORD arch;
+    LONG ret;
+
+    if (!pGetPackagesByPackageFamily)
+    {
+        win_skip("GetPackagesByPackageFamily not available.\n");
+        return;
+    }
+
+    GetSystemInfo(&si);
+    arch = si.wProcessorArchitecture;
+
+    count = 0;
+    length = 0;
+    ret = pGetPackagesByPackageFamily(L"Unknown_8wekyb3d8bbwe", &count, NULL, &length, NULL);
+    ok(ret == ERROR_SUCCESS, "Got unexpected ret %u.\n", ret);
+    ok(!count, "Got unexpected count %u.\n", count);
+    ok(!length, "Got unexpected length %u.\n", length);
+
+    count = 0;
+    length = 0;
+    ret = pGetPackagesByPackageFamily(L"Unknown_iekyb3d8bbwe", &count, NULL, &length, NULL);
+    ok(ret == ERROR_SUCCESS, "Got unexpected ret %u.\n", ret);
+    ok(!count, "Got unexpected count %u.\n", count);
+    ok(!length, "Got unexpected length %u.\n", length);
+
+    count = 0xdeadbeef;
+    length = 0xdeadbeef;
+    ret = pGetPackagesByPackageFamily(L"Unknown", &count, NULL, &length, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+    ok(count == 0xdeadbeef, "Got unexpected count %u.\n", count);
+    ok(length == 0xdeadbeef, "Got unexpected length %u.\n", length);
+
+    count = 0;
+    length = 0;
+    ret = pGetPackagesByPackageFamily(L"Unknown", &count, NULL, &length, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+    ok(!count, "Got unexpected count %u.\n", count);
+    ok(!length, "Got unexpected length %u.\n", length);
+
+    count = 0;
+    length = 0;
+    ret = pGetPackagesByPackageFamily(L"Unknown_8wekyb3d8bbwe_b", &count, NULL, &length, NULL);
+    ok(ret == ERROR_SUCCESS, "Got unexpected ret %u.\n", ret);
+    ok(!count, "Got unexpected count %u.\n", count);
+    ok(!length, "Got unexpected length %u.\n", length);
+
+    count = 0;
+    length = 0;
+    ret = pGetPackagesByPackageFamily(L"Unknown_", &count, NULL, &length, NULL);
+    ok(ret == ERROR_SUCCESS, "Got unexpected ret %u.\n", ret);
+    ok(!count, "Got unexpected count %u.\n", count);
+    ok(!length, "Got unexpected length %u.\n", length);
+
+    length = 0;
+    ret = pGetPackagesByPackageFamily(package_family_msvc140, NULL, NULL, &length, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+    ok(!length, "Got unexpected length %u.\n", length);
+
+    count = 0;
+    ret = pGetPackagesByPackageFamily(package_family_msvc140, &count, NULL, NULL, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+    ok(!count, "Got unexpected count %u.\n", count);
+
+    count = ARRAY_SIZE(full_names);
+    length = ARRAY_SIZE(buffer);
+    ret = pGetPackagesByPackageFamily(package_family_msvc140, &count, NULL, &length, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+    ok(count == ARRAY_SIZE(full_names), "Got unexpected count %u.\n", count);
+    ok(length == ARRAY_SIZE(buffer), "Got unexpected length %u.\n", length);
+
+    ret = pGetPackagesByPackageFamily(package_family_msvc140, &count, full_names, &length, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+    ok(count == ARRAY_SIZE(full_names), "Got unexpected count %u.\n", count);
+    ok(length == ARRAY_SIZE(buffer), "Got unexpected length %u.\n", length);
+
+    ret = pGetPackagesByPackageFamily(package_family_msvc140, &count, NULL, &length, buffer);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+    ok(count == ARRAY_SIZE(full_names), "Got unexpected count %u.\n", count);
+    ok(length == ARRAY_SIZE(buffer), "Got unexpected length %u.\n", length);
+
+    count = 0;
+    length = 0;
+    ret = pGetPackagesByPackageFamily(package_family_msvc140, &count, NULL, &length, NULL);
+    if (!ret && !count && !length)
+    {
+        win_skip("Package VCLibs.140.00 is not installed.\n");
+        return;
+    }
+
+    ok(ret == ERROR_INSUFFICIENT_BUFFER, "Got unexpected ret %u.\n", ret);
+    ok(count >= 1, "Got unexpected count %u.\n", count);
+    ok(length > 1, "Got unexpected length %u.\n", length);
+
+    ret = pGetPackagesByPackageFamily(package_family_msvc140, &count, full_names, &length, buffer);
+    ok(ret == ERROR_SUCCESS, "Got unexpected ret %u.\n", ret);
+    ok(count >= 1, "Got unexpected count %u.\n", count);
+    ok(length > 1, "Got unexpected length %u.\n", length);
+
+    id = (PACKAGE_ID *)id_buffer;
+    curr_length = 0;
+    arch_found = FALSE;
+    for (i = 0; i < count; ++i)
+    {
+        curr_length += lstrlenW(full_names[i]) + 1;
+
+        size = sizeof(id_buffer);
+        ret = pPackageIdFromFullName(full_names[i], 0, &size, id_buffer);
+        ok(ret == ERROR_SUCCESS, "Got unexpected ret %u.\n", ret);
+
+        if (id->processorArchitecture == arch)
+            arch_found = TRUE;
+    }
+    ok(curr_length == length, "Got unexpected length %u.\n", length);
+    ok(arch_found, "Did not find package for current arch.\n");
+}
+
 START_TEST(version)
 {
     init_function_pointers();
@@ -927,4 +1057,5 @@ START_TEST(version)
     test_VerifyVersionInfo();
     test_GetSystemFirmwareTable();
     test_PackageIdFromFullName();
+    test_package_info();
 }
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index b42a9af8b8e..5d21680f512 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -614,7 +614,7 @@
 # @ stub GetPackageStatusForUser
 # @ stub GetPackageTargetPlatformProperty
 # @ stub GetPackageVolumeSisPath
-# @ stub GetPackagesByPackageFamily
+@ stdcall GetPackagesByPackageFamily(wstr ptr ptr ptr ptr)
 @ stdcall GetPerformanceInfo(ptr long)
 @ stdcall GetPhysicallyInstalledSystemMemory(ptr)
 # @ stub GetPreviousFgPolicyRefreshInfoInternal
diff --git a/dlls/kernelbase/version.c b/dlls/kernelbase/version.c
index 66bd619e394..dca4ffb8647 100644
--- a/dlls/kernelbase/version.c
+++ b/dlls/kernelbase/version.c
@@ -39,10 +39,12 @@
 #include "winnls.h"
 #include "winternl.h"
 #include "winerror.h"
+#include "winreg.h"
 #include "appmodel.h"

 #include "kernelbase.h"
 #include "wine/debug.h"
+#include "wine/heap.h"

 WINE_DEFAULT_DEBUG_CHANNEL(ver);

@@ -154,6 +156,8 @@ static const struct
     }
 };

+static const WCHAR packages_key_name[] = L"Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows"
+        L"\\CurrentVersion\\AppModel\\PackageRepository\\Packages";

 /******************************************************************************
  *  init_current_version
@@ -1681,3 +1685,114 @@ LONG WINAPI PackageIdFromFullName(const WCHAR *full_name, UINT32 flags, UINT32 *

     return ERROR_SUCCESS;
 }
+
+
+/***********************************************************************
+ *         GetPackagesByPackageFamily   (kernelbase.@)
+ */
+LONG WINAPI GetPackagesByPackageFamily(const WCHAR *family_name, UINT32 *count, WCHAR **full_names,
+        UINT32 *buffer_length, WCHAR *buffer)
+{
+    UINT32 curr_count, curr_length, package_id_buf_size, size;
+    unsigned int i, name_len, publisher_id_len;
+    DWORD subkey_count, max_key_len, length;
+    const WCHAR *publisher_id;
+    WCHAR *package_name;
+    BOOL short_buffer;
+    PACKAGE_ID *id;
+    HKEY key;
+
+    TRACE("family_name %s, count %p, full_names %p, buffer_length %p, buffer %p.\n",
+            debugstr_w(family_name), count, full_names, buffer_length, buffer);
+
+    if (!buffer_length || !count || !family_name)
+        return ERROR_INVALID_PARAMETER;
+
+    if ((*buffer_length || *count) && (!full_names || !buffer))
+        return ERROR_INVALID_PARAMETER;
+
+    if (!(publisher_id = wcschr(family_name, L'_')))
+        return ERROR_INVALID_PARAMETER;
+
+    name_len = publisher_id - family_name;
+    ++publisher_id;
+    publisher_id_len = lstrlenW(publisher_id);
+
+    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, packages_key_name, 0, KEY_READ, &key))
+    {
+        ERR("Key open failed.\n");
+        *count = 0;
+        *buffer_length = 0;
+        return ERROR_SUCCESS;
+    }
+    if (RegQueryInfoKeyW(key, NULL, NULL, NULL, &subkey_count, &max_key_len, NULL, NULL, NULL, NULL, NULL, NULL))
+    {
+        ERR("Query key info failed.\n");
+        RegCloseKey(key);
+        *count = 0;
+        *buffer_length = 0;
+        return ERROR_SUCCESS;
+    }
+
+    if (!(package_name = heap_alloc((max_key_len + 1) * sizeof(*package_name))))
+    {
+        ERR("No memory.\n");
+        RegCloseKey(key);
+        return ERROR_OUTOFMEMORY;
+    }
+
+    package_id_buf_size = sizeof(*id) + (max_key_len + 1) * sizeof(WCHAR);
+    if (!(id = heap_alloc(package_id_buf_size)))
+    {
+        ERR("No memory.\n");
+        heap_free(package_name);
+        RegCloseKey(key);
+        return ERROR_OUTOFMEMORY;
+    }
+
+    curr_count = curr_length = 0;
+    for (i = 0; i < subkey_count; ++i)
+    {
+        length = max_key_len + 1;
+        if (RegEnumKeyExW(key, i, package_name, &length, NULL, NULL, NULL, NULL))
+        {
+            ERR("Error enumerating key %u.\n", i);
+            continue;
+        }
+
+        size = package_id_buf_size;
+        if (PackageIdFromFullName(package_name, 0, &size, (BYTE *)id))
+        {
+            ERR("Error getting package id from full name.\n");
+            continue;
+        }
+
+        if (lstrlenW(id->name) != name_len)
+            continue;
+        if (wcsnicmp(family_name, id->name, name_len))
+            continue;
+
+        if (lstrlenW(id->publisherId) != publisher_id_len)
+            continue;
+        if (wcsnicmp(publisher_id, id->publisherId, publisher_id_len))
+            continue;
+        if (curr_length + length < *buffer_length)
+        {
+            memcpy(buffer + curr_length, package_name, (length + 1) * sizeof(*package_name));
+            if (curr_count < *count)
+                full_names[curr_count] = buffer + curr_length;
+        }
+        curr_length += length + 1;
+        ++curr_count;
+    }
+
+    heap_free(id);
+    heap_free(package_name);
+    RegCloseKey(key);
+
+    short_buffer = curr_length > *buffer_length || curr_count > *count;
+    *count = curr_count;
+    *buffer_length = curr_length;
+
+    return short_buffer ? ERROR_INSUFFICIENT_BUFFER : ERROR_SUCCESS;
+}
diff --git a/include/appmodel.h b/include/appmodel.h
index e4288bbfbb0..27a0d0a8646 100644
--- a/include/appmodel.h
+++ b/include/appmodel.h
@@ -82,6 +82,8 @@ LONG WINAPI AppPolicyGetProcessTerminationMethod(HANDLE token, AppPolicyProcessT
 LONG WINAPI AppPolicyGetShowDeveloperDiagnostic(HANDLE token, AppPolicyShowDeveloperDiagnostic *policy);
 LONG WINAPI AppPolicyGetThreadInitializationType(HANDLE token, AppPolicyThreadInitializationType *policy);
 LONG WINAPI AppPolicyGetWindowingModel(HANDLE processToken, AppPolicyWindowingModel *policy);
+LONG WINAPI GetPackagesByPackageFamily(const WCHAR *family_name, UINT32 *count, WCHAR **full_names,
+        UINT32 *buffer_length, WCHAR *buffer);
 LONG WINAPI PackageIdFromFullName(const WCHAR *full_name, UINT32 flags, UINT32 *buffer_length, BYTE *buffer);

 #if defined(__cplusplus)
--
2.30.2

From 1bf233880b472769e5b560a3d50adbbecfeb5736 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 26 Mar 2021 01:10:08 +0300
Subject: [PATCH 09/16] kernel32: Implement PackageFullNameFromId().

---
 .../api-ms-win-appmodel-runtime-l1-1-1.spec   |  2 +-
 .../ext-ms-win-kernel32-package-l1-1-1.spec   |  2 +-
 dlls/kernel32/kernel32.spec                   |  1 +
 dlls/kernel32/tests/version.c                 | 22 +++++++++-
 dlls/kernelbase/kernelbase.spec               |  2 +-
 dlls/kernelbase/version.c                     | 43 +++++++++++++++++++
 include/appmodel.h                            |  1 +
 7 files changed, 69 insertions(+), 4 deletions(-)

diff --git a/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec b/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec
index 696bb75be30..72a0a33baf5 100644
--- a/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec
+++ b/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec
@@ -21,7 +21,7 @@
 @ stub OpenPackageInfoByFullName
 @ stub PackageFamilyNameFromFullName
 @ stub PackageFamilyNameFromId
-@ stub PackageFullNameFromId
+@ stdcall PackageFullNameFromId(ptr ptr ptr) kernel32.PackageFullNameFromId
 @ stdcall PackageIdFromFullName(wstr long ptr ptr) kernel32.PackageIdFromFullName
 @ stub PackageNameAndPublisherIdFromFamilyName
 @ stub ParseApplicationUserModelId
diff --git a/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec b/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec
index ff5118049e2..42566176b56 100644
--- a/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec
+++ b/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec
@@ -17,5 +17,5 @@
 @ stub OpenPackageInfoByFullName
 @ stub PackageFamilyNameFromFullName
 @ stub PackageFamilyNameFromId
-@ stub PackageFullNameFromId
+@ stdcall PackageFullNameFromId(ptr ptr ptr) kernel32.PackageFullNameFromId
 @ stdcall PackageIdFromFullName(wstr long ptr ptr) kernel32.PackageIdFromFullName
diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 59785a6de24..491f5ca0402 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -1152,6 +1152,7 @@
 @ stdcall -import PeekConsoleInputW(ptr ptr long ptr)
 @ stdcall -import PeekNamedPipe(long ptr long ptr ptr ptr)
 @ stdcall -import PostQueuedCompletionStatus(long long ptr ptr)
+@ stdcall -import PackageFullNameFromId(ptr ptr ptr)
 @ stdcall -import PackageIdFromFullName(wstr long ptr ptr)
 @ stdcall PowerClearRequest(long long)
 @ stdcall PowerCreateRequest(ptr)
diff --git a/dlls/kernel32/tests/version.c b/dlls/kernel32/tests/version.c
index 9a35d679323..ed1ef3e3bf7 100644
--- a/dlls/kernel32/tests/version.c
+++ b/dlls/kernel32/tests/version.c
@@ -26,6 +26,7 @@
 static LONG (WINAPI * pGetPackagesByPackageFamily)(const WCHAR *, UINT32 *, WCHAR **, UINT32 *, WCHAR *);
 static BOOL (WINAPI * pGetProductInfo)(DWORD, DWORD, DWORD, DWORD, DWORD *);
 static UINT (WINAPI * pGetSystemFirmwareTable)(DWORD, DWORD, void *, DWORD);
+static LONG (WINAPI * pPackageFullNameFromId)(const PACKAGE_ID *, UINT32 *, WCHAR *);
 static LONG (WINAPI * pPackageIdFromFullName)(const WCHAR *, UINT32, UINT32 *, BYTE *);
 static NTSTATUS (WINAPI * pNtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS, void *, ULONG, ULONG *);
 static NTSTATUS (WINAPI * pRtlGetVersion)(RTL_OSVERSIONINFOEXW *);
@@ -47,6 +48,7 @@ static void init_function_pointers(void)
     GET_PROC(GetPackagesByPackageFamily);
     GET_PROC(GetProductInfo);
     GET_PROC(GetSystemFirmwareTable);
+    GET_PROC(PackageFullNameFromId);
     GET_PROC(PackageIdFromFullName);

     hmod = GetModuleHandleA("ntdll.dll");
@@ -803,9 +805,11 @@ static void test_PackageIdFromFullName(void)
     {
         0, PROCESSOR_ARCHITECTURE_INTEL,
                 {{.Major = 1, .Minor = 2, .Build = 3, .Revision = 4}},
-                (WCHAR *)L"TestPackage", NULL,
+                (WCHAR *)L"TestPackage", (WCHAR *)L"TestResource",
                 (WCHAR *)L"TestResourceId", (WCHAR *)L"0abcdefghjkme"
     };
+    static const WCHAR test_package_fullname[] =
+            L"TestPackage_1.2.3.4_x86_TestResourceId_0abcdefghjkme";
     UINT32 size, expected_size;
     PACKAGE_ID test_id;
     WCHAR fullname[512];
@@ -918,6 +922,22 @@ static void test_PackageIdFromFullName(void)
     size = sizeof(id_buffer);
     ret = pPackageIdFromFullName(L"TestPackage_1.2.3.4_X86_0abcdefghjkme", 0, &size, id_buffer);
     ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+
+    ret = pPackageFullNameFromId(&test_package_id, NULL, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+
+    size = sizeof(fullname);
+    ret = pPackageFullNameFromId(&test_package_id, &size, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+
+    size = 0;
+    ret = pPackageFullNameFromId(&test_package_id, &size, NULL);
+    ok(ret == ERROR_INSUFFICIENT_BUFFER, "Got unexpected ret %u.\n", ret);
+    ok(size == lstrlenW(test_package_fullname) + 1, "Got unexpected size %u.\n", size);
+
+    ret = pPackageFullNameFromId(&test_package_id, &size, fullname);
+    ok(ret == ERROR_SUCCESS, "Got unexpected ret %u.\n", ret);
+    ok(!lstrcmpW(fullname, test_package_fullname), "Got unexpected fullname %s.\n", debugstr_w(fullname));
 }

 static void test_package_info(void)
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 5d21680f512..81d88b1a33a 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -1012,7 +1012,7 @@
 # @ stub PackageFamilyNameFromFullName
 # @ stub PackageFamilyNameFromId
 # @ stub PackageFamilyNameFromProductId
-# @ stub PackageFullNameFromId
+@ stdcall PackageFullNameFromId(ptr ptr ptr)
 # @ stub PackageFullNameFromProductId
 @ stdcall PackageIdFromFullName(wstr long ptr ptr)
 # @ stub PackageIdFromProductId
diff --git a/dlls/kernelbase/version.c b/dlls/kernelbase/version.c
index dca4ffb8647..560e45e965a 100644
--- a/dlls/kernelbase/version.c
+++ b/dlls/kernelbase/version.c
@@ -1597,6 +1597,16 @@ static UINT32 processor_arch_from_string(const WCHAR *str, unsigned int len)
     return ~0u;
 }

+const WCHAR *string_from_processor_arch(UINT32 code)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(arch_names); ++i)
+        if (code == arch_names[i].code)
+            return arch_names[i].name;
+    return NULL;
+}
+
 /***********************************************************************
  *         PackageIdFromFullName   (kernelbase.@)
  */
@@ -1687,6 +1697,39 @@ LONG WINAPI PackageIdFromFullName(const WCHAR *full_name, UINT32 flags, UINT32 *
 }


+/***********************************************************************
+ *         PackageFullNameFromId   (kernelbase.@)
+ */
+LONG WINAPI PackageFullNameFromId(const PACKAGE_ID *package_id, UINT32 *length, WCHAR *full_name)
+{
+    WCHAR ver_str[5 * 4 + 3 + 1];
+    const WCHAR *arch_str;
+    UINT32 have_length;
+
+    TRACE("package_id %p, length %p, full_name %p.\n", package_id, length, full_name);
+
+    if (!package_id || !length)
+        return ERROR_INVALID_PARAMETER;
+    if (!full_name && *length)
+        return ERROR_INVALID_PARAMETER;
+    if (!package_id->name || !package_id->resourceId || !package_id->publisherId
+            || !(arch_str = string_from_processor_arch(package_id->processorArchitecture)))
+        return ERROR_INVALID_PARAMETER;
+
+    swprintf(ver_str, ARRAY_SIZE(ver_str), L"%u.%u.%u.%u", package_id->version.u.s.Major,
+            package_id->version.u.s.Minor, package_id->version.u.s.Build, package_id->version.u.s.Revision);
+    have_length = *length;
+    *length = lstrlenW(package_id->name) + 1 + lstrlenW(ver_str) + 1 + lstrlenW(arch_str) + 1
+            + lstrlenW(package_id->resourceId) + 1 + lstrlenW(package_id->publisherId) + 1;
+
+    if (have_length < *length)
+        return ERROR_INSUFFICIENT_BUFFER;
+
+    swprintf(full_name, *length, L"%s_%s_%s_%s_%s", package_id->name, ver_str, arch_str, package_id->resourceId, package_id->publisherId);
+    return ERROR_SUCCESS;
+}
+
+
 /***********************************************************************
  *         GetPackagesByPackageFamily   (kernelbase.@)
  */
diff --git a/include/appmodel.h b/include/appmodel.h
index 27a0d0a8646..be59bc70f5f 100644
--- a/include/appmodel.h
+++ b/include/appmodel.h
@@ -84,6 +84,7 @@ LONG WINAPI AppPolicyGetThreadInitializationType(HANDLE token, AppPolicyThreadIn
 LONG WINAPI AppPolicyGetWindowingModel(HANDLE processToken, AppPolicyWindowingModel *policy);
 LONG WINAPI GetPackagesByPackageFamily(const WCHAR *family_name, UINT32 *count, WCHAR **full_names,
         UINT32 *buffer_length, WCHAR *buffer);
+LONG WINAPI PackageFullNameFromId(const PACKAGE_ID *package_id, UINT32 *length, WCHAR *full_name);
 LONG WINAPI PackageIdFromFullName(const WCHAR *full_name, UINT32 flags, UINT32 *buffer_length, BYTE *buffer);

 #if defined(__cplusplus)
--
2.30.2

From fb64ea93325eb2d4aa9be77c3e2b07ca20052c3d Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 15 Mar 2021 22:05:19 +0300
Subject: [PATCH 10/16] kernel32: Implement GetPackagePath().

---
 .../api-ms-win-appmodel-runtime-l1-1-1.spec   |  2 +-
 .../ext-ms-win-kernel32-package-l1-1-1.spec   |  2 +-
 dlls/kernel32/kernel32.spec                   |  1 +
 dlls/kernel32/tests/version.c                 | 64 +++++++++++++--
 dlls/kernelbase/kernelbase.spec               |  2 +-
 dlls/kernelbase/version.c                     | 82 +++++++++++++++++++
 include/appmodel.h                            |  1 +
 7 files changed, 146 insertions(+), 8 deletions(-)

diff --git a/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec b/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec
index 72a0a33baf5..e77ac397b03 100644
--- a/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec
+++ b/dlls/api-ms-win-appmodel-runtime-l1-1-1/api-ms-win-appmodel-runtime-l1-1-1.spec
@@ -13,7 +13,7 @@
 @ stdcall GetPackageFullName(long ptr ptr) kernel32.GetPackageFullName
 @ stub GetPackageId
 @ stub GetPackageInfo
-@ stub GetPackagePath
+@ stdcall GetPackagePath(ptr long ptr ptr) kernel32.GetPackagePath
 @ stub GetPackagePathByFullName
 @ stdcall GetPackagesByPackageFamily(wstr ptr ptr ptr ptr) kernel32.GetPackagesByPackageFamily
 @ stub GetStagedPackageOrigin
diff --git a/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec b/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec
index 42566176b56..58bf807b4be 100644
--- a/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec
+++ b/dlls/ext-ms-win-kernel32-package-l1-1-1/ext-ms-win-kernel32-package-l1-1-1.spec
@@ -11,7 +11,7 @@
 @ stdcall GetPackageFullName(long ptr ptr) kernel32.GetPackageFullName
 @ stub GetPackageId
 @ stub GetPackageInfo
-@ stub GetPackagePath
+@ stdcall GetPackagePath(ptr long ptr ptr) kernel32.GetPackagePath
 @ stdcall GetPackagesByPackageFamily(wstr ptr ptr ptr ptr) kernel32.GetPackagesByPackageFamily
 @ stub GetStagedPackageOrigin
 @ stub OpenPackageInfoByFullName
diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 491f5ca0402..6b1030b00df 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -768,6 +768,7 @@
 @ stdcall -import GetPackagesByPackageFamily(wstr ptr ptr ptr ptr)
 @ stdcall GetPackageFamilyName(long ptr ptr) kernelbase.GetPackageFamilyName
 @ stdcall GetPackageFullName(long ptr ptr) kernelbase.GetPackageFullName
+@ stdcall -import GetPackagePath(ptr long ptr ptr)
 @ stdcall -import GetPhysicallyInstalledSystemMemory(ptr)
 @ stdcall -import GetPriorityClass(long)
 @ stdcall GetPrivateProfileIntA(str str long str)
diff --git a/dlls/kernel32/tests/version.c b/dlls/kernel32/tests/version.c
index ed1ef3e3bf7..1d5dc550d46 100644
--- a/dlls/kernel32/tests/version.c
+++ b/dlls/kernel32/tests/version.c
@@ -23,6 +23,7 @@
 #include "winternl.h"
 #include "appmodel.h"

+static LONG (WINAPI * pGetPackagePath)(const PACKAGE_ID *, const UINT32, UINT32 *, WCHAR *);
 static LONG (WINAPI * pGetPackagesByPackageFamily)(const WCHAR *, UINT32 *, WCHAR **, UINT32 *, WCHAR *);
 static BOOL (WINAPI * pGetProductInfo)(DWORD, DWORD, DWORD, DWORD, DWORD *);
 static UINT (WINAPI * pGetSystemFirmwareTable)(DWORD, DWORD, void *, DWORD);
@@ -45,6 +46,7 @@ static void init_function_pointers(void)

     hmod = GetModuleHandleA("kernel32.dll");

+    GET_PROC(GetPackagePath);
     GET_PROC(GetPackagesByPackageFamily);
     GET_PROC(GetProductInfo);
     GET_PROC(GetSystemFirmwareTable);
@@ -943,15 +945,15 @@ static void test_PackageIdFromFullName(void)
 static void test_package_info(void)
 {
     static const WCHAR package_family_msvc140[] = L"Microsoft.VCLibs.140.00_8wekyb3d8bbwe";
-    UINT32 count, length, curr_length, size;
+    UINT32 count, length, curr_length, size, path_length, total_length;
+    WCHAR buffer[2048], path[MAX_PATH];
+    PACKAGE_ID *id, saved_id;
     WCHAR *full_names[32];
     BYTE id_buffer[512];
-    WCHAR buffer[2048];
+    DWORD arch, attrib;
     BOOL arch_found;
     SYSTEM_INFO si;
     unsigned int i;
-    PACKAGE_ID *id;
-    DWORD arch;
     LONG ret;

     if (!pGetPackagesByPackageFamily)
@@ -1032,6 +1034,10 @@ static void test_package_info(void)
     ok(count == ARRAY_SIZE(full_names), "Got unexpected count %u.\n", count);
     ok(length == ARRAY_SIZE(buffer), "Got unexpected length %u.\n", length);

+    length = 0;
+    ret = pGetPackagePath(NULL, 0, &length, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+
     count = 0;
     length = 0;
     ret = pGetPackagesByPackageFamily(package_family_msvc140, &count, NULL, &length, NULL);
@@ -1050,6 +1056,7 @@ static void test_package_info(void)
     ok(count >= 1, "Got unexpected count %u.\n", count);
     ok(length > 1, "Got unexpected length %u.\n", length);

+    total_length = length;
     id = (PACKAGE_ID *)id_buffer;
     curr_length = 0;
     arch_found = FALSE;
@@ -1063,9 +1070,56 @@ static void test_package_info(void)

         if (id->processorArchitecture == arch)
             arch_found = TRUE;
+
+        path_length = 0;
+        ret = pGetPackagePath(id, 0, &path_length, NULL);
+        ok(ret == ERROR_INSUFFICIENT_BUFFER, "Got unexpected ret %u.\n", ret);
+        ok(path_length > 1, "Got unexpected path_length %u.\n", path_length);
+
+        length = path_length;
+        ret = pGetPackagePath(id, 0, &length, path);
+        ok(ret == ERROR_SUCCESS, "Got unexpected ret %u.\n", ret);
+        ok(length == path_length, "Got unexpected length %u.\n", length);
+        attrib = GetFileAttributesW(path);
+        ok(attrib != INVALID_FILE_ATTRIBUTES && attrib & FILE_ATTRIBUTE_DIRECTORY,
+                "Got unexpected attrib %#x, GetLastError() %u.\n", attrib, GetLastError());
     }
-    ok(curr_length == length, "Got unexpected length %u.\n", length);
+    ok(curr_length == total_length, "Got unexpected length %u.\n", length);
     ok(arch_found, "Did not find package for current arch.\n");
+
+    size = sizeof(id_buffer);
+    ret = pPackageIdFromFullName(full_names[0], 0, &size, id_buffer);
+    ok(ret == ERROR_SUCCESS, "Got unexpected ret %u.\n", ret);
+    saved_id = *id;
+
+    id->publisherId = NULL;
+    length = ARRAY_SIZE(path);
+    ret = pGetPackagePath(id, 0, &length, path);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+
+    *id = saved_id;
+    id->name = NULL;
+    length = ARRAY_SIZE(path);
+    ret = pGetPackagePath(id, 0, &length, path);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+
+    *id = saved_id;
+    id->publisher = NULL;
+    length = ARRAY_SIZE(path);
+    ret = pGetPackagePath(id, 0, &length, path);
+    ok(ret == ERROR_SUCCESS, "Got unexpected ret %u.\n", ret);
+
+    *id = saved_id;
+    id->processorArchitecture = ~0u;
+    length = ARRAY_SIZE(path);
+    ret = pGetPackagePath(id, 0, &length, path);
+    ok(ret == ERROR_INVALID_PARAMETER, "Got unexpected ret %u.\n", ret);
+
+    *id = saved_id;
+    id->name[0] = L'X';
+    length = ARRAY_SIZE(path);
+    ret = pGetPackagePath(id, 0, &length, path);
+    ok(ret == ERROR_NOT_FOUND, "Got unexpected ret %u.\n", ret);
 }

 START_TEST(version)
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 81d88b1a33a..0b374a53b60 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -601,7 +601,7 @@
 # @ stub GetPackageInfo
 # @ stub GetPackageInstallTime
 # @ stub GetPackageOSMaxVersionTested
-# @ stub GetPackagePath
+@ stdcall GetPackagePath(ptr long ptr ptr)
 # @ stub GetPackagePathByFullName
 # @ stub GetPackagePathOnVolume
 # @ stub GetPackageProperty
diff --git a/dlls/kernelbase/version.c b/dlls/kernelbase/version.c
index 560e45e965a..1f16194a565 100644
--- a/dlls/kernelbase/version.c
+++ b/dlls/kernelbase/version.c
@@ -1839,3 +1839,85 @@ LONG WINAPI GetPackagesByPackageFamily(const WCHAR *family_name, UINT32 *count,

     return short_buffer ? ERROR_INSUFFICIENT_BUFFER : ERROR_SUCCESS;
 }
+
+
+/***********************************************************************
+ *         GetPackagePath   (kernelbase.@)
+ */
+LONG WINAPI GetPackagePath(const PACKAGE_ID *package_id, const UINT32 reserved, UINT32 *length, WCHAR *path)
+{
+    WCHAR *key_name = NULL, *expanded_path = NULL;
+    UINT32 required_length, have_length;
+    unsigned int offset;
+    HKEY key = NULL;
+    DWORD size;
+    LONG ret;
+
+    TRACE("package_id %p, reserved %u, length %p, path %p.\n", package_id, reserved, length, path);
+
+    if (!length)
+        return ERROR_INVALID_PARAMETER;
+    if (!path && *length)
+        return ERROR_INVALID_PARAMETER;
+
+    required_length = 0;
+    if ((ret = PackageFullNameFromId(package_id, &required_length, NULL)) != ERROR_INSUFFICIENT_BUFFER)
+        return ret;
+
+    offset = lstrlenW(packages_key_name) + 1;
+    if (!(key_name = heap_alloc((offset + required_length) * sizeof(WCHAR))))
+    {
+        ERR("No memory.");
+        return ERROR_OUTOFMEMORY;
+    }
+
+    if ((ret = PackageFullNameFromId(package_id, &required_length, key_name + offset)))
+        goto done;
+
+    memcpy(key_name, packages_key_name, (offset - 1) * sizeof(WCHAR));
+    key_name[offset - 1] = L'\\';
+
+    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, key_name, 0, KEY_READ, &key))
+    {
+        WARN("Key %s not found.\n", debugstr_w(key_name));
+        ret = ERROR_NOT_FOUND;
+        goto done;
+    }
+    if (RegGetValueW(key, NULL, L"Path", RRF_RT_REG_SZ, NULL, NULL, &size))
+    {
+        WARN("Path value not found in %s.\n", debugstr_w(key_name));
+        ret = ERROR_NOT_FOUND;
+        goto done;
+    }
+    if (!(expanded_path = heap_alloc(size)))
+    {
+        ERR("No memory.");
+        ret = ERROR_OUTOFMEMORY;
+        goto done;
+    }
+    if (RegGetValueW(key, NULL, L"Path", RRF_RT_REG_SZ, NULL, expanded_path, &size))
+    {
+        WARN("Could not get Path value from %s.\n", debugstr_w(key_name));
+        ret = ERROR_NOT_FOUND;
+        goto done;
+    }
+
+    have_length = *length;
+    *length = lstrlenW(expanded_path) + 1;
+    if (have_length >= *length)
+    {
+        memcpy(path, expanded_path, *length * sizeof(*path));
+        ret = ERROR_SUCCESS;
+    }
+    else
+    {
+        ret = ERROR_INSUFFICIENT_BUFFER;
+    }
+
+done:
+    if (key)
+        RegCloseKey(key);
+    heap_free(expanded_path);
+    heap_free(key_name);
+    return ret;
+}
diff --git a/include/appmodel.h b/include/appmodel.h
index be59bc70f5f..c73cb8d26ef 100644
--- a/include/appmodel.h
+++ b/include/appmodel.h
@@ -82,6 +82,7 @@ LONG WINAPI AppPolicyGetProcessTerminationMethod(HANDLE token, AppPolicyProcessT
 LONG WINAPI AppPolicyGetShowDeveloperDiagnostic(HANDLE token, AppPolicyShowDeveloperDiagnostic *policy);
 LONG WINAPI AppPolicyGetThreadInitializationType(HANDLE token, AppPolicyThreadInitializationType *policy);
 LONG WINAPI AppPolicyGetWindowingModel(HANDLE processToken, AppPolicyWindowingModel *policy);
+LONG WINAPI GetPackagePath(const PACKAGE_ID *package_id, const UINT32 reserved, UINT32 *length, WCHAR *path);
 LONG WINAPI GetPackagesByPackageFamily(const WCHAR *family_name, UINT32 *count, WCHAR **full_names,
         UINT32 *buffer_length, WCHAR *buffer);
 LONG WINAPI PackageFullNameFromId(const PACKAGE_ID *package_id, UINT32 *length, WCHAR *full_name);
--
2.30.2

From 995fdfb8cdb0a8eed82e16640034dc9673ded681 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 12 Mar 2021 23:58:39 +0300
Subject: [PATCH 14/16] esync: Fix restoring the objects state on wait all
 objects retry.

---
 dlls/ntdll/unix/esync.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 9a615fb277c..810477d02a0 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -1168,10 +1168,22 @@ tryagain:
                         {
                             /* We were too slow. Put everything back. */
                             value = 1;
-                            for (j = i; j >= 0; j--)
+                            for (j = i - 1; j >= 0; j--)
                             {
-                                if (write( obj->fd, &value, sizeof(value) ) == -1)
+                                struct esync *obj = objs[j];
+
+                                if (obj->type == ESYNC_MUTEX)
+                                {
+                                    struct mutex *mutex = obj->shm;
+
+                                    if (mutex->tid == GetCurrentThreadId())
+                                        continue;
+                                }
+                                if (write( fds[j].fd, &value, sizeof(value) ) == -1)
+                                {
+                                    ERR("write failed.\n");
                                     return errno_to_status( errno );
+                                }
                             }

                             goto tryagain;  /* break out of two loops and a switch */
--
2.30.2

From 47be204baf902d876fc5e5b0240b6167500ec0dd Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 29 Mar 2021 21:54:30 +0300
Subject: [PATCH] dxgi: Use proxy IDXGISwapChain interface when importing that
 from d3d implementation.

For Origin overlay.

Required for Origin overlay to work (which expects IDXGISwapChain
implementation methods to reside in dxgi.dll).
---
 dlls/dxgi/factory.c   | 511 +++++++++++++++++++++++++++++++++++++++++-
 dlls/dxgi/swapchain.c |   6 +-
 2 files changed, 509 insertions(+), 8 deletions(-)

diff --git a/dlls/dxgi/factory.c b/dlls/dxgi/factory.c
index af18bdd2c32..020faa26a11 100644
--- a/dlls/dxgi/factory.c
+++ b/dlls/dxgi/factory.c
@@ -29,7 +29,7 @@ static inline struct dxgi_factory *impl_from_IWineDXGIFactory(IWineDXGIFactory *
     return CONTAINING_RECORD(iface, struct dxgi_factory, IWineDXGIFactory_iface);
 }

-static HRESULT STDMETHODCALLTYPE dxgi_factory_QueryInterface(IWineDXGIFactory *iface, REFIID iid, void **out)
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH dxgi_factory_QueryInterface(IWineDXGIFactory *iface, REFIID iid, void **out)
 {
     struct dxgi_factory *factory = impl_from_IWineDXGIFactory(iface);

@@ -58,7 +58,7 @@ static HRESULT STDMETHODCALLTYPE dxgi_factory_QueryInterface(IWineDXGIFactory *i
     return E_NOINTERFACE;
 }

-static ULONG STDMETHODCALLTYPE dxgi_factory_AddRef(IWineDXGIFactory *iface)
+static ULONG STDMETHODCALLTYPE DECLSPEC_HOTPATCH dxgi_factory_AddRef(IWineDXGIFactory *iface)
 {
     struct dxgi_factory *factory = impl_from_IWineDXGIFactory(iface);
     ULONG refcount = InterlockedIncrement(&factory->refcount);
@@ -68,7 +68,7 @@ static ULONG STDMETHODCALLTYPE dxgi_factory_AddRef(IWineDXGIFactory *iface)
     return refcount;
 }

-static ULONG STDMETHODCALLTYPE dxgi_factory_Release(IWineDXGIFactory *iface)
+static ULONG STDMETHODCALLTYPE DECLSPEC_HOTPATCH dxgi_factory_Release(IWineDXGIFactory *iface)
 {
     struct dxgi_factory *factory = impl_from_IWineDXGIFactory(iface);
     ULONG refcount = InterlockedDecrement(&factory->refcount);
@@ -267,7 +267,494 @@ static BOOL STDMETHODCALLTYPE dxgi_factory_IsWindowedStereoEnabled(IWineDXGIFact
     return FALSE;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_factory_CreateSwapChainForHwnd(IWineDXGIFactory *iface,
+struct proxy_swapchain
+{
+    IDXGISwapChain4 IDXGISwapChain4_iface;
+    IDXGISwapChain4 *swapchain;
+};
+
+static inline struct proxy_swapchain *proxy_swapchain_from_IDXGISwapChain4(IDXGISwapChain4 *iface)
+{
+    return CONTAINING_RECORD(iface, struct proxy_swapchain, IDXGISwapChain4_iface);
+}
+
+/* IUnknown methods */
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_QueryInterface(IDXGISwapChain4 *iface, REFIID riid, void **object)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+    TRACE("iface %p, riid %s, object %p\n", iface, debugstr_guid(riid), object);
+
+    if (IsEqualGUID(riid, &IID_IUnknown)
+            || IsEqualGUID(riid, &IID_IDXGIObject)
+            || IsEqualGUID(riid, &IID_IDXGIDeviceSubObject)
+            || IsEqualGUID(riid, &IID_IDXGISwapChain)
+            || IsEqualGUID(riid, &IID_IDXGISwapChain1)
+            || IsEqualGUID(riid, &IID_IDXGISwapChain2)
+            || IsEqualGUID(riid, &IID_IDXGISwapChain3)
+            || IsEqualGUID(riid, &IID_IDXGISwapChain4))
+    {
+        IDXGISwapChain4_AddRef(swapchain->swapchain);
+        *object = iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE\n", debugstr_guid(riid));
+
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_AddRef(IDXGISwapChain4 *iface)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE("swapchain %p.\n", swapchain);
+
+    return IDXGISwapChain4_AddRef(swapchain->swapchain);
+}
+
+static ULONG STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_Release(IDXGISwapChain4 *iface)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+    ULONG refcount = IDXGISwapChain4_Release(swapchain->swapchain);
+
+    TRACE("%p decreasing refcount to %u.\n", swapchain, refcount);
+
+    if (!refcount)
+        heap_free(swapchain);
+
+    return refcount;
+}
+
+/* IDXGIObject methods */
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_SetPrivateData(IDXGISwapChain4 *iface,
+        REFGUID guid, UINT data_size, const void *data)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE("iface %p, guid %s, data_size %u, data %p.\n", iface, debugstr_guid(guid), data_size, data);
+
+    return IDXGISwapChain4_SetPrivateData(swapchain->swapchain, guid, data_size, data);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_SetPrivateDataInterface(IDXGISwapChain4 *iface,
+        REFGUID guid, const IUnknown *object)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE("iface %p, guid %s, object %p.\n", iface, debugstr_guid(guid), object);
+
+    return IDXGISwapChain4_SetPrivateDataInterface(swapchain->swapchain, guid, object);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetPrivateData(IDXGISwapChain4 *iface,
+        REFGUID guid, UINT *data_size, void *data)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE("iface %p, guid %s, data_size %p, data %p.\n", iface, debugstr_guid(guid), data_size, data);
+
+    return IDXGISwapChain4_GetPrivateData(swapchain->swapchain, guid, data_size, data);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetParent(IDXGISwapChain4 *iface, REFIID riid, void **parent)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE("iface %p, riid %s, parent %p.\n", iface, debugstr_guid(riid), parent);
+
+    return IDXGISwapChain4_GetParent(swapchain->swapchain, riid, parent);
+}
+
+/* IDXGIDeviceSubObject methods */
+
+static HRESULT STDMETHODCALLTYPE proxy_swapchain_GetDevice(IDXGISwapChain4 *iface, REFIID riid, void **device)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE("iface %p, riid %s, device %p.\n", iface, debugstr_guid(riid), device);
+
+    return IDXGISwapChain4_GetDevice(swapchain->swapchain, riid, device);
+}
+
+/* IDXGISwapChain methods */
+
+HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_Present(IDXGISwapChain4 *iface, UINT sync_interval, UINT flags)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE("iface %p, sync_interval %u, flags %#x.\n", iface, sync_interval, flags);
+
+    return IDXGISwapChain4_Present(swapchain->swapchain, sync_interval, flags);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetBuffer(IDXGISwapChain4 *iface,
+        UINT buffer_idx, REFIID riid, void **surface)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetBuffer(swapchain->swapchain, buffer_idx, riid, surface);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_SetFullscreenState(IDXGISwapChain4 *iface,
+        BOOL fullscreen, IDXGIOutput *target)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_SetFullscreenState(swapchain->swapchain, fullscreen, target);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetFullscreenState(IDXGISwapChain4 *iface,
+        BOOL *fullscreen, IDXGIOutput **target)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetFullscreenState(swapchain->swapchain, fullscreen, target);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetDesc(IDXGISwapChain4 *iface, DXGI_SWAP_CHAIN_DESC *desc)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetDesc(swapchain->swapchain, desc);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_ResizeBuffers(IDXGISwapChain4 *iface,
+        UINT buffer_count, UINT width, UINT height, DXGI_FORMAT format, UINT flags)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_ResizeBuffers(swapchain->swapchain, buffer_count, width, height, format, flags);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_ResizeTarget(IDXGISwapChain4 *iface,
+        const DXGI_MODE_DESC *target_mode_desc)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_ResizeTarget(swapchain->swapchain, target_mode_desc);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetContainingOutput(IDXGISwapChain4 *iface, IDXGIOutput **output)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetContainingOutput(swapchain->swapchain, output);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetFrameStatistics(IDXGISwapChain4 *iface,
+        DXGI_FRAME_STATISTICS *stats)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetFrameStatistics(swapchain->swapchain, stats);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetLastPresentCount(IDXGISwapChain4 *iface,
+        UINT *last_present_count)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetLastPresentCount(swapchain->swapchain, last_present_count);
+}
+
+/* IDXGISwapChain1 methods */
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetDesc1(IDXGISwapChain4 *iface, DXGI_SWAP_CHAIN_DESC1 *desc)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetDesc1(swapchain->swapchain, desc);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetFullscreenDesc(IDXGISwapChain4 *iface,
+        DXGI_SWAP_CHAIN_FULLSCREEN_DESC *desc)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetFullscreenDesc(swapchain->swapchain, desc);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetHwnd(IDXGISwapChain4 *iface, HWND *hwnd)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetHwnd(swapchain->swapchain, hwnd);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetCoreWindow(IDXGISwapChain4 *iface,
+        REFIID iid, void **core_window)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetCoreWindow(swapchain->swapchain, iid, core_window);
+}
+
+HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_Present1(IDXGISwapChain4 *iface,
+        UINT sync_interval, UINT flags, const DXGI_PRESENT_PARAMETERS *present_parameters)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_Present1(swapchain->swapchain, sync_interval, flags, present_parameters);
+}
+
+static BOOL STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_IsTemporaryMonoSupported(IDXGISwapChain4 *iface)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_IsTemporaryMonoSupported(swapchain->swapchain);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetRestrictToOutput(IDXGISwapChain4 *iface, IDXGIOutput **output)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetRestrictToOutput(swapchain->swapchain, output);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_SetBackgroundColor(IDXGISwapChain4 *iface, const DXGI_RGBA *color)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_SetBackgroundColor(swapchain->swapchain, color);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetBackgroundColor(IDXGISwapChain4 *iface, DXGI_RGBA *color)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetBackgroundColor(swapchain->swapchain, color);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_SetRotation(IDXGISwapChain4 *iface, DXGI_MODE_ROTATION rotation)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_SetRotation(swapchain->swapchain, rotation);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetRotation(IDXGISwapChain4 *iface, DXGI_MODE_ROTATION *rotation)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetRotation(swapchain->swapchain, rotation);
+}
+
+/* IDXGISwapChain2 methods */
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_SetSourceSize(IDXGISwapChain4 *iface, UINT width, UINT height)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_SetSourceSize(swapchain->swapchain, width, height);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetSourceSize(IDXGISwapChain4 *iface, UINT *width, UINT *height)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetSourceSize(swapchain->swapchain, width, height);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_SetMaximumFrameLatency(IDXGISwapChain4 *iface, UINT max_latency)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_SetMaximumFrameLatency(swapchain->swapchain, max_latency);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetMaximumFrameLatency(IDXGISwapChain4 *iface, UINT *max_latency)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetMaximumFrameLatency(swapchain->swapchain, max_latency);
+}
+
+static HANDLE STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetFrameLatencyWaitableObject(IDXGISwapChain4 *iface)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetFrameLatencyWaitableObject(swapchain->swapchain);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_SetMatrixTransform(IDXGISwapChain4 *iface,
+        const DXGI_MATRIX_3X2_F *matrix)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_SetMatrixTransform(swapchain->swapchain, matrix);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetMatrixTransform(IDXGISwapChain4 *iface,
+        DXGI_MATRIX_3X2_F *matrix)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetMatrixTransform(swapchain->swapchain, matrix);
+}
+
+/* IDXGISwapChain3 methods */
+
+static UINT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_GetCurrentBackBufferIndex(IDXGISwapChain4 *iface)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_GetCurrentBackBufferIndex(swapchain->swapchain);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_CheckColorSpaceSupport(IDXGISwapChain4 *iface,
+        DXGI_COLOR_SPACE_TYPE colour_space, UINT *colour_space_support)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_CheckColorSpaceSupport(swapchain->swapchain, colour_space, colour_space_support);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_SetColorSpace1(IDXGISwapChain4 *iface,
+        DXGI_COLOR_SPACE_TYPE colour_space)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_SetColorSpace1(swapchain->swapchain, colour_space);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_ResizeBuffers1(IDXGISwapChain4 *iface,
+        UINT buffer_count, UINT width, UINT height, DXGI_FORMAT format, UINT flags,
+        const UINT *node_mask, IUnknown * const *present_queue)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_ResizeBuffers1(swapchain->swapchain, buffer_count, width, height, format, flags, node_mask, present_queue);
+}
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH proxy_swapchain_SetHDRMetaData(IDXGISwapChain4 *iface,
+        DXGI_HDR_METADATA_TYPE type, UINT size, void *metadata)
+{
+    struct proxy_swapchain *swapchain = proxy_swapchain_from_IDXGISwapChain4(iface);
+
+    TRACE(".\n");
+
+    return IDXGISwapChain4_SetHDRMetaData(swapchain->swapchain, type, size, metadata);
+}
+
+static const struct IDXGISwapChain4Vtbl proxy_swapchain_vtbl =
+{
+    /* IUnknown methods */
+    proxy_swapchain_QueryInterface,
+    proxy_swapchain_AddRef,
+    proxy_swapchain_Release,
+    /* IDXGIObject methods */
+    proxy_swapchain_SetPrivateData,
+    proxy_swapchain_SetPrivateDataInterface,
+    proxy_swapchain_GetPrivateData,
+    proxy_swapchain_GetParent,
+    /* IDXGIDeviceSubObject methods */
+    proxy_swapchain_GetDevice,
+    /* IDXGISwapChain methods */
+    proxy_swapchain_Present,
+    proxy_swapchain_GetBuffer,
+    proxy_swapchain_SetFullscreenState,
+    proxy_swapchain_GetFullscreenState,
+    proxy_swapchain_GetDesc,
+    proxy_swapchain_ResizeBuffers,
+    proxy_swapchain_ResizeTarget,
+    proxy_swapchain_GetContainingOutput,
+    proxy_swapchain_GetFrameStatistics,
+    proxy_swapchain_GetLastPresentCount,
+    /* IDXGISwapChain1 methods */
+    proxy_swapchain_GetDesc1,
+    proxy_swapchain_GetFullscreenDesc,
+    proxy_swapchain_GetHwnd,
+    proxy_swapchain_GetCoreWindow,
+    proxy_swapchain_Present1,
+    proxy_swapchain_IsTemporaryMonoSupported,
+    proxy_swapchain_GetRestrictToOutput,
+    proxy_swapchain_SetBackgroundColor,
+    proxy_swapchain_GetBackgroundColor,
+    proxy_swapchain_SetRotation,
+    proxy_swapchain_GetRotation,
+    /* IDXGISwapChain2 methods */
+    proxy_swapchain_SetSourceSize,
+    proxy_swapchain_GetSourceSize,
+    proxy_swapchain_SetMaximumFrameLatency,
+    proxy_swapchain_GetMaximumFrameLatency,
+    proxy_swapchain_GetFrameLatencyWaitableObject,
+    proxy_swapchain_SetMatrixTransform,
+    proxy_swapchain_GetMatrixTransform,
+    /* IDXGISwapChain3 methods */
+    proxy_swapchain_GetCurrentBackBufferIndex,
+    proxy_swapchain_CheckColorSpaceSupport,
+    proxy_swapchain_SetColorSpace1,
+    proxy_swapchain_ResizeBuffers1,
+    /* IDXGISwapChain4 methods */
+    proxy_swapchain_SetHDRMetaData,
+};
+
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH dxgi_factory_CreateSwapChainForHwnd(IWineDXGIFactory *iface,
         IUnknown *device, HWND window, const DXGI_SWAP_CHAIN_DESC1 *desc,
         const DXGI_SWAP_CHAIN_FULLSCREEN_DESC *fullscreen_desc,
         IDXGIOutput *output, IDXGISwapChain1 **swapchain)
@@ -299,9 +786,23 @@ static HRESULT STDMETHODCALLTYPE dxgi_factory_CreateSwapChainForHwnd(IWineDXGIFa

     if (SUCCEEDED(IUnknown_QueryInterface(device, &IID_IWineDXGISwapChainFactory, (void **)&swapchain_factory)))
     {
+        IDXGISwapChain4 *swapchain_impl;
         hr = IWineDXGISwapChainFactory_create_swapchain(swapchain_factory,
-                (IDXGIFactory *)iface, window, desc, fullscreen_desc, output, swapchain);
+                (IDXGIFactory *)iface, window, desc, fullscreen_desc, output, (IDXGISwapChain1 **)&swapchain_impl);
         IWineDXGISwapChainFactory_Release(swapchain_factory);
+        if (SUCCEEDED(hr))
+        {
+            struct proxy_swapchain *obj;
+
+            obj = heap_alloc_zero(sizeof(*obj));
+            obj->IDXGISwapChain4_iface.lpVtbl = &proxy_swapchain_vtbl;
+            obj->swapchain = swapchain_impl;
+            *swapchain = (IDXGISwapChain1 *)&obj->IDXGISwapChain4_iface;
+        }
+        else
+        {
+            *swapchain = NULL;
+        }
         return hr;
     }

diff --git a/dlls/dxgi/swapchain.c b/dlls/dxgi/swapchain.c
index 82e5fbf811d..b1153ac4927 100644
--- a/dlls/dxgi/swapchain.c
+++ b/dlls/dxgi/swapchain.c
@@ -232,7 +232,7 @@ static ULONG STDMETHODCALLTYPE d3d11_swapchain_AddRef(IDXGISwapChain1 *iface)
     return refcount;
 }

-static ULONG STDMETHODCALLTYPE d3d11_swapchain_Release(IDXGISwapChain1 *iface)
+static ULONG STDMETHODCALLTYPE DECLSPEC_HOTPATCH d3d11_swapchain_Release(IDXGISwapChain1 *iface)
 {
     struct d3d11_swapchain *swapchain = d3d11_swapchain_from_IDXGISwapChain1(iface);
     ULONG refcount = InterlockedDecrement(&swapchain->refcount);
@@ -325,7 +325,7 @@ static HRESULT STDMETHODCALLTYPE d3d11_swapchain_GetDevice(IDXGISwapChain1 *ifac

 /* IDXGISwapChain1 methods */

-static HRESULT d3d11_swapchain_present(struct d3d11_swapchain *swapchain,
+static HRESULT DECLSPEC_HOTPATCH d3d11_swapchain_present(struct d3d11_swapchain *swapchain,
         unsigned int sync_interval, unsigned int flags)
 {
     if (sync_interval > 4)
@@ -697,7 +697,7 @@ static HRESULT STDMETHODCALLTYPE d3d11_swapchain_GetCoreWindow(IDXGISwapChain1 *
     return DXGI_ERROR_INVALID_CALL;
 }

-static HRESULT STDMETHODCALLTYPE d3d11_swapchain_Present1(IDXGISwapChain1 *iface,
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH d3d11_swapchain_Present1(IDXGISwapChain1 *iface,
         UINT sync_interval, UINT flags, const DXGI_PRESENT_PARAMETERS *present_parameters)
 {
     struct d3d11_swapchain *swapchain = d3d11_swapchain_from_IDXGISwapChain1(iface);
From 2fb560afba703185617bef6e277aa0cad3fcf681 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 30 Mar 2021 00:38:36 +0300
Subject: [PATCH] dxgi: Specify an image base.

For Origin overlay.
---
 dlls/dxgi/Makefile.in | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/dxgi/Makefile.in b/dlls/dxgi/Makefile.in
index c21cb18d8ff..1c626be213b 100644
--- a/dlls/dxgi/Makefile.in
+++ b/dlls/dxgi/Makefile.in
@@ -3,7 +3,7 @@ IMPORTLIB = dxgi
 IMPORTS   = gdi32 dxguid uuid wined3d user32
 EXTRAINCL = $(VKD3D_CFLAGS)

-EXTRADLLFLAGS = -mcygwin
+EXTRADLLFLAGS = -Wl,--image-base,0x7bb00000 -mcygwin

 C_SRCS = \
 	adapter.c \
From fec2ecbd2dfd3c357f63c8f7bd9383b7a10d4553 Mon Sep 17 00:00:00 2001
From: Esme Povirk <esme@codeweavers.com>
Date: Thu, 22 Apr 2021 14:35:40 -0500
Subject: [PATCH] HACK: mscoree: For M&B2:Bannerlord, redirect ManagedStarter
 loads to Bannerlord.exe

For M&B2:Bannerlord.
---
 dlls/mscoree/metahost.c | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/dlls/mscoree/metahost.c b/dlls/mscoree/metahost.c
index d9b599fadc7..25acdced21e 100644
--- a/dlls/mscoree/metahost.c
+++ b/dlls/mscoree/metahost.c
@@ -1742,6 +1742,32 @@ static MonoAssembly* CDECL mono_assembly_preload_hook_fn(MonoAssemblyName *aname
         }
     }

+    if (!strcmp(assemblyname, "ManagedStarter"))
+    {
+        /* HACK for Mount & Blade II: Bannerlord
+         *
+         * The launcher executable uses an AssemblyResolve event handler
+         * to redirect loads of the "ManagedStarter" assembly to
+         * Bannerlord.exe. Due to Mono issue #11319, the runtime attempts
+         * to load ManagedStarter before executing the static constructor
+         * that adds this event handler. We work around this by doing the
+         * same thing in our own assembly load hook. */
+        const char* sgi = getenv("SteamGameId");
+        if (sgi && !strcmp(sgi, "261550"))
+        {
+            FIXME("hack, using Bannerlord.exe\n");
+
+            result = mono_assembly_open("Bannerlord.exe", &stat);
+
+            if (result)
+                goto done;
+            else
+            {
+                ERR("Bannerlord.exe failed to load\n");
+            }
+        }
+    }
+
     /* FIXME: We should search the given paths before the GAC. */

     if ((search_flags & ASSEMBLY_SEARCH_GAC) != 0)
From 003223a6816f3121a8e60d8ef3ec79e1768878ce Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 7 May 2021 13:44:00 -0500
Subject: [PATCH] HACK: dxgi: Return a static factory for RE8: Village

CW-Bug-Id: 18923
---
 dlls/dxgi/dxgi_main.c    | 15 ++++++
 dlls/dxgi/dxgi_private.h |  2 +
 dlls/dxgi/factory.c      | 99 +++++++++++++++++++++++++++++++++++++++-
 3 files changed, 115 insertions(+), 1 deletion(-)

diff --git a/dlls/dxgi/dxgi_main.c b/dlls/dxgi/dxgi_main.c
index 83c3f3734a7..941e23b3394 100644
--- a/dlls/dxgi/dxgi_main.c
+++ b/dlls/dxgi/dxgi_main.c
@@ -56,6 +56,18 @@ BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, void *reserved)
     return TRUE;
 }

+static BOOL is_re8(void)
+{
+    static int status = -1;
+
+    if(status < 0){
+        const char *sgi = getenv("SteamGameId");
+        status = sgi && !strcmp(sgi, "1196590");
+    }
+
+    return status != 0;
+}
+
 HRESULT WINAPI CreateDXGIFactory2(UINT flags, REFIID iid, void **factory)
 {
     TRACE("flags %#x, iid %s, factory %p.\n", flags, debugstr_guid(iid), factory);
@@ -70,6 +82,9 @@ HRESULT WINAPI CreateDXGIFactory1(REFIID iid, void **factory)
 {
     TRACE("iid %s, factory %p.\n", debugstr_guid(iid), factory);

+    if(is_re8())
+        return get_re8_dxgi_factory(iid, factory);
+
     return dxgi_factory_create(iid, factory, TRUE);
 }

diff --git a/dlls/dxgi/dxgi_private.h b/dlls/dxgi/dxgi_private.h
index acba3544e39..9d1b1cde342 100644
--- a/dlls/dxgi/dxgi_private.h
+++ b/dlls/dxgi/dxgi_private.h
@@ -209,4 +209,6 @@ struct dxgi_surface
 HRESULT dxgi_surface_init(struct dxgi_surface *surface, IDXGIDevice *device,
         IUnknown *outer, struct wined3d_texture *wined3d_texture) DECLSPEC_HIDDEN;

+HRESULT get_re8_dxgi_factory(REFIID riid, void **factory) DECLSPEC_HIDDEN;
+
 #endif /* __WINE_DXGI_PRIVATE_H */
diff --git a/dlls/dxgi/factory.c b/dlls/dxgi/factory.c
index 020faa26a11..ba7d3e78905 100644
--- a/dlls/dxgi/factory.c
+++ b/dlls/dxgi/factory.c
@@ -1044,6 +1044,8 @@ static const struct IWineDXGIFactoryVtbl dxgi_factory_vtbl =
     dxgi_factory_UnregisterAdaptersChangedEvent,
 };

+static const struct IWineDXGIFactoryVtbl re8_factory_vtbl;
+
 struct dxgi_factory *unsafe_impl_from_IDXGIFactory(IDXGIFactory *iface)
 {
     IWineDXGIFactory *wine_factory;
@@ -1057,7 +1059,8 @@ struct dxgi_factory *unsafe_impl_from_IDXGIFactory(IDXGIFactory *iface)
         ERR("Failed to get IWineDXGIFactory interface, hr %#x.\n", hr);
         return NULL;
     }
-    assert(wine_factory->lpVtbl == &dxgi_factory_vtbl);
+    assert(wine_factory->lpVtbl == &dxgi_factory_vtbl ||
+            wine_factory->lpVtbl == &re8_factory_vtbl);
     factory = CONTAINING_RECORD(wine_factory, struct dxgi_factory, IWineDXGIFactory_iface);
     IWineDXGIFactory_Release(wine_factory);
     return factory;
@@ -1125,3 +1128,97 @@ HWND dxgi_factory_get_device_window(struct dxgi_factory *factory)

     return factory->device_window;
 }
+
+/* re8 calls DXGICreateFactory1 over and over again, which is very expensive in
+ * Wine.  instead just cache the first one we create and return that. */
+static struct dxgi_factory re8_factory;
+
+static CRITICAL_SECTION re8_factory_lock;
+static CRITICAL_SECTION_DEBUG re8_factory_lock_debug =
+{
+    0, 0, &re8_factory_lock,
+    { &re8_factory_lock_debug.ProcessLocksList, &re8_factory_lock_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": re8_factory_lock") }
+};
+static CRITICAL_SECTION re8_factory_lock = { &re8_factory_lock_debug, -1, 0, 0, 0, 0 };
+
+static ULONG STDMETHODCALLTYPE DECLSPEC_HOTPATCH re8_factory_AddRef(IWineDXGIFactory *iface)
+{
+    TRACE("%p static.\n", iface);
+    return re8_factory.refcount;
+}
+
+static ULONG STDMETHODCALLTYPE DECLSPEC_HOTPATCH re8_factory_Release(IWineDXGIFactory *iface)
+{
+    TRACE("%p static.\n", iface);
+    return re8_factory.refcount;
+}
+
+static const struct IWineDXGIFactoryVtbl re8_factory_vtbl =
+{
+    dxgi_factory_QueryInterface,
+    re8_factory_AddRef,
+    re8_factory_Release,
+    dxgi_factory_SetPrivateData,
+    dxgi_factory_SetPrivateDataInterface,
+    dxgi_factory_GetPrivateData,
+    dxgi_factory_GetParent,
+    dxgi_factory_EnumAdapters,
+    dxgi_factory_MakeWindowAssociation,
+    dxgi_factory_GetWindowAssociation,
+    dxgi_factory_CreateSwapChain,
+    dxgi_factory_CreateSoftwareAdapter,
+    /* IDXGIFactory1 methods */
+    dxgi_factory_EnumAdapters1,
+    dxgi_factory_IsCurrent,
+    /* IDXGIFactory2 methods */
+    dxgi_factory_IsWindowedStereoEnabled,
+    dxgi_factory_CreateSwapChainForHwnd,
+    dxgi_factory_CreateSwapChainForCoreWindow,
+    dxgi_factory_GetSharedResourceAdapterLuid,
+    dxgi_factory_RegisterStereoStatusWindow,
+    dxgi_factory_RegisterStereoStatusEvent,
+    dxgi_factory_UnregisterStereoStatus,
+    dxgi_factory_RegisterOcclusionStatusWindow,
+    dxgi_factory_RegisterOcclusionStatusEvent,
+    dxgi_factory_UnregisterOcclusionStatus,
+    dxgi_factory_CreateSwapChainForComposition,
+    /* IDXGIFactory3 methods */
+    dxgi_factory_GetCreationFlags,
+    /* IDXGIFactory4 methods */
+    dxgi_factory_EnumAdapterByLuid,
+    dxgi_factory_EnumWarpAdapter,
+    /* IDXIGFactory5 methods */
+    dxgi_factory_CheckFeatureSupport,
+    /* IDXGIFactory6 methods */
+    dxgi_factory_EnumAdapterByGpuPreference,
+    /* IDXGIFactory7 methods */
+    dxgi_factory_RegisterAdaptersChangedEvent,
+    dxgi_factory_UnregisterAdaptersChangedEvent,
+};
+
+HRESULT get_re8_dxgi_factory(REFIID riid, void **factory)
+{
+    HRESULT hr;
+
+    EnterCriticalSection(&re8_factory_lock);
+
+    if(re8_factory.refcount == 0){
+        if (FAILED(hr = dxgi_factory_init(&re8_factory, TRUE)))
+        {
+            WARN("Failed to initialize factory, hr %#x.\n", hr);
+            LeaveCriticalSection(&re8_factory_lock);
+            return hr;
+        }
+
+        re8_factory.IWineDXGIFactory_iface.lpVtbl = &re8_factory_vtbl;
+
+        TRACE("Created factory %p.\n", &re8_factory);
+    }
+
+    LeaveCriticalSection(&re8_factory_lock);
+
+    hr = IWineDXGIFactory_QueryInterface(&re8_factory.IWineDXGIFactory_iface, riid, factory);
+
+    return hr;
+}
From f48f52a2b6d96e8dcc0ea9eeadd895bfe397b3a0 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Fri, 21 Feb 2020 12:08:56 -0800
Subject: [PATCH] HACK: winevulkan: Add vkGetPhysicalDeviceProperties thunks to
 fake NVIDIA PCI IDs as AMD

Needed for RDR2 with NVIDIA cards, otherwise game crashes or gets stuck
trying to load nvapi64.dll
---
 dlls/winevulkan/loader.c        | 45 +++++++++++++++++++++++++++++++++
 dlls/winevulkan/make_vulkan     |  1 +
 dlls/winevulkan/vulkan_thunks.c |  4 +--
 dlls/winevulkan/vulkan_thunks.h |  2 ++
 4 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/dlls/winevulkan/loader_thunks.c b/dlls/winevulkan/loader_thunks.c
index 69fcd44160e..cb7b8b0e2b0 100644
--- a/dlls/winevulkan/loader_thunks.c
+++ b/dlls/winevulkan/loader_thunks.c
@@ -1568,11 +1568,6 @@ VkResult WINAPI vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physica
     return unix_funcs->p_vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
 }

-void WINAPI vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties)
-{
-    unix_funcs->p_vkGetPhysicalDeviceProperties(physicalDevice, pProperties);
-}
-
 void WINAPI vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses)
 {
     unix_funcs->p_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
diff --git a/dlls/winevulkan/loader.c b/dlls/winevulkan/loader.c
index 746a25041d0..57d811a41c9 100644
--- a/dlls/winevulkan/loader.c
+++ b/dlls/winevulkan/loader.c
@@ -18,6 +18,7 @@
  */

 #include <stdarg.h>
+#include <stdlib.h>

 #include "windef.h"
 #include "winbase.h"
@@ -344,6 +344,26 @@ static void fill_luid_property(VkPhysicalDeviceProperties2 *properties2)
             id->deviceNodeMask);
 }

+void WINAPI vkGetPhysicalDeviceProperties(VkPhysicalDevice phys_dev,
+        VkPhysicalDeviceProperties *properties)
+{
+    TRACE("%p, %p\n", phys_dev, properties);
+
+    unix_funcs->p_vkGetPhysicalDeviceProperties(phys_dev, properties);
+
+    {
+        const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+        if (sgi && *sgi != '0')
+        {
+            if (properties->vendorID == 0x10de /* NVIDIA */)
+            {
+                properties->vendorID = 0x1002; /* AMD */
+                properties->deviceID = 0x67df; /* RX 480 */
+            }
+        }
+    }
+}
+
 void WINAPI vkGetPhysicalDeviceProperties2(VkPhysicalDevice phys_dev,
         VkPhysicalDeviceProperties2 *properties2)
 {
@@ -351,6 +372,18 @@ void WINAPI vkGetPhysicalDeviceProperties2(VkPhysicalDevice phys_dev,

     unix_funcs->p_vkGetPhysicalDeviceProperties2(phys_dev, properties2);
     fill_luid_property(properties2);
+
+    {
+        const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+        if (sgi && *sgi != '0')
+        {
+            if (properties2->properties.vendorID == 0x10de /* NVIDIA */)
+            {
+                properties2->properties.vendorID = 0x1002; /* AMD */
+                properties2->properties.deviceID = 0x67df; /* RX 480 */
+            }
+        }
+    }
 }

 void WINAPI vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice phys_dev,
@@ -360,6 +393,18 @@ void WINAPI vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice phys_dev,

     unix_funcs->p_vkGetPhysicalDeviceProperties2KHR(phys_dev, properties2);
     fill_luid_property(properties2);
+
+    {
+        const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+        if (sgi && *sgi != '0')
+        {
+            if (properties2->properties.vendorID == 0x10de /* NVIDIA */)
+            {
+                properties2->properties.vendorID = 0x1002; /* AMD */
+                properties2->properties.deviceID = 0x67df; /* RX 480 */
+            }
+        }
+    }
 }

 BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, void *reserved)
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index f584330dc6e..3efdcb4c88c 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -169,6 +169,7 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceImageFormatProperties2" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
+    "vkGetPhysicalDeviceProperties" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},
     "vkGetPhysicalDeviceProperties2" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},
     "vkGetPhysicalDeviceProperties2KHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},

--
2.30.2

From 177a787cc4dcec5c6f5aecec10d3532aebf54e1a Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 19 Apr 2021 15:29:39 +0300
Subject: [PATCH] winevulkan: Don't hardcode performance frequency.

For FH4.
---
 dlls/winevulkan/vulkan.c | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 55e48f928e9..e159c87159c 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -1653,7 +1653,6 @@ VkResult WINAPI wine_vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevi

 /* From ntdll/unix/sync.c */
 #define NANOSECONDS_IN_A_SECOND 1000000000
-#define TICKSPERSEC             10000000

 static inline VkTimeDomainEXT get_performance_counter_time_domain(void)
 {
@@ -1680,7 +1679,17 @@ static VkTimeDomainEXT map_to_host_time_domain(VkTimeDomainEXT domain)

 static inline uint64_t convert_monotonic_timestamp(uint64_t value)
 {
-    return value / (NANOSECONDS_IN_A_SECOND / TICKSPERSEC);
+    static LARGE_INTEGER freq;
+
+    if (!freq.QuadPart)
+    {
+        LARGE_INTEGER temp;
+
+        RtlQueryPerformanceFrequency(&temp);
+        InterlockedCompareExchange64(&freq.QuadPart, temp.QuadPart, 0);
+    }
+
+    return value * freq.QuadPart / NANOSECONDS_IN_A_SECOND;
 }

 static inline uint64_t convert_timestamp(VkTimeDomainEXT host_domain, VkTimeDomainEXT target_domain, uint64_t value)

From ce0c255a1fd40bfa9a1de6f6765b83a4dcf9d0dd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 May 2021 14:57:46 +0200
Subject: [PATCH] user32: Implement rudimentary EnableMouseInPointer support.

CW-Bug-Id: 18943
---
 dlls/user32/input.c        |  9 +++++----
 dlls/user32/message.c      | 32 ++++++++++++++++++++++++++++++++
 dlls/user32/user_private.h |  1 +
 include/winuser.h          | 26 ++++++++++++++++++++++++++
 4 files changed, 64 insertions(+), 4 deletions(-)

diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index 455f857d9d0..dbfc9f36819 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -1324,15 +1324,16 @@ int WINAPI GetMouseMovePointsEx( UINT size, LPMOUSEMOVEPOINT ptin, LPMOUSEMOVEPO
     return copied;
 }

+BOOL enable_mouse_in_pointer = FALSE;
+
 /***********************************************************************
  *		EnableMouseInPointer (USER32.@)
  */
 BOOL WINAPI EnableMouseInPointer(BOOL enable)
 {
-    FIXME("(%#x) stub\n", enable);
-
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+    FIXME("(%#x) semi-stub\n", enable);
+    enable_mouse_in_pointer = TRUE;
+    return TRUE;
 }

 static DWORD CALLBACK devnotify_window_callback(HANDLE handle, DWORD flags, DEV_BROADCAST_HDR *header)
diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index a54ecccc7cd..57baea203e5 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2590,6 +2590,38 @@ static BOOL process_mouse_message( MSG *msg, UINT hw_id, ULONG_PTR extra_info, H
        in the WM_SETCURSOR message even if it's non-client mouse message */
     SendMessageW( msg->hwnd, WM_SETCURSOR, (WPARAM)msg->hwnd, MAKELONG( hittest, msg->message ));

+    if (enable_mouse_in_pointer) switch (msg->message)
+    {
+    case WM_MOUSEMOVE:
+    case WM_LBUTTONDOWN:
+    case WM_LBUTTONUP:
+    case WM_RBUTTONDOWN:
+    case WM_RBUTTONUP:
+    case WM_MBUTTONDOWN:
+    case WM_MBUTTONUP:
+    case WM_XBUTTONDOWN:
+    case WM_XBUTTONUP:
+    {
+        WORD flags = POINTER_MESSAGE_FLAG_INRANGE|POINTER_MESSAGE_FLAG_INCONTACT|POINTER_MESSAGE_FLAG_PRIMARY;
+        if (msg->message == WM_LBUTTONDOWN) flags |= POINTER_MESSAGE_FLAG_FIRSTBUTTON;
+        if (msg->message == WM_RBUTTONDOWN) flags |= POINTER_MESSAGE_FLAG_SECONDBUTTON;
+        if (msg->message == WM_MBUTTONDOWN) flags |= POINTER_MESSAGE_FLAG_THIRDBUTTON;
+        if (msg->message == WM_XBUTTONDOWN && LOWORD( msg->wParam ) == MK_LBUTTON) flags |= POINTER_MESSAGE_FLAG_FIRSTBUTTON;
+        if (msg->message == WM_XBUTTONDOWN && LOWORD( msg->wParam ) == MK_RBUTTON) flags |= POINTER_MESSAGE_FLAG_SECONDBUTTON;
+        if (msg->message == WM_XBUTTONDOWN && LOWORD( msg->wParam ) == MK_MBUTTON) flags |= POINTER_MESSAGE_FLAG_THIRDBUTTON;
+        if (msg->message == WM_XBUTTONDOWN && LOWORD( msg->wParam ) == MK_XBUTTON1) flags |= POINTER_MESSAGE_FLAG_FOURTHBUTTON;
+        if (msg->message == WM_XBUTTONDOWN && LOWORD( msg->wParam ) == MK_XBUTTON2) flags |= POINTER_MESSAGE_FLAG_FIFTHBUTTON;
+        SendMessageW( msg->hwnd, WM_POINTERUPDATE, MAKELONG( 1, flags ), MAKELONG( msg->pt.x, msg->pt.y ) );
+        break;
+    }
+    case WM_MOUSEWHEEL:
+        SendMessageW( msg->hwnd, WM_POINTERWHEEL, MAKELONG( 1, HIWORD( msg->wParam ) ), MAKELONG( msg->pt.x, msg->pt.y ) );
+        break;
+    case WM_MOUSEHWHEEL:
+        SendMessageW( msg->hwnd, WM_POINTERHWHEEL, MAKELONG( 1, HIWORD( msg->wParam ) ), MAKELONG( msg->pt.x, msg->pt.y ) );
+        break;
+    }
+
     msg->message = message;
     return !eatMsg;
 }
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 5a36f9bb7aa..0910e453f13 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -236,6 +236,7 @@ static inline BOOL is_broadcast( HWND hwnd )
 }

 extern HMODULE user32_module DECLSPEC_HIDDEN;
+extern BOOL enable_mouse_in_pointer DECLSPEC_HIDDEN;

 struct dce;
 struct tagWND;
diff --git a/include/winuser.h b/include/winuser.h
index fe82613e590..402fbee9dc4 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -3474,6 +3474,32 @@ typedef struct tagMENUGETOBJECTINFO
     void  *pvObj;
 } MENUGETOBJECTINFO, *PMENUGETOBJECTINFO;

+#define POINTER_MESSAGE_FLAG_NEW                      0x00000001
+#define POINTER_MESSAGE_FLAG_INRANGE                  0x00000002
+#define POINTER_MESSAGE_FLAG_INCONTACT                0x00000004
+#define POINTER_MESSAGE_FLAG_FIRSTBUTTON              0x00000010
+#define POINTER_MESSAGE_FLAG_SECONDBUTTON             0x00000020
+#define POINTER_MESSAGE_FLAG_THIRDBUTTON              0x00000040
+#define POINTER_MESSAGE_FLAG_FOURTHBUTTON             0x00000080
+#define POINTER_MESSAGE_FLAG_FIFTHBUTTON              0x00000100
+#define POINTER_MESSAGE_FLAG_PRIMARY                  0x00002000
+#define POINTER_MESSAGE_FLAG_CONFIDENCE               0x00004000
+#define POINTER_MESSAGE_FLAG_CANCELED                 0x00008000
+
+#define GET_POINTERID_WPARAM(wparam)                  (LOWORD(wparam))
+#define IS_POINTER_FLAG_SET_WPARAM(wparam, flags)     ((HIWORD(wparam) & (flags)) == (flags))
+#define IS_POINTER_NEW_WPARAM(wparam)                 IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_NEW)
+#define IS_POINTER_INRANGE_WPARAM(wparam)             IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_INRANGE)
+#define IS_POINTER_INCONTACT_WPARAM(wparam)           IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_INCONTACT)
+#define IS_POINTER_FIRSTBUTTON_WPARAM(wparam)         IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_FIRSTBUTTON)
+#define IS_POINTER_SECONDBUTTON_WPARAM(wparam)        IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_SECONDBUTTON)
+#define IS_POINTER_THIRDBUTTON_WPARAM(wparam)         IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_THIRDBUTTON)
+#define IS_POINTER_FOURTHBUTTON_WPARAM(wparam)        IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_FOURTHBUTTON)
+#define IS_POINTER_FIFTHBUTTON_WPARAM(wparam)         IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_FIFTHBUTTON)
+#define IS_POINTER_PRIMARY_WPARAM(wparam)             IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_PRIMARY)
+#define HAS_POINTER_CONFIDENCE_WPARAM(wparam)         IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_CONFIDENCE)
+#define IS_POINTER_CANCELED_WPARAM(wparam)            IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_CANCELED)
+
 #if defined(_WINGDI_) && !defined(NOGDI)
 WINUSERAPI LONG        WINAPI ChangeDisplaySettingsA(LPDEVMODEA,DWORD);
 WINUSERAPI LONG        WINAPI ChangeDisplaySettingsW(LPDEVMODEW,DWORD);

From 43c3113aa696898ec5758118b92f8c2a5fb61714 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 30 Jul 2021 21:01:13 +0300
Subject: [PATCH] kernelbase: HACK: Force CEF software rendering for
 UplayWebCore.

(To be revisited once builtin d3dcompiler is added).
---
 dlls/kernelbase/process.c | 27 ++++++++++++++++++++++++++-
 1 file changed, 26 insertions(+), 1 deletion(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 33197563cd8..9bcb377a62e 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -33,6 +33,7 @@

 #include "kernelbase.h"
 #include "wine/debug.h"
+#include "wine/heap.h"

 WINE_DEFAULT_DEBUG_CHANNEL(process);

@@ -517,7 +518,31 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
     }
     else
     {
-        if (!(tidy_cmdline = get_file_name( cmd_line, name, ARRAY_SIZE(name) ))) return FALSE;
+        static const WCHAR *opt = L" --use-gl=swiftshader";
+        WCHAR *cmdline_new = NULL;
+
+        if (cmd_line && wcsstr( cmd_line, L"UplayWebCore.exe" ))
+        {
+            FIXME( "HACK: appending %s to command line %s.\n", debugstr_w(opt), debugstr_w(cmd_line) );
+
+            cmdline_new = heap_alloc( sizeof(WCHAR) * (lstrlenW(cmd_line) + lstrlenW(opt) + 1) );
+            lstrcpyW(cmdline_new, cmd_line);
+            lstrcatW(cmdline_new, opt);
+        }
+
+        tidy_cmdline = get_file_name( cmdline_new ? cmdline_new : cmd_line, name, ARRAY_SIZE(name) );
+
+        if (!tidy_cmdline)
+        {
+            heap_free( cmdline_new );
+            return FALSE;
+        }
+
+        if (cmdline_new)
+        {
+            if (cmdline_new == tidy_cmdline) cmd_line = NULL;
+            else heap_free( cmdline_new );
+        }
         app_name = name;
     }

From 0597fa1ef89f5c4840c9b5762d74d7ce2e0abb56 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Wed, 23 Jun 2021 13:37:04 +0300
Subject: [PATCH] winex11.drv: Add a GPU for each Vulkan device that was not
 tied to an XRandR provider.

This assures that each Vulkan device has a LUID assigned (see X11DRV_InitGpu
and VkPhysicalDeviceIDProperties).

LUIDs are important for DirectX <-> Vulkan interop. VKD3D-Proton and
DXVK's DXGI use that to identify which underlaying Vulkan device to use
for the selected adapter.

This change fixes GPU selection in Hitman 2 in DX12 mode. Without it
VKD3D-Proton resorts to a heuristic (vid/pid matching, and if that fails
use the first device in enumeration order) which can select the wrong
one on some multi-GPU Nvidia setups due to nvapihack.

This also fixes Forza Horizon 4 on Wayland as XWayland doesn't expose
providers which results in missing LUIDs even for the GPU driving the
outputs.

CW-Bug-Id: #18737
CW-Bug-Id: #18925
---
 dlls/winex11.drv/xrandr.c | 149 +++++++++++++++++++++++++++++++++++---
 1 file changed, 139 insertions(+), 10 deletions(-)

diff --git a/dlls/winex11.drv/xrandr.c b/dlls/winex11.drv/xrandr.c
index 7edaaf07dc2..a17b8f47fbf 100644
--- a/dlls/winex11.drv/xrandr.c
+++ b/dlls/winex11.drv/xrandr.c
@@ -602,6 +602,113 @@ static BOOL is_crtc_primary( RECT primary, const XRRCrtcInfo *crtc )
            crtc->y + crtc->height == primary.bottom;
 }

+static void add_remaining_gpus_via_vulkan( struct x11drv_gpu **gpus, int *count )
+{
+    static const char *extensions[] =
+    {
+        VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,
+    };
+    const struct vulkan_funcs *vulkan_funcs = get_vulkan_driver( WINE_VULKAN_DRIVER_VERSION );
+    PFN_vkGetPhysicalDeviceProperties2KHR pvkGetPhysicalDeviceProperties2KHR;
+    PFN_vkEnumeratePhysicalDevices pvkEnumeratePhysicalDevices;
+    uint32_t device_count;
+    VkPhysicalDevice *vk_physical_devices = NULL;
+    VkPhysicalDeviceProperties2 properties2;
+    VkInstanceCreateInfo create_info;
+    VkPhysicalDeviceIDProperties id;
+    VkInstance vk_instance = NULL;
+    INT gpu_idx, device_idx;
+    INT original_gpu_count = *count;
+    struct x11drv_gpu *new_gpu;
+    BOOL new;
+    VkResult vr;
+
+    memset( &create_info, 0, sizeof(create_info) );
+    create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
+    create_info.enabledExtensionCount = ARRAY_SIZE(extensions);
+    create_info.ppEnabledExtensionNames = extensions;
+    vr = vulkan_funcs->p_vkCreateInstance( &create_info, NULL, &vk_instance );
+
+    if (vr != VK_SUCCESS)
+    {
+        WARN("Failed to create a Vulkan instance, vr %d.\n", vr);
+        goto done;
+    }
+
+#define LOAD_VK_FUNC(f)                                                             \
+    if (!(p##f = (void *)vulkan_funcs->p_vkGetInstanceProcAddr( vk_instance, #f ))) \
+    {                                                                               \
+        WARN("Failed to load " #f ".\n");                                           \
+        goto done;                                                                  \
+    }
+
+    LOAD_VK_FUNC(vkEnumeratePhysicalDevices)
+    LOAD_VK_FUNC(vkGetPhysicalDeviceProperties2KHR)
+#undef LOAD_VK_FUNC
+
+    vr = pvkEnumeratePhysicalDevices( vk_instance, &device_count, NULL );
+    if (vr != VK_SUCCESS || !device_count)
+    {
+        WARN("No Vulkan device found, vr %d, device_count %d.\n", vr, device_count);
+        goto done;
+    }
+
+    if (!(vk_physical_devices = heap_calloc( device_count, sizeof(*vk_physical_devices) )))
+        goto done;
+
+    vr = pvkEnumeratePhysicalDevices( vk_instance, &device_count, vk_physical_devices );
+    if (vr != VK_SUCCESS)
+    {
+        WARN("vkEnumeratePhysicalDevices failed, vr %d.\n", vr);
+        goto done;
+    }
+
+    for (device_idx = 0; device_idx < device_count; ++device_idx)
+    {
+            memset( &id, 0, sizeof(id) );
+            id.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
+            properties2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
+            properties2.pNext = &id;
+
+            pvkGetPhysicalDeviceProperties2KHR( vk_physical_devices[device_idx], &properties2 );
+
+            /* Ignore Khronos vendor IDs */
+            if (properties2.properties.vendorID >= 0x10000)
+                continue;
+
+            new = TRUE;
+            for (gpu_idx = 0; gpu_idx < original_gpu_count; ++gpu_idx)
+            {
+                if (!memcmp( &(*gpus)[gpu_idx].vulkan_uuid, id.deviceUUID, sizeof(id.deviceUUID) ))
+                {
+                    new = FALSE;
+                    break;
+                }
+            }
+
+            if (!new)
+                continue;
+
+            *gpus = heap_realloc( *gpus, (*count + 1) * sizeof(**gpus) );
+            if (!gpus) goto done;
+            new_gpu = &(*gpus)[(*count)++];
+            memset( new_gpu, 0, sizeof(*new_gpu) );
+            new_gpu->id = -1;
+
+            memcpy( &new_gpu->vulkan_uuid, id.deviceUUID, sizeof(id.deviceUUID) );
+            new_gpu->vendor_id = properties2.properties.vendorID;
+            new_gpu->device_id = properties2.properties.deviceID;
+            MultiByteToWideChar( CP_UTF8, 0, properties2.properties.deviceName, -1, new_gpu->name, ARRAY_SIZE(new_gpu->name) );
+
+            TRACE("Added a new GPU via Vulkan: %04x:%04x %s\n", new_gpu->vendor_id, new_gpu->device_id, debugstr_w(new_gpu->name));
+    }
+
+done:
+    heap_free( vk_physical_devices );
+    if (vk_instance)
+        vulkan_funcs->p_vkDestroyInstance( vk_instance, NULL );
+}
+
 VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)

 static BOOL get_gpu_properties_from_vulkan( struct x11drv_gpu *gpu, const XRRProviderInfo *provider_info )
@@ -718,6 +825,7 @@ static BOOL xrandr14_get_gpus2( struct x11drv_gpu **new_gpus, int *count, BOOL g
     XRRProviderInfo *provider_info = NULL;
     XRRCrtcInfo *crtc_info = NULL;
     INT primary_provider = -1;
+    INT gpu_count = 0;
     RECT primary_rect;
     BOOL ret = FALSE;
     INT i, j;
@@ -730,22 +838,17 @@ static BOOL xrandr14_get_gpus2( struct x11drv_gpu **new_gpus, int *count, BOOL g
     if (!provider_resources)
         goto done;

-    gpus = heap_calloc( provider_resources->nproviders ? provider_resources->nproviders : 1, sizeof(*gpus) );
-    if (!gpus)
-        goto done;
-
     /* Some XRandR implementations don't support providers.
      * In this case, report a fake one to try searching adapters in screen resources */
     if (!provider_resources->nproviders)
     {
         WARN("XRandR implementation doesn't report any providers, faking one.\n");
-        lstrcpyW( gpus[0].name, wine_adapterW );
-        *new_gpus = gpus;
-        *count = 1;
-        ret = TRUE;
-        goto done;
+        goto fallback;
     }

+    gpus = heap_calloc( provider_resources->nproviders, sizeof(*gpus) );
+    if (!gpus) goto done;
+
     primary_rect = get_primary_rect( screen_resources );
     for (i = 0; i < provider_resources->nproviders; ++i)
     {
@@ -778,6 +881,7 @@ static BOOL xrandr14_get_gpus2( struct x11drv_gpu **new_gpus, int *count, BOOL g
             /* FIXME: Add an alternate method of getting PCI IDs, for systems that don't support Vulkan */
         }
         pXRRFreeProviderInfo( provider_info );
+        gpu_count++;
     }

     /* Make primary GPU the first */
@@ -788,8 +892,29 @@ static BOOL xrandr14_get_gpus2( struct x11drv_gpu **new_gpus, int *count, BOOL g
         gpus[primary_provider] = tmp;
     }

+fallback:
+    /* Add the Vulkan only GPUs only if we need all the detailed properties */
+    if (get_properties)
+        add_remaining_gpus_via_vulkan( &gpus, &gpu_count );
+
+    if (gpu_count == 0)
+    {
+        /* we need at least one for get_adapters() / get_id() */
+        gpus = heap_calloc( 1, sizeof(*gpus) );
+        if (!gpus) goto done;
+        lstrcpyW( gpus[0].name, wine_adapterW );
+        gpu_count = 1;
+    }
+    else if (gpus[0].id == -1)
+    {
+        /* the only GPUs we have are from Vulkan, mark the first one
+         * as main so that we can use screen resources for adapters,
+         * see xrandr14_get_adapters() */
+        gpus[0].id = 0;
+    }
+
     *new_gpus = gpus;
-    *count = provider_resources->nproviders;
+    *count = gpu_count;
     ret = TRUE;
 done:
     if (provider_resources)
@@ -834,6 +959,10 @@ static BOOL xrandr14_get_adapters( ULONG_PTR gpu_id, struct x11drv_adapter **new
     if (!screen_resources)
         goto done;

+    /* Vulkan-only, adapter-less GPU */
+    if (gpu_id == -1)
+        goto done;
+
     if (gpu_id)
     {
         provider_info = pXRRGetProviderInfo( gdi_display, screen_resources, gpu_id );

From 498ecc1a9e25a63aa0b082b28896647bbc063cb3 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 25 Jun 2021 23:17:43 +0300
Subject: [PATCH] esync, fsync: Use usleep(0) instead of NtYieldExecution() in
 esync_pulse_event().

---
 dlls/ntdll/unix/esync.c | 2 +-
 dlls/ntdll/unix/fsync.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 810477d02a0..80f2ee88fc2 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -626,7 +626,7 @@ NTSTATUS esync_pulse_event( HANDLE handle )

     /* Try to give other threads a chance to wake up. Hopefully erring on this
      * side is the better thing to do... */
-    NtYieldExecution();
+    usleep(0);

     read( obj->fd, &value, sizeof(value) );

From ba230cf936910f12e756cf63594b6238391e6691 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 6 Jul 2021 14:04:51 +0200
Subject: [PATCH] HACK: qasf: Implement ASF Reader filter as a simple file
 source.

Shamelessly copied from quartz filesource.c.

It then exposes a single MEDIATYPE_Stream pin, which should be
automatically plugged to the GStreamer decodebin filter and then to
application provided renderer.

This is not how it's supposed to work, and it should instead be more
like a splitter filter able to expose compressed streams (and possibly
uncompressed streams too), and be implemented on top of wmvcore to
forward its interfaces as services, but this seems to work.

The specific AttemptConnection implementation also seems important for
Tokyo Xanadu eX+, as using the default implementation with IMemInputPin
interface seems to cause it to crash as well.

For Tokyo Xanadu eX+ crash on launch.

CW-Bug-Id: #18994
---
 dlls/qasf/Makefile.in |   2 +-
 dlls/qasf/asfreader.c | 887 +++++++++++++++++++++++++++++++++++++++---
 2 files changed, 834 insertions(+), 55 deletions(-)

diff --git a/dlls/qasf/Makefile.in b/dlls/qasf/Makefile.in
index 928bf04d80e..e960c6306fb 100644
--- a/dlls/qasf/Makefile.in
+++ b/dlls/qasf/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = qasf.dll
-IMPORTS   = strmbase dmoguids strmiids uuid ole32 oleaut32
+IMPORTS   = strmbase dmoguids strmiids uuid ole32 oleaut32 kernelbase

 EXTRADLLFLAGS = -mno-cygwin

diff --git a/dlls/qasf/asfreader.c b/dlls/qasf/asfreader.c
index a037728079f..3a355994851 100644
--- a/dlls/qasf/asfreader.c
+++ b/dlls/qasf/asfreader.c
@@ -18,35 +18,341 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */

+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
 #include "qasf_private.h"

+#include "wine/debug.h"
+#include "wine/heap.h"
+#include "uuids.h"
+#include "vfwmsgs.h"
+#include "winbase.h"
+#include "winreg.h"
+#include "shlwapi.h"
+#include <assert.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(quartz);

+/* see IAsyncReader::Request on MSDN for the explanation of this */
+#define MEDIATIME_FROM_BYTES(x) ((LONGLONG)(x) * 10000000)
+#define BYTES_FROM_MEDIATIME(time) ((time) / 10000000)
+
+static const AM_MEDIA_TYPE default_mt =
+{
+    {0xe436eb83,0x524f,0x11ce,{0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70}},   /* MEDIATYPE_Stream */
+    {0,0,0,{0,0,0,0,0,0,0,0}},
+    TRUE,
+    FALSE,
+    1,
+    {0,0,0,{0,0,0,0,0,0,0,0}},
+    NULL,
+    0,
+    NULL
+};
+
+struct request
+{
+    IMediaSample *sample;
+    DWORD_PTR cookie;
+    OVERLAPPED ovl;
+};
+
 struct asf_reader
 {
     struct strmbase_filter filter;
     IFileSourceFilter IFileSourceFilter_iface;

-    AM_MEDIA_TYPE type;
-    WCHAR *filename;
+    struct strmbase_source source;
+    IAsyncReader IAsyncReader_iface;
+
+    LPOLESTR pszFileName;
+    AM_MEDIA_TYPE mt;
+    HANDLE file, port, io_thread;
+    LARGE_INTEGER file_size;
+    CRITICAL_SECTION sample_cs;
+    BOOL flushing;
+    struct request *requests;
+    unsigned int max_requests;
+    CONDITION_VARIABLE sample_cv;
 };

-static inline struct asf_reader *impl_reader_from_strmbase_filter(struct strmbase_filter *iface)
+static const struct strmbase_source_ops source_ops;
+
+static inline struct asf_reader *impl_from_strmbase_filter(struct strmbase_filter *iface)
 {
     return CONTAINING_RECORD(iface, struct asf_reader, filter);
 }

+static inline struct asf_reader *impl_from_IFileSourceFilter(IFileSourceFilter *iface)
+{
+    return CONTAINING_RECORD(iface, struct asf_reader, IFileSourceFilter_iface);
+}
+
+static const IFileSourceFilterVtbl FileSource_Vtbl;
+static const IAsyncReaderVtbl FileAsyncReader_Vtbl;
+
+static int byte_from_hex_char(WCHAR c)
+{
+    if ('0' <= c && c <= '9') return c - '0';
+    if ('a' <= c && c <= 'f') return c - 'a' + 10;
+    if ('A' <= c && c <= 'F') return c - 'A' + 10;
+    return -1;
+}
+
+static BOOL process_pattern_string(const WCHAR *pattern, HANDLE file)
+{
+    ULONG size, offset, i, ret_size;
+    BYTE *mask, *expect, *actual;
+    int d;
+    BOOL ret = TRUE;
+
+    /* format: "offset, size, mask, value" */
+
+    offset = wcstol(pattern, NULL, 10);
+
+    if (!(pattern = wcschr(pattern, ',')))
+        return FALSE;
+    pattern++;
+
+    size = wcstol(pattern, NULL, 10);
+    mask = heap_alloc(size);
+    expect = heap_alloc(size);
+    memset(mask, 0xff, size);
+
+    if (!(pattern = wcschr(pattern, ',')))
+    {
+        heap_free(mask);
+        heap_free(expect);
+        return FALSE;
+    }
+    pattern++;
+    while (byte_from_hex_char(*pattern) == -1 && (*pattern != ','))
+        pattern++;
+
+    for (i = 0; (d = byte_from_hex_char(*pattern)) != -1 && (i/2 < size); pattern++, i++)
+    {
+        if (i % 2)
+            mask[i / 2] |= d;
+        else
+            mask[i / 2] = d << 4;
+    }
+
+    if (!(pattern = wcschr(pattern, ',')))
+    {
+        heap_free(mask);
+        heap_free(expect);
+        return FALSE;
+    }
+    pattern++;
+    while (byte_from_hex_char(*pattern) == -1 && (*pattern != ','))
+        pattern++;
+
+    for (i = 0; (d = byte_from_hex_char(*pattern)) != -1 && (i/2 < size); pattern++, i++)
+    {
+        if (i % 2)
+            expect[i / 2] |= d;
+        else
+            expect[i / 2] = d << 4;
+    }
+
+    actual = heap_alloc(size);
+    SetFilePointer(file, offset, NULL, FILE_BEGIN);
+    if (!ReadFile(file, actual, size, &ret_size, NULL) || ret_size != size)
+    {
+        heap_free(actual);
+        heap_free(expect);
+        heap_free(mask);
+        return FALSE;
+    }
+
+    for (i = 0; i < size; ++i)
+    {
+        if ((actual[i] & mask[i]) != expect[i])
+        {
+            ret = FALSE;
+            break;
+        }
+    }
+
+    heap_free(actual);
+    heap_free(expect);
+    heap_free(mask);
+
+    /* If there is a following tuple, then we must match that as well. */
+    if (ret && (pattern = wcschr(pattern, ',')))
+        return process_pattern_string(pattern + 1, file);
+
+    return ret;
+}
+
+BOOL get_media_type(const WCHAR *filename, GUID *majortype, GUID *subtype, GUID *source_clsid)
+{
+    WCHAR extensions_path[278] = L"Media Type\\Extensions\\";
+    DWORD majortype_idx, size;
+    const WCHAR *ext;
+    HKEY parent_key;
+    HANDLE file;
+
+    if ((ext = wcsrchr(filename, '.')))
+    {
+        WCHAR guidstr[39];
+        HKEY key;
+
+        wcscat(extensions_path, ext);
+        if (!RegOpenKeyExW(HKEY_CLASSES_ROOT, extensions_path, 0, KEY_READ, &key))
+        {
+            size = sizeof(guidstr);
+            if (majortype && !RegQueryValueExW(key, L"Media Type", NULL, NULL, (BYTE *)guidstr, &size))
+                CLSIDFromString(guidstr, majortype);
+
+            size = sizeof(guidstr);
+            if (subtype && !RegQueryValueExW(key, L"Subtype", NULL, NULL, (BYTE *)guidstr, &size))
+                CLSIDFromString(guidstr, subtype);
+
+            size = sizeof(guidstr);
+            if (source_clsid && !RegQueryValueExW(key, L"Source Filter", NULL, NULL, (BYTE *)guidstr, &size))
+                CLSIDFromString(guidstr, source_clsid);
+
+            RegCloseKey(key);
+            return FALSE;
+        }
+    }
+
+    if ((file = CreateFileW(filename, GENERIC_READ, FILE_SHARE_READ, NULL,
+            OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
+    {
+        WARN("Failed to open file %s, error %u.\n", debugstr_w(filename), GetLastError());
+        return FALSE;
+    }
+
+    if (RegOpenKeyExW(HKEY_CLASSES_ROOT, L"Media Type", 0, KEY_READ, &parent_key))
+    {
+        CloseHandle(file);
+        return FALSE;
+    }
+
+    for (majortype_idx = 0; ; ++majortype_idx)
+    {
+        WCHAR majortype_str[39];
+        HKEY majortype_key;
+        DWORD subtype_idx;
+
+        size = ARRAY_SIZE(majortype_str);
+        if (RegEnumKeyExW(parent_key, majortype_idx, majortype_str, &size, NULL, NULL, NULL, NULL))
+            break;
+
+        if (!wcscmp(majortype_str, L"Extensions"))
+            continue;
+
+        if (RegOpenKeyExW(parent_key, majortype_str, 0, KEY_READ, &majortype_key))
+            continue;
+
+        for (subtype_idx = 0; ; ++subtype_idx)
+        {
+            WCHAR subtype_str[39], *pattern;
+            DWORD value_idx, max_size;
+            HKEY subtype_key;
+
+            size = ARRAY_SIZE(subtype_str);
+            if (RegEnumKeyExW(majortype_key, subtype_idx, subtype_str, &size, NULL, NULL, NULL, NULL))
+                break;
+
+            if (RegOpenKeyExW(majortype_key, subtype_str, 0, KEY_READ, &subtype_key))
+                continue;
+
+            if (RegQueryInfoKeyW(subtype_key, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &max_size, NULL, NULL))
+                continue;
+
+            pattern = heap_alloc(max_size);
+
+            for (value_idx = 0; ; ++value_idx)
+            {
+                /* The longest name we should encounter is "Source Filter". */
+                WCHAR value_name[14], source_clsid_str[39];
+                DWORD value_len = ARRAY_SIZE(value_name);
+
+                size = max_size;
+                if (RegEnumValueW(subtype_key, value_idx, value_name, &value_len,
+                        NULL, NULL, (BYTE *)pattern, &max_size))
+                    break;
+
+                if (!wcscmp(value_name, L"Source Filter"))
+                    continue;
+
+                if (!process_pattern_string(pattern, file))
+                    continue;
+
+                if (majortype)
+                    CLSIDFromString(majortype_str, majortype);
+                if (subtype)
+                    CLSIDFromString(subtype_str, subtype);
+                size = sizeof(source_clsid_str);
+                if (source_clsid && !RegQueryValueExW(subtype_key, L"Source Filter",
+                        NULL, NULL, (BYTE *)source_clsid_str, &size))
+                    CLSIDFromString(source_clsid_str, source_clsid);
+
+                heap_free(pattern);
+                RegCloseKey(subtype_key);
+                RegCloseKey(majortype_key);
+                RegCloseKey(parent_key);
+                CloseHandle(file);
+                return TRUE;
+            }
+
+            heap_free(pattern);
+            RegCloseKey(subtype_key);
+        }
+
+        RegCloseKey(majortype_key);
+    }
+
+    RegCloseKey(parent_key);
+    CloseHandle(file);
+    return FALSE;
+}
+
 static struct strmbase_pin *asf_reader_get_pin(struct strmbase_filter *iface, unsigned int index)
 {
+    struct asf_reader *filter = impl_from_strmbase_filter(iface);
+
+    if (!index && filter->pszFileName)
+        return &filter->source.pin;
     return NULL;
 }

 static void asf_reader_destroy(struct strmbase_filter *iface)
 {
-    struct asf_reader *filter = impl_reader_from_strmbase_filter(iface);
+    struct asf_reader *filter = impl_from_strmbase_filter(iface);
+
+    if (filter->pszFileName)
+    {
+        unsigned int i;
+
+        if (filter->source.pin.peer)
+            IPin_Disconnect(filter->source.pin.peer);
+
+        IPin_Disconnect(&filter->source.pin.IPin_iface);
+
+        if (filter->requests)
+        {
+            for (i = 0; i < filter->max_requests; ++i)
+                CloseHandle(filter->requests[i].ovl.hEvent);
+            free(filter->requests);
+        }
+        CloseHandle(filter->file);
+        filter->sample_cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&filter->sample_cs);
+        strmbase_source_cleanup(&filter->source);
+
+        free(filter->pszFileName);
+        FreeMediaType(&filter->mt);
+    }

-    free(filter->filename);
-    FreeMediaType(&filter->type);
+    PostQueuedCompletionStatus(filter->port, 0, 1, NULL);
+    WaitForSingleObject(filter->io_thread, INFINITE);
+    CloseHandle(filter->io_thread);
+    CloseHandle(filter->port);

     strmbase_filter_cleanup(&filter->filter);
     free(filter);
@@ -54,7 +360,7 @@ static void asf_reader_destroy(struct strmbase_filter *iface)

 static HRESULT asf_reader_query_interface(struct strmbase_filter *iface, REFIID iid, void **out)
 {
-    struct asf_reader *filter = impl_reader_from_strmbase_filter(iface);
+    struct asf_reader *filter = impl_from_strmbase_filter(iface);

     if (IsEqualGUID(iid, &IID_IFileSourceFilter))
     {
@@ -66,110 +372,583 @@ static HRESULT asf_reader_query_interface(struct strmbase_filter *iface, REFIID
     return E_NOINTERFACE;
 }

-static struct strmbase_filter_ops filter_ops =
+static const struct strmbase_filter_ops filter_ops =
 {
     .filter_get_pin = asf_reader_get_pin,
     .filter_destroy = asf_reader_destroy,
     .filter_query_interface = asf_reader_query_interface,
 };

-static inline struct asf_reader *impl_from_IFileSourceFilter(IFileSourceFilter *iface)
+static DWORD CALLBACK io_thread(void *arg)
 {
-    return CONTAINING_RECORD(iface, struct asf_reader, IFileSourceFilter_iface);
+    struct asf_reader *filter = arg;
+    struct request *req;
+    OVERLAPPED *ovl;
+    ULONG_PTR key;
+    DWORD size;
+    BOOL ret;
+
+    for (;;)
+    {
+        ret = GetQueuedCompletionStatus(filter->port, &size, &key, &ovl, INFINITE);
+
+        if (ret && key)
+            break;
+
+        EnterCriticalSection(&filter->sample_cs);
+
+        req = CONTAINING_RECORD(ovl, struct request, ovl);
+        TRACE("Got sample %u.\n", req - filter->requests);
+        assert(req >= filter->requests && req < filter->requests + filter->max_requests);
+
+        if (ret)
+            WakeConditionVariable(&filter->sample_cv);
+        else
+        {
+            ERR("GetQueuedCompletionStatus() returned failure, error %u.\n", GetLastError());
+            req->sample = NULL;
+        }
+
+        LeaveCriticalSection(&filter->sample_cs);
+    }
+
+    return 0;
 }

-static HRESULT WINAPI filesourcefilter_QueryInterface(IFileSourceFilter *iface, REFIID iid, void **out)
+HRESULT asf_reader_create(IUnknown *outer, IUnknown **out)
 {
-    struct asf_reader *filter = impl_from_IFileSourceFilter(iface);
+    struct asf_reader *object;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;

-    return IBaseFilter_QueryInterface(&filter->filter.IBaseFilter_iface, iid, out);
+    strmbase_filter_init(&object->filter, outer, &CLSID_AsyncReader, &filter_ops);
+
+    object->IFileSourceFilter_iface.lpVtbl = &FileSource_Vtbl;
+    object->IAsyncReader_iface.lpVtbl = &FileAsyncReader_Vtbl;
+
+    InitializeCriticalSection(&object->sample_cs);
+    object->sample_cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": FileAsyncReader.sample_cs");
+    InitializeConditionVariable(&object->sample_cv);
+    object->port = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
+    object->io_thread = CreateThread(NULL, 0, io_thread, object, 0, NULL);
+
+    TRACE("Created file source %p.\n", object);
+    *out = &object->filter.IUnknown_inner;
+    return S_OK;
 }

-static ULONG WINAPI filesourcefilter_AddRef(IFileSourceFilter *iface)
+static HRESULT WINAPI FileSource_QueryInterface(IFileSourceFilter * iface, REFIID riid, LPVOID * ppv)
 {
     struct asf_reader *filter = impl_from_IFileSourceFilter(iface);
+    return IBaseFilter_QueryInterface(&filter->filter.IBaseFilter_iface, riid, ppv);
+}

+static ULONG WINAPI FileSource_AddRef(IFileSourceFilter * iface)
+{
+    struct asf_reader *filter = impl_from_IFileSourceFilter(iface);
     return IBaseFilter_AddRef(&filter->filter.IBaseFilter_iface);
 }

-static ULONG WINAPI filesourcefilter_Release(IFileSourceFilter *iface)
+static ULONG WINAPI FileSource_Release(IFileSourceFilter * iface)
 {
     struct asf_reader *filter = impl_from_IFileSourceFilter(iface);
-
     return IBaseFilter_Release(&filter->filter.IBaseFilter_iface);
 }

-static HRESULT WINAPI filesourcefilter_Load(IFileSourceFilter *iface, LPCOLESTR filename, const AM_MEDIA_TYPE *type)
+static HRESULT WINAPI FileSource_Load(IFileSourceFilter * iface, LPCOLESTR pszFileName, const AM_MEDIA_TYPE * pmt)
 {
-    struct asf_reader *filter = impl_from_IFileSourceFilter(iface);
+    struct asf_reader *This = impl_from_IFileSourceFilter(iface);
+    HANDLE hFile;

-    TRACE("filter %p, filename %s, type %p.\n", filter, debugstr_w(filename), type);
-    strmbase_dump_media_type(type);
+    TRACE("%p->(%s, %p)\n", This, debugstr_w(pszFileName), pmt);
+    strmbase_dump_media_type(pmt);

-    if (!filename)
+    if (!pszFileName)
         return E_POINTER;

-    if (filter->filename)
-        return E_FAIL;
+    /* open file */
+    /* FIXME: check the sharing values that native uses */
+    hFile = CreateFileW(pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
+
+    if (hFile == INVALID_HANDLE_VALUE)
+    {
+        return HRESULT_FROM_WIN32(GetLastError());
+    }
+
+    if (!GetFileSizeEx(hFile, &This->file_size))
+    {
+        WARN("Could not get file size.\n");
+        CloseHandle(hFile);
+        return HRESULT_FROM_WIN32(GetLastError());
+    }
+
+    if (This->pszFileName)
+    {
+        free(This->pszFileName);
+        FreeMediaType(&This->mt);
+    }

-    if (!(filter->filename = wcsdup(filename)))
+    if (!(This->pszFileName = wcsdup(pszFileName)))
+    {
+        CloseHandle(hFile);
         return E_OUTOFMEMORY;
+    }
+
+    strmbase_source_init(&This->source, &This->filter, L"Output", &source_ops);
+    BaseFilterImpl_IncrementPinVersion(&This->filter);
+
+    This->file = hFile;
+    This->flushing = FALSE;
+    This->requests = NULL;

-    if (type)
-        CopyMediaType(&filter->type, type);
+    if (!pmt)
+    {
+        CopyMediaType(&This->mt, &default_mt);
+        if (get_media_type(pszFileName, &This->mt.majortype, &This->mt.subtype, NULL))
+        {
+            TRACE("Found major type %s, subtype %s.\n",
+                    debugstr_guid(&This->mt.majortype), debugstr_guid(&This->mt.subtype));
+        }
+    }
+    else
+        CopyMediaType(&This->mt, pmt);

     return S_OK;
 }

-static HRESULT WINAPI filesourcefilter_GetCurFile(IFileSourceFilter *iface, LPOLESTR *filename, AM_MEDIA_TYPE *type)
+static HRESULT WINAPI FileSource_GetCurFile(IFileSourceFilter *iface, LPOLESTR *ppszFileName, AM_MEDIA_TYPE *mt)
 {
-    struct asf_reader *filter = impl_from_IFileSourceFilter(iface);
+    struct asf_reader *This = impl_from_IFileSourceFilter(iface);

-    TRACE("filter %p, filename %p, type %p.\n", filter, filename, type);
+    TRACE("filter %p, filename %p, mt %p.\n", This, ppszFileName, mt);

-    if (!filename)
+    if (!ppszFileName)
         return E_POINTER;
-    *filename = NULL;

-    if (type)
+    /* copy file name & media type if available, otherwise clear the outputs */
+    if (This->pszFileName)
     {
-        type->majortype = filter->type.majortype;
-        type->subtype = filter->type.subtype;
-        type->lSampleSize = filter->type.lSampleSize;
-        type->pUnk = filter->type.pUnk;
-        type->cbFormat = filter->type.cbFormat;
+        *ppszFileName = CoTaskMemAlloc((wcslen(This->pszFileName) + 1) * sizeof(WCHAR));
+        wcscpy(*ppszFileName, This->pszFileName);
+        if (mt)
+            CopyMediaType(mt, &This->mt);
     }
-
-    if (filter->filename)
+    else
     {
-        *filename = CoTaskMemAlloc((wcslen(filter->filename) + 1) * sizeof(WCHAR));
-        wcscpy(*filename, filter->filename);
+        *ppszFileName = NULL;
+        if (mt)
+            memset(mt, 0, sizeof(AM_MEDIA_TYPE));
     }

     return S_OK;
 }

-static const IFileSourceFilterVtbl filesourcefilter_vtbl =
+static const IFileSourceFilterVtbl FileSource_Vtbl =
 {
-    filesourcefilter_QueryInterface,
-    filesourcefilter_AddRef,
-    filesourcefilter_Release,
-    filesourcefilter_Load,
-    filesourcefilter_GetCurFile,
+    FileSource_QueryInterface,
+    FileSource_AddRef,
+    FileSource_Release,
+    FileSource_Load,
+    FileSource_GetCurFile
 };

-HRESULT asf_reader_create(IUnknown *outer, IUnknown **out)
+static inline struct asf_reader *impl_from_strmbase_pin(struct strmbase_pin *iface)
 {
-    struct asf_reader *object;
+    return CONTAINING_RECORD(iface, struct asf_reader, source.pin);
+}

-    if (!(object = calloc(1, sizeof(*object))))
+static inline struct asf_reader *impl_from_IAsyncReader(IAsyncReader *iface)
+{
+    return CONTAINING_RECORD(iface, struct asf_reader, IAsyncReader_iface);
+}
+
+static HRESULT source_query_accept(struct strmbase_pin *iface, const AM_MEDIA_TYPE *mt)
+{
+    struct asf_reader *filter = impl_from_strmbase_pin(iface);
+
+    if (IsEqualGUID(&mt->majortype, &filter->mt.majortype)
+            && (!IsEqualGUID(&mt->subtype, &GUID_NULL)
+            || IsEqualGUID(&filter->mt.subtype, &GUID_NULL)))
+        return S_OK;
+
+    return S_FALSE;
+}
+
+static HRESULT source_get_media_type(struct strmbase_pin *iface, unsigned int index, AM_MEDIA_TYPE *mt)
+{
+    struct asf_reader *filter = impl_from_strmbase_pin(iface);
+
+    if (index > 1)
+        return VFW_S_NO_MORE_ITEMS;
+
+    if (index == 0)
+        CopyMediaType(mt, &filter->mt);
+    else if (index == 1)
+        CopyMediaType(mt, &default_mt);
+    return S_OK;
+}
+
+static HRESULT source_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
+{
+    struct asf_reader *filter = impl_from_strmbase_pin(iface);
+
+    if (IsEqualGUID(iid, &IID_IAsyncReader))
+        *out = &filter->IAsyncReader_iface;
+    else
+        return E_NOINTERFACE;
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+/* Function called as a helper to IPin_Connect */
+/* specific AM_MEDIA_TYPE - it cannot be NULL */
+/* this differs from standard OutputPin_AttemptConnection only in that it
+ * doesn't need the IMemInputPin interface on the receiving pin */
+static HRESULT WINAPI FileAsyncReaderPin_AttemptConnection(struct strmbase_source *This,
+        IPin *pReceivePin, const AM_MEDIA_TYPE *pmt)
+{
+    HRESULT hr;
+
+    TRACE("%p->(%p, %p)\n", This, pReceivePin, pmt);
+
+    if (This->pin.ops->pin_query_accept(&This->pin, pmt) != S_OK)
+        return VFW_E_TYPE_NOT_ACCEPTED;
+
+    This->pin.peer = pReceivePin;
+    IPin_AddRef(pReceivePin);
+    CopyMediaType(&This->pin.mt, pmt);
+
+    hr = IPin_ReceiveConnection(pReceivePin, &This->pin.IPin_iface, pmt);
+
+    if (FAILED(hr))
+    {
+        IPin_Release(This->pin.peer);
+        This->pin.peer = NULL;
+        FreeMediaType(&This->pin.mt);
+    }
+
+    TRACE(" -- %x\n", hr);
+    return hr;
+}
+
+static const struct strmbase_source_ops source_ops =
+{
+    .base.pin_query_accept = source_query_accept,
+    .base.pin_get_media_type = source_get_media_type,
+    .base.pin_query_interface = source_query_interface,
+    .pfnAttemptConnection = FileAsyncReaderPin_AttemptConnection,
+};
+
+static HRESULT WINAPI FileAsyncReader_QueryInterface(IAsyncReader *iface, REFIID iid, void **out)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+    return IPin_QueryInterface(&filter->source.pin.IPin_iface, iid, out);
+}
+
+static ULONG WINAPI FileAsyncReader_AddRef(IAsyncReader * iface)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+    return IPin_AddRef(&filter->source.pin.IPin_iface);
+}
+
+static ULONG WINAPI FileAsyncReader_Release(IAsyncReader * iface)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+    return IPin_Release(&filter->source.pin.IPin_iface);
+}
+
+static HRESULT WINAPI FileAsyncReader_RequestAllocator(IAsyncReader *iface,
+        IMemAllocator *preferred, ALLOCATOR_PROPERTIES *props, IMemAllocator **ret_allocator)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+    IMemAllocator *allocator;
+    unsigned int i;
+    HRESULT hr;
+
+    TRACE("filter %p, preferred %p, props %p, ret_allocator %p.\n", filter, preferred, props, ret_allocator);
+
+    if (!props->cbAlign)
+        props->cbAlign = 1;
+
+    *ret_allocator = NULL;
+
+    if (preferred)
+        IMemAllocator_AddRef(allocator = preferred);
+    else if (FAILED(hr = CoCreateInstance(&CLSID_MemoryAllocator, NULL,
+            CLSCTX_INPROC, &IID_IMemAllocator, (void **)&allocator)))
+        return hr;
+
+    if (FAILED(hr = IMemAllocator_SetProperties(allocator, props, props)))
+    {
+        IMemAllocator_Release(allocator);
+        return hr;
+    }
+
+    if (filter->requests)
+    {
+        for (i = 0; i < filter->max_requests; ++i)
+            CloseHandle(filter->requests[i].ovl.hEvent);
+        free(filter->requests);
+    }
+
+    filter->max_requests = props->cBuffers;
+    TRACE("Maximum request count: %u.\n", filter->max_requests);
+    if (!(filter->requests = calloc(filter->max_requests, sizeof(filter->requests[0]))))
+    {
+        IMemAllocator_Release(allocator);
         return E_OUTOFMEMORY;
+    }

-    strmbase_filter_init(&object->filter, outer, &CLSID_WMAsfReader, &filter_ops);
-    object->IFileSourceFilter_iface.lpVtbl = &filesourcefilter_vtbl;
+    for (i = 0; i < filter->max_requests; ++i)
+        filter->requests[i].ovl.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);

-    TRACE("Created WM ASF reader %p.\n", object);
-    *out = &object->filter.IUnknown_inner;
+    *ret_allocator = allocator;
+    return S_OK;
+}
+
+static HRESULT WINAPI FileAsyncReader_Request(IAsyncReader *iface, IMediaSample *sample, DWORD_PTR cookie)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+    REFERENCE_TIME start, end;
+    struct request *req;
+    unsigned int i;
+    HRESULT hr;
+    BYTE *data;
+
+    TRACE("filter %p, sample %p, cookie %#lx.\n", filter, sample, cookie);
+
+    if (!sample)
+        return E_POINTER;
+
+    if (FAILED(hr = IMediaSample_GetTime(sample, &start, &end)))
+        return hr;
+
+    if (BYTES_FROM_MEDIATIME(start) >= filter->file_size.QuadPart)
+        return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
+
+    if (FAILED(hr = IMediaSample_GetPointer(sample, &data)))
+        return hr;
+
+    EnterCriticalSection(&filter->sample_cs);
+    if (filter->flushing)
+    {
+        LeaveCriticalSection(&filter->sample_cs);
+        return VFW_E_WRONG_STATE;
+    }
+
+    for (i = 0; i < filter->max_requests; ++i)
+    {
+        if (!filter->requests[i].sample)
+            break;
+    }
+    assert(i < filter->max_requests);
+    req = &filter->requests[i];
+
+    req->ovl.u.s.Offset = BYTES_FROM_MEDIATIME(start);
+    req->ovl.u.s.OffsetHigh = BYTES_FROM_MEDIATIME(start) >> 32;
+    /* No reference is taken. */
+
+    if (ReadFile(filter->file, data, BYTES_FROM_MEDIATIME(end - start), NULL, &req->ovl)
+            || GetLastError() == ERROR_IO_PENDING)
+    {
+        hr = S_OK;
+        req->sample = sample;
+        req->cookie = cookie;
+    }
+    else
+        hr = HRESULT_FROM_WIN32(GetLastError());
+
+    LeaveCriticalSection(&filter->sample_cs);
+    return hr;
+}
+
+static HRESULT WINAPI FileAsyncReader_WaitForNext(IAsyncReader *iface,
+        DWORD timeout, IMediaSample **sample, DWORD_PTR *cookie)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+    unsigned int i;
+
+    TRACE("filter %p, timeout %u, sample %p, cookie %p.\n", filter, timeout, sample, cookie);
+
+    *sample = NULL;
+    *cookie = 0;
+
+    EnterCriticalSection(&filter->sample_cs);
+
+    do
+    {
+        if (filter->flushing)
+        {
+            LeaveCriticalSection(&filter->sample_cs);
+            return VFW_E_WRONG_STATE;
+        }
+
+        for (i = 0; i < filter->max_requests; ++i)
+        {
+            struct request *req = &filter->requests[i];
+            DWORD size;
+
+            if (req->sample && GetOverlappedResult(filter->file, &req->ovl, &size, FALSE))
+            {
+                REFERENCE_TIME start, end;
+
+                IMediaSample_SetActualDataLength(req->sample, size);
+                start = MEDIATIME_FROM_BYTES(((ULONGLONG)req->ovl.u.s.OffsetHigh << 32) + req->ovl.u.s.Offset);
+                end = start + MEDIATIME_FROM_BYTES(size);
+                IMediaSample_SetTime(req->sample, &start, &end);
+
+                *sample = req->sample;
+                *cookie = req->cookie;
+                req->sample = NULL;
+
+                LeaveCriticalSection(&filter->sample_cs);
+                TRACE("Returning sample %u.\n", i);
+                return S_OK;
+            }
+        }
+    } while (SleepConditionVariableCS(&filter->sample_cv, &filter->sample_cs, timeout));
+
+    LeaveCriticalSection(&filter->sample_cs);
+    return VFW_E_TIMEOUT;
+}
+
+static BOOL sync_read(HANDLE file, LONGLONG offset, LONG length, BYTE *buffer, DWORD *read_len)
+{
+    OVERLAPPED ovl = {0};
+    BOOL ret;
+
+    ovl.hEvent = (HANDLE)((ULONG_PTR)CreateEventW(NULL, TRUE, FALSE, NULL) | 1);
+    ovl.u.s.Offset = (DWORD)offset;
+    ovl.u.s.OffsetHigh = offset >> 32;
+
+    *read_len = 0;
+
+    ret = ReadFile(file, buffer, length, NULL, &ovl);
+    if (ret || GetLastError() == ERROR_IO_PENDING)
+        ret = GetOverlappedResult(file, &ovl, read_len, TRUE);
+
+    TRACE("Returning %u bytes.\n", *read_len);
+
+    CloseHandle(ovl.hEvent);
+    return ret;
+}
+
+static HRESULT WINAPI FileAsyncReader_SyncReadAligned(IAsyncReader *iface, IMediaSample *sample)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+    REFERENCE_TIME start_time, end_time;
+    DWORD read_len;
+    BYTE *buffer;
+    LONG length;
+    HRESULT hr;
+    BOOL ret;
+
+    TRACE("filter %p, sample %p.\n", filter, sample);
+
+    hr = IMediaSample_GetTime(sample, &start_time, &end_time);
+
+    if (SUCCEEDED(hr))
+        hr = IMediaSample_GetPointer(sample, &buffer);
+
+    if (SUCCEEDED(hr))
+    {
+        length = BYTES_FROM_MEDIATIME(end_time - start_time);
+        ret = sync_read(filter->file, BYTES_FROM_MEDIATIME(start_time), length, buffer, &read_len);
+        if (ret)
+            hr = (read_len == length) ? S_OK : S_FALSE;
+        else if (GetLastError() == ERROR_HANDLE_EOF)
+            hr = S_OK;
+        else
+            hr = HRESULT_FROM_WIN32(GetLastError());
+    }
+
+    if (SUCCEEDED(hr))
+        IMediaSample_SetActualDataLength(sample, read_len);
+
+    return hr;
+}
+
+static HRESULT WINAPI FileAsyncReader_SyncRead(IAsyncReader *iface,
+        LONGLONG offset, LONG length, BYTE *buffer)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+    DWORD read_len;
+    HRESULT hr;
+    BOOL ret;
+
+    TRACE("filter %p, offset %s, length %d, buffer %p.\n",
+            filter, wine_dbgstr_longlong(offset), length, buffer);
+
+    ret = sync_read(filter->file, offset, length, buffer, &read_len);
+    if (ret)
+        hr = (read_len == length) ? S_OK : S_FALSE;
+    else if (GetLastError() == ERROR_HANDLE_EOF)
+        hr = S_FALSE;
+    else
+        hr = HRESULT_FROM_WIN32(GetLastError());
+
+    return hr;
+}
+
+static HRESULT WINAPI FileAsyncReader_Length(IAsyncReader *iface, LONGLONG *total, LONGLONG *available)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+
+    TRACE("iface %p, total %p, available %p.\n", iface, total, available);
+
+    *available = *total = filter->file_size.QuadPart;

     return S_OK;
 }
+
+static HRESULT WINAPI FileAsyncReader_BeginFlush(IAsyncReader * iface)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+    unsigned int i;
+
+    TRACE("iface %p.\n", iface);
+
+    EnterCriticalSection(&filter->sample_cs);
+
+    filter->flushing = TRUE;
+    for (i = 0; i < filter->max_requests; ++i)
+        filter->requests[i].sample = NULL;
+    CancelIoEx(filter->file, NULL);
+    WakeAllConditionVariable(&filter->sample_cv);
+
+    LeaveCriticalSection(&filter->sample_cs);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI FileAsyncReader_EndFlush(IAsyncReader * iface)
+{
+    struct asf_reader *filter = impl_from_IAsyncReader(iface);
+
+    TRACE("iface %p.\n", iface);
+
+    EnterCriticalSection(&filter->sample_cs);
+
+    filter->flushing = FALSE;
+
+    LeaveCriticalSection(&filter->sample_cs);
+
+    return S_OK;
+}
+
+static const IAsyncReaderVtbl FileAsyncReader_Vtbl =
+{
+    FileAsyncReader_QueryInterface,
+    FileAsyncReader_AddRef,
+    FileAsyncReader_Release,
+    FileAsyncReader_RequestAllocator,
+    FileAsyncReader_Request,
+    FileAsyncReader_WaitForNext,
+    FileAsyncReader_SyncReadAligned,
+    FileAsyncReader_SyncRead,
+    FileAsyncReader_Length,
+    FileAsyncReader_BeginFlush,
+    FileAsyncReader_EndFlush,
+};
From 38a3e2ae80c6a80be73be9288d2d12bfcb6ccb8d Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 22 Jul 2021 16:11:18 -0500
Subject: [PATCH] HACK: shell32: Update knownfolder paths in the registry

Guilty Gear Strive requires that the path be in the new format. Since we
haven't yet found a game that has a problem with the new format, let's
just use that in all cases.

For Steam cloud sync failures.

CW-Bug-Id: #18905
---
 dlls/shell32/shellpath.c | 21 ++++++++++++++++++---
 1 file changed, 18 insertions(+), 3 deletions(-)

diff --git a/dlls/shell32/shellpath.c b/dlls/shell32/shellpath.c
index a2b71bfb701..7227e97d6b9 100644
--- a/dlls/shell32/shellpath.c
+++ b/dlls/shell32/shellpath.c
@@ -4630,6 +4630,8 @@ static HRESULT _SHRegisterFolders(HKEY hRootKey, HANDLE hToken,
  LPCWSTR szUserShellFolderPath, LPCWSTR szShellFolderPath, const UINT folders[],
  UINT foldersLen)
 {
+    static const WCHAR WineVistaPathsW[] = {'_','_','W','i','n','e','V','i','s','t','a','P','a','t','h','s',0};
+
     const WCHAR *szValueName;
     WCHAR buffer[40];
     UINT i;
@@ -4638,6 +4640,7 @@ static HRESULT _SHRegisterFolders(HKEY hRootKey, HANDLE hToken,
     HKEY hUserKey = NULL, hKey = NULL;
     DWORD dwType, dwPathLen;
     LONG ret;
+    DWORD already_vista_paths = 0;

     TRACE("%p,%p,%s,%p,%u\n", hRootKey, hToken,
      debugstr_w(szUserShellFolderPath), folders, foldersLen);
@@ -4651,6 +4654,12 @@ static HRESULT _SHRegisterFolders(HKEY hRootKey, HANDLE hToken,
         if (ret)
             hr = HRESULT_FROM_WIN32(ret);
     }
+
+    /* check if the registry has already been updated to the vista+ style paths */
+    dwPathLen = sizeof(already_vista_paths);
+    RegQueryValueExW(hUserKey, WineVistaPathsW, NULL, &dwType,
+            (LPBYTE)&already_vista_paths, &dwPathLen);
+
     for (i = 0; SUCCEEDED(hr) && i < foldersLen; i++)
     {
         dwPathLen = MAX_PATH * sizeof(WCHAR);
@@ -4663,9 +4672,10 @@ static HRESULT _SHRegisterFolders(HKEY hRootKey, HANDLE hToken,
             szValueName = &buffer[0];
         }

-        if (RegQueryValueExW(hUserKey, szValueName, NULL,
-         &dwType, (LPBYTE)path, &dwPathLen) || (dwType != REG_SZ &&
-         dwType != REG_EXPAND_SZ))
+        if (!already_vista_paths ||
+                RegQueryValueExW(hUserKey, szValueName, NULL, &dwType,
+                    (LPBYTE)path, &dwPathLen) ||
+                (dwType != REG_SZ && dwType != REG_EXPAND_SZ))
         {
             *path = '\0';
             if (CSIDL_Data[folders[i]].type == CSIDL_Type_User)
@@ -4706,6 +4716,11 @@ static HRESULT _SHRegisterFolders(HKEY hRootKey, HANDLE hToken,
              hToken, SHGFP_TYPE_DEFAULT, path);
         }
     }
+
+    already_vista_paths = 1;
+    RegSetValueExW(hUserKey, WineVistaPathsW, 0, REG_DWORD,
+            (LPBYTE)&already_vista_paths, sizeof(already_vista_paths));
+
     if (hUserKey)
         RegCloseKey(hUserKey);
     if (hKey)
From a9ec37d83082b1623aea4bc5933f77f4c8a356cf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 14 Sep 2021 14:16:47 +0200
Subject: [PATCH] msvcrt: Check for ERMS support and use rep stosb for large
 memset calls.

---
 dlls/msvcrt/math.c   | 13 +++++++++
 dlls/msvcrt/msvcrt.h |  1 +
 dlls/msvcrt/string.c | 64 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 78 insertions(+)

diff --git a/dlls/msvcrt/math.c b/dlls/msvcrt/math.c
index d6b0d9422e7..ed763f02589 100644
--- a/dlls/msvcrt/math.c
+++ b/dlls/msvcrt/math.c
@@ -42,6 +42,7 @@
 #include <limits.h>
 #include <locale.h>
 #include <math.h>
+#include <intrin.h>

 #include "msvcrt.h"
 #include "winternl.h"
@@ -64,6 +65,7 @@ typedef int (CDECL *MSVCRT_matherr_func)(struct _exception *);

 static MSVCRT_matherr_func MSVCRT_default_matherr_func = NULL;

+BOOL erms_supported;
 BOOL sse2_supported;
 static BOOL sse2_enabled;

@@ -71,6 +73,17 @@ static const struct unix_funcs *unix_funcs;

 void msvcrt_init_math( void *module )
 {
+#if defined(__i386__) || defined(__x86_64__)
+    int regs[4];
+
+    __cpuid(regs, 0);
+    if (regs[0] >= 7)
+    {
+        __cpuidex(regs, 7, 0);
+        erms_supported = ((regs[1] >> 9) & 1);
+    }
+#endif
+
     sse2_supported = IsProcessorFeaturePresent( PF_XMMI64_INSTRUCTIONS_AVAILABLE );
 #if _MSVCR_VER <=71
     sse2_enabled = FALSE;
diff --git a/dlls/msvcrt/msvcrt.h b/dlls/msvcrt/msvcrt.h
index c84e0a0a638..69c52616e3f 100644
--- a/dlls/msvcrt/msvcrt.h
+++ b/dlls/msvcrt/msvcrt.h
@@ -32,6 +32,7 @@
 #include "winbase.h"
 #undef strncpy

+extern BOOL erms_supported DECLSPEC_HIDDEN;
 extern BOOL sse2_supported DECLSPEC_HIDDEN;

 #define DBL80_MAX_10_EXP 4932
diff --git a/dlls/msvcrt/string.c b/dlls/msvcrt/string.c
index 70cca8d18ee..3daa0d483d0 100644
--- a/dlls/msvcrt/string.c
+++ b/dlls/msvcrt/string.c
@@ -2722,6 +2722,13 @@ __ASM_GLOBAL_FUNC( sse2_memmove,
         MEMMOVE_CLEANUP
         "ret" )

+#undef MEMMOVE_INIT
+#undef MEMMOVE_CLEANUP
+#undef DEST_REG
+#undef SRC_REG
+#undef LEN_REG
+#undef TMP_REG
+
 #endif

 /*********************************************************************
@@ -2845,6 +2852,56 @@ void * __cdecl memcpy(void *dst, const void *src, size_t n)
     return memmove(dst, src, n);
 }

+#if defined(__i386__) || defined(__x86_64__)
+
+#ifdef __i386__
+#define DEST_REG "%edi"
+#define LEN_REG "%ecx"
+#define VAL_REG "%eax"
+
+#define MEMSET_INIT \
+    "movl " DEST_REG ", %edx\n\t" \
+    "movl 4(%esp), " DEST_REG "\n\t" \
+    "movl 8(%esp), " VAL_REG "\n\t" \
+    "movl 12(%esp), " LEN_REG "\n\t"
+
+#define MEMSET_RET \
+    "movl %edx, " DEST_REG "\n\t" \
+    "ret"
+
+#else
+
+#define DEST_REG "%rdi"
+#define LEN_REG "%rcx"
+#define VAL_REG "%eax"
+
+#define MEMSET_INIT \
+    "movq " DEST_REG ", %r9\n\t" \
+    "movq %rcx, " DEST_REG "\n\t" \
+    "movl %edx, " VAL_REG "\n\t" \
+    "movq %r8, " LEN_REG "\n\t"
+
+#define MEMSET_RET \
+    "movq %r9, " DEST_REG "\n\t" \
+    "ret"
+
+#endif
+
+void __cdecl erms_memset_aligned_32(unsigned char *d, unsigned int c, size_t n);
+__ASM_GLOBAL_FUNC( erms_memset_aligned_32,
+        MEMSET_INIT
+        "rep\n\t"
+        "stosb\n\t"
+        MEMSET_RET )
+
+#undef MEMSET_INIT
+#undef MEMSET_RET
+#undef DEST_REG
+#undef LEN_REG
+#undef VAL_REG
+
+#endif
+
 static inline void memset_aligned_32(unsigned char *d, uint64_t v, size_t n)
 {
     while (n >= 32)
@@ -2880,6 +2937,13 @@ void *__cdecl memset(void *dst, int c, size_t n)
         if (n <= 64) return dst;

         n = (n - a) & ~0x1f;
+#if defined(__i386__) || defined(__x86_64__)
+        if (n >= 2048 && erms_supported)
+        {
+            erms_memset_aligned_32(d + a, v, n);
+            return dst;
+        }
+#endif
         memset_aligned_32(d + a, v, n);
         return dst;
     }
From 454d37da51ed35ce16d73ba162c4fad3de7f93b1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 14 Sep 2021 14:16:48 +0200
Subject: [PATCH] msvcrt: Add an SSE2 memset_aligned_32 implementation.

---
 dlls/msvcrt/string.c | 33 +++++++++++++++++++++++++++++++++
 1 file changed, 33 insertions(+)

diff --git a/dlls/msvcrt/string.c b/dlls/msvcrt/string.c
index 3daa0d483d0..74409a6fb76 100644
--- a/dlls/msvcrt/string.c
+++ b/dlls/msvcrt/string.c
@@ -2894,6 +2894,27 @@ __ASM_GLOBAL_FUNC( erms_memset_aligned_32,
         "stosb\n\t"
         MEMSET_RET )

+void __cdecl sse2_memset_aligned_32(unsigned char *d, unsigned int c, size_t n);
+__ASM_GLOBAL_FUNC( sse2_memset_aligned_32,
+        MEMSET_INIT
+        "movd " VAL_REG ", %xmm0\n\t"
+        "pshufd $0, %xmm0, %xmm0\n\t"
+        "test $0x20, " LEN_REG "\n\t"
+        "je 1f\n\t"
+        "sub $0x20, " LEN_REG "\n\t"
+        "movdqa %xmm0, 0x00(" DEST_REG ", " LEN_REG ")\n\t"
+        "movdqa %xmm0, 0x10(" DEST_REG ", " LEN_REG ")\n\t"
+        "je 2f\n\t"
+        "1:\n\t"
+        "sub $0x40, " LEN_REG "\n\t"
+        "movdqa %xmm0, 0x00(" DEST_REG ", " LEN_REG ")\n\t"
+        "movdqa %xmm0, 0x10(" DEST_REG ", " LEN_REG ")\n\t"
+        "movdqa %xmm0, 0x20(" DEST_REG ", " LEN_REG ")\n\t"
+        "movdqa %xmm0, 0x30(" DEST_REG ", " LEN_REG ")\n\t"
+        "ja 1b\n\t"
+        "2:\n\t"
+        MEMSET_RET )
+
 #undef MEMSET_INIT
 #undef MEMSET_RET
 #undef DEST_REG
@@ -2943,9 +2964,21 @@ void *__cdecl memset(void *dst, int c, size_t n)
             erms_memset_aligned_32(d + a, v, n);
             return dst;
         }
+#ifdef __x86_64__
+        sse2_memset_aligned_32(d + a, v, n);
+        return dst;
+#else
+        if (sse2_supported)
+        {
+            sse2_memset_aligned_32(d + a, v, n);
+            return dst;
+        }
+#endif
 #endif
+#ifndef __x86_64__
         memset_aligned_32(d + a, v, n);
         return dst;
+#endif
     }
     if (n >= 8)
     {
From 1ace788f817b0175e63d02732c0c11269d19ae0a Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 16 Sep 2021 18:01:42 +0300
Subject: [PATCH] kernelbase: Return an error from
 InitializeProcessForWsWatch() stub.

CW-Bug-ID: #19445

For DeathLoop.
---
 dlls/kernelbase/debug.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/kernelbase/debug.c b/dlls/kernelbase/debug.c
index cbc53e22ac1..60b03c57137 100644
--- a/dlls/kernelbase/debug.c
+++ b/dlls/kernelbase/debug.c
@@ -1525,7 +1525,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetWsChangesEx( HANDLE process, PSAPI_WS_WATCH_INF
 BOOL WINAPI /* DECLSPEC_HOTPATCH */ InitializeProcessForWsWatch( HANDLE process )
 {
     FIXME( "(process=%p): stub\n", process );
-    return TRUE;
+    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
+    return FALSE;
 }


From c5012eb1b2613f053a331d9156046fe8b7245687 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 17 Sep 2021 21:49:11 +0300
Subject: [PATCH] advapi32: HACK: Don't free provider library in
 CryptReleaseContext() for DeathLoop.

CW-Bug-Id: 19427

Avoids a lockup in DeathLoop. To be dropped once we have a
GetModuleHandle() not blocking on the loader lock.
---
 dlls/advapi32/crypt.c | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/dlls/advapi32/crypt.c b/dlls/advapi32/crypt.c
index 20c55558fa5..db6e16ae435 100644
--- a/dlls/advapi32/crypt.c
+++ b/dlls/advapi32/crypt.c
@@ -645,9 +645,19 @@ BOOL WINAPI CryptReleaseContext (HCRYPTPROV hProv, DWORD dwFlags)

 	if (InterlockedDecrement(&pProv->refcount) == 0)
 	{
+		static unsigned int once;
+		char sgi[64];
+
 		ret = pProv->pFuncs->pCPReleaseContext(pProv->hPrivate, dwFlags);
 		pProv->dwMagic = 0;
-		FreeLibrary(pProv->hModule);
+		if(GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi)) && !strcmp(sgi, "1252330"))
+		{
+			if (!once++) FIXME("HACK: not freeing provider library.\n");
+		}
+		else
+		{
+			FreeLibrary(pProv->hModule);
+		}
 #if 0
 		CRYPT_Free(pProv->pVTable->pContextInfo);
 #endif
From 8ec69866810c5fa605915a0be77796e89ab3f72b Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 14 Oct 2021 17:51:51 +0300
Subject: [PATCH] winhttp: Process end of read data before sending callback in
 read_data().

CW-Bug-ID: #19544

Fixes Fallout76 random crash on start.
---
 dlls/winhttp/request.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index c795a26d1a4..353c0ed3f60 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -1845,6 +1845,7 @@ static DWORD read_data( struct request *request, void *buffer, DWORD size, DWORD

 done:
     TRACE( "retrieved %u bytes (%u/%u)\n", bytes_read, request->content_read, request->content_length );
+    if (end_of_read_data( request )) finished_reading( request );
     if (async)
     {
         if (!ret) send_callback( &request->hdr, WINHTTP_CALLBACK_STATUS_READ_COMPLETE, buffer, bytes_read );
@@ -1858,7 +1859,6 @@ static DWORD read_data( struct request *request, void *buffer, DWORD size, DWORD
     }

     if (!ret && read) *read = bytes_read;
-    if (end_of_read_data( request )) finished_reading( request );
     return ret;
 }

From 050bcf50ef3349114b291d84d6f49aaef4165750 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 15 Oct 2021 16:59:48 +0300
Subject: [PATCH] winhttp: Don't send notifications when connection is closed
 on read finish.

CW-Bug-ID: #19544

Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
(cherry picked from commit d349013ddea1c407189cd22df2a4ff8bf025085b)
---
 dlls/winhttp/request.c            | 10 ++++------
 dlls/winhttp/tests/notification.c | 32 ++++++++-----------------------
 2 files changed, 12 insertions(+), 30 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 353c0ed3f60..a2a5774d74d 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -1792,13 +1792,11 @@ static void finished_reading( struct request *request )
         if (!wcsicmp( connection, L"close" )) close = TRUE;
     }
     else if (!wcscmp( request->version, L"HTTP/1.0" )) close = TRUE;
-    if (close)
-    {
-        close_connection( request );
-        return;
-    }

-    cache_connection( request->netconn );
+    if (close)
+        netconn_close( request->netconn );
+    else
+        cache_connection( request->netconn );
     request->netconn = NULL;
 }

diff --git a/dlls/winhttp/tests/notification.c b/dlls/winhttp/tests/notification.c
index e6e7e0b21e7..9392ddccab8 100644
--- a/dlls/winhttp/tests/notification.c
+++ b/dlls/winhttp/tests/notification.c
@@ -1112,32 +1112,15 @@ static const struct notification read_test[] =
     { winhttp_read_data,        WINHTTP_CALLBACK_STATUS_READ_COMPLETE, NF_SIGNAL }
 };

-static const struct notification read_allow_close_test[] =
-{
-    { winhttp_read_data,        WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE, NF_ALLOW },
-    { winhttp_read_data,        WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED, NF_ALLOW },
-    { winhttp_read_data,        WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION, NF_ALLOW },
-    { winhttp_read_data,        WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED, NF_ALLOW },
-    { winhttp_read_data,        WINHTTP_CALLBACK_STATUS_READ_COMPLETE, NF_SIGNAL }
-};
-
-#define read_request_data(a,b,c,d) _read_request_data(a,b,c,d,__LINE__)
-static void _read_request_data(struct test_request *req, struct info *info, const char *expected_data, BOOL closing_connection, unsigned line)
+#define read_request_data(a,b,c) _read_request_data(a,b,c,__LINE__)
+static void _read_request_data(struct test_request *req, struct info *info, const char *expected_data, unsigned line)
 {
     char buffer[1024];
     DWORD len;
     BOOL ret;

-    if (closing_connection)
-    {
-        info->test = read_allow_close_test;
-        info->count = ARRAY_SIZE( read_allow_close_test );
-    }
-    else
-    {
-        info->test = read_test;
-        info->count = ARRAY_SIZE( read_test );
-    }
+    info->test = read_test;
+    info->count = ARRAY_SIZE( read_test );
     info->index = 0;

     setup_test( info, winhttp_read_data, line );
@@ -1168,7 +1151,7 @@ static void test_persistent_connection(int port)
                        "Content-Length: 1\r\n"
                        "\r\n"
                        "X" );
-    read_request_data( &req, &info, "X", FALSE );
+    read_request_data( &req, &info, "X" );
     close_request( &req, &info, FALSE );

     /* chunked connection test */
@@ -1182,7 +1165,7 @@ static void test_persistent_connection(int port)
                        "\r\n"
                        "9\r\n123456789\r\n"
                        "0\r\n\r\n" );
-    read_request_data( &req, &info, "123456789", FALSE );
+    read_request_data( &req, &info, "123456789" );
     close_request( &req, &info, FALSE );

     /* HTTP/1.1 connections are persistent by default, no additional header is needed */
@@ -1194,7 +1177,7 @@ static void test_persistent_connection(int port)
                        "Content-Length: 2\r\n"
                        "\r\n"
                        "xx" );
-    read_request_data( &req, &info, "xx", FALSE );
+    read_request_data( &req, &info, "xx" );
     close_request( &req, &info, FALSE );

     open_async_request( port, &req, &info, L"/test", TRUE );
@@ -1206,6 +1189,7 @@ static void test_persistent_connection(int port)
                        "Connection: close\r\n"
                        "\r\n"
                        "yy" );
+    read_request_data( &req, &info, "yy" );
     close_request( &req, &info, TRUE );

     SetEvent( server_socket_done );
