From f7c3d6caddfa5f34f11a063021444389c697e8e8 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Sat, 11 Dec 2021 13:28:36 +0100
Subject: [PATCH] winevulkan: Fullscreen hack

Includes work by Georg Lehmann, Zhiyi Zhang, Brendan Shanks, and Joshua
Ashton.
---
 dlls/winevulkan/make_vulkan      |   19 +-
 dlls/winevulkan/vulkan.c         | 1397 ++++++++++++++++++++++++++++++
 dlls/winevulkan/vulkan_private.h |   38 +
 3 files changed, 1449 insertions(+), 5 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 360b2087eb9..705a4a6e24e 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -228,11 +228,11 @@ FUNCTION_OVERRIDES = {
 
     # VK_KHR_swapchain
     "vkAcquireNextImageKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
-    "vkAcquireNextImage2KHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
-    "vkCreateSwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
-    "vkDestroySwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
-    "vkGetSwapchainImagesKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
-    "vkQueuePresentKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
+    "vkAcquireNextImage2KHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
+    "vkCreateSwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
+    "vkDestroySwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
+    "vkGetSwapchainImagesKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
+    "vkQueuePresentKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
 
     # VK_KHR_external_fence_capabilities
     "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
@@ -1083,6 +1083,8 @@ class VkHandle(object):
     def native_handle(self, name):
         """ Provide access to the native handle of a wrapped object. """
 
+        if self.name == "VkSwapchainKHR":
+            return "((struct VkSwapchainKHR_T *)(uintptr_t) ({0}))->swapchain".format(name)
         if self.name == "VkCommandPool":
             return "wine_cmd_pool_from_handle({0})->command_pool".format(name)
         if self.name == "VkDebugUtilsMessengerEXT":
@@ -2580,6 +2658,12 @@ class VkGenerator(object):
         f.write("\n")
         f.write("    /* winevulkan specific functions */\n")
         f.write("    VkSurfaceKHR (*p_wine_get_native_surface)(VkSurfaceKHR);\n")
+        f.write("\n    /* Optional. Returns TRUE if FS hack is active, otherwise returns FALSE. If\n")
+        f.write("     * it returns TRUE, then real_sz will contain the actual display\n")
+        f.write("     * resolution; user_sz will contain the app's requested mode; and dst_blit\n")
+        f.write("     * will contain the area to blit the user image to in real coordinates.\n")
+        f.write("     * All parameters are optional. */\n")
+        f.write("    VkBool32 (*query_fs_hack)(VkSurfaceKHR surface, VkExtent2D *real_sz, VkExtent2D *user_sz, VkRect2D *dst_blit, VkFilter *filter);\n")
         f.write("};\n\n")

         f.write("extern const struct vulkan_funcs * CDECL __wine_get_vulkan_driver(HDC hdc, UINT version);\n\n")
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 9f12660a407..3c8bd452eca 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -22,6 +22,7 @@
 #endif
 
 #include "config.h"
+#include <math.h>
 #include <time.h>
 #include <stdlib.h>
 
@@ -1657,6 +1658,751 @@ NTSTATUS wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(void *args)
     return STATUS_SUCCESS;
 }
 
+VkResult WINAPI wine_vkSetPrivateDataEXT(VkDevice device, VkObjectType object_type, uint64_t object_handle,
+        VkPrivateDataSlotEXT private_data_slot, uint64_t data)
+{
+    TRACE("%p, %#x, 0x%s, 0x%s, 0x%s\n", device, object_type, wine_dbgstr_longlong(object_handle),
+            wine_dbgstr_longlong(private_data_slot), wine_dbgstr_longlong(data));
+
+    object_handle = wine_vk_unwrap_handle(object_type, object_handle);
+    return device->funcs.p_vkSetPrivateDataEXT(device->device, object_type, object_handle, private_data_slot, data);
+}
+
+void WINAPI wine_vkGetPrivateDataEXT(VkDevice device, VkObjectType object_type, uint64_t object_handle,
+        VkPrivateDataSlotEXT private_data_slot, uint64_t *data)
+{
+    TRACE("%p, %#x, 0x%s, 0x%s, %p\n", device, object_type, wine_dbgstr_longlong(object_handle),
+            wine_dbgstr_longlong(private_data_slot), data);
+
+    object_handle = wine_vk_unwrap_handle(object_type, object_handle);
+    device->funcs.p_vkGetPrivateDataEXT(device->device, object_type, object_handle, private_data_slot, data);
+}
+
+/*
+#version 450
+
+layout(binding = 0) uniform sampler2D texSampler;
+layout(binding = 1, rgba8) uniform writeonly image2D outImage;
+layout(push_constant) uniform pushConstants {
+    //both in real image coords
+    vec2 offset;
+    vec2 extents;
+} constants;
+
+layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
+
+void main()
+{
+    vec2 texcoord = (vec2(gl_GlobalInvocationID.xy) - constants.offset) / constants.extents;
+    vec4 c = texture(texSampler, texcoord);
+    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), c.bgra);
+}
+*/
+const uint32_t blit_comp_spv[] = {
+    0x07230203,0x00010000,0x00080006,0x00000037,0x00000000,0x00020011,0x00000001,0x0006000b,
+    0x00000001,0x4c534c47,0x6474732e,0x3035342e,0x00000000,0x0003000e,0x00000000,0x00000001,
+    0x0006000f,0x00000005,0x00000004,0x6e69616d,0x00000000,0x0000000d,0x00060010,0x00000004,
+    0x00000011,0x00000008,0x00000008,0x00000001,0x00030003,0x00000002,0x000001c2,0x00040005,
+    0x00000004,0x6e69616d,0x00000000,0x00050005,0x00000009,0x63786574,0x64726f6f,0x00000000,
+    0x00080005,0x0000000d,0x475f6c67,0x61626f6c,0x766e496c,0x7461636f,0x496e6f69,0x00000044,
+    0x00060005,0x00000012,0x68737570,0x736e6f43,0x746e6174,0x00000073,0x00050006,0x00000012,
+    0x00000000,0x7366666f,0x00007465,0x00050006,0x00000012,0x00000001,0x65747865,0x0073746e,
+    0x00050005,0x00000014,0x736e6f63,0x746e6174,0x00000073,0x00030005,0x00000021,0x00000063,
+    0x00050005,0x00000025,0x53786574,0x6c706d61,0x00007265,0x00050005,0x0000002c,0x4974756f,
+    0x6567616d,0x00000000,0x00040047,0x0000000d,0x0000000b,0x0000001c,0x00050048,0x00000012,
+    0x00000000,0x00000023,0x00000000,0x00050048,0x00000012,0x00000001,0x00000023,0x00000008,
+    0x00030047,0x00000012,0x00000002,0x00040047,0x00000025,0x00000022,0x00000000,0x00040047,
+    0x00000025,0x00000021,0x00000000,0x00040047,0x0000002c,0x00000022,0x00000000,0x00040047,
+    0x0000002c,0x00000021,0x00000001,0x00030047,0x0000002c,0x00000019,0x00040047,0x00000036,
+    0x0000000b,0x00000019,0x00020013,0x00000002,0x00030021,0x00000003,0x00000002,0x00030016,
+    0x00000006,0x00000020,0x00040017,0x00000007,0x00000006,0x00000002,0x00040020,0x00000008,
+    0x00000007,0x00000007,0x00040015,0x0000000a,0x00000020,0x00000000,0x00040017,0x0000000b,
+    0x0000000a,0x00000003,0x00040020,0x0000000c,0x00000001,0x0000000b,0x0004003b,0x0000000c,
+    0x0000000d,0x00000001,0x00040017,0x0000000e,0x0000000a,0x00000002,0x0004001e,0x00000012,
+    0x00000007,0x00000007,0x00040020,0x00000013,0x00000009,0x00000012,0x0004003b,0x00000013,
+    0x00000014,0x00000009,0x00040015,0x00000015,0x00000020,0x00000001,0x0004002b,0x00000015,
+    0x00000016,0x00000000,0x00040020,0x00000017,0x00000009,0x00000007,0x0004002b,0x00000015,
+    0x0000001b,0x00000001,0x00040017,0x0000001f,0x00000006,0x00000004,0x00040020,0x00000020,
+    0x00000007,0x0000001f,0x00090019,0x00000022,0x00000006,0x00000001,0x00000000,0x00000000,
+    0x00000000,0x00000001,0x00000000,0x0003001b,0x00000023,0x00000022,0x00040020,0x00000024,
+    0x00000000,0x00000023,0x0004003b,0x00000024,0x00000025,0x00000000,0x0004002b,0x00000006,
+    0x00000028,0x00000000,0x00090019,0x0000002a,0x00000006,0x00000001,0x00000000,0x00000000,
+    0x00000000,0x00000002,0x00000004,0x00040020,0x0000002b,0x00000000,0x0000002a,0x0004003b,
+    0x0000002b,0x0000002c,0x00000000,0x00040017,0x00000030,0x00000015,0x00000002,0x0004002b,
+    0x0000000a,0x00000034,0x00000008,0x0004002b,0x0000000a,0x00000035,0x00000001,0x0006002c,
+    0x0000000b,0x00000036,0x00000034,0x00000034,0x00000035,0x00050036,0x00000002,0x00000004,
+    0x00000000,0x00000003,0x000200f8,0x00000005,0x0004003b,0x00000008,0x00000009,0x00000007,
+    0x0004003b,0x00000020,0x00000021,0x00000007,0x0004003d,0x0000000b,0x0000000f,0x0000000d,
+    0x0007004f,0x0000000e,0x00000010,0x0000000f,0x0000000f,0x00000000,0x00000001,0x00040070,
+    0x00000007,0x00000011,0x00000010,0x00050041,0x00000017,0x00000018,0x00000014,0x00000016,
+    0x0004003d,0x00000007,0x00000019,0x00000018,0x00050083,0x00000007,0x0000001a,0x00000011,
+    0x00000019,0x00050041,0x00000017,0x0000001c,0x00000014,0x0000001b,0x0004003d,0x00000007,
+    0x0000001d,0x0000001c,0x00050088,0x00000007,0x0000001e,0x0000001a,0x0000001d,0x0003003e,
+    0x00000009,0x0000001e,0x0004003d,0x00000023,0x00000026,0x00000025,0x0004003d,0x00000007,
+    0x00000027,0x00000009,0x00070058,0x0000001f,0x00000029,0x00000026,0x00000027,0x00000002,
+    0x00000028,0x0003003e,0x00000021,0x00000029,0x0004003d,0x0000002a,0x0000002d,0x0000002c,
+    0x0004003d,0x0000000b,0x0000002e,0x0000000d,0x0007004f,0x0000000e,0x0000002f,0x0000002e,
+    0x0000002e,0x00000000,0x00000001,0x0004007c,0x00000030,0x00000031,0x0000002f,0x0004003d,
+    0x0000001f,0x00000032,0x00000021,0x0009004f,0x0000001f,0x00000033,0x00000032,0x00000032,
+    0x00000002,0x00000001,0x00000000,0x00000003,0x00040063,0x0000002d,0x00000031,0x00000033,
+    0x000100fd,0x00010038
+};
+
+static VkResult create_pipeline(VkDevice device, struct VkSwapchainKHR_T *swapchain, VkShaderModule shaderModule)
+{
+    VkResult res;
+#if defined(USE_STRUCT_CONVERSION)
+    VkComputePipelineCreateInfo_host pipelineInfo = {0};
+#else
+    VkComputePipelineCreateInfo pipelineInfo = {0};
+#endif
+
+    pipelineInfo.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
+    pipelineInfo.stage.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
+    pipelineInfo.stage.stage = VK_SHADER_STAGE_COMPUTE_BIT;
+    pipelineInfo.stage.module = shaderModule;
+    pipelineInfo.stage.pName = "main";
+    pipelineInfo.layout = swapchain->pipeline_layout;
+    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;
+    pipelineInfo.basePipelineIndex = -1;
+
+    res = device->funcs.p_vkCreateComputePipelines(device->device, VK_NULL_HANDLE, 1, &pipelineInfo, NULL, &swapchain->pipeline);
+    if(res != VK_SUCCESS){
+        ERR("vkCreateComputePipelines: %d\n", res);
+        return res;
+    }
+
+    return VK_SUCCESS;
+}
+
+static VkResult create_descriptor_set(VkDevice device, struct VkSwapchainKHR_T *swapchain, struct fs_hack_image *hack)
+{
+    VkResult res;
+#if defined(USE_STRUCT_CONVERSION)
+    VkDescriptorSetAllocateInfo_host descriptorAllocInfo = {0};
+    VkWriteDescriptorSet_host descriptorWrites[2] = {{0}, {0}};
+    VkDescriptorImageInfo_host userDescriptorImageInfo = {0}, realDescriptorImageInfo = {0};
+#else
+    VkDescriptorSetAllocateInfo descriptorAllocInfo = {0};
+    VkWriteDescriptorSet descriptorWrites[2] = {{0}, {0}};
+    VkDescriptorImageInfo userDescriptorImageInfo = {0}, realDescriptorImageInfo = {0};
+#endif
+
+    descriptorAllocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
+    descriptorAllocInfo.descriptorPool = swapchain->descriptor_pool;
+    descriptorAllocInfo.descriptorSetCount = 1;
+    descriptorAllocInfo.pSetLayouts = &swapchain->descriptor_set_layout;
+
+    res = device->funcs.p_vkAllocateDescriptorSets(device->device, &descriptorAllocInfo, &hack->descriptor_set);
+    if(res != VK_SUCCESS){
+        ERR("vkAllocateDescriptorSets: %d\n", res);
+        return res;
+    }
+
+    userDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+    userDescriptorImageInfo.imageView = hack->user_view;
+    userDescriptorImageInfo.sampler = swapchain->sampler;
+
+    realDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_GENERAL;
+    realDescriptorImageInfo.imageView = hack->blit_view;
+
+    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
+    descriptorWrites[0].dstSet = hack->descriptor_set;
+    descriptorWrites[0].dstBinding = 0;
+    descriptorWrites[0].dstArrayElement = 0;
+    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
+    descriptorWrites[0].descriptorCount = 1;
+    descriptorWrites[0].pImageInfo = &userDescriptorImageInfo;
+
+    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
+    descriptorWrites[1].dstSet = hack->descriptor_set;
+    descriptorWrites[1].dstBinding = 1;
+    descriptorWrites[1].dstArrayElement = 0;
+    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
+    descriptorWrites[1].descriptorCount = 1;
+    descriptorWrites[1].pImageInfo = &realDescriptorImageInfo;
+
+    device->funcs.p_vkUpdateDescriptorSets(device->device, 2, descriptorWrites, 0, NULL);
+
+    return VK_SUCCESS;
+}
+
+static VkResult init_blit_images(VkDevice device, struct VkSwapchainKHR_T *swapchain)
+{
+    VkResult res;
+    VkSamplerCreateInfo samplerInfo = {0};
+    VkDescriptorPoolSize poolSizes[2] = {{0}, {0}};
+    VkDescriptorPoolCreateInfo poolInfo = {0};
+    VkDescriptorSetLayoutBinding layoutBindings[2] = {{0}, {0}};
+    VkDescriptorSetLayoutCreateInfo descriptorLayoutInfo = {0};
+    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {0};
+    VkPushConstantRange pushConstants;
+    VkShaderModuleCreateInfo shaderInfo = {0};
+    VkShaderModule shaderModule = 0;
+    VkDeviceSize blitMemTotal = 0, offs;
+    VkImageCreateInfo imageInfo = {0};
+#if defined(USE_STRUCT_CONVERSION)
+    VkMemoryRequirements_host blitMemReq;
+    VkMemoryAllocateInfo_host allocInfo = {0};
+    VkPhysicalDeviceMemoryProperties_host memProperties;
+    VkImageViewCreateInfo_host viewInfo = {0};
+#else
+    VkMemoryRequirements blitMemReq;
+    VkMemoryAllocateInfo allocInfo = {0};
+    VkPhysicalDeviceMemoryProperties memProperties;
+    VkImageViewCreateInfo viewInfo = {0};
+#endif
+    uint32_t blit_memory_type = -1, i;
+
+    samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
+    samplerInfo.magFilter = swapchain->fs_hack_filter;
+    samplerInfo.minFilter = swapchain->fs_hack_filter;
+    samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
+    samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
+    samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
+    samplerInfo.anisotropyEnable = VK_FALSE;
+    samplerInfo.maxAnisotropy = 1;
+    samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
+    samplerInfo.unnormalizedCoordinates = VK_FALSE;
+    samplerInfo.compareEnable = VK_FALSE;
+    samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;
+    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
+    samplerInfo.mipLodBias = 0.0f;
+    samplerInfo.minLod = 0.0f;
+    samplerInfo.maxLod = 0.0f;
+
+    res = device->funcs.p_vkCreateSampler(device->device, &samplerInfo, NULL, &swapchain->sampler);
+    if(res != VK_SUCCESS)
+    {
+        WARN("vkCreateSampler failed, res=%d\n", res);
+        return res;
+    }
+
+    poolSizes[0].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
+    poolSizes[0].descriptorCount = swapchain->n_images;
+    poolSizes[1].type = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
+    poolSizes[1].descriptorCount = swapchain->n_images;
+
+    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
+    poolInfo.poolSizeCount = 2;
+    poolInfo.pPoolSizes = poolSizes;
+    poolInfo.maxSets = swapchain->n_images;
+
+    res = device->funcs.p_vkCreateDescriptorPool(device->device, &poolInfo, NULL, &swapchain->descriptor_pool);
+    if(res != VK_SUCCESS){
+        ERR("vkCreateDescriptorPool: %d\n", res);
+        goto fail;
+    }
+
+    layoutBindings[0].binding = 0;
+    layoutBindings[0].descriptorCount = 1;
+    layoutBindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
+    layoutBindings[0].pImmutableSamplers = NULL;
+    layoutBindings[0].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
+
+    layoutBindings[1].binding = 1;
+    layoutBindings[1].descriptorCount = 1;
+    layoutBindings[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
+    layoutBindings[1].pImmutableSamplers = NULL;
+    layoutBindings[1].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
+
+    descriptorLayoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
+    descriptorLayoutInfo.bindingCount = 2;
+    descriptorLayoutInfo.pBindings = layoutBindings;
+
+    res = device->funcs.p_vkCreateDescriptorSetLayout(device->device, &descriptorLayoutInfo, NULL, &swapchain->descriptor_set_layout);
+    if(res != VK_SUCCESS){
+        ERR("vkCreateDescriptorSetLayout: %d\n", res);
+        goto fail;
+    }
+
+    pushConstants.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
+    pushConstants.offset = 0;
+    pushConstants.size = 4 * sizeof(float); /* 2 * vec2 */
+
+    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
+    pipelineLayoutInfo.setLayoutCount = 1;
+    pipelineLayoutInfo.pSetLayouts = &swapchain->descriptor_set_layout;
+    pipelineLayoutInfo.pushConstantRangeCount = 1;
+    pipelineLayoutInfo.pPushConstantRanges = &pushConstants;
+
+    res = device->funcs.p_vkCreatePipelineLayout(device->device, &pipelineLayoutInfo, NULL, &swapchain->pipeline_layout);
+    if(res != VK_SUCCESS){
+        ERR("vkCreatePipelineLayout: %d\n", res);
+        goto fail;
+    }
+
+    shaderInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
+    shaderInfo.codeSize = sizeof(blit_comp_spv);
+    shaderInfo.pCode = blit_comp_spv;
+
+    res = device->funcs.p_vkCreateShaderModule(device->device, &shaderInfo, NULL, &shaderModule);
+    if(res != VK_SUCCESS){
+        ERR("vkCreateShaderModule: %d\n", res);
+        goto fail;
+    }
+
+    res = create_pipeline(device, swapchain, shaderModule);
+    if(res != VK_SUCCESS)
+        goto fail;
+
+    device->funcs.p_vkDestroyShaderModule(device->device, shaderModule, NULL);
+
+    if(!(swapchain->surface_usage & VK_IMAGE_USAGE_STORAGE_BIT)){
+        TRACE("using intermediate blit images\n");
+        /* create intermediate blit images */
+        for(i = 0; i < swapchain->n_images; ++i){
+            struct fs_hack_image *hack = &swapchain->fs_hack_images[i];
+
+            imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
+            imageInfo.imageType = VK_IMAGE_TYPE_2D;
+            imageInfo.extent.width = swapchain->real_extent.width;
+            imageInfo.extent.height = swapchain->real_extent.height;
+            imageInfo.extent.depth = 1;
+            imageInfo.mipLevels = 1;
+            imageInfo.arrayLayers = 1;
+            imageInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
+            imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
+            imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+            imageInfo.usage = VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
+            imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
+            imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
+            res = device->funcs.p_vkCreateImage(device->device, &imageInfo, NULL, &hack->blit_image);
+            if(res != VK_SUCCESS){
+                ERR("vkCreateImage failed: %d\n", res);
+                goto fail;
+            }
+
+            device->funcs.p_vkGetImageMemoryRequirements(device->device, hack->blit_image, &blitMemReq);
+
+            offs = blitMemTotal % blitMemReq.alignment;
+            if(offs)
+                blitMemTotal += blitMemReq.alignment - offs;
+
+            blitMemTotal += blitMemReq.size;
+        }
+
+        /* allocate backing memory */
+        device->phys_dev->instance->funcs.p_vkGetPhysicalDeviceMemoryProperties(device->phys_dev->phys_dev, &memProperties);
+
+        for(i = 0; i < memProperties.memoryTypeCount; i++){
+            if((memProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) == VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT){
+                if(blitMemReq.memoryTypeBits & (1 << i)){
+                    blit_memory_type = i;
+                    break;
+                }
+            }
+        }
+
+        if(blit_memory_type == -1){
+            ERR("unable to find suitable memory type\n");
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto fail;
+        }
+
+        allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
+        allocInfo.allocationSize = blitMemTotal;
+        allocInfo.memoryTypeIndex = blit_memory_type;
+
+        res = device->funcs.p_vkAllocateMemory(device->device, &allocInfo, NULL, &swapchain->blit_image_memory);
+        if(res != VK_SUCCESS){
+            ERR("vkAllocateMemory: %d\n", res);
+            goto fail;
+        }
+
+        /* bind backing memory and create imageviews */
+        blitMemTotal = 0;
+        for(i = 0; i < swapchain->n_images; ++i){
+            struct fs_hack_image *hack = &swapchain->fs_hack_images[i];
+
+            device->funcs.p_vkGetImageMemoryRequirements(device->device, hack->blit_image, &blitMemReq);
+
+            offs = blitMemTotal % blitMemReq.alignment;
+            if(offs)
+                blitMemTotal += blitMemReq.alignment - offs;
+
+            res = device->funcs.p_vkBindImageMemory(device->device, hack->blit_image, swapchain->blit_image_memory, blitMemTotal);
+            if(res != VK_SUCCESS){
+                ERR("vkBindImageMemory: %d\n", res);
+                goto fail;
+            }
+
+            blitMemTotal += blitMemReq.size;
+        }
+    }else
+        TRACE("blitting directly to swapchain images\n");
+
+    /* create imageviews */
+    for(i = 0; i < swapchain->n_images; ++i){
+        struct fs_hack_image *hack = &swapchain->fs_hack_images[i];
+
+        viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
+        viewInfo.image = hack->blit_image ? hack->blit_image : hack->swapchain_image;
+        viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
+        viewInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
+        viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        viewInfo.subresourceRange.baseMipLevel = 0;
+        viewInfo.subresourceRange.levelCount = 1;
+        viewInfo.subresourceRange.baseArrayLayer = 0;
+        viewInfo.subresourceRange.layerCount = 1;
+
+        res = device->funcs.p_vkCreateImageView(device->device, &viewInfo, NULL, &hack->blit_view);
+        if(res != VK_SUCCESS){
+            ERR("vkCreateImageView(blit): %d\n", res);
+            goto fail;
+        }
+
+        res = create_descriptor_set(device, swapchain, hack);
+        if(res != VK_SUCCESS)
+            goto fail;
+    }
+
+    return VK_SUCCESS;
+
+fail:
+    for(i = 0; i < swapchain->n_images; ++i){
+        struct fs_hack_image *hack = &swapchain->fs_hack_images[i];
+
+        device->funcs.p_vkDestroyImageView(device->device, hack->blit_view, NULL);
+        hack->blit_view = VK_NULL_HANDLE;
+
+        device->funcs.p_vkDestroyImage(device->device, hack->blit_image, NULL);
+        hack->blit_image = VK_NULL_HANDLE;
+    }
+
+    device->funcs.p_vkDestroyShaderModule(device->device, shaderModule, NULL);
+
+    device->funcs.p_vkDestroyPipeline(device->device, swapchain->pipeline, NULL);
+    swapchain->pipeline = VK_NULL_HANDLE;
+
+    device->funcs.p_vkDestroyPipelineLayout(device->device, swapchain->pipeline_layout, NULL);
+    swapchain->pipeline_layout = VK_NULL_HANDLE;
+
+    device->funcs.p_vkDestroyDescriptorSetLayout(device->device, swapchain->descriptor_set_layout, NULL);
+    swapchain->descriptor_set_layout = VK_NULL_HANDLE;
+
+    device->funcs.p_vkDestroyDescriptorPool(device->device, swapchain->descriptor_pool, NULL);
+    swapchain->descriptor_pool = VK_NULL_HANDLE;
+
+    device->funcs.p_vkFreeMemory(device->device, swapchain->blit_image_memory, NULL);
+    swapchain->blit_image_memory = VK_NULL_HANDLE;
+
+    device->funcs.p_vkDestroySampler(device->device, swapchain->sampler, NULL);
+    swapchain->sampler = VK_NULL_HANDLE;
+
+    return res;
+}
+
+static void destroy_fs_hack_image(VkDevice device, struct VkSwapchainKHR_T *swapchain, struct fs_hack_image *hack)
+{
+    device->funcs.p_vkDestroyImageView(device->device, hack->user_view, NULL);
+    device->funcs.p_vkDestroyImageView(device->device, hack->blit_view, NULL);
+    device->funcs.p_vkDestroyImage(device->device, hack->user_image, NULL);
+    device->funcs.p_vkDestroyImage(device->device, hack->blit_image, NULL);
+    if(hack->cmd)
+        device->funcs.p_vkFreeCommandBuffers(device->device,
+                swapchain->cmd_pools[hack->cmd_queue_idx],
+                    1, &hack->cmd);
+    device->funcs.p_vkDestroySemaphore(device->device, hack->blit_finished, NULL);
+}
+
+#if defined(USE_STRUCT_CONVERSION)
+static VkResult init_fs_hack_images(VkDevice device, struct VkSwapchainKHR_T *swapchain, VkSwapchainCreateInfoKHR_host *createinfo)
+#else
+static VkResult init_fs_hack_images(VkDevice device, struct VkSwapchainKHR_T *swapchain, VkSwapchainCreateInfoKHR *createinfo)
+#endif
+{
+    VkResult res;
+    VkImage *real_images = NULL;
+    VkDeviceSize userMemTotal = 0, offs;
+    VkImageCreateInfo imageInfo = {0};
+    VkSemaphoreCreateInfo semaphoreInfo = {0};
+#if defined(USE_STRUCT_CONVERSION)
+    VkMemoryRequirements_host userMemReq;
+    VkMemoryAllocateInfo_host allocInfo = {0};
+    VkPhysicalDeviceMemoryProperties_host memProperties;
+    VkImageViewCreateInfo_host viewInfo = {0};
+#else
+    VkMemoryRequirements userMemReq;
+    VkMemoryAllocateInfo allocInfo = {0};
+    VkPhysicalDeviceMemoryProperties memProperties;
+    VkImageViewCreateInfo viewInfo = {0};
+#endif
+    uint32_t count, i = 0, user_memory_type = -1;
+
+    res = device->funcs.p_vkGetSwapchainImagesKHR(device->device, swapchain->swapchain, &count, NULL);
+    if(res != VK_SUCCESS)
+    {
+        WARN("vkGetSwapchainImagesKHR failed, res=%d\n", res);
+        return res;
+    }
+
+    real_images = malloc(count * sizeof(VkImage));
+    swapchain->cmd_pools = calloc(device->queue_count, sizeof(VkCommandPool));
+    swapchain->fs_hack_images = calloc(count, sizeof(struct fs_hack_image));
+    if(!real_images || !swapchain->cmd_pools || !swapchain->fs_hack_images)
+        goto fail;
+
+    res = device->funcs.p_vkGetSwapchainImagesKHR(device->device, swapchain->swapchain, &count, real_images);
+    if(res != VK_SUCCESS)
+    {
+        WARN("vkGetSwapchainImagesKHR failed, res=%d\n", res);
+        goto fail;
+    }
+
+    /* create user images */
+    for(i = 0; i < count; ++i){
+        struct fs_hack_image *hack = &swapchain->fs_hack_images[i];
+
+        hack->swapchain_image = real_images[i];
+
+        semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+        res = device->funcs.p_vkCreateSemaphore(device->device, &semaphoreInfo, NULL, &hack->blit_finished);
+        if(res != VK_SUCCESS)
+        {
+            WARN("vkCreateSemaphore failed, res=%d\n", res);
+            goto fail;
+        }
+
+        imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
+        imageInfo.imageType = VK_IMAGE_TYPE_2D;
+        imageInfo.extent.width = swapchain->user_extent.width;
+        imageInfo.extent.height = swapchain->user_extent.height;
+        imageInfo.extent.depth = 1;
+        imageInfo.mipLevels = 1;
+        imageInfo.arrayLayers = createinfo->imageArrayLayers;
+        imageInfo.format = createinfo->imageFormat;
+        imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
+        imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+        imageInfo.usage = createinfo->imageUsage | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
+        imageInfo.sharingMode = createinfo->imageSharingMode;
+        imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
+        imageInfo.queueFamilyIndexCount = createinfo->queueFamilyIndexCount;
+        imageInfo.pQueueFamilyIndices = createinfo->pQueueFamilyIndices;
+        res = device->funcs.p_vkCreateImage(device->device, &imageInfo, NULL, &hack->user_image);
+        if(res != VK_SUCCESS){
+            ERR("vkCreateImage failed: %d\n", res);
+            goto fail;
+        }
+
+        device->funcs.p_vkGetImageMemoryRequirements(device->device, hack->user_image, &userMemReq);
+
+        offs = userMemTotal % userMemReq.alignment;
+        if(offs)
+            userMemTotal += userMemReq.alignment - offs;
+
+        userMemTotal += userMemReq.size;
+
+        swapchain->n_images++;
+    }
+
+    /* allocate backing memory */
+    device->phys_dev->instance->funcs.p_vkGetPhysicalDeviceMemoryProperties(device->phys_dev->phys_dev, &memProperties);
+
+    for (i = 0; i < memProperties.memoryTypeCount; i++){
+        if((memProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) == VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT){
+            if(userMemReq.memoryTypeBits & (1 << i)){
+                user_memory_type = i;
+                break;
+            }
+        }
+    }
+
+    if(user_memory_type == -1){
+        ERR("unable to find suitable memory type\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto fail;
+    }
+
+    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
+    allocInfo.allocationSize = userMemTotal;
+    allocInfo.memoryTypeIndex = user_memory_type;
+
+    res = device->funcs.p_vkAllocateMemory(device->device, &allocInfo, NULL, &swapchain->user_image_memory);
+    if(res != VK_SUCCESS){
+        ERR("vkAllocateMemory: %d\n", res);
+        goto fail;
+    }
+
+    /* bind backing memory and create imageviews */
+    userMemTotal = 0;
+    for(i = 0; i < count; ++i){
+        device->funcs.p_vkGetImageMemoryRequirements(device->device, swapchain->fs_hack_images[i].user_image, &userMemReq);
+
+        offs = userMemTotal % userMemReq.alignment;
+        if(offs)
+            userMemTotal += userMemReq.alignment - offs;
+
+        res = device->funcs.p_vkBindImageMemory(device->device, swapchain->fs_hack_images[i].user_image, swapchain->user_image_memory, userMemTotal);
+        if(res != VK_SUCCESS){
+            ERR("vkBindImageMemory: %d\n", res);
+            goto fail;
+        }
+
+        userMemTotal += userMemReq.size;
+
+        viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
+        viewInfo.image = swapchain->fs_hack_images[i].user_image;
+        viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
+        viewInfo.format = createinfo->imageFormat;
+        viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        viewInfo.subresourceRange.baseMipLevel = 0;
+        viewInfo.subresourceRange.levelCount = 1;
+        viewInfo.subresourceRange.baseArrayLayer = 0;
+        viewInfo.subresourceRange.layerCount = 1;
+
+        res = device->funcs.p_vkCreateImageView(device->device, &viewInfo, NULL, &swapchain->fs_hack_images[i].user_view);
+        if(res != VK_SUCCESS){
+            ERR("vkCreateImageView(user): %d\n", res);
+            goto fail;
+        }
+    }
+
+    free(real_images);
+
+    return VK_SUCCESS;
+
+fail:
+    for(i = 0; i < swapchain->n_images; ++i)
+        destroy_fs_hack_image(device, swapchain, &swapchain->fs_hack_images[i]);
+    free(real_images);
+    free(swapchain->cmd_pools);
+    free(swapchain->fs_hack_images);
+    return res;
+}
+
+#if defined(USE_STRUCT_CONVERSION)
+static inline void convert_VkSwapchainCreateInfoKHR_win_to_host(const VkSwapchainCreateInfoKHR *in, VkSwapchainCreateInfoKHR_host *out)
+#else
+static inline void convert_VkSwapchainCreateInfoKHR_win_to_host(const VkSwapchainCreateInfoKHR *in, VkSwapchainCreateInfoKHR *out)
+#endif
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->flags = in->flags;
+    out->surface = wine_surface_from_handle(in->surface)->driver_surface;
+    out->minImageCount = in->minImageCount;
+    out->imageFormat = in->imageFormat;
+    out->imageColorSpace = in->imageColorSpace;
+    out->imageExtent = in->imageExtent;
+    out->imageArrayLayers = in->imageArrayLayers;
+    out->imageUsage = in->imageUsage;
+    out->imageSharingMode = in->imageSharingMode;
+    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
+    out->pQueueFamilyIndices = in->pQueueFamilyIndices;
+    out->preTransform = in->preTransform;
+    out->compositeAlpha = in->compositeAlpha;
+    out->presentMode = in->presentMode;
+    out->clipped = in->clipped;
+    out->oldSwapchain = in->oldSwapchain;
+}
+
+NTSTATUS wine_vkCreateSwapchainKHR(void *args)
+{
+    struct vkCreateSwapchainKHR_params *params = args;
+    VkDevice device = params->device;
+    const VkSwapchainCreateInfoKHR *create_info = params->pCreateInfo;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+    VkSwapchainKHR *swapchain = params->pSwapchain;
+#if defined(USE_STRUCT_CONVERSION)
+    VkSwapchainCreateInfoKHR_host native_info;
+#else
+    VkSwapchainCreateInfoKHR native_info;
+#endif
+    VkResult result;
+    VkExtent2D user_sz;
+    struct VkSwapchainKHR_T *object;
+
+    TRACE("%p, %p, %p, %p\n", device, create_info, allocator, swapchain);
+
+    if (!(object = calloc(1, sizeof(*object))))
+    {
+        ERR("Failed to allocate memory for swapchain\n");
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+
+    convert_VkSwapchainCreateInfoKHR_win_to_host(create_info, &native_info);
+
+    if(native_info.oldSwapchain)
+        native_info.oldSwapchain = ((struct VkSwapchainKHR_T *)(UINT_PTR)native_info.oldSwapchain)->swapchain;
+
+    if(vk_funcs->query_fs_hack &&
+            vk_funcs->query_fs_hack(native_info.surface, &object->real_extent, &user_sz, &object->blit_dst, &object->fs_hack_filter) &&
+            native_info.imageExtent.width == user_sz.width &&
+            native_info.imageExtent.height == user_sz.height)
+    {
+        uint32_t count;
+        VkSurfaceCapabilitiesKHR caps = {0};
+
+        device->phys_dev->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyProperties(device->phys_dev->phys_dev, &count, NULL);
+
+        device->queue_props = malloc(sizeof(VkQueueFamilyProperties) * count);
+
+        device->phys_dev->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyProperties(device->phys_dev->phys_dev, &count, device->queue_props);
+
+        result = device->phys_dev->instance->funcs.p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device->phys_dev->phys_dev, native_info.surface, &caps);
+        if(result != VK_SUCCESS)
+        {
+            TRACE("vkGetPhysicalDeviceSurfaceCapabilities failed, res=%d\n", result);
+            free(object);
+            return result;
+        }
+
+        object->surface_usage = caps.supportedUsageFlags;
+        TRACE("surface usage flags: 0x%x\n", object->surface_usage);
+
+        native_info.imageExtent = object->real_extent;
+        native_info.imageUsage |= VK_IMAGE_USAGE_TRANSFER_DST_BIT; /* XXX: check if supported by surface */
+
+        if(native_info.imageFormat != VK_FORMAT_B8G8R8A8_UNORM &&
+                native_info.imageFormat != VK_FORMAT_B8G8R8A8_SRGB){
+            FIXME("swapchain image format is not BGRA8 UNORM/SRGB. Things may go badly. %d\n", native_info.imageFormat);
+        }
+
+        object->fs_hack_enabled = TRUE;
+    }
+
+    result = device->funcs.p_vkCreateSwapchainKHR(device->device, &native_info, NULL, &object->swapchain);
+    if(result != VK_SUCCESS)
+    {
+        TRACE("vkCreateSwapchainKHR failed, res=%d\n", result);
+        free(object);
+        return result;
+    }
+
+    WINE_VK_ADD_NON_DISPATCHABLE_MAPPING(device->phys_dev->instance, object, object->swapchain);
+
+    if(object->fs_hack_enabled){
+        object->user_extent = create_info->imageExtent;
+
+        result = init_fs_hack_images(device, object, &native_info);
+        if(result != VK_SUCCESS){
+            ERR("creating fs hack images failed: %d\n", result);
+            device->funcs.p_vkDestroySwapchainKHR(device->device, object->swapchain, NULL);
+            WINE_VK_REMOVE_HANDLE_MAPPING(device->phys_dev->instance, object);
+            free(object);
+            return result;
+        }
+
+        /* FIXME: would be nice to do this on-demand, but games can use up all
+         * memory so we fail to allocate later */
+        result = init_blit_images(device, object);
+        if(result != VK_SUCCESS){
+            ERR("creating blit images failed: %d\n", result);
+            device->funcs.p_vkDestroySwapchainKHR(device->device, object->swapchain, NULL);
+            WINE_VK_REMOVE_HANDLE_MAPPING(device->phys_dev->instance, object);
+            free(object);
+            return result;
+        }
+    }
+
+    *swapchain = (uint64_t)(UINT_PTR)object;
+
+    return result;
+}
+
 NTSTATUS wine_vkCreateWin32SurfaceKHR(void *args)
 {
     struct vkCreateWin32SurfaceKHR_params *params = args;
@@ -1736,6 +2482,7 @@ NTSTATUS wine_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(void *args)
     VkSurfaceKHR surface = params->surface;
     VkSurfaceCapabilitiesKHR *capabilities = params->pSurfaceCapabilities;
     VkResult res;
+    VkExtent2D user_res;
 
     TRACE("%p, 0x%s, %p\n", phys_dev, wine_dbgstr_longlong(surface), capabilities);
 
@@ -1744,6 +2491,13 @@ NTSTATUS wine_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(void *args)
     if (res == VK_SUCCESS)
         adjust_max_image_count(phys_dev, capabilities);
 
+    if (res == VK_SUCCESS && vk_funcs->query_fs_hack &&
+            vk_funcs->query_fs_hack(wine_surface_from_handle(surface)->driver_surface, NULL, &user_res, NULL, NULL)){
+        capabilities->currentExtent = user_res;
+        capabilities->minImageExtent = user_res;
+        capabilities->maxImageExtent = user_res;
+    }
+
     return res;
 }
 
@@ -1754,6 +2508,7 @@ NTSTATUS wine_vkGetPhysicalDeviceSurfaceCapabilities2KHR(void *args)
     const VkPhysicalDeviceSurfaceInfo2KHR *surface_info = params->pSurfaceInfo;
     VkSurfaceCapabilities2KHR *capabilities = params->pSurfaceCapabilities;
     VkResult res;
+    VkExtent2D user_res;
 
     TRACE("%p, %p, %p\n", phys_dev, surface_info, capabilities);
 
@@ -1762,6 +2517,13 @@ NTSTATUS wine_vkGetPhysicalDeviceSurfaceCapabilities2KHR(void *args)
     if (res == VK_SUCCESS)
         adjust_max_image_count(phys_dev, &capabilities->surfaceCapabilities);
 
+    if (res == VK_SUCCESS && vk_funcs->query_fs_hack &&
+            vk_funcs->query_fs_hack(wine_surface_from_handle(surface_info->surface)->driver_surface, NULL, &user_res, NULL, NULL)){
+        capabilities->surfaceCapabilities.currentExtent = user_res;
+        capabilities->surfaceCapabilities.minImageExtent = user_res;
+        capabilities->surfaceCapabilities.maxImageExtent = user_res;
+    }
+
     return res;
 }
 
@@ -1894,6 +2656,641 @@ NTSTATUS wine_vkDestroyDebugReportCallbackEXT(void *args)
     return STATUS_SUCCESS;
 }
 
+NTSTATUS wine_vkAcquireNextImage2KHR(void *args)
+{
+    struct vkAcquireNextImage2KHR_params *params = args;
+    VkDevice device = params->device;
+    const VkAcquireNextImageInfoKHR *pAcquireInfo = params->pAcquireInfo;
+    uint32_t *pImageIndex = params->pImageIndex;
+#if defined(USE_STRUCT_CONVERSION)
+    VkAcquireNextImageInfoKHR_host image_info_host = {0};
+#else
+    VkAcquireNextImageInfoKHR image_info_host = {0};
+#endif
+    struct VkSwapchainKHR_T *object = (struct VkSwapchainKHR_T *)(UINT_PTR)pAcquireInfo->swapchain;
+    TRACE("%p, %p, %p\n", device, pAcquireInfo, pImageIndex);
+
+    image_info_host.sType = pAcquireInfo->sType;
+    image_info_host.pNext = pAcquireInfo->pNext;
+    image_info_host.swapchain = object->swapchain;
+    image_info_host.timeout = pAcquireInfo->timeout;
+    image_info_host.semaphore = pAcquireInfo->semaphore;
+    image_info_host.fence = pAcquireInfo->fence;
+    image_info_host.deviceMask = pAcquireInfo->deviceMask;
+
+    return device->funcs.p_vkAcquireNextImage2KHR(device->device, &image_info_host, pImageIndex);
+}
+
+NTSTATUS wine_vkDestroySwapchainKHR(void *args)
+{
+    struct vkDestroySwapchainKHR_params *params = args;
+    VkDevice device = params->device;
+    VkSwapchainKHR swapchain = params->swapchain;
+    const VkAllocationCallbacks *pAllocator = params->pAllocator;
+    struct VkSwapchainKHR_T *object = (struct VkSwapchainKHR_T *)(UINT_PTR)swapchain;
+    uint32_t i;
+
+    TRACE("%p, 0x%s, %p\n", device, wine_dbgstr_longlong(swapchain), pAllocator);
+
+    if(!object)
+        return STATUS_SUCCESS;
+
+    if(object->fs_hack_enabled){
+        for(i = 0; i < object->n_images; ++i)
+            destroy_fs_hack_image(device, object, &object->fs_hack_images[i]);
+
+        for(i = 0; i < device->queue_count; ++i)
+            if(object->cmd_pools[i])
+                device->funcs.p_vkDestroyCommandPool(device->device, object->cmd_pools[i], NULL);
+
+        device->funcs.p_vkDestroyPipeline(device->device, object->pipeline, NULL);
+        device->funcs.p_vkDestroyPipelineLayout(device->device, object->pipeline_layout, NULL);
+        device->funcs.p_vkDestroyDescriptorSetLayout(device->device, object->descriptor_set_layout, NULL);
+        device->funcs.p_vkDestroyDescriptorPool(device->device, object->descriptor_pool, NULL);
+        device->funcs.p_vkDestroySampler(device->device, object->sampler, NULL);
+        device->funcs.p_vkFreeMemory(device->device, object->user_image_memory, NULL);
+        device->funcs.p_vkFreeMemory(device->device, object->blit_image_memory, NULL);
+        free(object->cmd_pools);
+        free(object->fs_hack_images);
+    }
+
+    device->funcs.p_vkDestroySwapchainKHR(device->device, object->swapchain, NULL);
+
+    WINE_VK_REMOVE_HANDLE_MAPPING(device->phys_dev->instance, object);
+    free(object);
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS wine_vkGetSwapchainImagesKHR(void *args)
+{
+    struct vkGetSwapchainImagesKHR_params *params = args;
+    VkDevice device = params->device;
+    VkSwapchainKHR swapchain = params->swapchain;
+    uint32_t *pSwapchainImageCount = params->pSwapchainImageCount;
+    VkImage *pSwapchainImages = params->pSwapchainImages;
+    struct VkSwapchainKHR_T *object = (struct VkSwapchainKHR_T *)(UINT_PTR)swapchain;
+    uint32_t i;
+
+    TRACE("%p, 0x%s, %p, %p\n", device, wine_dbgstr_longlong(swapchain), pSwapchainImageCount, pSwapchainImages);
+
+    if(pSwapchainImages && object->fs_hack_enabled){
+        if(*pSwapchainImageCount > object->n_images)
+            *pSwapchainImageCount = object->n_images;
+        for(i = 0; i < *pSwapchainImageCount ; ++i)
+            pSwapchainImages[i] = object->fs_hack_images[i].user_image;
+        return *pSwapchainImageCount == object->n_images ? VK_SUCCESS : VK_INCOMPLETE;
+    }
+
+    return device->funcs.p_vkGetSwapchainImagesKHR(device->device, object->swapchain, pSwapchainImageCount, pSwapchainImages);
+}
+
+static VkCommandBuffer create_hack_cmd(VkQueue queue, struct VkSwapchainKHR_T *swapchain, uint32_t queue_idx)
+{
+#if defined(USE_STRUCT_CONVERSION)
+    VkCommandBufferAllocateInfo_host allocInfo = {0};
+#else
+    VkCommandBufferAllocateInfo allocInfo = {0};
+#endif
+    VkCommandBuffer cmd;
+    VkResult result;
+
+    if(!swapchain->cmd_pools[queue_idx]){
+        VkCommandPoolCreateInfo poolInfo = {0};
+
+        poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
+        poolInfo.queueFamilyIndex = queue_idx;
+
+        result = queue->device->funcs.p_vkCreateCommandPool(queue->device->device, &poolInfo, NULL, &swapchain->cmd_pools[queue_idx]);
+        if(result != VK_SUCCESS){
+            ERR("vkCreateCommandPool failed, res=%d\n", result);
+            return NULL;
+        }
+    }
+
+    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
+    allocInfo.commandPool = swapchain->cmd_pools[queue_idx];
+    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
+    allocInfo.commandBufferCount = 1;
+
+    result = queue->device->funcs.p_vkAllocateCommandBuffers(queue->device->device, &allocInfo, &cmd);
+    if(result != VK_SUCCESS){
+        ERR("vkAllocateCommandBuffers failed, res=%d\n", result);
+        return NULL;
+    }
+
+    return cmd;
+}
+
+static VkResult record_compute_cmd(VkDevice device, struct VkSwapchainKHR_T *swapchain, struct fs_hack_image *hack)
+{
+    VkResult result;
+    VkImageCopy region = {0};
+#if defined(USE_STRUCT_CONVERSION)
+    VkImageMemoryBarrier_host barriers[3] = {{0}};
+    VkCommandBufferBeginInfo_host beginInfo = {0};
+#else
+    VkImageMemoryBarrier barriers[3] = {{0}};
+    VkCommandBufferBeginInfo beginInfo = {0};
+#endif
+    float constants[4];
+
+    TRACE("recording compute command\n");
+
+#if 0
+    /* DOOM runs out of memory when allocating blit images after loading. */
+    if(!swapchain->blit_image_memory){
+        result = init_blit_images(device, swapchain);
+        if(result != VK_SUCCESS)
+            return result;
+    }
+#endif
+
+    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
+    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
+
+    device->funcs.p_vkBeginCommandBuffer(hack->cmd, &beginInfo);
+
+    /* for the cs we run... */
+    /* transition user image from PRESENT_SRC to SHADER_READ */
+    barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[0].oldLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    barriers[0].newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+    barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].image = hack->user_image;
+    barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[0].subresourceRange.baseMipLevel = 0;
+    barriers[0].subresourceRange.levelCount = 1;
+    barriers[0].subresourceRange.baseArrayLayer = 0;
+    barriers[0].subresourceRange.layerCount = 1;
+    barriers[0].srcAccessMask = 0;
+    barriers[0].dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
+
+    /* storage image... */
+    /* transition blit image from whatever to GENERAL */
+    barriers[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[1].oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+    barriers[1].newLayout = VK_IMAGE_LAYOUT_GENERAL;
+    barriers[1].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].image = hack->blit_image ? hack->blit_image : hack->swapchain_image;
+    barriers[1].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[1].subresourceRange.baseMipLevel = 0;
+    barriers[1].subresourceRange.levelCount = 1;
+    barriers[1].subresourceRange.baseArrayLayer = 0;
+    barriers[1].subresourceRange.layerCount = 1;
+    barriers[1].srcAccessMask = 0;
+    barriers[1].dstAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+
+    device->funcs.p_vkCmdPipelineBarrier(
+            hack->cmd,
+            VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+            0,
+            0, NULL,
+            0, NULL,
+            2, barriers
+    );
+
+    /* perform blit shader */
+    device->funcs.p_vkCmdBindPipeline(hack->cmd,
+            VK_PIPELINE_BIND_POINT_COMPUTE, swapchain->pipeline);
+
+    device->funcs.p_vkCmdBindDescriptorSets(hack->cmd,
+            VK_PIPELINE_BIND_POINT_COMPUTE, swapchain->pipeline_layout,
+            0, 1, &hack->descriptor_set, 0, NULL);
+
+    /* vec2: blit dst offset in real coords */
+    constants[0] = swapchain->blit_dst.offset.x;
+    constants[1] = swapchain->blit_dst.offset.y;
+    /* vec2: blit dst extents in real coords */
+    constants[2] = swapchain->blit_dst.extent.width;
+    constants[3] = swapchain->blit_dst.extent.height;
+    device->funcs.p_vkCmdPushConstants(hack->cmd,
+            swapchain->pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT,
+            0, sizeof(constants), constants);
+
+    /* local sizes in shader are 8 */
+    device->funcs.p_vkCmdDispatch(hack->cmd, ceil(swapchain->real_extent.width / 8.),
+            ceil(swapchain->real_extent.height / 8.), 1);
+
+    /* transition user image from SHADER_READ back to PRESENT_SRC */
+    barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[0].oldLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+    barriers[0].newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].image = hack->user_image;
+    barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[0].subresourceRange.baseMipLevel = 0;
+    barriers[0].subresourceRange.levelCount = 1;
+    barriers[0].subresourceRange.baseArrayLayer = 0;
+    barriers[0].subresourceRange.layerCount = 1;
+    barriers[0].srcAccessMask = VK_ACCESS_SHADER_READ_BIT;
+    barriers[0].dstAccessMask = 0;
+
+    device->funcs.p_vkCmdPipelineBarrier(
+            hack->cmd,
+            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+            VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
+            0,
+            0, NULL,
+            0, NULL,
+            1, barriers
+    );
+
+    if(hack->blit_image){
+        /* for the copy... */
+        /* no transition, just a barrier for our access masks (w -> r) */
+        barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+        barriers[0].oldLayout = VK_IMAGE_LAYOUT_GENERAL;
+        barriers[0].newLayout = VK_IMAGE_LAYOUT_GENERAL;
+        barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].image = hack->blit_image;
+        barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        barriers[0].subresourceRange.baseMipLevel = 0;
+        barriers[0].subresourceRange.levelCount = 1;
+        barriers[0].subresourceRange.baseArrayLayer = 0;
+        barriers[0].subresourceRange.layerCount = 1;
+        barriers[0].srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+        barriers[0].dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
+
+        /* for the copy... */
+        /* transition swapchain image from whatever to TRANSFER_DST
+         * we don't care about the contents... */
+        barriers[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+        barriers[1].oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+        barriers[1].newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
+        barriers[1].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[1].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[1].image = hack->swapchain_image;
+        barriers[1].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        barriers[1].subresourceRange.baseMipLevel = 0;
+        barriers[1].subresourceRange.levelCount = 1;
+        barriers[1].subresourceRange.baseArrayLayer = 0;
+        barriers[1].subresourceRange.layerCount = 1;
+        barriers[1].srcAccessMask = 0;
+        barriers[1].dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
+
+        device->funcs.p_vkCmdPipelineBarrier(
+                hack->cmd,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                VK_PIPELINE_STAGE_TRANSFER_BIT,
+                0,
+                0, NULL,
+                0, NULL,
+                2, barriers
+        );
+
+        /* copy from blit image to swapchain image */
+        region.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        region.srcSubresource.layerCount = 1;
+        region.srcOffset.x = 0;
+        region.srcOffset.y = 0;
+        region.srcOffset.z = 0;
+        region.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        region.dstSubresource.layerCount = 1;
+        region.dstOffset.x = 0;
+        region.dstOffset.y = 0;
+        region.dstOffset.z = 0;
+        region.extent.width = swapchain->real_extent.width;
+        region.extent.height = swapchain->real_extent.height;
+        region.extent.depth = 1;
+
+        device->funcs.p_vkCmdCopyImage(hack->cmd,
+                hack->blit_image, VK_IMAGE_LAYOUT_GENERAL,
+                hack->swapchain_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
+                1, &region);
+
+        /* transition swapchain image from TRANSFER_DST_OPTIMAL to PRESENT_SRC */
+        barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+        barriers[0].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
+        barriers[0].newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+        barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].image = hack->swapchain_image;
+        barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        barriers[0].subresourceRange.baseMipLevel = 0;
+        barriers[0].subresourceRange.levelCount = 1;
+        barriers[0].subresourceRange.baseArrayLayer = 0;
+        barriers[0].subresourceRange.layerCount = 1;
+        barriers[0].srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
+        barriers[0].dstAccessMask = 0;
+
+        device->funcs.p_vkCmdPipelineBarrier(
+                hack->cmd,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                VK_PIPELINE_STAGE_TRANSFER_BIT,
+                0,
+                0, NULL,
+                0, NULL,
+                1, barriers
+        );
+    }else{
+        /* transition swapchain image from GENERAL to PRESENT_SRC */
+        barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+        barriers[0].oldLayout = VK_IMAGE_LAYOUT_GENERAL;
+        barriers[0].newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+        barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].image = hack->swapchain_image;
+        barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        barriers[0].subresourceRange.baseMipLevel = 0;
+        barriers[0].subresourceRange.levelCount = 1;
+        barriers[0].subresourceRange.baseArrayLayer = 0;
+        barriers[0].subresourceRange.layerCount = 1;
+        barriers[0].srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+        barriers[0].dstAccessMask = 0;
+
+        device->funcs.p_vkCmdPipelineBarrier(
+                hack->cmd,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
+                0,
+                0, NULL,
+                0, NULL,
+                1, barriers
+        );
+    }
+
+    result = device->funcs.p_vkEndCommandBuffer(hack->cmd);
+    if(result != VK_SUCCESS){
+        ERR("vkEndCommandBuffer: %d\n", result);
+        return result;
+    }
+
+    return VK_SUCCESS;
+}
+
+static VkResult record_graphics_cmd(VkDevice device, struct VkSwapchainKHR_T *swapchain, struct fs_hack_image *hack)
+{
+    VkResult result;
+    VkImageBlit blitregion = {0};
+    VkImageSubresourceRange range = {0};
+    VkClearColorValue black = {{0.f, 0.f, 0.f}};
+#if defined(USE_STRUCT_CONVERSION)
+    VkImageMemoryBarrier_host barriers[2] = {{0}};
+    VkCommandBufferBeginInfo_host beginInfo = {0};
+#else
+    VkImageMemoryBarrier barriers[2] = {{0}};
+    VkCommandBufferBeginInfo beginInfo = {0};
+#endif
+
+    TRACE("recording graphics command\n");
+
+    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
+    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
+
+    device->funcs.p_vkBeginCommandBuffer(hack->cmd, &beginInfo);
+
+    /* transition real image from whatever to TRANSFER_DST_OPTIMAL */
+    barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[0].oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+    barriers[0].newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
+    barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].image = hack->swapchain_image;
+    barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[0].subresourceRange.baseMipLevel = 0;
+    barriers[0].subresourceRange.levelCount = 1;
+    barriers[0].subresourceRange.baseArrayLayer = 0;
+    barriers[0].subresourceRange.layerCount = 1;
+    barriers[0].srcAccessMask = 0;
+    barriers[0].dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
+
+    /* transition user image from PRESENT_SRC to TRANSFER_SRC_OPTIMAL */
+    barriers[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[1].oldLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    barriers[1].newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
+    barriers[1].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].image = hack->user_image;
+    barriers[1].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[1].subresourceRange.baseMipLevel = 0;
+    barriers[1].subresourceRange.levelCount = 1;
+    barriers[1].subresourceRange.baseArrayLayer = 0;
+    barriers[1].subresourceRange.layerCount = 1;
+    barriers[1].srcAccessMask = 0;
+    barriers[1].dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
+
+    device->funcs.p_vkCmdPipelineBarrier(
+            hack->cmd,
+            VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+            VK_PIPELINE_STAGE_TRANSFER_BIT,
+            0,
+            0, NULL,
+            0, NULL,
+            2, barriers
+    );
+
+    /* clear the image */
+    range.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    range.baseMipLevel = 0;
+    range.levelCount = 1;
+    range.baseArrayLayer = 0;
+    range.layerCount = 1;
+
+    device->funcs.p_vkCmdClearColorImage(
+            hack->cmd, hack->swapchain_image,
+            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
+            &black, 1, &range);
+
+    /* perform blit */
+    blitregion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    blitregion.srcSubresource.layerCount = 1;
+    blitregion.srcOffsets[0].x = 0;
+    blitregion.srcOffsets[0].y = 0;
+    blitregion.srcOffsets[0].z = 0;
+    blitregion.srcOffsets[1].x = swapchain->user_extent.width;
+    blitregion.srcOffsets[1].y = swapchain->user_extent.height;
+    blitregion.srcOffsets[1].z = 1;
+    blitregion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    blitregion.dstSubresource.layerCount = 1;
+    blitregion.dstOffsets[0].x = swapchain->blit_dst.offset.x;
+    blitregion.dstOffsets[0].y = swapchain->blit_dst.offset.y;
+    blitregion.dstOffsets[0].z = 0;
+    blitregion.dstOffsets[1].x = swapchain->blit_dst.offset.x + swapchain->blit_dst.extent.width;
+    blitregion.dstOffsets[1].y = swapchain->blit_dst.offset.y + swapchain->blit_dst.extent.height;
+    blitregion.dstOffsets[1].z = 1;
+
+    device->funcs.p_vkCmdBlitImage(hack->cmd,
+            hack->user_image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
+            hack->swapchain_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
+            1, &blitregion, swapchain->fs_hack_filter);
+
+    /* transition real image from TRANSFER_DST to PRESENT_SRC */
+    barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[0].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
+    barriers[0].newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].image = hack->swapchain_image;
+    barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[0].subresourceRange.baseMipLevel = 0;
+    barriers[0].subresourceRange.levelCount = 1;
+    barriers[0].subresourceRange.baseArrayLayer = 0;
+    barriers[0].subresourceRange.layerCount = 1;
+    barriers[0].srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
+    barriers[0].dstAccessMask = 0;
+
+    /* transition user image from TRANSFER_SRC_OPTIMAL to back to PRESENT_SRC */
+    barriers[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[1].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
+    barriers[1].newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    barriers[1].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].image = hack->user_image;
+    barriers[1].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[1].subresourceRange.baseMipLevel = 0;
+    barriers[1].subresourceRange.levelCount = 1;
+    barriers[1].subresourceRange.baseArrayLayer = 0;
+    barriers[1].subresourceRange.layerCount = 1;
+    barriers[1].srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
+    barriers[1].dstAccessMask = 0;
+
+    device->funcs.p_vkCmdPipelineBarrier(
+            hack->cmd,
+            VK_PIPELINE_STAGE_TRANSFER_BIT,
+            VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
+            0,
+            0, NULL,
+            0, NULL,
+            2, barriers
+    );
+
+    result = device->funcs.p_vkEndCommandBuffer(hack->cmd);
+    if(result != VK_SUCCESS){
+        ERR("vkEndCommandBuffer: %d\n", result);
+        return result;
+    }
+
+    return VK_SUCCESS;
+}
+
+NTSTATUS wine_vkQueuePresentKHR(void *args)
+{
+    struct vkQueuePresentKHR_params *params = args;
+    VkQueue queue = params->queue;
+    const VkPresentInfoKHR *pPresentInfo = params->pPresentInfo;
+    VkResult res;
+    VkPresentInfoKHR our_presentInfo;
+    VkSwapchainKHR *arr;
+    VkCommandBuffer *blit_cmds = NULL;
+    VkSubmitInfo submitInfo = {0};
+    VkSemaphore blit_sema;
+    struct VkSwapchainKHR_T *swapchain;
+    uint32_t i, n_hacks = 0;
+    uint32_t queue_idx;
+
+    TRACE("%p, %p\n", queue, pPresentInfo);
+
+    our_presentInfo = *pPresentInfo;
+
+    for(i = 0; i < our_presentInfo.swapchainCount; ++i){
+        swapchain = (struct VkSwapchainKHR_T *)(UINT_PTR)our_presentInfo.pSwapchains[i];
+
+        if(swapchain->fs_hack_enabled){
+            struct fs_hack_image *hack = &swapchain->fs_hack_images[our_presentInfo.pImageIndices[i]];
+
+            if(!blit_cmds){
+                queue_idx = queue->family_index;
+                blit_cmds = malloc(our_presentInfo.swapchainCount * sizeof(VkCommandBuffer));
+                blit_sema = hack->blit_finished;
+            }
+
+            if(!hack->cmd || hack->cmd_queue_idx != queue_idx){
+                if(hack->cmd)
+                    queue->device->funcs.p_vkFreeCommandBuffers(queue->device->device,
+                            swapchain->cmd_pools[hack->cmd_queue_idx],
+                            1, &hack->cmd);
+
+                hack->cmd_queue_idx = queue_idx;
+                hack->cmd = create_hack_cmd(queue, swapchain, queue_idx);
+
+                if(!hack->cmd){
+                    free(blit_cmds);
+                    return VK_ERROR_DEVICE_LOST;
+                }
+
+                if(queue->device->queue_props[queue_idx].queueFlags & VK_QUEUE_GRAPHICS_BIT)
+                    res = record_graphics_cmd(queue->device, swapchain, hack);
+                else if(queue->device->queue_props[queue_idx].queueFlags & VK_QUEUE_COMPUTE_BIT)
+                    res = record_compute_cmd(queue->device, swapchain, hack);
+                else{
+                    ERR("Present queue is neither graphics nor compute queue!\n");
+                    res = VK_ERROR_DEVICE_LOST;
+                }
+
+                if(res != VK_SUCCESS){
+                    queue->device->funcs.p_vkFreeCommandBuffers(queue->device->device,
+                            swapchain->cmd_pools[hack->cmd_queue_idx],
+                            1, &hack->cmd);
+                    hack->cmd = NULL;
+                    free(blit_cmds);
+                    return res;
+                }
+            }
+
+            blit_cmds[n_hacks] = hack->cmd;
+
+            ++n_hacks;
+        }
+    }
+
+    if(n_hacks > 0){
+        VkPipelineStageFlags waitStage, *waitStages, *waitStages_arr = NULL;
+
+        if(pPresentInfo->waitSemaphoreCount > 1){
+            waitStages_arr = malloc(sizeof(VkPipelineStageFlags) * pPresentInfo->waitSemaphoreCount);
+            for(i = 0; i < pPresentInfo->waitSemaphoreCount; ++i)
+                waitStages_arr[i] = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
+            waitStages = waitStages_arr;
+        }else{
+            waitStage = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
+            waitStages = &waitStage;
+        }
+
+        /* blit user image to real image */
+        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
+        submitInfo.waitSemaphoreCount = pPresentInfo->waitSemaphoreCount;
+        submitInfo.pWaitSemaphores = pPresentInfo->pWaitSemaphores;
+        submitInfo.pWaitDstStageMask = waitStages;
+        submitInfo.commandBufferCount = n_hacks;
+        submitInfo.pCommandBuffers = blit_cmds;
+        submitInfo.signalSemaphoreCount = 1;
+        submitInfo.pSignalSemaphores = &blit_sema;
+
+        res = queue->device->funcs.p_vkQueueSubmit(queue->queue, 1, &submitInfo, VK_NULL_HANDLE);
+        if(res != VK_SUCCESS)
+            ERR("vkQueueSubmit: %d\n", res);
+
+        free(waitStages_arr);
+        free(blit_cmds);
+
+        our_presentInfo.waitSemaphoreCount = 1;
+        our_presentInfo.pWaitSemaphores = &blit_sema;
+    }
+
+    arr = malloc(our_presentInfo.swapchainCount * sizeof(VkSwapchainKHR));
+    if(!arr){
+        ERR("Failed to allocate memory for swapchain array\n");
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+
+    for(i = 0; i < our_presentInfo.swapchainCount; ++i)
+        arr[i] = ((struct VkSwapchainKHR_T *)(UINT_PTR)our_presentInfo.pSwapchains[i])->swapchain;
+
+    our_presentInfo.pSwapchains = arr;
+
+    res = queue->device->funcs.p_vkQueuePresentKHR(queue->queue, &our_presentInfo);
+
+    free(arr);
+
+    return res;
+
+}
+
 BOOL WINAPI wine_vk_is_available_instance_function(VkInstance instance, const char *name)
 {
     return !!vk_funcs->p_vkGetInstanceProcAddr(instance->instance, name);
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 666ef95e1b1..491e4cbe4a7 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -63,6 +63,44 @@ struct VkDevice_T
     struct VkQueue_T* queues;
     uint32_t queue_count;
 
+    VkQueueFamilyProperties *queue_props;
+
+    struct wine_vk_mapping mapping;
+};
+
+struct fs_hack_image
+{
+    uint32_t cmd_queue_idx;
+    VkCommandBuffer cmd;
+    VkImage swapchain_image;
+    VkImage blit_image;
+    VkImage user_image;
+    VkSemaphore blit_finished;
+    VkImageView user_view, blit_view;
+    VkDescriptorSet descriptor_set;
+};
+
+struct VkSwapchainKHR_T
+{
+    VkSwapchainKHR swapchain; /* native swapchain */
+
+    /* fs hack data below */
+    BOOL fs_hack_enabled;
+    VkExtent2D user_extent;
+    VkExtent2D real_extent;
+    VkImageUsageFlags surface_usage;
+    VkRect2D blit_dst;
+    VkCommandPool *cmd_pools; /* VkCommandPool[device->queue_count] */
+    VkDeviceMemory user_image_memory, blit_image_memory;
+    uint32_t n_images;
+    struct fs_hack_image *fs_hack_images; /* struct fs_hack_image[n_images] */
+    VkFilter fs_hack_filter;
+    VkSampler sampler;
+    VkDescriptorPool descriptor_pool;
+    VkDescriptorSetLayout descriptor_set_layout;
+    VkPipelineLayout pipeline_layout;
+    VkPipeline pipeline;
+
     struct wine_vk_mapping mapping;
 };
 

From 16dc52e38a40f4feae70ece79e3ad2d715cf0620 Mon Sep 17 00:00:00 2001
From: Kai Krakow <kai@kaishome.de>
Date: Sun, 10 Oct 2021 20:48:24 +0200
Subject: [PATCH] winex11.drv: Bypass compositor in fullscreen mode.

Bypass the compositor in fullscreen mode. This reduces stutter
introduced by window updates in the background and also allows for maybe
a few more FPS. To not change the visual appearance of the desktop for
windowed games, this hack only enables itself when the game was switched
to fullscreen mode, and returns to default WM setting when the game
leaves fullscreen mode.

Compositors tend to cause severe stutter if the game is GPU-bound.
---
 dlls/winex11.drv/window.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 45a45a29f1a..c6b23d857af 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1144,6 +1144,7 @@ void update_user_time( Time time )
 void update_net_wm_states( struct x11drv_win_data *data )
 {
     DWORD i, style, ex_style, new_state = 0;
+    unsigned long net_wm_bypass_compositor = 0;

     if (!data->managed) return;
     if (data->whole_window == root_window) return;
@@ -1156,7 +1157,10 @@ void update_net_wm_states( struct x11drv_win_data *data )
         if ((style & WS_MAXIMIZE) && (style & WS_CAPTION) == WS_CAPTION)
             new_state |= (1 << NET_WM_STATE_MAXIMIZED);
         else if (!(style & WS_MINIMIZE))
+        {
+            net_wm_bypass_compositor = 1;
             new_state |= (1 << NET_WM_STATE_FULLSCREEN);
+        }
     }
     else if (style & WS_MAXIMIZE)
         new_state |= (1 << NET_WM_STATE_MAXIMIZED);
@@ -1218,6 +1222,9 @@ void update_net_wm_states( struct x11drv_win_data *data )
         }
     }
     data->net_wm_state = new_state;
+
+    XChangeProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_BYPASS_COMPOSITOR), XA_CARDINAL,
+                     32, PropModeReplace, (unsigned char *)&net_wm_bypass_compositor, 1 );
 }

 /***********************************************************************
From 045bf41a42665b1a0c56d0549a6b34fd330f052b Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Sun, 10 Oct 2021 20:53:45 +0200
Subject: [PATCH] winex11.drv: Fullscreen hack
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on work by Zhiyi Zhang, includes work by Giovanni Mascellani, Rmi
Bernon, Arkadiusz Hiler, Kai Krakow, Joshua Ashton, Zebediah Figura, and
Matteo Bruni.
---
 dlls/winex11.drv/Makefile.in   |   1 +
 dlls/winex11.drv/desktop.c     |   1 +
 dlls/winex11.drv/display.c     |  93 +++-
 dlls/winex11.drv/event.c       |  29 +-
 dlls/winex11.drv/fs.c          | 899 +++++++++++++++++++++++++++++++++
 dlls/winex11.drv/graphics.c    |   3 +-
 dlls/winex11.drv/mouse.c       |  44 +-
 dlls/winex11.drv/opengl.c      | 525 ++++++++++++++++++-
 dlls/winex11.drv/settings.c    |  28 +-
 dlls/winex11.drv/vulkan.c      |  59 +++
 dlls/winex11.drv/window.c      | 152 +++++-
 dlls/winex11.drv/x11drv.h      |  35 ++
 dlls/winex11.drv/x11drv_main.c |   8 +-
 dlls/winex11.drv/xrandr.c      |  20 +
 dlls/winex11.drv/xrender.c     | 137 ++++-
 dlls/winex11.drv/xvidmode.c    |   1 +
 16 files changed, 1967 insertions(+), 68 deletions(-)
 create mode 100644 dlls/winex11.drv/fs.c

diff --git a/dlls/winex11.drv/Makefile.in b/dlls/winex11.drv/Makefile.in
index c64a8464914..d44c9907498 100644
--- a/dlls/winex11.drv/Makefile.in
+++ b/dlls/winex11.drv/Makefile.in
@@ -13,6 +13,7 @@ C_SRCS = \
 	desktop.c \
 	display.c \
 	event.c \
+	fs.c \
 	graphics.c \
 	ime.c \
 	init.c \
diff --git a/dlls/winex11.drv/desktop.c b/dlls/winex11.drv/desktop.c
index 15350244610..ece6c2890ff 100644
--- a/dlls/winex11.drv/desktop.c
+++ b/dlls/winex11.drv/desktop.c
@@ -317,6 +317,7 @@ void X11DRV_init_desktop( Window win, unsigned int width, unsigned int height )
     settings_handler.free_modes = X11DRV_desktop_free_modes;
     settings_handler.get_current_mode = X11DRV_desktop_get_current_mode;
     settings_handler.set_current_mode = X11DRV_desktop_set_current_mode;
+    settings_handler.convert_coordinates = NULL;
     X11DRV_Settings_SetHandler( &settings_handler );
 }

diff --git a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
index 04380ff660f..cf638ff43a0 100644
--- a/dlls/winex11.drv/display.c
+++ b/dlls/winex11.drv/display.c
@@ -139,21 +139,33 @@ static BOOL update_screen_cache(void)

 POINT virtual_screen_to_root(INT x, INT y)
 {
-    RECT virtual = get_virtual_screen_rect();
+    RECT virtual = fs_hack_get_real_virtual_screen();
     POINT pt;

-    pt.x = x - virtual.left;
-    pt.y = y - virtual.top;
+    TRACE("from %d,%d\n", x, y);
+
+    pt.x = x;
+    pt.y = y;
+    fs_hack_point_user_to_real(&pt);
+    TRACE("to real %d,%d\n", pt.x, pt.y);
+
+    pt.x -= virtual.left;
+    pt.y -= virtual.top;
+    TRACE("to root %d,%d\n", pt.x, pt.y);
     return pt;
 }

 POINT root_to_virtual_screen(INT x, INT y)
 {
-    RECT virtual = get_virtual_screen_rect();
+    RECT virtual = fs_hack_get_real_virtual_screen();
     POINT pt;

+    TRACE("from root %d,%d\n", x, y);
     pt.x = x + virtual.left;
     pt.y = y + virtual.top;
+    TRACE("to real %d,%d\n", pt.x, pt.y);
+    fs_hack_point_real_to_user(&pt);
+    TRACE("to user %d,%d\n", pt.x, pt.y);
     return pt;
 }

@@ -283,6 +295,11 @@ void X11DRV_DisplayDevices_SetHandler(const struct x11drv_display_device_handler
     }
 }

+struct x11drv_display_device_handler X11DRV_DisplayDevices_GetHandler(void)
+{
+    return host_handler;
+}
+
 void X11DRV_DisplayDevices_RegisterEventHandlers(void)
 {
     struct x11drv_display_device_handler *handler = is_virtual_desktop() ? &desktop_handler : &host_handler;
@@ -295,22 +312,72 @@ static BOOL CALLBACK update_windows_on_display_change(HWND hwnd, LPARAM lparam)
 {
     struct x11drv_win_data *data;
     UINT mask = (UINT)lparam;
+    HMONITOR monitor;

     if (!(data = get_win_data(hwnd)))
         return TRUE;

-    /* update the full screen state */
-    update_net_wm_states(data);
+    monitor = fs_hack_monitor_from_hwnd( hwnd );
+    if (fs_hack_mapping_required( monitor ) &&
+            fs_hack_matches_current_mode( monitor,
+                data->whole_rect.right - data->whole_rect.left,
+                data->whole_rect.bottom - data->whole_rect.top)){
+        if(!data->fs_hack){
+            RECT real_rect = fs_hack_real_mode( monitor );
+            MONITORINFO monitor_info;
+            UINT width, height;
+            POINT tl;
+
+            monitor_info.cbSize = sizeof(monitor_info);
+            GetMonitorInfoW( monitor, &monitor_info );
+            tl = virtual_screen_to_root( monitor_info.rcMonitor.left, monitor_info.rcMonitor.top );
+            width = real_rect.right - real_rect.left;
+            height = real_rect.bottom - real_rect.top;
+
+            TRACE("Enabling fs hack, resizing window %p to (%u,%u)-(%u,%u)\n", hwnd, tl.x, tl.y, width, height);
+            data->fs_hack = TRUE;
+            set_wm_hints( data );
+            XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, width, height);
+            if(data->client_window)
+                XMoveResizeWindow(gdi_display, data->client_window, 0, 0, width, height);
+            sync_gl_drawable(hwnd, FALSE);
+            update_net_wm_states( data );
+        }
+    } else {
+        /* update the full screen state */
+        update_net_wm_states(data);

-    if (mask && data->whole_window)
-    {
-        POINT pos = virtual_screen_to_root(data->whole_rect.left, data->whole_rect.top);
-        XWindowChanges changes;
-        changes.x = pos.x;
-        changes.y = pos.y;
-        XReconfigureWMWindow(data->display, data->whole_window, data->vis.screen, mask, &changes);
+        if (data->fs_hack)
+            mask |= CWX | CWY;
+
+        if (mask && data->whole_window)
+        {
+            POINT pos = virtual_screen_to_root(data->whole_rect.left, data->whole_rect.top);
+            XWindowChanges changes;
+            changes.x = pos.x;
+            changes.y = pos.y;
+            XReconfigureWMWindow(data->display, data->whole_window, data->vis.screen, mask, &changes);
+        }
+
+        if(data->fs_hack && (!fs_hack_mapping_required(monitor) ||
+            !fs_hack_matches_current_mode(monitor,
+                data->whole_rect.right - data->whole_rect.left,
+                data->whole_rect.bottom - data->whole_rect.top))){
+            TRACE("Disabling fs hack\n");
+            data->fs_hack = FALSE;
+            if(data->client_window){
+                XMoveResizeWindow(gdi_display, data->client_window,
+                        data->client_rect.left - data->whole_rect.left,
+                        data->client_rect.top - data->whole_rect.top,
+                        data->client_rect.right - data->client_rect.left,
+                        data->client_rect.bottom - data->client_rect.top);
+            }
+            sync_gl_drawable(hwnd, FALSE);
+        }
     }
     release_win_data(data);
+    if (hwnd == GetForegroundWindow())
+        clip_fullscreen_window(hwnd, TRUE);
     return TRUE;
 }

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 3a903eebd7e..d22d34ea1c7 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -1186,8 +1186,19 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )
     }
     else pos = root_to_virtual_screen( x, y );

-    X11DRV_X_to_window_rect( data, &rect, pos.x, pos.y, event->width, event->height );
-    if (root_coords) MapWindowPoints( 0, parent, (POINT *)&rect, 2 );
+    if(data->fs_hack){
+        MONITORINFO monitor_info;
+        HMONITOR monitor;
+
+        monitor = fs_hack_monitor_from_hwnd( hwnd );
+        monitor_info.cbSize = sizeof(monitor_info);
+        GetMonitorInfoW( monitor, &monitor_info );
+        rect = monitor_info.rcMonitor;
+        TRACE( "monitor %p rect: %s\n", monitor, wine_dbgstr_rect(&rect) );
+    }else{
+        X11DRV_X_to_window_rect( data, &rect, pos.x, pos.y, event->width, event->height );
+        if (root_coords) MapWindowPoints( 0, parent, (POINT *)&rect, 2 );
+    }

     TRACE( "win %p/%lx new X rect %d,%d,%dx%d (event %d,%d,%dx%d)\n",
            hwnd, data->whole_window, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top,
@@ -1195,6 +1206,19 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )

     /* Compare what has changed */

+    {
+        const char *steamgameid = getenv("SteamGameId");
+        if(steamgameid && !strcmp(steamgameid, "590380")){
+            /* Into The Breach is extremely picky about the size of its window. */
+            if(is_window_rect_full_screen(&data->whole_rect) &&
+                    is_window_rect_full_screen(&rect)){
+                TRACE("window is fullscreen and new size is also fullscreen, so preserving window size\n");
+                rect.right = rect.left + (data->whole_rect.right - data->whole_rect.left);
+                rect.bottom = rect.top + (data->whole_rect.bottom - data->whole_rect.top);
+            }
+        }
+    }
+
     x     = rect.left;
     y     = rect.top;
     cx    = rect.right - rect.left;
@@ -1596,6 +1620,7 @@ static void EVENT_DropFromOffiX( HWND hWnd, XClientMessageEvent *event )
     Window		win, w_aux_root, w_aux_child;

     if (!(data = get_win_data( hWnd ))) return;
+    ERR("TODO: fs hack\n");
     cx = data->whole_rect.right - data->whole_rect.left;
     cy = data->whole_rect.bottom - data->whole_rect.top;
     win = data->whole_window;
diff --git a/dlls/winex11.drv/fs.c b/dlls/winex11.drv/fs.c
new file mode 100644
index 00000000000..641fdd40d45
--- /dev/null
+++ b/dlls/winex11.drv/fs.c
@@ -0,0 +1,899 @@
+/*
+ * Fullscreen Hack
+ *
+ * Simulate monitor resolution change
+ *
+ * Copyright 2020 Andrew Eikum for CodeWeavers
+ * Copyright 2020 Zhiyi Zhang for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#include "config.h"
+#include <math.h>
+#include <stdlib.h>
+
+#define NONAMELESSSTRUCT
+#define NONAMELESSUNION
+
+#include "x11drv.h"
+#include "wine/debug.h"
+#include "wine/list.h"
+#include "wine/heap.h"
+#include "wine/unicode.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(fshack);
+
+static struct x11drv_display_device_handler real_device_handler;
+static struct x11drv_settings_handler real_settings_handler;
+static struct list fs_monitors = LIST_INIT(fs_monitors);
+
+/* Access to fs_monitors is protected by fs_section */
+static CRITICAL_SECTION fs_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &fs_section,
+    {&critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList},
+    0, 0, {(DWORD_PTR)(__FILE__ ": fs_section")}
+};
+static CRITICAL_SECTION fs_section = {&critsect_debug, -1, 0, 0, 0, 0};
+
+struct fs_monitor_size
+{
+    DWORD width;
+    DWORD height;
+};
+
+/* A table of resolutions some games expect but host system may not report */
+static struct fs_monitor_size fs_monitor_sizes[] =
+{
+    {640, 480},   /*  4:3 */
+    {800, 600},   /*  4:3 */
+    {1024, 768},  /*  4:3 */
+    {1600, 1200}, /*  4:3 */
+    {960, 540},   /* 16:9 */
+    {1280, 720},  /* 16:9 */
+    {1600, 900},  /* 16:9 */
+    {1920, 1080}, /* 16:9 */
+    {2560, 1440}, /* 16:9 */
+    {2880, 1620}, /* 16:9 */
+    {3200, 1800}, /* 16:9 */
+    {1440, 900},  /*  8:5 */
+    {1680, 1050}, /*  8:5 */
+    {1920, 1200}, /*  8:5 */
+    {2560, 1600}, /*  8:5 */
+    {1440, 960},  /*  3:2 */
+    {1920, 1280}, /*  3:2 */
+    {2560, 1080}, /* 21:9 ultra-wide */
+    {1920, 800},  /* 12:5 */
+    {3840, 1600}, /* 12:5 */
+    {1280, 1024}, /*  5:4 */
+};
+
+/* A fake monitor for the fullscreen hack */
+struct fs_monitor
+{
+    struct list entry;
+
+    DEVMODEW user_mode;         /* Mode changed to by users */
+    DEVMODEW real_mode;         /* Mode actually used by the host system */
+    double user_to_real_scale;  /* Scale factor from fake monitor to real monitor */
+    POINT top_left;             /* Top left corner of the fake monitor rectangle in real virtual screen coordinates */
+    DEVMODEW *modes;            /* Supported display modes */
+    UINT mode_count;            /* Display mode count */
+    UINT unique_resolutions;    /* Number of unique resolutions in terms of WxH */
+};
+
+static void add_fs_mode(struct fs_monitor *fs_monitor, DWORD depth, DWORD width, DWORD height,
+                        DWORD frequency, DWORD orientation)
+{
+    int i;
+    DEVMODEW *mode;
+    const char *appid;
+    BOOL is_new_resolution;
+
+    /* Titan Souls renders incorrectly if we report modes smaller than 800x600 */
+    if ((appid = getenv("SteamAppId")) && !strcmp(appid, "297130"))
+    {
+        if (orientation == DMDO_DEFAULT || orientation == DMDO_180)
+        {
+            if (height <= 600 && !(height == 600 && width == 800))
+                return;
+        }
+        else
+        {
+            if (width <= 600 && !(width == 600 && height == 800))
+                return;
+        }
+    }
+
+    is_new_resolution = TRUE;
+
+    for (i = 0; i < fs_monitor->mode_count; ++i)
+    {
+        if (fs_monitor->modes[i].dmPelsWidth == width &&
+            fs_monitor->modes[i].dmPelsHeight == height)
+        {
+            is_new_resolution = FALSE;
+
+            if (fs_monitor->modes[i].dmBitsPerPel == depth &&
+                fs_monitor->modes[i].dmDisplayFrequency == frequency &&
+                fs_monitor->modes[i].u1.s2.dmDisplayOrientation == orientation)
+                return; /* The exact mode is already added, nothing to do */
+        }
+    }
+
+    if (is_new_resolution) {
+        /* Some games crash if we report too many unique resolutions (in terms of HxW) */
+        if (limit_number_of_resolutions && fs_monitor->unique_resolutions >= limit_number_of_resolutions)
+            return;
+
+        fs_monitor->unique_resolutions++;
+    }
+
+    mode = &fs_monitor->modes[fs_monitor->mode_count++];
+    mode->dmSize = sizeof(*mode);
+
+    mode->dmDriverExtra = 0;
+    mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
+                     DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY;
+    mode->u1.s2.dmDisplayOrientation = orientation;
+    mode->dmBitsPerPel = depth;
+    mode->dmPelsWidth = width;
+    mode->dmPelsHeight = height;
+    mode->u2.dmDisplayFlags = 0;
+    mode->dmDisplayFrequency = frequency;
+}
+
+static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
+{
+    DEVMODEW *real_modes, *real_mode, current_mode;
+    UINT real_mode_count;
+    DWORD width, height;
+    ULONG_PTR real_id;
+    ULONG offset;
+    UINT i, j;
+
+    if (!real_settings_handler.get_id(fs_monitor->user_mode.dmDeviceName, &real_id))
+        return FALSE;
+
+    if (!real_settings_handler.get_current_mode(real_id, &current_mode))
+        return FALSE;
+
+    /* Fullscreen hack doesn't support changing display orientations */
+    if (!real_settings_handler.get_modes(real_id, 0, &real_modes, &real_mode_count))
+        return FALSE;
+
+    fs_monitor->mode_count = 0;
+    fs_monitor->unique_resolutions = 0;
+    fs_monitor->modes = heap_calloc(ARRAY_SIZE(fs_monitor_sizes) * DEPTH_COUNT + real_mode_count,
+                                    sizeof(*fs_monitor->modes));
+    if (!fs_monitor->modes)
+    {
+        real_settings_handler.free_modes(real_modes);
+        return FALSE;
+    }
+
+    /* Add the current mode early, in case we have to limit */
+    add_fs_mode(fs_monitor, current_mode.dmBitsPerPel, current_mode.dmPelsWidth,
+                current_mode.dmPelsHeight, current_mode.dmDisplayFrequency,
+                current_mode.u1.s2.dmDisplayOrientation);
+
+    /* Linux reports far fewer resolutions than Windows. Add modes that some games may expect. */
+    for (i = 0; i < ARRAY_SIZE(fs_monitor_sizes); ++i)
+    {
+        if (current_mode.u1.s2.dmDisplayOrientation == DMDO_DEFAULT ||
+            current_mode.u1.s2.dmDisplayOrientation == DMDO_180)
+        {
+            width = fs_monitor_sizes[i].width;
+            height = fs_monitor_sizes[i].height;
+        }
+        else
+        {
+            width = fs_monitor_sizes[i].height;
+            height = fs_monitor_sizes[i].width;
+        }
+
+        /* Don't report modes that are larger than the current mode */
+        if (width > current_mode.dmPelsWidth || height > current_mode.dmPelsHeight)
+            continue;
+
+        for (j = 0; j < DEPTH_COUNT; ++j)
+            add_fs_mode(fs_monitor, depths[j], width, height, 60,
+                        current_mode.u1.s2.dmDisplayOrientation);
+    }
+
+    for (i = 0; i < real_mode_count; ++i)
+    {
+        offset = (sizeof(*real_modes) + real_modes[0].dmDriverExtra) * i;
+        real_mode = (DEVMODEW *)((BYTE *)real_modes + offset);
+
+        /* Don't report real modes that are larger than the current mode */
+        if (real_mode->dmPelsWidth > current_mode.dmPelsWidth ||
+            real_mode->dmPelsHeight > current_mode.dmPelsHeight)
+            continue;
+
+        add_fs_mode(fs_monitor, real_mode->dmBitsPerPel, real_mode->dmPelsWidth,
+                    real_mode->dmPelsHeight, real_mode->dmDisplayFrequency,
+                    real_mode->u1.s2.dmDisplayOrientation);
+    }
+    real_settings_handler.free_modes(real_modes);
+
+    /* Sort display modes so that X11DRV_EnumDisplaySettingsEx gets an already sorted mode list */
+    qsort(fs_monitor->modes, fs_monitor->mode_count, sizeof(*fs_monitor->modes), mode_compare);
+    return TRUE;
+}
+
+/* Add a fake monitor to fs_monitors list.
+ * Call this function with fs_section entered */
+static BOOL fs_add_monitor(const WCHAR *device_name)
+{
+    struct fs_monitor *fs_monitor;
+    DEVMODEW real_mode;
+    ULONG_PTR real_id;
+
+    if (!real_settings_handler.get_id(device_name, &real_id))
+        return FALSE;
+
+    if (!real_settings_handler.get_current_mode(real_id, &real_mode))
+        return FALSE;
+
+    if (!(fs_monitor = heap_alloc(sizeof(*fs_monitor))))
+        return FALSE;
+
+    fs_monitor->user_mode = real_mode;
+    fs_monitor->real_mode = real_mode;
+    fs_monitor->user_to_real_scale = 1.0;
+    fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x;
+    fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y;
+    lstrcpyW(fs_monitor->user_mode.dmDeviceName, device_name);
+    if (!fs_monitor_add_modes(fs_monitor))
+    {
+        ERR("Failed to initialize display modes.\n");
+        heap_free(fs_monitor);
+        return FALSE;
+    }
+    list_add_tail(&fs_monitors, &fs_monitor->entry);
+    return TRUE;
+}
+
+/* Fullscreen settings handler */
+
+/* Convert fullscreen hack settings handler id to GDI device name */
+static void fs_id_to_device_name(ULONG_PTR id, WCHAR *device_name)
+{
+    static WCHAR display_fmtW[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0};
+    sprintfW(device_name, display_fmtW, (INT)id);
+}
+
+static BOOL fs_get_id(const WCHAR *device_name, ULONG_PTR *id)
+{
+    static const WCHAR displayW[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y'};
+    long int display_index;
+    WCHAR *end;
+
+    if (strncmpiW( device_name, displayW, ARRAY_SIZE(displayW) ))
+        return FALSE;
+
+    display_index = strtolW( device_name + ARRAY_SIZE(displayW), &end, 10 );
+    if (*end)
+        return FALSE;
+
+    *id = (ULONG_PTR)display_index;
+    return TRUE;
+}
+
+/* Find a fs_monitor from a display name.
+ * Call this function with fs_section entered */
+static struct fs_monitor *fs_get_monitor_by_name(const WCHAR *name)
+{
+    struct fs_monitor *fs_monitor;
+
+    TRACE("name %s\n", wine_dbgstr_w(name));
+
+    LIST_FOR_EACH_ENTRY(fs_monitor, &fs_monitors, struct fs_monitor, entry)
+    {
+        if (!lstrcmpiW(fs_monitor->user_mode.dmDeviceName, name))
+            return fs_monitor;
+    }
+
+    return NULL;
+}
+
+static BOOL fs_get_modes(ULONG_PTR id, DWORD flags, DEVMODEW **new_modes, UINT *mode_count)
+{
+    WCHAR device_name[CCHDEVICENAME];
+    struct fs_monitor *fs_monitor;
+
+    fs_id_to_device_name(id, device_name);
+    EnterCriticalSection(&fs_section);
+    if ((fs_monitor = fs_get_monitor_by_name(device_name)))
+    {
+        *new_modes = fs_monitor->modes;
+        *mode_count = fs_monitor->mode_count;
+        LeaveCriticalSection(&fs_section);
+        return TRUE;
+    }
+
+    LeaveCriticalSection(&fs_section);
+    return FALSE;
+}
+
+static void fs_free_modes(DEVMODEW *modes){}
+
+/* Find a fs_monitor from a HMONITOR handle.
+ * Call this function with fs_section entered */
+static struct fs_monitor *fs_find_monitor_by_handle(HMONITOR monitor)
+{
+    MONITORINFOEXW monitor_info;
+
+    TRACE("monitor %p\n", monitor);
+
+    monitor_info.cbSize = sizeof(monitor_info);
+    if (!GetMonitorInfoW(monitor, (MONITORINFO *)&monitor_info))
+        return NULL;
+
+    return fs_get_monitor_by_name(monitor_info.szDevice);
+}
+
+static BOOL fs_get_current_mode(ULONG_PTR id, DEVMODEW *mode)
+{
+    WCHAR device_name[CCHDEVICENAME];
+    struct fs_monitor *fs_monitor;
+
+    fs_id_to_device_name(id, device_name);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_get_monitor_by_name(device_name);
+    if (fs_monitor)
+    {
+        *mode = fs_monitor->user_mode;
+        LeaveCriticalSection(&fs_section);
+        return TRUE;
+    }
+    LeaveCriticalSection(&fs_section);
+    return FALSE;
+}
+
+static LONG fs_set_current_mode(ULONG_PTR id, DEVMODEW *user_mode)
+{
+    WCHAR device_name[CCHDEVICENAME];
+    struct fs_monitor *fs_monitor;
+    DEVMODEW real_mode;
+    ULONG_PTR real_id;
+    double scale;
+
+    fs_id_to_device_name(id, device_name);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_get_monitor_by_name(device_name);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        return DISP_CHANGE_FAILED;
+    }
+
+    if (is_detached_mode(&fs_monitor->real_mode) && !is_detached_mode(user_mode))
+    {
+        FIXME("Attaching adapters is unsupported with fullscreen hack.\n");
+        return DISP_CHANGE_SUCCESSFUL;
+    }
+
+    /* Real modes may be changed since initialization */
+    if (!real_settings_handler.get_id(device_name, &real_id) ||
+        !real_settings_handler.get_current_mode(real_id, &real_mode))
+    {
+        LeaveCriticalSection(&fs_section);
+        return DISP_CHANGE_FAILED;
+    }
+
+    fs_monitor->user_mode = *user_mode;
+    fs_monitor->real_mode = real_mode;
+    lstrcpyW(fs_monitor->user_mode.dmDeviceName, device_name);
+
+    if (is_detached_mode(user_mode))
+    {
+        fs_monitor->user_to_real_scale = 0;
+        fs_monitor->top_left.x = 0;
+        fs_monitor->top_left.y = 0;
+    }
+    /* Integer scaling */
+    else if (fs_hack_is_integer())
+    {
+        scale = min(real_mode.dmPelsWidth / user_mode->dmPelsWidth, real_mode.dmPelsHeight / user_mode->dmPelsHeight);
+        fs_monitor->user_to_real_scale = scale;
+        fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x + (real_mode.dmPelsWidth - user_mode->dmPelsWidth * scale) / 2;
+        fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y + (real_mode.dmPelsHeight - user_mode->dmPelsHeight * scale) / 2;
+    }
+    /* If real mode is narrower than fake mode, scale to fit width */
+    else if ((double)real_mode.dmPelsWidth / (double)real_mode.dmPelsHeight
+             < (double)user_mode->dmPelsWidth / (double)user_mode->dmPelsHeight)
+    {
+        scale = (double)real_mode.dmPelsWidth / (double)user_mode->dmPelsWidth;
+        fs_monitor->user_to_real_scale = scale;
+        fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x;
+        fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y + (real_mode.dmPelsHeight - user_mode->dmPelsHeight * scale) / 2;
+    }
+    /* Else scale to fit height */
+    else
+    {
+        scale = (double)real_mode.dmPelsHeight / (double)user_mode->dmPelsHeight;
+        fs_monitor->user_to_real_scale = scale;
+        fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x + (real_mode.dmPelsWidth - user_mode->dmPelsWidth * scale) / 2;
+        fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y;
+    }
+
+    TRACE("real_mode x %d y %d width %d height %d\n", real_mode.u1.s2.dmPosition.x, real_mode.u1.s2.dmPosition.y,
+          real_mode.dmPelsWidth, real_mode.dmPelsHeight);
+    TRACE("user_mode x %d y %d width %d height %d\n", user_mode->u1.s2.dmPosition.x, user_mode->u1.s2.dmPosition.y,
+          user_mode->dmPelsWidth, user_mode->dmPelsHeight);
+    TRACE("user_to_real_scale %lf\n", fs_monitor->user_to_real_scale);
+    TRACE("top left corner:%s\n", wine_dbgstr_point(&fs_monitor->top_left));
+
+    LeaveCriticalSection(&fs_section);
+    return DISP_CHANGE_SUCCESSFUL;
+}
+
+/* Display device handler functions */
+
+static BOOL fs_get_monitors(ULONG_PTR adapter_id, struct gdi_monitor **new_monitors, int *count)
+{
+    struct gdi_monitor *monitor;
+    struct fs_monitor *fs_monitor;
+    RECT rect;
+    INT i;
+
+    if (!real_device_handler.get_monitors(adapter_id, new_monitors, count))
+        return FALSE;
+
+    EnterCriticalSection(&fs_section);
+    for (i = 0; i < *count; ++i)
+    {
+        monitor = &(*new_monitors)[i];
+
+        LIST_FOR_EACH_ENTRY(fs_monitor, &fs_monitors, struct fs_monitor, entry)
+        {
+            rect.left = fs_monitor->real_mode.u1.s2.dmPosition.x;
+            rect.top = fs_monitor->real_mode.u1.s2.dmPosition.y;
+            rect.right = rect.left + fs_monitor->real_mode.dmPelsWidth;
+            rect.bottom = rect.top + fs_monitor->real_mode.dmPelsHeight;
+
+            if (EqualRect(&rect, &monitor->rc_monitor))
+            {
+                monitor->rc_monitor.left = fs_monitor->user_mode.u1.s2.dmPosition.x;
+                monitor->rc_monitor.top = fs_monitor->user_mode.u1.s2.dmPosition.y;
+                monitor->rc_monitor.right = monitor->rc_monitor.left + fs_monitor->user_mode.dmPelsWidth;
+                monitor->rc_monitor.bottom = monitor->rc_monitor.top + fs_monitor->user_mode.dmPelsHeight;
+                monitor->rc_work = monitor->rc_monitor;
+                monitor->state_flags = DISPLAY_DEVICE_ATTACHED;
+                if (fs_monitor->user_mode.dmPelsWidth && fs_monitor->user_mode.dmPelsHeight)
+                    monitor->state_flags |= DISPLAY_DEVICE_ACTIVE;
+            }
+        }
+    }
+    LeaveCriticalSection(&fs_section);
+    return TRUE;
+}
+
+/* Fullscreen hack helpers */
+
+/* Return whether fullscreen hack is enabled on a specific monitor */
+BOOL fs_hack_enabled(HMONITOR monitor)
+{
+    struct fs_monitor *fs_monitor;
+    BOOL enabled = FALSE;
+
+    TRACE("monitor %p\n", monitor);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (fs_monitor && (fs_monitor->user_mode.dmPelsWidth != fs_monitor->real_mode.dmPelsWidth ||
+                       fs_monitor->user_mode.dmPelsHeight != fs_monitor->real_mode.dmPelsHeight))
+        enabled = TRUE;
+    LeaveCriticalSection(&fs_section);
+    TRACE("enabled: %s\n", enabled ? "TRUE" : "FALSE");
+    return enabled;
+}
+
+BOOL fs_hack_mapping_required(HMONITOR monitor)
+{
+    BOOL required;
+
+    TRACE("monitor %p\n", monitor);
+
+    /* steamcompmgr does our mapping for us */
+    required = !wm_is_steamcompmgr(NULL) && fs_hack_enabled(monitor);
+    TRACE("required: %s\n", required ? "TRUE" : "FALSE");
+    return required;
+}
+
+/* Return whether integer scaling is on */
+BOOL fs_hack_is_integer(void)
+{
+    static int is_int = -1;
+    if (is_int < 0)
+    {
+        const char *e = getenv("WINE_FULLSCREEN_INTEGER_SCALING");
+        is_int = e && strcmp(e, "0");
+    }
+    TRACE("is_interger_scaling: %s\n", is_int ? "TRUE" : "FALSE");
+    return is_int;
+}
+
+HMONITOR fs_hack_monitor_from_rect(const RECT *in_rect)
+{
+    RECT rect = *in_rect;
+
+    TRACE("rect %s\n", wine_dbgstr_rect(&rect));
+    rect.right = rect.left + 1;
+    rect.bottom = rect.top + 1;
+    return MonitorFromRect(&rect, MONITOR_DEFAULTTOPRIMARY);
+}
+
+/* Get the monitor a window is on. MonitorFromWindow() doesn't work here because it finds the
+ * monitor with the maximum overlapped rectangle when a window is spanned over two monitors, whereas
+ * for the fullscreen hack, the monitor where the left top corner of the window is on is the correct
+ * one. For example, a game with a window of 3840x2160 changes the primary monitor to 1280x720, if
+ * there is a secondary monitor of 3840x2160 to the right, MonitorFromWindow() will return the
+ * secondary monitor instead of the primary one. */
+HMONITOR fs_hack_monitor_from_hwnd(HWND hwnd)
+{
+    RECT rect = {0};
+
+    if (!GetWindowRect(hwnd, &rect))
+        ERR("Invalid hwnd %p.\n", hwnd);
+
+    TRACE("hwnd %p rect %s\n", hwnd, wine_dbgstr_rect(&rect));
+    return fs_hack_monitor_from_rect(&rect);
+}
+
+/* Return the rectangle of a monitor in current mode in user virtual screen coordinates */
+RECT fs_hack_current_mode(HMONITOR monitor)
+{
+    struct fs_monitor *fs_monitor;
+    RECT rect = {0};
+
+    TRACE("monitor %p\n", monitor);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        return rect;
+    }
+
+    rect.left = fs_monitor->user_mode.u1.s2.dmPosition.x;
+    rect.top = fs_monitor->user_mode.u1.s2.dmPosition.y;
+    rect.right = rect.left + fs_monitor->user_mode.dmPelsWidth;
+    rect.bottom = rect.top + fs_monitor->user_mode.dmPelsHeight;
+    LeaveCriticalSection(&fs_section);
+    TRACE("current mode rect: %s\n", wine_dbgstr_rect(&rect));
+    return rect;
+}
+
+/* Return the rectangle of a monitor in real mode in real virtual screen coordinates */
+RECT fs_hack_real_mode(HMONITOR monitor)
+{
+    struct fs_monitor *fs_monitor;
+    RECT rect = {0};
+
+    TRACE("monitor %p\n", monitor);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        return rect;
+    }
+
+    rect.left = fs_monitor->real_mode.u1.s2.dmPosition.x;
+    rect.top = fs_monitor->real_mode.u1.s2.dmPosition.y;
+    rect.right = rect.left + fs_monitor->real_mode.dmPelsWidth;
+    rect.bottom = rect.top + fs_monitor->real_mode.dmPelsHeight;
+    LeaveCriticalSection(&fs_section);
+    TRACE("real mode rect: %s\n", wine_dbgstr_rect(&rect));
+    return rect;
+}
+
+/* Return whether width and height are the same as the current mode used by a monitor */
+BOOL fs_hack_matches_current_mode(HMONITOR monitor, INT width, INT height)
+{
+    MONITORINFO monitor_info;
+    BOOL matched;
+
+    TRACE("monitor %p\n", monitor);
+
+    monitor_info.cbSize = sizeof(monitor_info);
+    if (!GetMonitorInfoW(monitor, &monitor_info))
+        return FALSE;
+
+    matched = (width == monitor_info.rcMonitor.right - monitor_info.rcMonitor.left)
+              && (height == monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top);
+    TRACE("matched: %s\n", matched ? "TRUE" : "FALSE");
+    return matched;
+}
+
+/* Transform a point in user virtual screen coordinates to real virtual screen coordinates */
+void fs_hack_point_user_to_real(POINT *pos)
+{
+    struct fs_monitor *fs_monitor;
+    RECT rect;
+
+    TRACE("from %d,%d\n", pos->x, pos->y);
+
+    if (wm_is_steamcompmgr(NULL))
+        return;
+
+    EnterCriticalSection(&fs_section);
+    LIST_FOR_EACH_ENTRY(fs_monitor, &fs_monitors, struct fs_monitor, entry)
+    {
+        rect.left = fs_monitor->user_mode.u1.s2.dmPosition.x;
+        rect.top = fs_monitor->user_mode.u1.s2.dmPosition.y;
+        rect.right = rect.left + fs_monitor->user_mode.dmPelsWidth;
+        rect.bottom = rect.top + fs_monitor->user_mode.dmPelsHeight;
+
+        if (PtInRect(&rect, *pos))
+        {
+            pos->x -= fs_monitor->user_mode.u1.s2.dmPosition.x;
+            pos->y -= fs_monitor->user_mode.u1.s2.dmPosition.y;
+            pos->x = lround(pos->x * fs_monitor->user_to_real_scale);
+            pos->y = lround(pos->y * fs_monitor->user_to_real_scale);
+            pos->x += fs_monitor->top_left.x;
+            pos->y += fs_monitor->top_left.y;
+            LeaveCriticalSection(&fs_section);
+            TRACE("to %d,%d\n", pos->x, pos->y);
+            return;
+        }
+    }
+    LeaveCriticalSection(&fs_section);
+    WARN("%d,%d not transformed.\n", pos->x, pos->y);
+}
+
+/* Transform a point in real virtual screen coordinates to user virtual screen coordinates */
+void fs_hack_point_real_to_user(POINT *pos)
+{
+    struct fs_monitor *fs_monitor;
+    RECT rect;
+
+    TRACE("from %d,%d\n", pos->x, pos->y);
+
+    if (wm_is_steamcompmgr(NULL))
+        return;
+
+    EnterCriticalSection(&fs_section);
+    LIST_FOR_EACH_ENTRY(fs_monitor, &fs_monitors, struct fs_monitor, entry)
+    {
+        rect.left = fs_monitor->real_mode.u1.s2.dmPosition.x;
+        rect.top = fs_monitor->real_mode.u1.s2.dmPosition.y;
+        rect.right = rect.left + fs_monitor->real_mode.dmPelsWidth;
+        rect.bottom = rect.top + fs_monitor->real_mode.dmPelsHeight;
+
+        if (PtInRect(&rect, *pos))
+        {
+            pos->x -= fs_monitor->top_left.x;
+            pos->y -= fs_monitor->top_left.y;
+            pos->x = lround(pos->x / fs_monitor->user_to_real_scale);
+            pos->y = lround(pos->y / fs_monitor->user_to_real_scale);
+            pos->x += fs_monitor->user_mode.u1.s2.dmPosition.x;
+            pos->y += fs_monitor->user_mode.u1.s2.dmPosition.y;
+            pos->x = max(pos->x, fs_monitor->user_mode.u1.s2.dmPosition.x);
+            pos->y = max(pos->y, fs_monitor->user_mode.u1.s2.dmPosition.y);
+            pos->x = min(pos->x, fs_monitor->user_mode.u1.s2.dmPosition.x + (INT)fs_monitor->user_mode.dmPelsWidth - 1);
+            pos->y = min(pos->y, fs_monitor->user_mode.u1.s2.dmPosition.y + (INT)fs_monitor->user_mode.dmPelsHeight - 1);
+            LeaveCriticalSection(&fs_section);
+            TRACE("to %d,%d\n", pos->x, pos->y);
+            return;
+        }
+    }
+    LeaveCriticalSection(&fs_section);
+    WARN("%d,%d not transformed.\n", pos->x, pos->y);
+}
+
+/* Transform RGNDATA in user virtual screen coordinates to real virtual screen coordinates.
+ * This is for clipping. Be sure to use Unsorted for Xlib calls after this transformation because
+ * this may break the requirement of using YXBanded. For example, say there are two monitors aligned
+ * horizontally with the primary monitor on the right. Each of monitor is of real resolution
+ * 1920x1080 and the fake primary monitor resolution is 1024x768. Then (0, 10, 1024, 768) should be
+ * transformed to (0, 14, 1920, 1080). While (1024, 10, 2944, 1080) should be transformed to
+ * (1920, 10, 3840, 1080) and this is breaking YXBanded because it requires y in non-decreasing order */
+void fs_hack_rgndata_user_to_real(RGNDATA *data)
+{
+    unsigned int i;
+    XRectangle *xrect;
+    RECT rect;
+
+    if (!data || wm_is_steamcompmgr(NULL))
+        return;
+
+    xrect = (XRectangle *)data->Buffer;
+    for (i = 0; i < data->rdh.nCount; i++)
+    {
+        rect.left = xrect[i].x;
+        rect.top = xrect[i].y;
+        rect.right = xrect[i].x + xrect[i].width;
+        rect.bottom = xrect[i].y + xrect[i].height;
+        TRACE("from rect %s\n", wine_dbgstr_rect(&rect));
+        fs_hack_rect_user_to_real(&rect);
+        TRACE("to rect %s\n", wine_dbgstr_rect(&rect));
+        xrect[i].x = rect.left;
+        xrect[i].y = rect.top;
+        xrect[i].width = rect.right - rect.left;
+        xrect[i].height = rect.bottom - rect.top;
+    }
+}
+
+/* Transform a rectangle in user virtual screen coordinates to real virtual screen coordinates. A
+ * difference compared to fs_hack_point_user_to_real() is that fs_hack_point_user_to_real() finds
+ * the wrong monitor if the point is on the right edge of the monitor rectangle. For example, when
+ * there are two monitors of real size 1920x1080, the primary monitor is of user mode 1024x768 and
+ * the secondary monitor is to the right. Rectangle (0, 0, 1024, 768) should transform to
+ * (0, 0, 1920, 1080). If (1024, 768) is passed to fs_hack_point_user_to_real(),
+ * fs_hack_point_user_to_real() will think (1024, 768) is on the secondary monitor, ends up
+ * returning a wrong result to callers. */
+void fs_hack_rect_user_to_real(RECT *rect)
+{
+    struct fs_monitor *fs_monitor;
+    HMONITOR monitor;
+    POINT point;
+
+    TRACE("from %s\n", wine_dbgstr_rect(rect));
+
+    if (wm_is_steamcompmgr(NULL))
+        return;
+
+    point.x = rect->left;
+    point.y = rect->top;
+    monitor = MonitorFromPoint(point, MONITOR_DEFAULTTONEAREST);
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        WARN("%s not transformed.\n", wine_dbgstr_rect(rect));
+        return;
+    }
+
+    OffsetRect(rect, -fs_monitor->user_mode.u1.s2.dmPosition.x, -fs_monitor->user_mode.u1.s2.dmPosition.y);
+    rect->left = lround(rect->left * fs_monitor->user_to_real_scale);
+    rect->right = lround(rect->right * fs_monitor->user_to_real_scale);
+    rect->top = lround(rect->top * fs_monitor->user_to_real_scale);
+    rect->bottom = lround(rect->bottom * fs_monitor->user_to_real_scale);
+    OffsetRect(rect, fs_monitor->top_left.x, fs_monitor->top_left.y);
+    LeaveCriticalSection(&fs_section);
+    TRACE("to %s\n", wine_dbgstr_rect(rect));
+}
+
+/* Get the user_to_real_scale value in a monitor */
+double fs_hack_get_user_to_real_scale(HMONITOR monitor)
+{
+    struct fs_monitor *fs_monitor;
+    double scale = 1.0;
+
+    TRACE("monitor %p\n", monitor);
+
+    if (wm_is_steamcompmgr(NULL))
+        return scale;
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        return scale;
+    }
+    scale = fs_monitor->user_to_real_scale;
+
+    LeaveCriticalSection(&fs_section);
+    TRACE("scale %lf\n", scale);
+    return scale;
+}
+
+/* Get the scaled scree size of a monitor */
+SIZE fs_hack_get_scaled_screen_size(HMONITOR monitor)
+{
+    struct fs_monitor *fs_monitor;
+    SIZE size = {0};
+
+    TRACE("monitor %p\n", monitor);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        return size;
+    }
+
+    if (wm_is_steamcompmgr(NULL))
+    {
+        LeaveCriticalSection(&fs_section);
+        size.cx = fs_monitor->user_mode.dmPelsWidth;
+        size.cy = fs_monitor->user_mode.dmPelsHeight;
+        TRACE("width %d height %d\n", size.cx, size.cy);
+        return size;
+    }
+
+    size.cx = lround(fs_monitor->user_mode.dmPelsWidth * fs_monitor->user_to_real_scale);
+    size.cy = lround(fs_monitor->user_mode.dmPelsHeight * fs_monitor->user_to_real_scale);
+    LeaveCriticalSection(&fs_section);
+    TRACE("width %d height %d\n", size.cx, size.cy);
+    return size;
+}
+
+/* Get the real virtual screen size instead of virtual screen size using fake modes */
+RECT fs_hack_get_real_virtual_screen(void)
+{
+    struct fs_monitor *fs_monitor;
+    RECT rect, virtual = {0};
+
+    EnterCriticalSection(&fs_section);
+    LIST_FOR_EACH_ENTRY(fs_monitor, &fs_monitors, struct fs_monitor, entry)
+    {
+        rect.left = fs_monitor->real_mode.u1.s2.dmPosition.x;
+        rect.top = fs_monitor->real_mode.u1.s2.dmPosition.y;
+        rect.right = rect.left + fs_monitor->real_mode.dmPelsWidth;
+        rect.bottom = rect.top + fs_monitor->real_mode.dmPelsHeight;
+
+        UnionRect(&virtual, &virtual, &rect);
+    }
+    LeaveCriticalSection(&fs_section);
+    TRACE("real virtual screen rect:%s\n", wine_dbgstr_rect(&virtual));
+    return virtual;
+}
+
+/* Initialize the fullscreen hack, which is a layer on top of real settings handlers and real
+ * display device handlers */
+void fs_hack_init(void)
+{
+    static WCHAR display_fmt[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0};
+    struct x11drv_display_device_handler device_handler;
+    struct x11drv_settings_handler settings_handler;
+    WCHAR device_name[CCHDEVICENAME];
+    INT i = 0;
+
+    real_device_handler = X11DRV_DisplayDevices_GetHandler();
+    real_settings_handler = X11DRV_Settings_GetHandler();
+
+    EnterCriticalSection(&fs_section);
+    while (1)
+    {
+        sprintfW(device_name, display_fmt, ++i);
+        if (!fs_add_monitor(device_name))
+            break;
+    }
+    LeaveCriticalSection(&fs_section);
+
+    settings_handler.name = "Fullscreen Hack";
+    settings_handler.priority = 500;
+    settings_handler.get_id = fs_get_id;
+    settings_handler.get_modes = fs_get_modes;
+    settings_handler.free_modes = fs_free_modes;
+    settings_handler.get_current_mode = fs_get_current_mode;
+    settings_handler.set_current_mode = fs_set_current_mode;
+    settings_handler.convert_coordinates = NULL;
+    X11DRV_Settings_SetHandler(&settings_handler);
+
+    device_handler.name = "Fullscreen Hack";
+    device_handler.priority = 500;
+    device_handler.get_gpus = real_device_handler.get_gpus;
+    device_handler.get_adapters = real_device_handler.get_adapters;
+    device_handler.get_monitors = fs_get_monitors;
+    device_handler.free_gpus = real_device_handler.free_gpus;
+    device_handler.free_adapters = real_device_handler.free_adapters;
+    device_handler.free_monitors = real_device_handler.free_monitors;
+    device_handler.register_event_handlers = NULL;
+    X11DRV_DisplayDevices_SetHandler(&device_handler);
+}
diff --git a/dlls/winex11.drv/graphics.c b/dlls/winex11.drv/graphics.c
index b3df3cafcb1..a486f78746b 100644
--- a/dlls/winex11.drv/graphics.c
+++ b/dlls/winex11.drv/graphics.c
@@ -251,8 +251,9 @@ static void update_x11_clipping( X11DRV_PDEVICE *physDev, HRGN rgn )
     }
     else if ((data = X11DRV_GetRegionData( rgn, 0 )))
     {
+        fs_hack_rgndata_user_to_real(data);
         XSetClipRectangles( gdi_display, physDev->gc, physDev->dc_rect.left, physDev->dc_rect.top,
-                            (XRectangle *)data->Buffer, data->rdh.nCount, YXBanded );
+                            (XRectangle *)data->Buffer, data->rdh.nCount, Unsorted );
         HeapFree( GetProcessHeap(), 0, data );
     }
 }
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 511550a8486..cb4363ae02e 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -433,6 +433,7 @@ static BOOL grab_clipping_window( const RECT *clip )
     Window clip_window;
     HWND msg_hwnd = 0;
     POINT pos;
+    RECT real_clip;

     if (GetWindowThreadProcessId( GetDesktopWindow(), NULL ) == GetCurrentThreadId())
         return TRUE;  /* don't clip in the desktop process */
@@ -450,9 +451,21 @@ static BOOL grab_clipping_window( const RECT *clip )
     TRACE( "clipping to %s win %lx\n", wine_dbgstr_rect(clip), clip_window );

     if (!data->clip_hwnd) XUnmapWindow( data->display, clip_window );
+
+    TRACE("user clip rect %s\n", wine_dbgstr_rect(clip));
+
+    real_clip = *clip;
+    fs_hack_rect_user_to_real(&real_clip);
+
     pos = virtual_screen_to_root( clip->left, clip->top );
+
+    TRACE("setting real clip to %d,%d x %d,%d\n",
+            pos.x, pos.y,
+            real_clip.right - real_clip.left,
+            real_clip.bottom - real_clip.top);
+
     XMoveResizeWindow( data->display, clip_window, pos.x, pos.y,
-                       max( 1, clip->right - clip->left ), max( 1, clip->bottom - clip->top ) );
+                       max( 1, real_clip.right - real_clip.left ), max( 1, real_clip.bottom - real_clip.top ) );
     XMapWindow( data->display, clip_window );

     /* if the rectangle is shrinking we may get a pointer warp */
@@ -631,11 +644,17 @@ static void map_event_coords( HWND hwnd, Window window, Window event_root, int x
         thread_data = x11drv_thread_data();
         if (!thread_data->clip_hwnd) return;
         if (thread_data->clip_window != window) return;
-        pt.x += clip_rect.left;
-        pt.y += clip_rect.top;
+        pt.x = clip_rect.left;
+        pt.y = clip_rect.top;
+        fs_hack_point_user_to_real(&pt);
+
+        pt.x += input->u.mi.dx;
+        pt.y += input->u.mi.dy;
+        fs_hack_point_real_to_user(&pt);
     }
     else if ((data = get_win_data( hwnd )))
     {
+        if (data->fs_hack) fs_hack_point_real_to_user(&pt);
         if (window == root_window) pt = root_to_virtual_screen( pt.x, pt.y );
         else if (event_root == root_window) pt = root_to_virtual_screen( x_root, y_root );
         else
@@ -1513,11 +1532,13 @@ BOOL CDECL X11DRV_SetCursorPos( INT x, INT y )
     struct x11drv_thread_data *data = x11drv_init_thread_data();
     POINT pos = virtual_screen_to_root( x, y );

+    TRACE("real setting to %u, %u\n", pos.x, pos.y);
+
     XWarpPointer( data->display, root_window, root_window, 0, 0, 0, 0, pos.x, pos.y );
     data->warp_serial = NextRequest( data->display );
     XNoOp( data->display );
     XFlush( data->display ); /* avoids bad mouse lag in games that do their own mouse warping */
-    TRACE( "warped to %d,%d serial %lu\n", x, y, data->warp_serial );
+    TRACE( "warped to (fake) %d,%d serial %lu\n", x, y, data->warp_serial );
     return TRUE;
 }

@@ -1933,9 +1933,11 @@ static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input, RAWINPUT *raw
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     XIValuatorClassInfo *x = &thread_data->x_valuator, *y = &thread_data->y_valuator;
     const double *values = event->valuators.values, *raw_values = event->raw_values;
-    double x_raw = 0, y_raw = 0, x_value = 0, y_value = 0, x_scale, y_scale;
+    double x_raw = 0, y_raw = 0, x_value = 0, y_value = 0, x_scale, y_scale, user_to_real_scale;
     RECT virtual_rect;
     int i;
+    POINT pt;
+    HMONITOR monitor;

     if (x->number < 0 || y->number < 0) return FALSE;
     if (!event->valuators.mask_len) return FALSE;
@@ -1968,6 +1999,12 @@ static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input, RAWINPUT *raw
     else
         FIXME( "Unsupported relative/absolute X/Y axis mismatch\n." );

+    GetCursorPos(&pt);
+    monitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONULL);
+    user_to_real_scale = fs_hack_get_user_to_real_scale(monitor);
+    input->u.mi.dx = lround((double)input->u.mi.dx / user_to_real_scale);
+    input->u.mi.dy = lround((double)input->u.mi.dy / user_to_real_scale);
+
     if (input->u.mi.dwFlags & MOUSEEVENTF_VIRTUALDESK) SetRect( &virtual_rect, 0, 0, 65535, 65535 );
     else virtual_rect = get_virtual_screen_rect();

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 3f3deae59ba..bf5f9637227 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -40,6 +40,10 @@
 #include "wine/heap.h"
 #include "wine/debug.h"

+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
+#endif
+
 #ifdef SONAME_LIBGL

 WINE_DEFAULT_DEBUG_CHANNEL(wgl);
@@ -203,6 +207,13 @@ struct wgl_context
     struct gl_drawable *drawables[2];
     struct gl_drawable *new_drawables[2];
     BOOL refresh_drawables;
+    BOOL fs_hack;
+    BOOL fs_hack_integer;
+    GLuint fs_hack_fbo, fs_hack_resolve_fbo;
+    GLuint fs_hack_color_texture, fs_hack_ds_texture;
+    GLuint fs_hack_color_renderbuffer, fs_hack_color_resolve_renderbuffer, fs_hack_ds_renderbuffer;
+    POINT setup_for;
+    GLuint current_draw_fbo, current_read_fbo;
     struct list entry;
 };

@@ -247,6 +258,10 @@ struct gl_drawable
     int                            swap_interval;
     BOOL                           refresh_swap_interval;
     BOOL                           mutable_pf;
+    BOOL                           fs_hack;
+    BOOL                           fs_hack_did_swapbuf;
+    BOOL                           fs_hack_context_set_up;
+    BOOL                           has_scissor_indexed;
 };

 enum glx_swap_control_method
@@ -370,6 +385,10 @@ static int   (*pglXSwapIntervalSGI)(int);
 static void* (*pglXAllocateMemoryNV)(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
 static void  (*pglXFreeMemoryNV)(GLvoid *pointer);

+static void (*pglScissorIndexed)(GLuint, GLint, GLint, GLsizei, GLsizei);
+static void (*pglScissorIndexedv)(GLuint, const GLint *);
+static void (*pglGetIntegeri_v)(GLenum, GLuint, GLint *);
+
 /* MESA GLX Extensions */
 static void (*pglXCopySubBufferMESA)(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
 static int (*pglXSwapIntervalMESA)(unsigned int interval);
@@ -393,6 +412,27 @@ static void wglFinish(void);
 static void wglFlush(void);
 static const GLubyte *wglGetString(GLenum name);

+/* Fullscreen hack */
+static void (*pglBindFramebuffer)( GLenum target, GLuint framebuffer );
+static void (*pglBindFramebufferEXT)( GLenum target, GLuint framebuffer );
+static void (*pglBindRenderbuffer)( GLenum target, GLuint renderbuffer );
+static void (*pglBlitFramebuffer)( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter );
+void (*pglDeleteFramebuffers)( GLsizei n, const GLuint *framebuffers );
+void (*pglDeleteRenderbuffers)( GLsizei n, const GLuint *renderbuffers );
+static void (*pglDrawBuffer)( GLenum buffer );
+static void (*pglFramebufferRenderbuffer)( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer );
+static void (*pglFramebufferTexture2D)( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level );
+static void (*pglGenFramebuffers)( GLsizei n, GLuint *ids );
+static void (*pglGenRenderbuffers)( GLsizei n, GLuint *renderbuffers );
+static void (*pglReadBuffer)( GLenum src );
+static void (*pglRenderbufferStorage)( GLenum target, GLenum internalformat, GLsizei width, GLsizei height );
+static void (*pglRenderbufferStorageMultisample)( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height );
+
+static void wglBindFramebuffer( GLenum target, GLuint framebuffer );
+static void wglBindFramebufferEXT( GLenum target, GLuint framebuffer );
+static void wglDrawBuffer( GLenum buffer );
+static void wglReadBuffer( GLenum src );
+
 /* check if the extension is present in the list */
 static BOOL has_extension( const char *list, const char *ext )
 {
@@ -568,9 +608,11 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
     /* redirect some standard OpenGL functions */
 #define REDIRECT(func) \
     do { p##func = opengl_funcs.gl.p_##func; opengl_funcs.gl.p_##func = w##func; } while(0)
+    REDIRECT( glDrawBuffer );
     REDIRECT( glFinish );
     REDIRECT( glFlush );
     REDIRECT( glGetString );
+    REDIRECT( glReadBuffer );
 #undef REDIRECT

     pglXGetProcAddressARB = dlsym(opengl_handle, "glXGetProcAddressARB");
@@ -579,6 +621,22 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
         goto failed;
     }

+    /* Fullscreen hack */
+#define LOAD_FUNCPTR(func) p##func = (void *)pglXGetProcAddressARB((const unsigned char *)#func);
+    LOAD_FUNCPTR( glBindFramebuffer );
+    LOAD_FUNCPTR( glBindFramebufferEXT );
+    LOAD_FUNCPTR( glBindRenderbuffer );
+    LOAD_FUNCPTR( glBlitFramebuffer );
+    LOAD_FUNCPTR( glDeleteFramebuffers );
+    LOAD_FUNCPTR( glDeleteRenderbuffers );
+    LOAD_FUNCPTR( glFramebufferRenderbuffer );
+    LOAD_FUNCPTR( glFramebufferTexture2D );
+    LOAD_FUNCPTR( glGenFramebuffers );
+    LOAD_FUNCPTR( glGenRenderbuffers );
+    LOAD_FUNCPTR( glRenderbufferStorage );
+    LOAD_FUNCPTR( glRenderbufferStorageMultisample );
+#undef LOAD_FUNCPTR
+
 #define LOAD_FUNCPTR(f) do if((p##f = (void*)pglXGetProcAddressARB((const unsigned char*)#f)) == NULL) \
     { \
         ERR( "%s not found in libGL, disabling OpenGL.\n", #f ); \
@@ -629,6 +687,10 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
     /* NV GLX Extension */
     LOAD_FUNCPTR(glXAllocateMemoryNV);
     LOAD_FUNCPTR(glXFreeMemoryNV);
+
+    LOAD_FUNCPTR(glScissorIndexed);
+    LOAD_FUNCPTR(glScissorIndexedv);
+    LOAD_FUNCPTR(glGetIntegeri_v);
 #undef LOAD_FUNCPTR

     if(!X11DRV_WineGL_InitOpenglInfo()) goto failed;
@@ -719,6 +781,13 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
         pglXSwapBuffersMscOML = pglXGetProcAddressARB( (const GLubyte *)"glXSwapBuffersMscOML" );
     }

+    if (has_extension( glExtensions, "GL_ARB_viewport_array"))
+    {
+        opengl_funcs.ext.p_glGetIntegeri_v = pglGetIntegeri_v;
+        opengl_funcs.ext.p_glScissorIndexed = pglScissorIndexed;
+        opengl_funcs.ext.p_glScissorIndexedv = pglScissorIndexedv;
+    }
+
     X11DRV_WineGL_LoadExtensions();
     init_pixel_formats( gdi_display );
     return TRUE;
@@ -1329,10 +1398,17 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel

     if (!known_child && !GetWindow( hwnd, GW_CHILD ) && GetAncestor( hwnd, GA_PARENT ) == GetDesktopWindow())  /* childless top-level window */
     {
+        struct x11drv_win_data *data;
+
         gl->type = DC_GL_WINDOW;
         gl->window = create_client_window( hwnd, visual );
         if (gl->window)
             gl->drawable = pglXCreateWindow( gdi_display, gl->format->fbconfig, gl->window, NULL );
+        data = get_win_data( hwnd );
+        gl->fs_hack = data->fs_hack;
+        if (gl->fs_hack)
+            TRACE( "Window %p has the fullscreen hack enabled\n", hwnd );
+        release_win_data( data );
         TRACE( "%p created client %lx drawable %lx\n", hwnd, gl->window, gl->drawable );
     }
 #ifdef SONAME_LIBXCOMPOSITE
@@ -1454,6 +1530,9 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
 void sync_gl_drawable( HWND hwnd, BOOL known_child )
 {
     struct gl_drawable *old, *new;
+    struct x11drv_win_data *data;
+
+    TRACE("%p\n", hwnd);

     if (!(old = get_gl_drawable( hwnd, 0 ))) return;

@@ -1472,6 +1551,15 @@ void sync_gl_drawable( HWND hwnd, BOOL known_child )
     default:
         break;
     }
+
+    if (DC_GL_PIXMAP_WIN != old->type) {
+        data = get_win_data( hwnd );
+        old->fs_hack = data->fs_hack;
+        if (old->fs_hack)
+            TRACE( "Window %p has the fullscreen hack enabled\n", hwnd );
+        release_win_data( data );
+    }
+
     release_gl_drawable( old );
 }

@@ -1779,6 +1867,10 @@ static BOOL WINAPI glxdrv_wglDeleteContext(struct wgl_context *ctx)
 static PROC WINAPI glxdrv_wglGetProcAddress(LPCSTR lpszProc)
 {
     if (!strncmp(lpszProc, "wgl", 3)) return NULL;
+    if (!strcmp(lpszProc, "glBindFramebuffer"))
+        return (PROC)wglBindFramebuffer;
+    if (!strcmp(lpszProc, "glBindFramebufferEXT"))
+        return (PROC)wglBindFramebufferEXT;
     return pglXGetProcAddressARB((const GLubyte*)lpszProc);
 }

@@ -1798,12 +1890,248 @@ static void set_context_drawables( struct wgl_context *ctx, struct gl_drawable *
     for (i = 0; i < 4; i++) release_gl_drawable( prev[i] );
 }

+struct fs_hack_fbconfig_attribs
+{
+    int render_type;
+    int buffer_size;
+    int red_size;
+    int green_size;
+    int blue_size;
+    int alpha_size;
+    int depth_size;
+    int stencil_size;
+    int doublebuffer;
+    int samples;
+    int srgb;
+};
+
+struct fs_hack_fbo_attachments_config
+{
+    GLint color_internalformat;
+    GLenum color_format;
+    GLenum color_type;
+    GLint ds_internalformat;
+    GLenum ds_format;
+    GLenum ds_type;
+    int samples;
+};
+
+static void fs_hack_get_attachments_config( struct gl_drawable *gl, struct fs_hack_fbconfig_attribs *attribs,
+        struct fs_hack_fbo_attachments_config *config )
+{
+    if (attribs->render_type != GLX_RGBA_BIT)
+        FIXME( "Unsupported GLX_RENDER_TYPE %#x.\n", attribs->render_type );
+    if (attribs->red_size != 8 || attribs->green_size != 8 || attribs->blue_size != 8)
+        FIXME( "Unsupported RGBA color sizes {%u, %u, %u, %u}.\n",
+                attribs->red_size, attribs->green_size, attribs->blue_size, attribs->alpha_size );
+    if (attribs->srgb)
+        config->color_internalformat = attribs->alpha_size ? GL_SRGB8_ALPHA8 : GL_SRGB8;
+    else
+        config->color_internalformat = attribs->alpha_size ? GL_RGBA8 : GL_RGB8;
+    config->color_format = GL_BGRA;
+    config->color_type = GL_UNSIGNED_INT_8_8_8_8_REV;
+    if (attribs->depth_size || attribs->stencil_size)
+    {
+        if (attribs->depth_size != 24)
+            FIXME( "Unsupported depth buffer size %u.\n", attribs->depth_size );
+        if (attribs->stencil_size && attribs->stencil_size != 8)
+            FIXME( "Unsupported stencil buffer size %u.\n", attribs->stencil_size );
+        config->ds_internalformat = attribs->stencil_size ? GL_DEPTH24_STENCIL8 : GL_DEPTH_COMPONENT24;
+        config->ds_format = attribs->stencil_size ? GL_DEPTH_STENCIL : GL_DEPTH_COMPONENT;
+        config->ds_type = attribs->stencil_size ? GL_UNSIGNED_INT_24_8 : GL_UNSIGNED_INT;
+    }
+    else
+    {
+        config->ds_internalformat = config->ds_format = config->ds_type = 0;
+    }
+    config->samples = attribs->samples;
+}
+
+static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *gl )
+{
+    GLuint prev_draw_fbo, prev_read_fbo, prev_texture, prev_renderbuffer;
+    float prev_clear_color[4];
+    unsigned int i;
+    struct fs_hack_fbo_attachments_config config;
+    struct fs_hack_fbconfig_attribs attribs;
+    static const struct fbconfig_attribs_query
+    {
+        int attribute;
+        unsigned int offset;
+    }
+    queries[] =
+    {
+        {GLX_RENDER_TYPE, offsetof(struct fs_hack_fbconfig_attribs, render_type)},
+        {GLX_BUFFER_SIZE, offsetof(struct fs_hack_fbconfig_attribs, buffer_size)},
+        {GLX_RED_SIZE, offsetof(struct fs_hack_fbconfig_attribs, red_size)},
+        {GLX_GREEN_SIZE, offsetof(struct fs_hack_fbconfig_attribs, green_size)},
+        {GLX_BLUE_SIZE, offsetof(struct fs_hack_fbconfig_attribs, blue_size)},
+        {GLX_ALPHA_SIZE, offsetof(struct fs_hack_fbconfig_attribs, alpha_size)},
+        {GLX_DEPTH_SIZE, offsetof(struct fs_hack_fbconfig_attribs, depth_size)},
+        {GLX_STENCIL_SIZE, offsetof(struct fs_hack_fbconfig_attribs, stencil_size)},
+        {GLX_DOUBLEBUFFER, offsetof(struct fs_hack_fbconfig_attribs, doublebuffer)},
+        {GLX_SAMPLES_ARB, offsetof(struct fs_hack_fbconfig_attribs, samples)},
+        {GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT, offsetof(struct fs_hack_fbconfig_attribs, srgb)},
+    };
+    BYTE *ptr = (BYTE *)&attribs;
+
+    if (ctx->fs_hack)
+    {
+        MONITORINFO monitor_info;
+        HMONITOR monitor;
+        int width, height;
+
+        monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
+        memset(&monitor_info, 0, sizeof(monitor_info));
+        monitor_info.cbSize = sizeof(monitor_info);
+        GetMonitorInfoW(monitor, &monitor_info);
+        width = monitor_info.rcMonitor.right - monitor_info.rcMonitor.left;
+        height = monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top;
+
+        TRACE("Render buffer width:%d height:%d\n", width, height);
+
+        opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&prev_draw_fbo );
+        opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&prev_read_fbo );
+        opengl_funcs.gl.p_glGetIntegerv( GL_TEXTURE_BINDING_2D, (GLint *)&prev_texture );
+        opengl_funcs.gl.p_glGetIntegerv( GL_RENDERBUFFER_BINDING, (GLint *)&prev_renderbuffer );
+        opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, prev_clear_color );
+        TRACE( "Previous draw FBO %u, read FBO %u for ctx %p\n", prev_draw_fbo, prev_read_fbo, ctx);
+
+        if (!ctx->fs_hack_fbo)
+        {
+            pglGenFramebuffers( 1, &ctx->fs_hack_fbo );
+            pglGenFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
+            TRACE( "Created FBO %u for fullscreen hack.\n", ctx->fs_hack_fbo );
+        }
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
+
+        for (i = 0; i < ARRAY_SIZE(queries); ++i)
+            pglXGetFBConfigAttrib( gdi_display, gl->format->fbconfig, queries[i].attribute,
+                    (int *)&ptr[queries[i].offset] );
+        fs_hack_get_attachments_config( gl, &attribs, &config );
+
+        if (config.samples)
+        {
+            if (!ctx->fs_hack_color_renderbuffer)
+                pglGenRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
+            pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
+            pglRenderbufferStorageMultisample( GL_RENDERBUFFER, config.samples,
+                    config.color_internalformat, width, height );
+            pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                    GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
+            TRACE( "Created renderbuffer %u for fullscreen hack.\n", ctx->fs_hack_color_renderbuffer );
+            pglGenRenderbuffers( 1, &ctx->fs_hack_color_resolve_renderbuffer );
+            pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_resolve_renderbuffer );
+            pglRenderbufferStorage( GL_RENDERBUFFER, config.color_internalformat, width, height );
+            pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
+            pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                    GL_RENDERBUFFER, ctx->fs_hack_color_resolve_renderbuffer );
+            pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
+            pglBindRenderbuffer( GL_RENDERBUFFER, prev_renderbuffer );
+            TRACE( "Also created renderbuffer %u and FBO %u for color resolve.\n",
+                    ctx->fs_hack_color_resolve_renderbuffer, ctx->fs_hack_resolve_fbo );
+        }
+        else
+        {
+            if (!ctx->fs_hack_color_texture)
+                opengl_funcs.gl.p_glGenTextures( 1, &ctx->fs_hack_color_texture );
+            opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_color_texture );
+            opengl_funcs.gl.p_glTexImage2D( GL_TEXTURE_2D, 0, config.color_internalformat, width, height,
+                    0, config.color_format, config.color_type, NULL);
+            opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
+            opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, prev_texture );
+            pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                    GL_TEXTURE_2D, ctx->fs_hack_color_texture, 0 );
+            TRACE( "Created texture %u for fullscreen hack.\n", ctx->fs_hack_color_texture );
+        }
+
+        if (config.ds_internalformat)
+        {
+            if (config.samples)
+            {
+                if (!ctx->fs_hack_ds_renderbuffer)
+                    pglGenRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
+                pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
+                pglRenderbufferStorageMultisample( GL_RENDERBUFFER, config.samples,
+                        config.ds_internalformat, width, height );
+                pglBindRenderbuffer( GL_RENDERBUFFER, prev_renderbuffer );
+                if (attribs.depth_size)
+                    pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
+                            GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
+                if (attribs.stencil_size)
+                    pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,
+                            GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
+                TRACE( "Created DS renderbuffer %u for fullscreen hack.\n", ctx->fs_hack_ds_renderbuffer );
+            }
+            else
+            {
+                if (!ctx->fs_hack_ds_texture)
+                    opengl_funcs.gl.p_glGenTextures( 1, &ctx->fs_hack_ds_texture );
+                opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_ds_texture );
+                opengl_funcs.gl.p_glTexImage2D( GL_TEXTURE_2D, 0, config.ds_internalformat, width, height,
+                        0, config.ds_format, config.ds_type, NULL);
+                opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
+                opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, prev_texture );
+                if (attribs.depth_size)
+                    pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, ctx->fs_hack_ds_texture, 0 );
+                if (attribs.stencil_size)
+                    pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, ctx->fs_hack_ds_texture, 0 );
+                TRACE( "Created DS texture %u for fullscreen hack.\n", ctx->fs_hack_ds_texture );
+            }
+        }
+
+        opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
+        if(!gl->fs_hack_context_set_up)
+            opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
+        pglDrawBuffer( GL_BACK );
+        if(!gl->fs_hack_context_set_up)
+            opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
+        opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1], prev_clear_color[2], prev_clear_color[3] );
+        wglBindFramebuffer( GL_DRAW_FRAMEBUFFER, prev_draw_fbo );
+        wglBindFramebuffer( GL_READ_FRAMEBUFFER, prev_read_fbo );
+
+        ctx->setup_for.x = width;
+        ctx->setup_for.y = height;
+        gl->has_scissor_indexed = has_extension(glExtensions, "GL_ARB_viewport_array");
+        ctx->fs_hack_integer = fs_hack_is_integer();
+        gl->fs_hack_context_set_up = TRUE;
+    }
+    else
+    {
+        TRACE( "Releasing fullscreen hack texture %u and FBO %u\n", ctx->fs_hack_color_texture, ctx->fs_hack_fbo );
+        if (ctx->current_draw_fbo == ctx->fs_hack_fbo)
+        {
+            pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
+            ctx->current_draw_fbo = 0;
+        }
+        if (ctx->current_read_fbo == ctx->fs_hack_fbo)
+        {
+            pglBindFramebuffer( GL_READ_FRAMEBUFFER, 0 );
+            ctx->current_read_fbo = 0;
+        }
+
+        pglDeleteRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
+        pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_resolve_renderbuffer );
+        pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
+        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_ds_texture );
+        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_color_texture );
+        ctx->fs_hack_color_renderbuffer = ctx->fs_hack_color_resolve_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
+        ctx->fs_hack_color_texture = ctx->fs_hack_ds_texture = 0;
+        pglDeleteFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
+        pglDeleteFramebuffers( 1, &ctx->fs_hack_fbo );
+        ctx->fs_hack_fbo = 0;
+
+        gl->fs_hack_context_set_up = FALSE;
+    }
+}
+
 /***********************************************************************
  *		glxdrv_wglMakeCurrent
  */
 static BOOL WINAPI glxdrv_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
 {
-    BOOL ret = FALSE;
+    BOOL ret = FALSE, setup_fs_hack = FALSE;
     struct gl_drawable *gl;

     TRACE("(%p,%p)\n", hdc, ctx);
@@ -1832,10 +2160,17 @@ static BOOL WINAPI glxdrv_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
         if (ret)
         {
             NtCurrentTeb()->glContext = ctx;
-            ctx->has_been_current = TRUE;
+            if (ctx->fs_hack != gl->fs_hack || (ctx->fs_hack && ctx->drawables[0] != gl))
+                setup_fs_hack = TRUE;
             ctx->hdc = hdc;
             set_context_drawables( ctx, gl, gl );
             ctx->refresh_drawables = FALSE;
+            if (setup_fs_hack)
+            {
+                ctx->fs_hack = gl->fs_hack;
+                fs_hack_setup_context( ctx, gl );
+            }
+            ctx->has_been_current = TRUE;
             LeaveCriticalSection( &context_section );
             goto done;
         }
@@ -1854,7 +2189,7 @@ static BOOL WINAPI glxdrv_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
  */
 static BOOL X11DRV_wglMakeContextCurrentARB( HDC draw_hdc, HDC read_hdc, struct wgl_context *ctx )
 {
-    BOOL ret = FALSE;
+    BOOL ret = FALSE, setup_fs_hack = FALSE;
     struct gl_drawable *draw_gl, *read_gl = NULL;

     TRACE("(%p,%p,%p)\n", draw_hdc, read_hdc, ctx);
@@ -1877,11 +2212,18 @@ static BOOL X11DRV_wglMakeContextCurrentARB( HDC draw_hdc, HDC read_hdc, struct
                                      read_gl ? read_gl->drawable : 0, ctx->ctx);
         if (ret)
         {
-            ctx->has_been_current = TRUE;
+            NtCurrentTeb()->glContext = ctx;
+            if (ctx->fs_hack != draw_gl->fs_hack || (ctx->fs_hack && ctx->drawables[0] != draw_gl))
+                setup_fs_hack = TRUE;
             ctx->hdc = draw_hdc;
             set_context_drawables( ctx, draw_gl, read_gl );
             ctx->refresh_drawables = FALSE;
-            NtCurrentTeb()->glContext = ctx;
+            if (setup_fs_hack)
+            {
+                ctx->fs_hack = draw_gl->fs_hack;
+                fs_hack_setup_context( ctx, draw_gl );
+            }
+            ctx->has_been_current = TRUE;
             LeaveCriticalSection( &context_section );
             goto done;
         }
@@ -1940,6 +2282,145 @@ static BOOL WINAPI glxdrv_wglShareLists(struct wgl_context *org, struct wgl_cont
     return FALSE;
 }

+static void wglBindFramebuffer( GLenum target, GLuint framebuffer )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    TRACE( "target %#x, framebuffer %u\n", target, framebuffer );
+    if (ctx->fs_hack && !framebuffer)
+        framebuffer = ctx->fs_hack_fbo;
+
+    if (target == GL_DRAW_FRAMEBUFFER || target == GL_FRAMEBUFFER)
+        ctx->current_draw_fbo = framebuffer;
+    if (target == GL_READ_FRAMEBUFFER || target == GL_FRAMEBUFFER)
+        ctx->current_read_fbo = framebuffer;
+
+    pglBindFramebuffer( target, framebuffer );
+}
+
+static void wglBindFramebufferEXT( GLenum target, GLuint framebuffer )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    TRACE( "target %#x, framebuffer %u\n", target, framebuffer );
+    if (ctx->fs_hack && !framebuffer)
+        framebuffer = ctx->fs_hack_fbo;
+
+    if (target == GL_DRAW_FRAMEBUFFER || target == GL_FRAMEBUFFER)
+        ctx->current_draw_fbo = framebuffer;
+    if (target == GL_READ_FRAMEBUFFER || target == GL_FRAMEBUFFER)
+        ctx->current_read_fbo = framebuffer;
+
+    pglBindFramebufferEXT( target, framebuffer );
+}
+
+static void wglDrawBuffer( GLenum buffer )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (ctx->fs_hack && ctx->current_draw_fbo == ctx->fs_hack_fbo)
+    {
+        TRACE("Overriding %#x with GL_COLOR_ATTACHMENT0\n", buffer);
+        buffer = GL_COLOR_ATTACHMENT0;
+    }
+    pglDrawBuffer( buffer );
+}
+
+static void wglReadBuffer( GLenum buffer )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (ctx->fs_hack && ctx->current_read_fbo == ctx->fs_hack_fbo)
+    {
+        TRACE("Overriding %#x with GL_COLOR_ATTACHMENT0\n", buffer);
+        buffer = GL_COLOR_ATTACHMENT0;
+    }
+    pglReadBuffer( buffer );
+}
+
+static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    SIZE scaled, src, real;
+    GLuint prev_draw_fbo, prev_read_fbo;
+    GLint prev_scissor[4];
+    RECT user_rect, real_rect;
+    POINT scaled_origin;
+    float prev_clear_color[4];
+    HMONITOR monitor;
+
+    monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
+    scaled = fs_hack_get_scaled_screen_size(monitor);
+    user_rect = fs_hack_current_mode(monitor);
+    real_rect = fs_hack_real_mode(monitor);
+    src.cx = user_rect.right - user_rect.left;
+    src.cy = user_rect.bottom - user_rect.top;
+    real.cx = real_rect.right - real_rect.left;
+    real.cy = real_rect.bottom - real_rect.top;
+    scaled_origin.x = user_rect.left;
+    scaled_origin.y = user_rect.top;
+    fs_hack_point_user_to_real(&scaled_origin);
+    scaled_origin.x -= real_rect.left;
+    scaled_origin.y -= real_rect.top;
+
+    TRACE("scaled:%dx%d src:%dx%d real:%dx%d user_rect:%s real_rect:%s scaled_origin:%s\n", scaled.cx, scaled.cy,
+          src.cx, src.cy, real.cx, real.cy, wine_dbgstr_rect(&user_rect), wine_dbgstr_rect(&real_rect),
+          wine_dbgstr_point(&scaled_origin));
+
+    if(ctx->setup_for.x != src.cx ||
+            ctx->setup_for.y != src.cy)
+        fs_hack_setup_context( ctx, gl );
+
+    TRACE( "Blitting from FBO %u %ux%u to %ux%u\n", ctx->fs_hack_fbo, src.cx, src.cy, scaled.cx, scaled.cy );
+
+    opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&prev_draw_fbo );
+    opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&prev_read_fbo );
+    TRACE( "Previous draw FBO %u, read FBO %u\n", prev_draw_fbo, prev_read_fbo );
+
+    if(gl->has_scissor_indexed){
+        opengl_funcs.ext.p_glGetIntegeri_v(GL_SCISSOR_BOX, 0, prev_scissor);
+        opengl_funcs.ext.p_glScissorIndexed(0, 0, 0, real.cx, real.cy);
+    }else{
+        opengl_funcs.gl.p_glGetIntegerv(GL_SCISSOR_BOX, prev_scissor);
+        opengl_funcs.gl.p_glScissor(0, 0, real.cx, real.cy);
+    }
+
+    pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_fbo );
+    if (ctx->fs_hack_color_resolve_renderbuffer)
+    {
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
+        pglBlitFramebuffer( 0, 0, src.cx, src.cy, 0, 0, src.cx, src.cy, GL_COLOR_BUFFER_BIT, GL_NEAREST );
+        pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
+    }
+    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
+
+    //HACK
+    //pglDrawBuffer( draw_buffer );
+    pglDrawBuffer( GL_BACK );
+
+    opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, prev_clear_color );
+    opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
+    opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
+    opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1], prev_clear_color[2], prev_clear_color[3] );
+
+    pglBlitFramebuffer( 0, 0, src.cx, src.cy,
+            scaled_origin.x, scaled_origin.y, scaled_origin.x + scaled.cx, scaled_origin.y + scaled.cy,
+            GL_COLOR_BUFFER_BIT, ctx->fs_hack_integer ? GL_NEAREST : GL_LINEAR );
+    //HACK
+    if ( draw_buffer == GL_FRONT )
+        pglXSwapBuffers(gdi_display, gl->drawable);
+
+    if(gl->has_scissor_indexed){
+        opengl_funcs.ext.p_glScissorIndexedv(0, prev_scissor);
+    }else{
+        opengl_funcs.gl.p_glScissor(prev_scissor[0], prev_scissor[1],
+                prev_scissor[2], prev_scissor[3]);
+    }
+
+    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, prev_draw_fbo );
+    pglBindFramebuffer( GL_READ_FRAMEBUFFER, prev_read_fbo );
+}
+
 static void wglFinish(void)
 {
     struct x11drv_escape_present_drawable escape;
@@ -1959,6 +2440,18 @@ static void wglFinish(void)
         default: break;
         }
         sync_context(ctx);
+
+        if (gl->fs_hack) {
+            ctx->fs_hack = gl->fs_hack;
+            if(!gl->fs_hack_context_set_up)
+                fs_hack_setup_context( ctx, gl );
+            if(!gl->fs_hack_did_swapbuf)
+                fs_hack_blit_framebuffer( gl, GL_FRONT );
+        }else if(gl->fs_hack_context_set_up){
+            ctx->fs_hack = FALSE;
+            fs_hack_setup_context(ctx, gl);
+        }
+
         release_gl_drawable( gl );
     }

@@ -1985,6 +2478,18 @@ static void wglFlush(void)
         default: break;
         }
         sync_context(ctx);
+
+        if (gl->fs_hack) {
+            ctx->fs_hack = gl->fs_hack;
+            if(!gl->fs_hack_context_set_up)
+                fs_hack_setup_context( ctx, gl );
+            if(!gl->fs_hack_did_swapbuf)
+                fs_hack_blit_framebuffer( gl, GL_FRONT );
+        }else if(gl->fs_hack_context_set_up){
+            ctx->fs_hack = FALSE;
+            fs_hack_setup_context(ctx, gl);
+        }
+
         release_gl_drawable( gl );
     }

@@ -3363,6 +3868,16 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
             target_sbc = pglXSwapBuffersMscOML( gdi_display, gl->drawable, 0, 0, 0 );
             break;
         }
+        if (gl->fs_hack){
+            ctx->fs_hack = gl->fs_hack;
+            if(!gl->fs_hack_context_set_up)
+                fs_hack_setup_context( ctx, gl );
+            fs_hack_blit_framebuffer( gl, GL_BACK );
+            gl->fs_hack_did_swapbuf = TRUE;
+        }else if(gl->fs_hack_context_set_up){
+            ctx->fs_hack = FALSE;
+            fs_hack_setup_context(ctx, gl);
+        }
         pglXSwapBuffers(gdi_display, gl->drawable);
         break;
     }
diff --git a/dlls/winex11.drv/settings.c b/dlls/winex11.drv/settings.c
index cea7ebbc6b7..5af96dfb5be 100644
--- a/dlls/winex11.drv/settings.c
+++ b/dlls/winex11.drv/settings.c
@@ -36,15 +36,6 @@

 WINE_DEFAULT_DEBUG_CHANNEL(x11settings);

-struct x11drv_display_setting
-{
-    ULONG_PTR id;
-    BOOL placed;
-    RECT new_rect;
-    RECT desired_rect;
-    DEVMODEW desired_mode;
-};
-
 struct x11drv_display_depth
 {
     struct list entry;
@@ -88,6 +79,11 @@ void X11DRV_Settings_SetHandler(const struct x11drv_settings_handler *new_handle
     }
 }

+struct x11drv_settings_handler X11DRV_Settings_GetHandler(void)
+{
+    return handler;
+}
+
 /***********************************************************************
  * Default handlers if resolution switching is not enabled
  *
@@ -170,7 +166,6 @@ static LONG nores_set_current_mode(ULONG_PTR id, DEVMODEW *mode)
     return DISP_CHANGE_SUCCESSFUL;
 }

-/* default handler only gets the current X desktop resolution */
 void X11DRV_Settings_Init(void)
 {
     struct x11drv_settings_handler nores_handler;
@@ -184,6 +179,7 @@ void X11DRV_Settings_Init(void)
     nores_handler.free_modes = nores_free_modes;
     nores_handler.get_current_mode = nores_get_current_mode;
     nores_handler.set_current_mode = nores_set_current_mode;
+    nores_handler.convert_coordinates = NULL;
     X11DRV_Settings_SetHandler(&nores_handler);
 }

@@ -367,7 +363,7 @@ BOOL get_primary_adapter(WCHAR *name)
     return FALSE;
 }

-static int mode_compare(const void *p1, const void *p2)
+int mode_compare(const void *p1, const void *p2)
 {
     DWORD a_width, a_height, b_width, b_height;
     const DEVMODEW *a = p1, *b = p2;
@@ -832,7 +828,6 @@ static POINT get_placement_offset(const struct x11drv_display_setting *displays,

 static void place_all_displays(struct x11drv_display_setting *displays, INT display_count)
 {
-    INT left_most = INT_MAX, top_most = INT_MAX;
     INT placing_idx, display_idx;
     POINT min_offset, offset;

@@ -867,15 +862,6 @@ static void place_all_displays(struct x11drv_display_setting *displays, INT disp
     {
         displays[display_idx].desired_mode.u1.s2.dmPosition.x = displays[display_idx].new_rect.left;
         displays[display_idx].desired_mode.u1.s2.dmPosition.y = displays[display_idx].new_rect.top;
-        left_most = min(left_most, displays[display_idx].new_rect.left);
-        top_most = min(top_most, displays[display_idx].new_rect.top);
-    }
-
-    /* Convert virtual screen coordinates to root coordinates */
-    for (display_idx = 0; display_idx < display_count; ++display_idx)
-    {
-        displays[display_idx].desired_mode.u1.s2.dmPosition.x -= left_most;
-        displays[display_idx].desired_mode.u1.s2.dmPosition.y -= top_most;
     }
 }

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 1a077d9323e..6bfbb9dc7bc 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -610,6 +610,64 @@ static VkSurfaceKHR X11DRV_wine_get_native_surface(VkSurfaceKHR surface)
     return x11_surface->surface;
 }

+static VkBool32 X11DRV_query_fs_hack(VkSurfaceKHR surface, VkExtent2D *real_sz, VkExtent2D *user_sz,
+        VkRect2D *dst_blit, VkFilter *filter)
+{
+    struct wine_vk_surface *x11_surface = surface_from_handle(surface);
+    HMONITOR monitor;
+    HWND hwnd;
+
+    if (wm_is_steamcompmgr(gdi_display))
+        return VK_FALSE;
+
+    if (XFindContext(gdi_display, x11_surface->window, winContext, (char **)&hwnd) != 0)
+    {
+        ERR("Failed to find hwnd context\n");
+        return VK_FALSE;
+    }
+
+    monitor = fs_hack_monitor_from_hwnd(hwnd);
+    if(fs_hack_enabled(monitor)){
+        RECT real_rect = fs_hack_real_mode(monitor);
+        RECT user_rect = fs_hack_current_mode(monitor);
+        SIZE scaled = fs_hack_get_scaled_screen_size(monitor);
+        POINT scaled_origin;
+
+        scaled_origin.x = user_rect.left;
+        scaled_origin.y = user_rect.top;
+        fs_hack_point_user_to_real(&scaled_origin);
+        scaled_origin.x -= real_rect.left;
+        scaled_origin.y -= real_rect.top;
+
+        TRACE("real_rect:%s user_rect:%s scaled:%dx%d scaled_origin:%s\n", wine_dbgstr_rect(&real_rect),
+              wine_dbgstr_rect(&user_rect), scaled.cx, scaled.cy, wine_dbgstr_point(&scaled_origin));
+
+        if(real_sz){
+            real_sz->width = real_rect.right - real_rect.left;
+            real_sz->height = real_rect.bottom - real_rect.top;
+        }
+
+        if(user_sz){
+            user_sz->width = user_rect.right - user_rect.left;
+            user_sz->height = user_rect.bottom - user_rect.top;
+        }
+
+        if(dst_blit){
+            dst_blit->offset.x = scaled_origin.x;
+            dst_blit->offset.y = scaled_origin.y;
+            dst_blit->extent.width = scaled.cx;
+            dst_blit->extent.height = scaled.cy;
+        }
+
+        if(filter)
+            *filter = fs_hack_is_integer() ? VK_FILTER_NEAREST : VK_FILTER_LINEAR;
+
+        return VK_TRUE;
+    }
+
+    return VK_FALSE;
+}
+
 static const struct vulkan_funcs vulkan_funcs =
 {
     X11DRV_vkCreateInstance,
@@ -634,6 +692,7 @@ static const struct vulkan_funcs vulkan_funcs =
     X11DRV_vkQueuePresentKHR,

     X11DRV_wine_get_native_surface,
+    X11DRV_query_fs_hack,
 };

 static void *X11DRV_get_vk_device_proc_addr(const char *name)
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index c6b23d857af..a60001aec6d 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -475,6 +475,11 @@ static void sync_window_region( struct x11drv_win_data *data, HRGN win_region )
     HRGN hrgn = win_region;

     if (!data->whole_window) return;
+
+    if(data->fs_hack){
+        ERR("shaped windows with fs hack not supported, things may go badly\n");
+    }
+
     data->shaped = FALSE;

     if (IsRectEmpty( &data->window_rect ))  /* set an empty shape */
@@ -1144,6 +1149,7 @@ void update_user_time( Time time )
 void update_net_wm_states( struct x11drv_win_data *data )
 {
     DWORD i, style, ex_style, new_state = 0;
+    HMONITOR monitor;
     unsigned long net_wm_bypass_compositor = 0;

     if (!data->managed) return;
@@ -1152,21 +1158,38 @@ void update_net_wm_states( struct x11drv_win_data *data )
     style = GetWindowLongW( data->hwnd, GWL_STYLE );
     if (style & WS_MINIMIZE)
         new_state |= data->net_wm_state & ((1 << NET_WM_STATE_FULLSCREEN)|(1 << NET_WM_STATE_MAXIMIZED));
-    if (is_window_rect_full_screen( &data->whole_rect ))
+    monitor = fs_hack_monitor_from_hwnd( data->hwnd );
+    if ((!data->fs_hack || fs_hack_enabled( monitor )) && is_window_rect_full_screen( &data->whole_rect ))
     {
         if ((style & WS_MAXIMIZE) && (style & WS_CAPTION) == WS_CAPTION)
             new_state |= (1 << NET_WM_STATE_MAXIMIZED);
         else if (!(style & WS_MINIMIZE))
         {
-            net_wm_bypass_compositor = 1;
-            new_state |= (1 << NET_WM_STATE_FULLSCREEN);
+            if (!wm_is_steamcompmgr(data->display) || !fs_hack_enabled(monitor))
+            {
+                /* when fs hack is enabled, we don't want steamcompmgr to resize the window to be fullscreened */
+                net_wm_bypass_compositor = 1;
+                new_state |= (1 << NET_WM_STATE_FULLSCREEN);
+            }
         }
     }
     else if (style & WS_MAXIMIZE)
         new_state |= (1 << NET_WM_STATE_MAXIMIZED);

     ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
-    if (ex_style & WS_EX_TOPMOST)
+    if ((ex_style & WS_EX_TOPMOST) &&
+            /* mutter < 3.31 has a bug where a FULLSCREEN and ABOVE window when
+             * minimized will incorrectly show a black window.  this workaround
+             * should be removed when the fix is widely distributed.  see
+             * mutter issue #306. */
+            !(wm_is_mutter(data->display) && (new_state & (1 << NET_WM_STATE_FULLSCREEN))) &&
+
+            /* KDE refuses to allow alt-tabbing out of fullscreen+above
+             * windows. Other WMs (XFCE) don't make fullscreen (without above)
+             * windows appear above their panels. KDE still does the right
+             * thing with fullscreen-only windows, so let's comprimise by not
+             * setting above on KDE. */
+            !wm_is_kde(data->display))
         new_state |= (1 << NET_WM_STATE_ABOVE);
     if (!data->add_taskbar)
     {
@@ -1213,6 +1236,12 @@ void update_net_wm_states( struct x11drv_win_data *data )
                    i, data->hwnd, data->whole_window,
                    (new_state & (1 << i)) != 0, (data->net_wm_state & (1 << i)) != 0 );

+            if(i == NET_WM_STATE_FULLSCREEN)
+            {
+                data->pending_fullscreen = (new_state & (1 << i)) != 0;
+                TRACE("set pending_fullscreen to: %u\n", data->pending_fullscreen);
+            }
+
             xev.xclient.data.l[0] = (new_state & (1 << i)) ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;
             xev.xclient.data.l[1] = X11DRV_Atoms[net_wm_state_atoms[i] - FIRST_XATOM];
             xev.xclient.data.l[2] = ((net_wm_state_atoms[i] == XATOM__NET_WM_STATE_MAXIMIZED_VERT) ?
@@ -1458,8 +1487,19 @@ static void sync_window_position( struct x11drv_win_data *data,
     /* resizing a managed maximized window is not allowed */
     if (!(style & WS_MAXIMIZE) || !data->managed)
     {
-        changes.width = data->whole_rect.right - data->whole_rect.left;
-        changes.height = data->whole_rect.bottom - data->whole_rect.top;
+        if(data->fs_hack){
+            HMONITOR monitor;
+            RECT rect;
+
+            monitor = fs_hack_monitor_from_hwnd(data->hwnd);
+            rect = fs_hack_real_mode(monitor);
+            changes.width = rect.right - rect.left;
+            changes.height = rect.bottom - rect.top;
+            TRACE("change width:%d height:%d\n", changes.width, changes.height);
+        }else{
+            changes.width = data->whole_rect.right - data->whole_rect.left;
+            changes.height = data->whole_rect.bottom - data->whole_rect.top;
+        }
         /* if window rect is empty force size to 1x1 */
         if (changes.width <= 0 || changes.height <= 0) changes.width = changes.height = 1;
         if (changes.width > 65535) changes.width = 65535;
@@ -1542,6 +1582,20 @@ static void sync_client_position( struct x11drv_win_data *data,
     if (changes.width  != old_client_rect->right - old_client_rect->left) mask |= CWWidth;
     if (changes.height != old_client_rect->bottom - old_client_rect->top) mask |= CWHeight;

+    if(data->fs_hack){
+        HMONITOR monitor;
+        RECT rect;
+
+        monitor = fs_hack_monitor_from_hwnd(data->hwnd);
+        rect = fs_hack_real_mode(monitor);
+        changes.x = 0;
+        changes.y = 0;
+        changes.width = rect.right - rect.left;
+        changes.height = rect.bottom - rect.top;
+        mask = CWX | CWY | CWWidth | CWHeight;
+        TRACE( "x:%d y:%d width:%d height:%d\n", changes.x, changes.y, changes.width, changes.height );
+    }
+
     if (mask)
     {
         TRACE( "setting client win %lx pos %d,%d,%dx%d changes=%x\n",
@@ -1713,6 +1767,16 @@ Window create_client_window( HWND hwnd, const XVisualInfo *visual )
     cx = min( max( 1, data->client_rect.right - data->client_rect.left ), 65535 );
     cy = min( max( 1, data->client_rect.bottom - data->client_rect.top ), 65535 );

+    if(data->fs_hack){
+        HMONITOR monitor = fs_hack_monitor_from_hwnd(hwnd);
+        RECT rect = fs_hack_real_mode(monitor);
+        cx = rect.right - rect.left;
+        cy = rect.bottom - rect.top;
+
+        TRACE("width:%d height:%d\n", cx, cy);
+    }
+
+    TRACE("setting client rect: %u, %u x %ux%u\n", x, y, cx, cy);
     ret = data->client_window = XCreateWindow( gdi_display,
                                                data->whole_window ? data->whole_window : dummy_parent,
                                                x, y, cx, cy, 0, default_visual.depth, InputOutput,
@@ -1721,6 +1785,8 @@ Window create_client_window( HWND hwnd, const XVisualInfo *visual )
     if (data->client_window)
     {
         XSaveContext( data->display, data->client_window, winContext, (char *)data->hwnd );
+        /* Save to gdi_display as well for fullscreen hack, needed in X11DRV_query_fs_hack() */
+        XSaveContext( gdi_display, data->client_window, winContext, (char *)data->hwnd );
         XMapWindow( gdi_display, data->client_window );
         XSync( gdi_display, False );
         if (data->whole_window) XSelectInput( data->display, data->client_window, ExposureMask );
@@ -1765,11 +1831,25 @@ static void create_whole_window( struct x11drv_win_data *data )

     mask = get_window_attributes( data, &attr );

+    attr.background_pixel = XBlackPixel(data->display, data->vis.screen);
+    mask |= CWBackPixel;
+
     if (!(cx = data->whole_rect.right - data->whole_rect.left)) cx = 1;
     else if (cx > 65535) cx = 65535;
     if (!(cy = data->whole_rect.bottom - data->whole_rect.top)) cy = 1;
     else if (cy > 65535) cy = 65535;

+    if(data->fs_hack){
+        RECT rect = {0, 0, 0, 0};
+        HMONITOR monitor;
+
+        monitor = fs_hack_monitor_from_hwnd(data->hwnd);
+        rect = fs_hack_real_mode(monitor);
+        cx = rect.right - rect.left;
+        cy = rect.bottom - rect.top;
+        TRACE("width:%d height:%d\n", cx, cy);
+    }
+
     pos = virtual_screen_to_root( data->whole_rect.left, data->whole_rect.top );
     data->whole_window = XCreateWindow( data->display, root_window, pos.x, pos.y,
                                         cx, cy, 0, data->vis.depth, InputOutput,
@@ -2540,9 +2620,45 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
     DWORD flags;
     COLORREF key;
     BOOL layered = GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED;
+    HMONITOR monitor;

     if (!data && !(data = X11DRV_create_win_data( hwnd, window_rect, client_rect ))) return TRUE;

+    monitor = fs_hack_monitor_from_rect(window_rect);
+    if(!wm_is_steamcompmgr(data->display) && !data->fs_hack && fs_hack_enabled(monitor) &&
+            fs_hack_matches_current_mode(monitor,
+                window_rect->right - window_rect->left,
+                window_rect->bottom - window_rect->top)){
+        RECT real_rect = fs_hack_real_mode(monitor);
+        RECT user_rect = fs_hack_current_mode(monitor);
+        POINT tl = virtual_screen_to_root(user_rect.left, user_rect.top);
+
+        TRACE("Enabling fs hack for %p, resizing the window to (%u,%u)-(%u,%u)\n", hwnd, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+        data->fs_hack = TRUE;
+        if(data->whole_window)
+            XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+        if(data->client_window)
+            XMoveResizeWindow(data->display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+    }else if(data->fs_hack && (!fs_hack_enabled(monitor) ||
+            !fs_hack_matches_current_mode(monitor,
+                window_rect->right - window_rect->left,
+                window_rect->bottom - window_rect->top))){
+        TRACE("Disabling fs hack for %p\n", hwnd);
+        data->fs_hack = FALSE;
+        if(data->whole_window)
+            XMoveResizeWindow(data->display, data->whole_window,
+                    window_rect->left, window_rect->top,
+                    window_rect->right - window_rect->left,
+                    window_rect->bottom - window_rect->top);
+        if(data->client_window){
+            XMoveResizeWindow(data->display, data->client_window,
+                    data->client_rect.left - data->whole_rect.left,
+                    data->client_rect.top - data->whole_rect.top,
+                    data->client_rect.right - data->client_rect.left,
+                    data->client_rect.bottom - data->client_rect.top);
+        }
+    }
+
     /* check if we need to switch the window to managed */
     if (!data->managed && data->whole_window && is_window_managed( hwnd, swp_flags, window_rect ))
     {
@@ -2678,6 +2794,9 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
         return;
     }

+    if (data->fs_hack)
+        sync_gl_drawable( hwnd, FALSE );
+
     /* check if we are currently processing an event relevant to this window */
     event_type = 0;
     if (thread_data &&
@@ -2772,6 +2891,7 @@ UINT CDECL X11DRV_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp )
     DWORD style = GetWindowLongW( hwnd, GWL_STYLE );
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     struct x11drv_win_data *data = get_win_data( hwnd );
+    HMONITOR monitor;

     if (!data || !data->whole_window) goto done;
     if (style & WS_MINIMIZE)
@@ -2801,7 +2921,25 @@ UINT CDECL X11DRV_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp )
                   &root, &x, &y, &width, &height, &border, &depth );
     XTranslateCoordinates( thread_data->display, data->whole_window, root, 0, 0, &x, &y, &top );
     pos = root_to_virtual_screen( x, y );
-    X11DRV_X_to_window_rect( data, rect, pos.x, pos.y, width, height );
+    monitor = fs_hack_monitor_from_hwnd(hwnd);
+    if (data->fs_hack ||
+            (fs_hack_enabled(monitor) &&
+             fs_hack_matches_current_mode(monitor,
+                 rect->right - rect->left,
+                 rect->bottom - rect->top)))
+    {
+        MONITORINFO monitor_info;
+
+        monitor_info.cbSize = sizeof(monitor_info);
+        GetMonitorInfoW( monitor, &monitor_info );
+        X11DRV_X_to_window_rect( data, rect, monitor_info.rcMonitor.left, monitor_info.rcMonitor.top,
+                                 monitor_info.rcMonitor.right - monitor_info.rcMonitor.left,
+                                 monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top );
+    }
+    else
+    {
+        X11DRV_X_to_window_rect( data, rect, pos.x, pos.y, width, height );
+    }
     swp &= ~(SWP_NOMOVE | SWP_NOCLIENTMOVE | SWP_NOSIZE | SWP_NOCLIENTSIZE);

 done:
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 213143014a7..26843c830eb 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -443,6 +443,7 @@ extern BOOL private_color_map DECLSPEC_HIDDEN;
 extern int primary_monitor DECLSPEC_HIDDEN;
 extern int copy_default_colors DECLSPEC_HIDDEN;
 extern int alloc_system_colors DECLSPEC_HIDDEN;
+extern int limit_number_of_resolutions DECLSPEC_HIDDEN;
 extern int xrender_error_base DECLSPEC_HIDDEN;
 extern int xfixes_event_base DECLSPEC_HIDDEN;
 extern HMODULE x11drv_module DECLSPEC_HIDDEN;
@@ -626,6 +627,7 @@ struct x11drv_win_data
     BOOL        skip_taskbar : 1; /* does window should be deleted from taskbar */
     BOOL        add_taskbar : 1; /* does window should be added to taskbar regardless of style */
     BOOL        pending_fullscreen : 1;
+    BOOL        fs_hack : 1;
     ULONGLONG   take_focus_back;
     int         wm_state;       /* current value of the WM_STATE property */
     DWORD       net_wm_state;   /* bit mask of active x11drv_net_wm_state values */
@@ -670,6 +672,23 @@ extern BOOL wm_is_mutter(Display *) DECLSPEC_HIDDEN;
 extern BOOL wm_is_steamcompmgr(Display *) DECLSPEC_HIDDEN;

 extern void set_wm_hints( struct x11drv_win_data *data ) DECLSPEC_HIDDEN;
+extern BOOL fs_hack_enabled(HMONITOR monitor) DECLSPEC_HIDDEN;
+extern BOOL fs_hack_mapping_required(HMONITOR monitor) DECLSPEC_HIDDEN;
+extern BOOL fs_hack_is_integer(void) DECLSPEC_HIDDEN;
+extern HMONITOR fs_hack_monitor_from_hwnd(HWND hwnd) DECLSPEC_HIDDEN;
+extern HMONITOR fs_hack_monitor_from_rect(const RECT *rect) DECLSPEC_HIDDEN;
+extern BOOL fs_hack_matches_current_mode(HMONITOR monitor, INT width, INT height) DECLSPEC_HIDDEN;
+extern RECT fs_hack_current_mode(HMONITOR monitor) DECLSPEC_HIDDEN;
+extern RECT fs_hack_real_mode(HMONITOR monitor) DECLSPEC_HIDDEN;
+extern void fs_hack_point_user_to_real(POINT *pos) DECLSPEC_HIDDEN;
+extern void fs_hack_point_real_to_user(POINT *pos) DECLSPEC_HIDDEN;
+extern void fs_hack_rect_user_to_real(RECT *rect) DECLSPEC_HIDDEN;
+extern void fs_hack_rgndata_user_to_real(RGNDATA *data) DECLSPEC_HIDDEN;
+extern double fs_hack_get_user_to_real_scale(HMONITOR) DECLSPEC_HIDDEN;
+extern SIZE fs_hack_get_scaled_screen_size(HMONITOR monitor) DECLSPEC_HIDDEN;
+extern RECT fs_hack_get_real_virtual_screen(void) DECLSPEC_HIDDEN;
+extern void fs_hack_init(void) DECLSPEC_HIDDEN;
+extern int mode_compare(const void *p1, const void *p2) DECLSPEC_HIDDEN;

 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 {
@@ -718,6 +737,16 @@ extern void xinerama_init( unsigned int width, unsigned int height ) DECLSPEC_HI
 #define DEPTH_COUNT 3
 extern const unsigned int *depths DECLSPEC_HIDDEN;

+struct x11drv_display_setting
+{
+    ULONG_PTR id;
+    BOOL placed;
+    RECT new_rect;
+    RECT old_rect;
+    RECT desired_rect;
+    DEVMODEW desired_mode;
+};
+
 /* Required functions for changing and enumerating display settings */
 struct x11drv_settings_handler
 {
@@ -761,9 +790,14 @@ struct x11drv_settings_handler
      *
      * Return DISP_CHANGE_*, same as ChangeDisplaySettingsExW() return values */
     LONG (*set_current_mode)(ULONG_PTR id, DEVMODEW *mode);
+
+    /* convert_coordinates() will be called to convert virtual screen coordinates to driver specific coordinates.
+     * This function is optional and can be NULL if driver don't need to convert coordinates */
+    void (*convert_coordinates)(struct x11drv_display_setting *displays, UINT display_count);
 };

 extern void X11DRV_Settings_SetHandler(const struct x11drv_settings_handler *handler) DECLSPEC_HIDDEN;
+extern struct x11drv_settings_handler X11DRV_Settings_GetHandler(void) DECLSPEC_HIDDEN;

 extern void X11DRV_init_desktop( Window win, unsigned int width, unsigned int height ) DECLSPEC_HIDDEN;
 extern void X11DRV_resize_desktop(BOOL) DECLSPEC_HIDDEN;
@@ -825,6 +859,7 @@ extern HANDLE get_display_device_init_mutex(void) DECLSPEC_HIDDEN;
 extern BOOL get_host_primary_gpu(struct gdi_gpu *gpu) DECLSPEC_HIDDEN;
 extern void release_display_device_init_mutex(HANDLE) DECLSPEC_HIDDEN;
 extern void X11DRV_DisplayDevices_SetHandler(const struct x11drv_display_device_handler *handler) DECLSPEC_HIDDEN;
+extern struct x11drv_display_device_handler X11DRV_DisplayDevices_GetHandler(void) DECLSPEC_HIDDEN;
 extern void X11DRV_DisplayDevices_Init(BOOL force) DECLSPEC_HIDDEN;
 extern void X11DRV_DisplayDevices_RegisterEventHandlers(void) DECLSPEC_HIDDEN;
 extern void X11DRV_DisplayDevices_Update(BOOL) DECLSPEC_HIDDEN;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 1e7c140641f..c9ca46364cd 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -63,7 +63,7 @@ Colormap default_colormap = None;
 XPixmapFormatValues **pixmap_formats;
 unsigned int screen_bpp;
 Window root_window;
-BOOL usexvidmode = TRUE;
+BOOL usexvidmode = FALSE;
 BOOL usexrandr = TRUE;
 BOOL usexcomposite = TRUE;
 BOOL use_xfixes = FALSE;
@@ -83,6 +83,7 @@ BOOL client_side_with_render = TRUE;
 BOOL shape_layered_windows = TRUE;
 int copy_default_colors = 128;
 int alloc_system_colors = 256;
+int limit_number_of_resolutions = 0;
 DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 int xrender_error_base = 0;
 int xfixes_event_base = 0;
@@ -456,6 +457,9 @@ static void setup_options(void)
     if (!get_config_key( hkey, appkey, "AllocSystemColors", buffer, sizeof(buffer) ))
         alloc_system_colors = atoi(buffer);

+    if (!get_config_key( hkey, appkey, "LimitNumberOfResolutions", buffer, sizeof(buffer) ))
+        limit_number_of_resolutions = atoi(buffer);
+
     get_config_key( hkey, appkey, "InputStyle", input_style, sizeof(input_style) );

     if (appkey) RegCloseKey( appkey );
@@ -706,6 +710,8 @@ static BOOL process_attach(void)
     X11DRV_InitMouse( gdi_display );
     if (use_xim) use_xim = X11DRV_InitXIM( input_style );

+    fs_hack_init();
+
     init_user_driver();
     X11DRV_DisplayDevices_Init(FALSE);
     return TRUE;
diff --git a/dlls/winex11.drv/xrandr.c b/dlls/winex11.drv/xrandr.c
index fb7a4405a1e..0a080ea6be8 100644
--- a/dlls/winex11.drv/xrandr.c
+++ b/dlls/winex11.drv/xrandr.c
@@ -1647,6 +1647,24 @@ static LONG xrandr14_set_current_mode( ULONG_PTR id, DEVMODEW *mode )

 #endif

+static void xrandr14_convert_coordinates( struct x11drv_display_setting *displays, UINT display_count )
+{
+    INT left_most = INT_MAX, top_most = INT_MAX;
+    UINT display_idx;
+
+    for (display_idx = 0; display_idx < display_count; ++display_idx)
+    {
+        left_most = min( left_most, displays[display_idx].desired_mode.u1.s2.dmPosition.x );
+        top_most = min( top_most, displays[display_idx].desired_mode.u1.s2.dmPosition.y );
+    }
+
+    for (display_idx = 0; display_idx < display_count; ++display_idx)
+    {
+        displays[display_idx].desired_mode.u1.s2.dmPosition.x -= left_most;
+        displays[display_idx].desired_mode.u1.s2.dmPosition.y -= top_most;
+    }
+}
+
 void X11DRV_XRandR_Init(void)
 {
     struct x11drv_display_device_handler display_handler;
@@ -1675,6 +1693,7 @@ void X11DRV_XRandR_Init(void)
     settings_handler.free_modes = xrandr10_free_modes;
     settings_handler.get_current_mode = xrandr10_get_current_mode;
     settings_handler.set_current_mode = xrandr10_set_current_mode;
+    settings_handler.convert_coordinates = NULL;
     X11DRV_Settings_SetHandler( &settings_handler );

 #ifdef HAVE_XRRGETPROVIDERRESOURCES
@@ -1733,6 +1752,7 @@ void X11DRV_XRandR_Init(void)
         settings_handler.free_modes = xrandr14_free_modes;
         settings_handler.get_current_mode = xrandr14_get_current_mode;
         settings_handler.set_current_mode = xrandr14_set_current_mode;
+        settings_handler.convert_coordinates = xrandr14_convert_coordinates;
         X11DRV_Settings_SetHandler( &settings_handler );
     }
 #endif
diff --git a/dlls/winex11.drv/xrender.c b/dlls/winex11.drv/xrender.c
index 92dc35fa9e1..d43d67c02cf 100644
--- a/dlls/winex11.drv/xrender.c
+++ b/dlls/winex11.drv/xrender.c
@@ -475,6 +475,7 @@ static void update_xrender_clipping( struct xrender_physdev *dev, HRGN rgn )
     }
     else if ((data = X11DRV_GetRegionData( rgn, 0 )))
     {
+        fs_hack_rgndata_user_to_real(data);
         pXRenderSetPictureClipRectangles( gdi_display, dev->pict,
                                           dev->x11dev->dc_rect.left, dev->x11dev->dc_rect.top,
                                           (XRectangle *)data->Buffer, data->rdh.nCount );
@@ -1461,13 +1462,77 @@ static void multiply_alpha( Picture pict, XRenderPictFormat *format, int alpha,
     XFreePixmap( gdi_display, mask_pixmap );
 }

+/* if we are letterboxing, draw black bars */
+static void fs_hack_draw_black_bars( HMONITOR monitor, Picture dst_pict )
+{
+    static const XRenderColor black = { 0, 0, 0, 0xffff };
+    POINT tl, br;   /* top-left / bottom-right */
+    RECT user_rect = fs_hack_current_mode(monitor);
+    RECT real_rect = fs_hack_real_mode(monitor);
+    SIZE scaled_screen = fs_hack_get_scaled_screen_size(monitor);
+    XRenderPictureAttributes pa;
+
+    /* first unclip the picture, so that we can actually draw them */
+    pa.clip_mask = None;
+    pXRenderChangePicture( gdi_display, dst_pict, CPClipMask, &pa );
+
+    tl.x = user_rect.left;
+    tl.y = user_rect.top;
+    fs_hack_point_user_to_real(&tl);
+    tl.x = tl.x - real_rect.left;
+    tl.y = tl.y - real_rect.top;
+    br.x = tl.x + scaled_screen.cx;
+    br.y = tl.y + scaled_screen.cy;
+
+    if (tl.x > 0)
+    {
+        /* black bars left & right */
+        pXRenderFillRectangle(gdi_display, PictOpSrc, dst_pict, &black,
+                0, 0, /* x, y */
+                tl.x, real_rect.bottom - real_rect.top);    /* w, h */
+        pXRenderFillRectangle(gdi_display, PictOpSrc, dst_pict, &black,
+                br.x, 0,
+                real_rect.right - real_rect.left - br.x, real_rect.bottom - real_rect.top);
+    }
+    else if (tl.y > 0)
+    {
+        /* black bars top & bottom */
+        pXRenderFillRectangle(gdi_display, PictOpSrc, dst_pict, &black,
+                0, 0,
+                real_rect.right - real_rect.left, tl.y);
+        pXRenderFillRectangle(gdi_display, PictOpSrc, dst_pict, &black,
+                0, br.y,
+                real_rect.right - real_rect.left, real_rect.bottom - real_rect.top - br.y);
+    }
+}
+
 /* Helper function for (stretched) blitting using xrender */
-static void xrender_blit( int op, Picture src_pict, Picture mask_pict, Picture dst_pict,
+static void xrender_blit( struct xrender_physdev *physdev,
+                          int op, Picture src_pict, Picture mask_pict, Picture dst_pict,
                           int x_src, int y_src, int width_src, int height_src,
                           int x_dst, int y_dst, int width_dst, int height_dst,
                           double xscale, double yscale )
 {
     int x_offset, y_offset;
+    HMONITOR monitor;
+
+    monitor = fs_hack_monitor_from_hwnd(WindowFromDC(physdev->dev.hdc));
+    if (fs_hack_mapping_required(monitor))
+    {
+        double user_to_real_scale;
+        POINT p;
+        p.x = x_dst;
+        p.y = y_dst;
+        fs_hack_point_user_to_real(&p);
+        x_dst = p.x;
+        y_dst = p.y;
+
+        user_to_real_scale = fs_hack_get_user_to_real_scale(monitor);
+        width_dst *= user_to_real_scale;
+        height_dst *= user_to_real_scale;
+        xscale /= user_to_real_scale;
+        yscale /= user_to_real_scale;
+    }

     if (width_src < 0)
     {
@@ -1508,6 +1573,9 @@ static void xrender_blit( int op, Picture src_pict, Picture mask_pict, Picture d
     }
     pXRenderComposite( gdi_display, op, src_pict, mask_pict, dst_pict,
                        x_offset, y_offset, 0, 0, x_dst, y_dst, width_dst, height_dst );
+
+    if (fs_hack_mapping_required( monitor ))
+        fs_hack_draw_black_bars( monitor, dst_pict );
 }

 /* Helper function for (stretched) mono->color blitting using xrender */
@@ -1664,7 +1732,7 @@ static void xrender_stretch_blit( struct xrender_physdev *physdev_src, struct xr
         if (physdev_dst->pict_format->depth == 32 && physdev_src->pict_format->depth < 32)
             mask_pict = get_no_alpha_mask();

-        xrender_blit( PictOpSrc, src_pict, mask_pict, dst_pict,
+        xrender_blit( physdev_dst, PictOpSrc, src_pict, mask_pict, dst_pict,
                       physdev_src->x11dev->dc_rect.left + src->x,
                       physdev_src->x11dev->dc_rect.top + src->y,
                       src->width, src->height, x_dst, y_dst, dst->width, dst->height, xscale, yscale );
@@ -1688,6 +1756,7 @@ static void xrender_put_image( Pixmap src_pixmap, Picture src_pict, Picture mask
         RGNDATA *clip_data = NULL;

         if (clip) clip_data = X11DRV_GetRegionData( clip, 0 );
+        fs_hack_rgndata_user_to_real(clip_data);
         x_dst = dst->x;
         y_dst = dst->y;
         dst_pict = pXRenderCreatePicture( gdi_display, drawable, dst_format, 0, NULL );
@@ -1710,7 +1779,7 @@ static void xrender_put_image( Pixmap src_pixmap, Picture src_pict, Picture mask
     }
     else xscale = yscale = 1;  /* no scaling needed with a repeating source */

-    xrender_blit( PictOpSrc, src_pict, mask_pict, dst_pict, src->x, src->y, src->width, src->height,
+    xrender_blit( physdev, PictOpSrc, src_pict, mask_pict, dst_pict, src->x, src->y, src->width, src->height,
                   x_dst, y_dst, dst->width, dst->height, xscale, yscale );

     if (drawable) pXRenderFreePicture( gdi_display, dst_pict );
@@ -1726,6 +1795,11 @@ static BOOL CDECL xrenderdrv_StretchBlt( PHYSDEV dst_dev, struct bitblt_coords *
     struct xrender_physdev *physdev_dst = get_xrender_dev( dst_dev );
     struct xrender_physdev *physdev_src = get_xrender_dev( src_dev );
     BOOL stretch = (src->width != dst->width) || (src->height != dst->height);
+    HMONITOR monitor;
+
+    TRACE("src %d,%d %dx%d vis=%s  dst %d,%d %dx%d vis=%s  rop=%06x\n",
+          src->x, src->y, src->width, src->height, wine_dbgstr_rect(&src->visrect),
+          dst->x, dst->y, dst->width, dst->height, wine_dbgstr_rect(&dst->visrect), rop );

     if (src_dev->funcs != dst_dev->funcs)
     {
@@ -1737,6 +1811,10 @@ static BOOL CDECL xrenderdrv_StretchBlt( PHYSDEV dst_dev, struct bitblt_coords *
     if (physdev_dst->format == WXR_FORMAT_MONO && physdev_src->format != WXR_FORMAT_MONO)
         goto x11drv_fallback;

+    monitor = fs_hack_monitor_from_hwnd(WindowFromDC(dst_dev->hdc));
+    if (fs_hack_mapping_required(monitor))
+        stretch = TRUE;
+
     /* if not stretching, we only need to handle format conversion */
     if (!stretch && physdev_dst->format == physdev_src->format) goto x11drv_fallback;

@@ -1755,8 +1833,20 @@ static BOOL CDECL xrenderdrv_StretchBlt( PHYSDEV dst_dev, struct bitblt_coords *
         tmpGC = XCreateGC( gdi_display, physdev_dst->x11dev->drawable, 0, NULL );
         XSetSubwindowMode( gdi_display, tmpGC, IncludeInferiors );
         XSetGraphicsExposures( gdi_display, tmpGC, False );
-        tmp_pixmap = XCreatePixmap( gdi_display, root_window, tmp.visrect.right - tmp.visrect.left,
-                                    tmp.visrect.bottom - tmp.visrect.top, physdev_dst->pict_format->depth );
+
+        if (fs_hack_mapping_required( monitor ))
+        {
+            double user_to_real_scale;
+            SIZE size;
+
+            user_to_real_scale = fs_hack_get_user_to_real_scale( monitor );
+            size.cx = (tmp.visrect.right - tmp.visrect.left) * user_to_real_scale;
+            size.cy = (tmp.visrect.bottom - tmp.visrect.top) * user_to_real_scale;
+            tmp_pixmap = XCreatePixmap( gdi_display, root_window, size.cx, size.cy, physdev_dst->pict_format->depth );
+        }
+        else
+            tmp_pixmap = XCreatePixmap( gdi_display, root_window, tmp.visrect.right - tmp.visrect.left,
+                                        tmp.visrect.bottom - tmp.visrect.top, physdev_dst->pict_format->depth );

         xrender_stretch_blit( physdev_src, physdev_dst, tmp_pixmap, src, &tmp );
         execute_rop( physdev_dst->x11dev, tmp_pixmap, tmpGC, &dst->visrect, rop );
@@ -1791,6 +1881,10 @@ static DWORD CDECL xrenderdrv_PutImage( PHYSDEV dev, HRGN clip, BITMAPINFO *info
     Picture src_pict, mask_pict = 0;
     BOOL use_repeat;

+    TRACE("src %d,%d %dx%d vis=%s  dst %d,%d %dx%d vis=%s  rop=%06x\n",
+          src->x, src->y, src->width, src->height, wine_dbgstr_rect(&src->visrect),
+          dst->x, dst->y, dst->width, dst->height, wine_dbgstr_rect(&dst->visrect), rop );
+
     dst_format = physdev->format;
     src_format = get_xrender_format_from_bitmapinfo( info );
     if (!(pict_format = pict_formats[src_format])) goto update_format;
@@ -1815,6 +1909,7 @@ static DWORD CDECL xrenderdrv_PutImage( PHYSDEV dev, HRGN clip, BITMAPINFO *info
         if (rop != SRCCOPY)
         {
             BOOL restore_region = add_extra_clipping_region( physdev->x11dev, clip );
+            HMONITOR monitor;

             /* make coordinates relative to tmp pixmap */
             tmp = *dst;
@@ -1825,13 +1920,29 @@ static DWORD CDECL xrenderdrv_PutImage( PHYSDEV dev, HRGN clip, BITMAPINFO *info
             gc = XCreateGC( gdi_display, physdev->x11dev->drawable, 0, NULL );
             XSetSubwindowMode( gdi_display, gc, IncludeInferiors );
             XSetGraphicsExposures( gdi_display, gc, False );
-            tmp_pixmap = XCreatePixmap( gdi_display, root_window,
-                                        tmp.visrect.right - tmp.visrect.left,
-                                        tmp.visrect.bottom - tmp.visrect.top,
-                                        physdev->pict_format->depth );
+
+            monitor = fs_hack_monitor_from_hwnd( WindowFromDC( dev->hdc ) );
+            if (fs_hack_mapping_required( monitor ))
+            {
+                double user_to_real_scale;
+                SIZE size;
+
+                user_to_real_scale = fs_hack_get_user_to_real_scale( monitor );
+                size.cx = (tmp.visrect.right - tmp.visrect.left) * user_to_real_scale;
+                size.cy = (tmp.visrect.bottom - tmp.visrect.top) * user_to_real_scale;
+                tmp_pixmap = XCreatePixmap( gdi_display, root_window, size.cx, size.cy,
+                                            physdev->pict_format->depth );
+            }
+            else
+            {
+                tmp_pixmap = XCreatePixmap( gdi_display, root_window,
+                                            tmp.visrect.right - tmp.visrect.left,
+                                            tmp.visrect.bottom - tmp.visrect.top,
+                                            physdev->pict_format->depth );
+            }

             xrender_put_image( src_pixmap, src_pict, mask_pict, NULL, physdev->pict_format,
-                               NULL, tmp_pixmap, src, &tmp, use_repeat );
+                               physdev, tmp_pixmap, src, &tmp, use_repeat );
             execute_rop( physdev->x11dev, tmp_pixmap, gc, &dst->visrect, rop );

             XFreePixmap( gdi_display, tmp_pixmap );
@@ -1908,7 +2019,7 @@ static DWORD CDECL xrenderdrv_BlendImage( PHYSDEV dev, BITMAPINFO *info, const s
         EnterCriticalSection( &xrender_cs );
         mask_pict = get_mask_pict( func.SourceConstantAlpha * 257 );

-        xrender_blit( PictOpOver, src_pict, mask_pict, dst_pict,
+        xrender_blit( physdev, PictOpOver, src_pict, mask_pict, dst_pict,
                       src->x, src->y, src->width, src->height,
                       physdev->x11dev->dc_rect.left + dst->x,
                       physdev->x11dev->dc_rect.top + dst->y,
@@ -1997,7 +2108,7 @@ static BOOL CDECL xrenderdrv_AlphaBlend( PHYSDEV dst_dev, struct bitblt_coords *
     EnterCriticalSection( &xrender_cs );
     mask_pict = get_mask_pict( blendfn.SourceConstantAlpha * 257 );

-    xrender_blit( PictOpOver, src_pict, mask_pict, dst_pict,
+    xrender_blit( physdev_dst, PictOpOver, src_pict, mask_pict, dst_pict,
                   physdev_src->x11dev->dc_rect.left + src->x,
                   physdev_src->x11dev->dc_rect.top + src->y,
                   src->width, src->height,
@@ -2100,7 +2211,7 @@ static BOOL CDECL xrenderdrv_GradientFill( PHYSDEV dev, TRIVERTEX *vert_array, U
             dst_pict = get_xrender_picture( physdev, 0, NULL );

             src_pict = pXRenderCreateLinearGradient( gdi_display, &gradient, stops, colors, 2 );
-            xrender_blit( PictOpSrc, src_pict, 0, dst_pict,
+            xrender_blit( physdev, PictOpSrc, src_pict, 0, dst_pict,
                           0, 0, rc.right - rc.left, rc.bottom - rc.top,
                           physdev->x11dev->dc_rect.left + rc.left,
                           physdev->x11dev->dc_rect.top + rc.top,
diff --git a/dlls/winex11.drv/xvidmode.c b/dlls/winex11.drv/xvidmode.c
index d0be58342a5..123e5d036a9 100644
--- a/dlls/winex11.drv/xvidmode.c
+++ b/dlls/winex11.drv/xvidmode.c
@@ -313,6 +313,7 @@ void X11DRV_XF86VM_Init(void)
   xf86vm_handler.free_modes = xf86vm_free_modes;
   xf86vm_handler.get_current_mode = xf86vm_get_current_mode;
   xf86vm_handler.set_current_mode = xf86vm_set_current_mode;
+  xf86vm_handler.convert_coordinates = NULL;
   X11DRV_Settings_SetHandler(&xf86vm_handler);
   return;

From b2f26fe9bab670740b6298e99a99f34509dcd6b4 Mon Sep 17 00:00:00 2001
From: Matteo Bruni <mbruni@codeweavers.com>
Date: Tue, 16 Feb 2021 13:30:51 -0600
Subject: [PATCH] winex11: Clear fs hack depth / stencil attachment.

---
 dlls/winex11.drv/opengl.c | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index bf5f9637227..53ac19dfe50 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1950,7 +1950,8 @@ static void fs_hack_get_attachments_config( struct gl_drawable *gl, struct fs_ha
 static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *gl )
 {
     GLuint prev_draw_fbo, prev_read_fbo, prev_texture, prev_renderbuffer;
-    float prev_clear_color[4];
+    float prev_clear_color[4], prev_clear_depth;
+    int prev_clear_stencil;
     unsigned int i;
     struct fs_hack_fbo_attachments_config config;
     struct fs_hack_fbconfig_attribs attribs;
@@ -1995,6 +1996,8 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         opengl_funcs.gl.p_glGetIntegerv( GL_TEXTURE_BINDING_2D, (GLint *)&prev_texture );
         opengl_funcs.gl.p_glGetIntegerv( GL_RENDERBUFFER_BINDING, (GLint *)&prev_renderbuffer );
         opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, prev_clear_color );
+        opengl_funcs.gl.p_glGetFloatv( GL_DEPTH_CLEAR_VALUE, &prev_clear_depth );
+        opengl_funcs.gl.p_glGetIntegerv( GL_STENCIL_CLEAR_VALUE, &prev_clear_stencil );
         TRACE( "Previous draw FBO %u, read FBO %u for ctx %p\n", prev_draw_fbo, prev_read_fbo, ctx);

         if (!ctx->fs_hack_fbo)
@@ -2080,14 +2083,22 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
             }
         }

-        opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
         if(!gl->fs_hack_context_set_up)
-            opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
+        {
+            opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
+            opengl_funcs.gl.p_glClearDepth( 1.0 );
+            opengl_funcs.gl.p_glClearStencil( 0 );
+            opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT );
+        }
         pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
         pglDrawBuffer( GL_BACK );
         if(!gl->fs_hack_context_set_up)
+        {
             opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
-        opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1], prev_clear_color[2], prev_clear_color[3] );
+            opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1], prev_clear_color[2], prev_clear_color[3] );
+            opengl_funcs.gl.p_glClearDepth( prev_clear_depth );
+            opengl_funcs.gl.p_glClearStencil( prev_clear_stencil );
+        }
         wglBindFramebuffer( GL_DRAW_FRAMEBUFFER, prev_draw_fbo );
         wglBindFramebuffer( GL_READ_FRAMEBUFFER, prev_read_fbo );

From ba4e9dc41c7fb272c4354669b032b781d96e2e59 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 19 Dec 2019 09:12:17 -0600
Subject: [PATCH] winex11.drv: Remove nvidia hack workaround

This breaks things for users who legitimately have only one resolution.
---
 dlls/winex11.drv/xrandr.c | 13 -------------
 1 file changed, 13 deletions(-)

diff --git a/dlls/winex11.drv/xrandr.c b/dlls/winex11.drv/xrandr.c
index 0a080ea6be8..667013df5ac 100644
--- a/dlls/winex11.drv/xrandr.c
+++ b/dlls/winex11.drv/xrandr.c
@@ -28,9 +28,6 @@
 #include "wine/debug.h"

 WINE_DEFAULT_DEBUG_CHANNEL(xrandr);
-#ifdef HAVE_XRRGETPROVIDERRESOURCES
-WINE_DECLARE_DEBUG_CHANNEL(winediag);
-#endif

 #ifdef SONAME_LIBXRANDR

@@ -378,7 +375,6 @@ static BOOL is_broken_driver(void)
     XRRScreenResources *screen_resources;
     XRROutputInfo *output_info;
     XRRModeInfo *first_mode;
-    INT major, event, error;
     INT output_idx, i, j;
     BOOL only_one_mode;

@@ -429,15 +425,6 @@ static BOOL is_broken_driver(void)

         if (!only_one_mode)
             continue;
-
-        /* Check if it is NVIDIA proprietary driver */
-        if (XQueryExtension( gdi_display, "NV-CONTROL", &major, &event, &error ))
-        {
-            ERR_(winediag)("Broken NVIDIA RandR detected, falling back to RandR 1.0. "
-                           "Please consider using the Nouveau driver instead.\n");
-            pXRRFreeScreenResources( screen_resources );
-            return TRUE;
-        }
     }
     pXRRFreeScreenResources( screen_resources );
     return FALSE;
From efc3bf9dd9f195641604d0fe392f542bdde2c5f8 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Mon, 6 Apr 2020 15:30:40 +0800
Subject: [PATCH] winex11.drv: Bypass compositor only when a window is full
 virtual screen.

Bypass compositor only when a window is full virtual screen. Otherwise, it might cause flicking on
other monitors.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/winex11.drv/window.c | 10 +++++++++-
 dlls/winex11.drv/x11drv.h |  1 +
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index a60001aec6d..ac7c0005a14 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -386,6 +386,13 @@ BOOL is_window_rect_full_screen( const RECT *rect )
     return info.full_screen;
 }

+BOOL is_window_rect_full_virtual_screen( const RECT *rect )
+{
+    RECT virtual_rect = get_virtual_screen_rect();
+    return (rect->left <= virtual_rect.left && rect->right >= virtual_rect.right &&
+            rect->top <= virtual_rect.top && rect->bottom >= virtual_rect.bottom);
+}
+
 /***********************************************************************
  *              get_mwm_decorations
  */
@@ -1168,7 +1175,8 @@ void update_net_wm_states( struct x11drv_win_data *data )
             if (!wm_is_steamcompmgr(data->display) || !fs_hack_enabled(monitor))
             {
                 /* when fs hack is enabled, we don't want steamcompmgr to resize the window to be fullscreened */
-                net_wm_bypass_compositor = 1;
+                if (is_window_rect_full_virtual_screen( &data->whole_rect ))
+                    net_wm_bypass_compositor = 1;
                 new_state |= (1 << NET_WM_STATE_FULLSCREEN);
             }
         }
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 26843c830eb..55875edc788 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -726,6 +726,7 @@ extern void X11DRV_expect_error( Display *display, x11drv_error_callback callbac
 extern int X11DRV_check_error(void) DECLSPEC_HIDDEN;
 extern void X11DRV_X_to_window_rect( struct x11drv_win_data *data, RECT *rect, int x, int y, int cx, int cy ) DECLSPEC_HIDDEN;
 extern BOOL is_window_rect_full_screen( const RECT *rect ) DECLSPEC_HIDDEN;
+extern BOOL is_window_rect_full_virtual_screen( const RECT *rect ) DECLSPEC_HIDDEN;
 extern POINT virtual_screen_to_root( INT x, INT y ) DECLSPEC_HIDDEN;
 extern POINT root_to_virtual_screen( INT x, INT y ) DECLSPEC_HIDDEN;
 extern RECT get_virtual_screen_rect(void) DECLSPEC_HIDDEN;
From 37b625a90d44c24f3bdc8c5a61f0dd5b0d37a924 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Sun, 17 May 2020 23:27:59 +0800
Subject: [PATCH] user32/tests: Test moving full screen windows.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/user32/tests/win.c | 79 +++++++++++++++++++++++++++++++++++++++--
 1 file changed, 76 insertions(+), 3 deletions(-)

diff --git a/dlls/user32/tests/win.c b/dlls/user32/tests/win.c
index 0156987f529..83969bf89f6 100644
--- a/dlls/user32/tests/win.c
+++ b/dlls/user32/tests/win.c
@@ -92,8 +92,8 @@ static void dump_minmax_info( const MINMAXINFO *minmax )
 static void flush_events( BOOL remove_messages )
 {
     MSG msg;
-    int diff = 200;
-    int min_timeout = 100;
+    int diff = 500;
+    int min_timeout = 200;
     DWORD time = GetTickCount() + diff;

     while (diff > 0)
@@ -102,7 +102,6 @@ static void flush_events( BOOL remove_messages )
         if (remove_messages)
             while (PeekMessageA( &msg, 0, 0, 0, PM_REMOVE )) DispatchMessageA( &msg );
         diff = time - GetTickCount();
-        min_timeout = 50;
     }
 }

@@ -8587,6 +8586,29 @@ static LRESULT CALLBACK fullscreen_wnd_proc(HWND hwnd, UINT msg, WPARAM wp, LPAR
     return DefWindowProcA(hwnd, msg, wp, lp);
 }

+struct monitor_info
+{
+    RECT first_monitor;
+    RECT second_monitor;
+};
+
+static BOOL CALLBACK enum_monitor_cb(HMONITOR monitor, HDC hdc, RECT *monitor_rect, LPARAM lparam)
+{
+    struct monitor_info *info = (struct monitor_info *)lparam;
+
+    if (IsRectEmpty(&info->first_monitor))
+    {
+        info->first_monitor = *monitor_rect;
+    }
+    else
+    {
+        info->second_monitor = *monitor_rect;
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
 static void test_fullscreen(void)
 {
     static const DWORD t_style[] = {
@@ -8595,6 +8617,7 @@ static void test_fullscreen(void)
     static const DWORD t_ex_style[] = {
         0, WS_EX_APPWINDOW, WS_EX_TOOLWINDOW
     };
+    struct monitor_info monitor_info;
     WNDCLASSA cls;
     int timeout;
     HWND hwnd;
@@ -8747,6 +8770,56 @@ static void test_fullscreen(void)
     DestroyWindow(hwnd);

     UnregisterClassA("fullscreen_class", GetModuleHandleA(NULL));
+
+    /* Test moving a full screen window to another monitor */
+    memset(&monitor_info, 0, sizeof(monitor_info));
+    EnumDisplayMonitors(NULL, NULL, enum_monitor_cb, (LPARAM)&monitor_info);
+    if (!IsRectEmpty(&monitor_info.first_monitor) && !IsRectEmpty(&monitor_info.second_monitor))
+    {
+        hwnd = CreateWindowA("static", "static1", WS_POPUP | WS_VISIBLE,
+                monitor_info.first_monitor.left, monitor_info.first_monitor.top,
+                monitor_info.first_monitor.right - monitor_info.first_monitor.left,
+                monitor_info.first_monitor.bottom - monitor_info.first_monitor.top, NULL, NULL,
+                GetModuleHandleA(NULL), NULL);
+        ok(!!hwnd, "CreateWindow failed, error %#x.\n", GetLastError());
+        flush_events(TRUE);
+
+        GetWindowRect(hwnd, &rc);
+        ok(EqualRect(&rc, &monitor_info.first_monitor), "Expected window rect %s, got %s.\n",
+                wine_dbgstr_rect(&monitor_info.first_monitor), wine_dbgstr_rect(&rc));
+
+        SetWindowPos(hwnd, 0, monitor_info.second_monitor.left, monitor_info.second_monitor.top,
+                monitor_info.second_monitor.right - monitor_info.second_monitor.left,
+                monitor_info.second_monitor.bottom - monitor_info.second_monitor.top, SWP_NOZORDER);
+        flush_events(TRUE);
+        GetWindowRect(hwnd, &rc);
+        /* todo_wine on KWin */
+        todo_wine_if(!EqualRect(&rc, &monitor_info.second_monitor))
+        ok(EqualRect(&rc, &monitor_info.second_monitor), "Expected window rect %s, got %s.\n",
+                wine_dbgstr_rect(&monitor_info.second_monitor), wine_dbgstr_rect(&rc));
+        DestroyWindow(hwnd);
+
+        hwnd = CreateWindowA("static", "static2", WS_POPUP | WS_VISIBLE,
+                monitor_info.second_monitor.left, monitor_info.second_monitor.top,
+                100, 100, NULL, NULL, NULL, NULL);
+        ok(!!hwnd, "CreateWindow failed, error %#x.\n", GetLastError());
+        flush_events(TRUE);
+
+        SetWindowPos(hwnd, 0, monitor_info.first_monitor.left, monitor_info.first_monitor.top,
+                monitor_info.first_monitor.right - monitor_info.first_monitor.left,
+                monitor_info.first_monitor.bottom - monitor_info.first_monitor.top, SWP_NOZORDER);
+        flush_events(TRUE);
+        GetWindowRect(hwnd, &rc);
+        /* todo_wine on KWin */
+        todo_wine_if(!EqualRect(&rc, &monitor_info.first_monitor))
+        ok(EqualRect(&rc, &monitor_info.first_monitor), "Expected window rect %s, got %s.\n",
+                wine_dbgstr_rect(&monitor_info.first_monitor), wine_dbgstr_rect(&rc));
+        DestroyWindow(hwnd);
+    }
+    else
+    {
+        skip("This test requires two monitors present.\n");
+    }
 }

 static BOOL test_thick_child_got_minmax;
From 533d833c1ae99a2b51bf8389b3bfd55ed6dbb3b5 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Mon, 11 Oct 2021 11:03:06 +0200
Subject: [PATCH] gdi32/tests: Test GetDeviceCaps() for DCs on multiple monitor
 systems.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/gdi32/tests/dc.c | 217 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 217 insertions(+)

diff --git a/dlls/gdi32/tests/dc.c b/dlls/gdi32/tests/dc.c
index 2e005f23f3c..1cc6c4cc81f 100644
--- a/dlls/gdi32/tests/dc.c
+++ b/dlls/gdi32/tests/dc.c
@@ -1698,6 +1698,222 @@ static void test_SetPixel(void)
     ok(c == ~0, "SetPixel returned: %x\n", c);
 }

+static void test_multi_monitor_dc(void)
+{
+    INT value, count, old_count;
+    DWORD device_idx, mode_idx;
+    DEVMODEA dm, dm2, dm3;
+    DISPLAY_DEVICEA dd;
+    BOOL ret;
+    LONG res;
+    HDC hdc;
+
+    /* Test DCs covering the entire virtual screen */
+    hdc = CreateDCA("DISPLAY", NULL, NULL, NULL);
+    ok(!!hdc, "CreateDCA failed.\n");
+
+    memset(&dm, 0, sizeof(dm));
+    dm.dmSize = sizeof(dm);
+    ret = EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm);
+    ok(ret, "EnumDisplaySettingsA failed.\n");
+
+    value = GetDeviceCaps(hdc, HORZRES);
+    ok(value == dm.dmPelsWidth, "Expected %d, got %d.\n", dm.dmPelsWidth, value);
+
+    value = GetDeviceCaps(hdc, VERTRES);
+    ok(value == dm.dmPelsHeight, "Expected %d, got %d.\n", dm.dmPelsHeight, value);
+
+    value = GetDeviceCaps(hdc, DESKTOPHORZRES);
+    todo_wine_if(dm.dmPelsWidth != GetSystemMetrics(SM_CXVIRTUALSCREEN)
+                 && value == GetSystemMetrics(SM_CXVIRTUALSCREEN))
+    ok(value == dm.dmPelsWidth, "Expected %d, got %d.\n", dm.dmPelsWidth, value);
+
+    value = GetDeviceCaps(hdc, DESKTOPVERTRES);
+    todo_wine_if(dm.dmPelsHeight != GetSystemMetrics(SM_CYVIRTUALSCREEN)
+                 && value == GetSystemMetrics(SM_CYVIRTUALSCREEN))
+    ok(value == dm.dmPelsHeight, "Expected %d, got %d.\n", dm.dmPelsHeight, value);
+
+    value = GetDeviceCaps(hdc, VREFRESH);
+    todo_wine_if(value != dm.dmDisplayFrequency && value == 1)
+    ok(value == dm.dmDisplayFrequency, "Expected %d, got %d.\n", dm.dmDisplayFrequency, value);
+
+    /* Test GetDeviceCaps() values after mode changes */
+    memset(&dm2, 0, sizeof(dm2));
+    dm2.dmSize = sizeof(dm2);
+    for (mode_idx = 0; EnumDisplaySettingsA(NULL, mode_idx, &dm2); ++mode_idx)
+    {
+        if (dm2.dmPelsWidth != dm.dmPelsWidth && dm2.dmPelsHeight != dm.dmPelsHeight)
+            break;
+    }
+    ok(dm2.dmPelsWidth && dm2.dmPelsWidth != dm.dmPelsWidth && dm2.dmPelsHeight != dm.dmPelsHeight,
+       "Failed to find a different resolution.\n");
+
+    res = ChangeDisplaySettingsExA(NULL, &dm2, NULL, CDS_RESET, NULL);
+    ok(res == DISP_CHANGE_SUCCESSFUL || broken(res == DISP_CHANGE_FAILED), /* Win8 TestBots */
+       "ChangeDisplaySettingsExA returned unexpected %d.\n", res);
+    if (res == DISP_CHANGE_SUCCESSFUL)
+    {
+        value = GetDeviceCaps(hdc, HORZRES);
+        ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, VERTRES);
+        ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPHORZRES);
+        todo_wine_if(dm2.dmPelsWidth != GetSystemMetrics(SM_CXVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CXVIRTUALSCREEN))
+        ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPVERTRES);
+        todo_wine_if(dm2.dmPelsHeight != GetSystemMetrics(SM_CYVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CYVIRTUALSCREEN))
+        ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, VREFRESH);
+        todo_wine_if(value != dm2.dmDisplayFrequency && value == 1)
+        ok(value == dm2.dmDisplayFrequency, "Expected %d, got %d.\n", dm2.dmDisplayFrequency, value);
+
+        res = ChangeDisplaySettingsExA(NULL, NULL, NULL, 0, NULL);
+        ok(res == DISP_CHANGE_SUCCESSFUL, "ChangeDisplaySettingsExA returned unexpected %d.\n", res);
+    }
+
+    DeleteDC(hdc);
+
+    /* Test DCs covering a specific monitor */
+    dd.cb = sizeof(dd);
+    for (device_idx = 0; EnumDisplayDevicesA(NULL, device_idx, &dd, 0); ++device_idx)
+    {
+        if (!(dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP))
+            continue;
+
+        memset(&dm, 0, sizeof(dm));
+        dm.dmSize = sizeof(dm);
+        ret = EnumDisplaySettingsA(dd.DeviceName, ENUM_CURRENT_SETTINGS, &dm);
+        ok(ret, "EnumDisplaySettingsA %s failed.\n", dd.DeviceName);
+
+        hdc = CreateDCA(dd.DeviceName, NULL, NULL, NULL);
+        ok(!!hdc, "CreateDCA %s failed.\n", dd.DeviceName);
+
+        value = GetDeviceCaps(hdc, HORZRES);
+        todo_wine_if(dm.dmPelsWidth != GetSystemMetrics(SM_CXSCREEN))
+        ok(value == dm.dmPelsWidth, "Expected %d, got %d.\n", dm.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, VERTRES);
+        todo_wine_if(dm.dmPelsHeight != GetSystemMetrics(SM_CYSCREEN))
+        ok(value == dm.dmPelsHeight, "Expected %d, got %d.\n", dm.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPHORZRES);
+        todo_wine_if(dm.dmPelsWidth != GetSystemMetrics(SM_CXVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CXVIRTUALSCREEN))
+        ok(value == dm.dmPelsWidth, "Expected %d, got %d.\n", dm.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPVERTRES);
+        todo_wine_if(dm.dmPelsHeight != GetSystemMetrics(SM_CYVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CYVIRTUALSCREEN))
+        ok(value == dm.dmPelsHeight, "Expected %d, got %d.\n", dm.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, VREFRESH);
+        todo_wine_if(value != dm.dmDisplayFrequency && value == 1)
+        ok(value == dm.dmDisplayFrequency, "Expected %d, got %d.\n", dm.dmDisplayFrequency, value);
+
+        /* Test GetDeviceCaps() values after mode changes */
+        memset(&dm2, 0, sizeof(dm2));
+        dm2.dmSize = sizeof(dm2);
+        for (mode_idx = 0; EnumDisplaySettingsA(dd.DeviceName, mode_idx, &dm2); ++mode_idx)
+        {
+            if (dm2.dmPelsWidth != dm.dmPelsWidth && dm2.dmPelsHeight != dm.dmPelsHeight)
+                break;
+        }
+        ok(dm2.dmPelsWidth && dm2.dmPelsWidth != dm.dmPelsWidth && dm2.dmPelsHeight != dm.dmPelsHeight,
+           "Failed to find a different resolution for %s.\n", dd.DeviceName);
+
+        res = ChangeDisplaySettingsExA(dd.DeviceName, &dm2, NULL, CDS_RESET, NULL);
+        ok(res == DISP_CHANGE_SUCCESSFUL
+           || broken(res == DISP_CHANGE_FAILED), /* Win8 TestBots */
+           "ChangeDisplaySettingsExA %s returned unexpected %d.\n", dd.DeviceName, res);
+        if (res != DISP_CHANGE_SUCCESSFUL)
+        {
+            win_skip("Failed to change display mode for %s.\n", dd.DeviceName);
+            DeleteDC(hdc);
+            continue;
+        }
+
+        value = GetDeviceCaps(hdc, HORZRES);
+        todo_wine_if(dm2.dmPelsWidth != GetSystemMetrics(SM_CXSCREEN))
+        ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, VERTRES);
+        todo_wine_if(dm2.dmPelsHeight != GetSystemMetrics(SM_CYSCREEN))
+        ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPHORZRES);
+        todo_wine_if(dm2.dmPelsWidth != GetSystemMetrics(SM_CXVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CXVIRTUALSCREEN))
+        ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPVERTRES);
+        todo_wine_if(dm2.dmPelsHeight != GetSystemMetrics(SM_CYVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CYVIRTUALSCREEN))
+        ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, VREFRESH);
+        todo_wine_if(value != dm2.dmDisplayFrequency && value == 1)
+        ok(value == dm2.dmDisplayFrequency, "Expected %d, got %d.\n", dm2.dmDisplayFrequency, value);
+
+        /* Test GetDeviceCaps() values after monitor detach */
+        if (!(dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE))
+        {
+            old_count = GetSystemMetrics(SM_CMONITORS);
+
+            ret = EnumDisplaySettingsA(dd.DeviceName, ENUM_CURRENT_SETTINGS, &dm3);
+            ok(ret, "EnumDisplaySettingsA %s failed.\n", dd.DeviceName);
+
+            dm3.dmFields = DM_POSITION | DM_PELSWIDTH | DM_PELSHEIGHT;
+            dm3.dmPelsWidth = 0;
+            dm3.dmPelsHeight = 0;
+            res = ChangeDisplaySettingsExA(dd.DeviceName, &dm3, NULL, CDS_UPDATEREGISTRY | CDS_NORESET, NULL);
+            ok(res == DISP_CHANGE_SUCCESSFUL, "ChangeDisplaySettingsExA %s returned unexpected %d.\n",
+               dd.DeviceName, res);
+            res = ChangeDisplaySettingsExA(dd.DeviceName, NULL, NULL, 0, NULL);
+            ok(res == DISP_CHANGE_SUCCESSFUL, "ChangeDisplaySettingsExA %s returned unexpected %d.\n",
+               dd.DeviceName, res);
+
+            count = GetSystemMetrics(SM_CMONITORS);
+            ok(count == old_count - 1, "Expect monitor count %d, got %d.\n", old_count - 1, count);
+
+            /* Should report the same values before detach */
+            value = GetDeviceCaps(hdc, HORZRES);
+            todo_wine_if(dm2.dmPelsWidth != GetSystemMetrics(SM_CXSCREEN))
+            ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+            value = GetDeviceCaps(hdc, VERTRES);
+            todo_wine_if(dm2.dmPelsHeight != GetSystemMetrics(SM_CYSCREEN))
+            ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+            value = GetDeviceCaps(hdc, DESKTOPHORZRES);
+            todo_wine_if(dm2.dmPelsWidth != GetSystemMetrics(SM_CXVIRTUALSCREEN)
+                         && value == GetSystemMetrics(SM_CXVIRTUALSCREEN))
+            ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+            value = GetDeviceCaps(hdc, DESKTOPVERTRES);
+            todo_wine_if(dm2.dmPelsHeight != GetSystemMetrics(SM_CYVIRTUALSCREEN)
+                         && value == GetSystemMetrics(SM_CYVIRTUALSCREEN))
+            ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+            value = GetDeviceCaps(hdc, VREFRESH);
+            todo_wine_if(value != dm2.dmDisplayFrequency && value == 1)
+            ok(value == dm2.dmDisplayFrequency, "Expected %d, got %d.\n", dm2.dmDisplayFrequency, value);
+        }
+
+        res = ChangeDisplaySettingsExA(dd.DeviceName, &dm, NULL, CDS_UPDATEREGISTRY | CDS_NORESET, NULL);
+        ok(res == DISP_CHANGE_SUCCESSFUL, "ChangeDisplaySettingsExA %s returned unexpected %d.\n",
+           dd.DeviceName, res);
+        res = ChangeDisplaySettingsExA(NULL, NULL, NULL, 0, NULL);
+        ok(res == DISP_CHANGE_SUCCESSFUL, "ChangeDisplaySettingsExA %s returned unexpected %d.\n",
+           dd.DeviceName, res);
+        DeleteDC(hdc);
+    }
+}

 START_TEST(dc)
 {
@@ -1716,4 +1932,5 @@ START_TEST(dc)
     test_pscript_printer_dc();
     test_clip_box();
     test_SetPixel();
+    test_multi_monitor_dc();
 }
From 9807dd24837a522537dfc0e84cdf5e29693df837 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Tue, 26 May 2020 22:36:07 +0800
Subject: [PATCH] winex11.drv: Do not move window with _NET_WM_STATE_FULLSCREEN
 set.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/user32/tests/win.c   |  4 ----
 dlls/winex11.drv/window.c | 13 +++++++++++++
 2 files changed, 13 insertions(+), 4 deletions(-)

diff --git a/dlls/user32/tests/win.c b/dlls/user32/tests/win.c
index 83969bf89f6..4722be3fd47 100644
--- a/dlls/user32/tests/win.c
+++ b/dlls/user32/tests/win.c
@@ -8793,8 +8793,6 @@ static void test_fullscreen(void)
                 monitor_info.second_monitor.bottom - monitor_info.second_monitor.top, SWP_NOZORDER);
         flush_events(TRUE);
         GetWindowRect(hwnd, &rc);
-        /* todo_wine on KWin */
-        todo_wine_if(!EqualRect(&rc, &monitor_info.second_monitor))
         ok(EqualRect(&rc, &monitor_info.second_monitor), "Expected window rect %s, got %s.\n",
                 wine_dbgstr_rect(&monitor_info.second_monitor), wine_dbgstr_rect(&rc));
         DestroyWindow(hwnd);
@@ -8810,8 +8808,6 @@ static void test_fullscreen(void)
                 monitor_info.first_monitor.bottom - monitor_info.first_monitor.top, SWP_NOZORDER);
         flush_events(TRUE);
         GetWindowRect(hwnd, &rc);
-        /* todo_wine on KWin */
-        todo_wine_if(!EqualRect(&rc, &monitor_info.first_monitor))
         ok(EqualRect(&rc, &monitor_info.first_monitor), "Expected window rect %s, got %s.\n",
                 wine_dbgstr_rect(&monitor_info.first_monitor), wine_dbgstr_rect(&rc));
         DestroyWindow(hwnd);
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index ac7c0005a14..bbe2a1728b5 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1487,6 +1487,7 @@ static void sync_window_position( struct x11drv_win_data *data,
 {
     DWORD style = GetWindowLongW( data->hwnd, GWL_STYLE );
     DWORD ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
+    RECT original_rect = {0};
     XWindowChanges changes;
     unsigned int mask = 0;

@@ -1541,9 +1542,21 @@ static void sync_window_position( struct x11drv_win_data *data,

     set_size_hints( data, style );
     set_mwm_hints( data, style, ex_style );
+    /* KWin doesn't allow moving a window with _NET_WM_STATE_FULLSCREEN set. So we need to remove
+     * _NET_WM_STATE_FULLSCREEN before moving the window and restore it later */
+    if (wm_is_kde( data->display ) && is_window_rect_full_screen( &data->whole_rect ))
+    {
+        original_rect = data->whole_rect;
+        SetRectEmpty( &data->whole_rect );
+    }
     update_net_wm_states( data );
     data->configure_serial = NextRequest( data->display );
     XReconfigureWMWindow( data->display, data->whole_window, data->vis.screen, mask, &changes );
+    if (!IsRectEmpty( &original_rect ))
+    {
+        data->whole_rect = original_rect;
+        update_net_wm_states( data );
+    }
 #ifdef HAVE_LIBXSHAPE
     if (IsRectEmpty( old_window_rect ) != IsRectEmpty( &data->window_rect ))
         sync_window_region( data, (HRGN)1 );
From fa17abadf6856748a1502464dcb0c56fea0d58a8 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 18 Feb 2021 10:05:52 -0600
Subject: [PATCH] winex11.drv: Support adjusting gamma in the fshack

CW-Bug-Id: 16421
---
 dlls/winex11.drv/fs.c       |  33 ++
 dlls/winex11.drv/opengl.c   | 637 ++++++++++++++++++++++++++++++++----
 dlls/winex11.drv/x11drv.h   |   2 +
 dlls/winex11.drv/xvidmode.c |  23 +-
 4 files changed, 622 insertions(+), 73 deletions(-)

diff --git a/dlls/winex11.drv/fs.c b/dlls/winex11.drv/fs.c
index 641fdd40d45..913c37dee68 100644
--- a/dlls/winex11.drv/fs.c
+++ b/dlls/winex11.drv/fs.c
@@ -39,6 +39,10 @@ static struct x11drv_display_device_handler real_device_handler;
 static struct x11drv_settings_handler real_settings_handler;
 static struct list fs_monitors = LIST_INIT(fs_monitors);

+static WORD gamma_ramp_i[GAMMA_RAMP_SIZE * 3];
+static float gamma_ramp[GAMMA_RAMP_SIZE * 4];
+static LONG gamma_serial;
+
 /* Access to fs_monitors is protected by fs_section */
 static CRITICAL_SECTION fs_section;
 static CRITICAL_SECTION_DEBUG critsect_debug =
@@ -897,3 +901,32 @@ void fs_hack_init(void)
     device_handler.register_event_handlers = NULL;
     X11DRV_DisplayDevices_SetHandler(&device_handler);
 }
+
+const float *fs_hack_get_gamma_ramp(LONG *serial)
+{
+    if(gamma_serial == 0)
+        return NULL;
+    if(serial)
+        *serial = gamma_serial;
+    return gamma_ramp;
+}
+
+void fs_hack_set_gamma_ramp(const WORD *ramp)
+{
+    int i;
+    if(memcmp(gamma_ramp_i, ramp, sizeof(gamma_ramp_i)) == 0){
+        /* identical */
+        return;
+    }
+    for(i = 0; i < GAMMA_RAMP_SIZE; ++i){
+        gamma_ramp[i * 4    ] = ramp[i                      ] / 65535.f;
+        gamma_ramp[i * 4 + 1] = ramp[i +     GAMMA_RAMP_SIZE] / 65535.f;
+        gamma_ramp[i * 4 + 2] = ramp[i + 2 * GAMMA_RAMP_SIZE] / 65535.f;
+    }
+    memcpy(gamma_ramp_i, ramp, sizeof(gamma_ramp_i));
+    InterlockedIncrement(&gamma_serial);
+    TRACE("new gamma serial: %u\n", gamma_serial);
+    if(gamma_serial == 0){
+        InterlockedIncrement(&gamma_serial);
+    }
+}
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 53ac19dfe50..fab13d5b1df 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -209,9 +209,11 @@ struct wgl_context
     BOOL refresh_drawables;
     BOOL fs_hack;
     BOOL fs_hack_integer;
+    BOOL is_core;
     GLuint fs_hack_fbo, fs_hack_resolve_fbo;
     GLuint fs_hack_color_texture, fs_hack_ds_texture;
-    GLuint fs_hack_color_renderbuffer, fs_hack_color_resolve_renderbuffer, fs_hack_ds_renderbuffer;
+    GLuint fs_hack_color_renderbuffer, fs_hack_ds_renderbuffer;
+    GLuint fs_hack_gamma_pgm, ramp_ubo;
     POINT setup_for;
     GLuint current_draw_fbo, current_read_fbo;
     struct list entry;
@@ -262,6 +264,11 @@ struct gl_drawable
     BOOL                           fs_hack_did_swapbuf;
     BOOL                           fs_hack_context_set_up;
     BOOL                           has_scissor_indexed;
+    BOOL                           has_clip_control;
+    BOOL                           has_ati_frag_shader;
+    BOOL                           has_fragment_program;
+    BOOL                           has_vertex_program;
+    LONG                           last_gamma_serial;
 };

 enum glx_swap_control_method
@@ -385,10 +392,6 @@ static int   (*pglXSwapIntervalSGI)(int);
 static void* (*pglXAllocateMemoryNV)(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
 static void  (*pglXFreeMemoryNV)(GLvoid *pointer);

-static void (*pglScissorIndexed)(GLuint, GLint, GLint, GLsizei, GLsizei);
-static void (*pglScissorIndexedv)(GLuint, const GLint *);
-static void (*pglGetIntegeri_v)(GLenum, GLuint, GLint *);
-
 /* MESA GLX Extensions */
 static void (*pglXCopySubBufferMESA)(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
 static int (*pglXSwapIntervalMESA)(unsigned int interval);
@@ -413,21 +416,57 @@ static void wglFlush(void);
 static const GLubyte *wglGetString(GLenum name);

 /* Fullscreen hack */
+static void (*pglActiveTexture)( GLenum texture );
+static void (*pglAttachShader)( GLuint program, GLuint shader );
+static void (*pglBindBuffer)( GLenum target, GLuint buffer );
+static void (*pglBindBufferBase)( GLenum target, GLuint index, GLuint buffer );
+static void (*pglBindBufferRange)( GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size );
 static void (*pglBindFramebuffer)( GLenum target, GLuint framebuffer );
 static void (*pglBindFramebufferEXT)( GLenum target, GLuint framebuffer );
 static void (*pglBindRenderbuffer)( GLenum target, GLuint renderbuffer );
+static void (*pglBindSampler)( GLuint target, GLuint sampler );
 static void (*pglBlitFramebuffer)( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter );
-void (*pglDeleteFramebuffers)( GLsizei n, const GLuint *framebuffers );
-void (*pglDeleteRenderbuffers)( GLsizei n, const GLuint *renderbuffers );
+static void (*pglBufferData)( GLenum target, GLsizeiptr size, const void *data, GLenum usage );
+static void (*pglClipControl)( GLenum origin, GLenum depth );
+static void (*pglColorMaski)( GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a );
+static void (*pglCompileShader)( GLuint shader );
+static GLuint (*pglCreateProgram)( void );
+static GLuint (*pglCreateShader)( GLenum type );
+static void (*pglDeleteBuffers)( GLsizei n, GLuint *buffers );
+static void (*pglDeleteFramebuffers)( GLsizei n, const GLuint *framebuffers );
+static void (*pglDeleteProgram)( GLuint program );
+static void (*pglDeleteRenderbuffers)( GLsizei n, const GLuint *renderbuffers );
+static void (*pglDeleteShader)( GLuint shader );
+static void (*pglDrawArrays)( GLenum mode, GLint first, GLsizei count );
 static void (*pglDrawBuffer)( GLenum buffer );
 static void (*pglFramebufferRenderbuffer)( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer );
 static void (*pglFramebufferTexture2D)( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level );
+static void (*pglGenBuffers)( GLsizei n, GLuint *buffers );
 static void (*pglGenFramebuffers)( GLsizei n, GLuint *ids );
+static void (*pglGetBooleani_v )(GLenum target, GLuint index, GLboolean *data);
+static void (*pglGetInteger64i_v)(GLenum target, GLuint index, GLint64 *data);
+static void (*pglGetIntegeri_v)(GLenum, GLuint, GLint *);
+static void (*pglGetFloati_v)(GLenum, GLuint, GLfloat *);
 static void (*pglGenRenderbuffers)( GLsizei n, GLuint *renderbuffers );
+static void (*pglGetProgramiv)( GLuint program, GLenum pname, GLint *params );
+static void (*pglGetProgramInfoLog)( GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog );
+static void (*pglGetShaderiv)( GLuint shader, GLenum pname, GLint *params );
+static void (*pglGetShaderInfoLog)( GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog );
+static GLuint (*pglGetUniformBlockIndex)( GLuint program, const GLchar *uniformBlockName );
+static GLint (*pglGetUniformLocation)( GLuint program, const GLchar *name );
+static void (*pglLinkProgram)( GLuint program );
 static void (*pglReadBuffer)( GLenum src );
 static void (*pglRenderbufferStorage)( GLenum target, GLenum internalformat, GLsizei width, GLsizei height );
 static void (*pglRenderbufferStorageMultisample)( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height );
-
+static void (*pglScissorIndexed)(GLuint, GLint, GLint, GLsizei, GLsizei);
+static void (*pglScissorIndexedv)(GLuint, const GLint *);
+static void (*pglShaderSource)( GLuint shader, GLsizei count, const GLchar *const *string, const GLint *length );
+static void (*pglUniformBlockBinding)( GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding );
+static void (*pglUniform1i)( GLint location, GLint v0 );
+static void (*pglUseProgram)( GLuint program );
+static void (*pglViewportIndexedf)( GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h );
+static void (*pglViewportIndexedfv)( GLuint index, const GLfloat *v );
+static void (*pglGetFramebufferAttachmentParameteriv)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
 static void wglBindFramebuffer( GLenum target, GLuint framebuffer );
 static void wglBindFramebufferEXT( GLenum target, GLuint framebuffer );
 static void wglDrawBuffer( GLenum buffer );
@@ -623,18 +662,55 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )

     /* Fullscreen hack */
 #define LOAD_FUNCPTR(func) p##func = (void *)pglXGetProcAddressARB((const unsigned char *)#func);
+    LOAD_FUNCPTR( glActiveTexture );
+    LOAD_FUNCPTR( glAttachShader );
+    LOAD_FUNCPTR( glBindBuffer );
+    LOAD_FUNCPTR( glBindBufferBase );
+    LOAD_FUNCPTR( glBindBufferRange );
     LOAD_FUNCPTR( glBindFramebuffer );
     LOAD_FUNCPTR( glBindFramebufferEXT );
     LOAD_FUNCPTR( glBindRenderbuffer );
+    LOAD_FUNCPTR( glBindSampler );
     LOAD_FUNCPTR( glBlitFramebuffer );
+    LOAD_FUNCPTR( glBufferData );
+    LOAD_FUNCPTR( glClipControl );
+    LOAD_FUNCPTR( glColorMaski );
+    LOAD_FUNCPTR( glCompileShader );
+    LOAD_FUNCPTR( glCreateProgram );
+    LOAD_FUNCPTR( glCreateShader );
+    LOAD_FUNCPTR( glDeleteBuffers );
     LOAD_FUNCPTR( glDeleteFramebuffers );
+    LOAD_FUNCPTR( glDeleteProgram );
     LOAD_FUNCPTR( glDeleteRenderbuffers );
+    LOAD_FUNCPTR( glDeleteShader );
+    LOAD_FUNCPTR( glDrawArrays );
     LOAD_FUNCPTR( glFramebufferRenderbuffer );
     LOAD_FUNCPTR( glFramebufferTexture2D );
+    LOAD_FUNCPTR( glGenBuffers );
     LOAD_FUNCPTR( glGenFramebuffers );
+    LOAD_FUNCPTR( glGetBooleani_v );
+    LOAD_FUNCPTR( glGetInteger64i_v );
+    LOAD_FUNCPTR( glGetIntegeri_v );
+    LOAD_FUNCPTR( glGetFloati_v );
     LOAD_FUNCPTR( glGenRenderbuffers );
+    LOAD_FUNCPTR( glGetProgramiv );
+    LOAD_FUNCPTR( glGetProgramInfoLog );
+    LOAD_FUNCPTR( glGetShaderiv );
+    LOAD_FUNCPTR( glGetShaderInfoLog );
+    LOAD_FUNCPTR( glGetUniformBlockIndex );
+    LOAD_FUNCPTR( glGetUniformLocation );
+    LOAD_FUNCPTR( glLinkProgram );
     LOAD_FUNCPTR( glRenderbufferStorage );
     LOAD_FUNCPTR( glRenderbufferStorageMultisample );
+    LOAD_FUNCPTR( glScissorIndexed );
+    LOAD_FUNCPTR( glScissorIndexedv );
+    LOAD_FUNCPTR( glShaderSource );
+    LOAD_FUNCPTR( glUniformBlockBinding );
+    LOAD_FUNCPTR( glUniform1i );
+    LOAD_FUNCPTR( glUseProgram );
+    LOAD_FUNCPTR( glViewportIndexedf );
+    LOAD_FUNCPTR( glViewportIndexedfv );
+    LOAD_FUNCPTR( glGetFramebufferAttachmentParameteriv );
 #undef LOAD_FUNCPTR

 #define LOAD_FUNCPTR(f) do if((p##f = (void*)pglXGetProcAddressARB((const unsigned char*)#f)) == NULL) \
@@ -687,10 +763,6 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
     /* NV GLX Extension */
     LOAD_FUNCPTR(glXAllocateMemoryNV);
     LOAD_FUNCPTR(glXFreeMemoryNV);
-
-    LOAD_FUNCPTR(glScissorIndexed);
-    LOAD_FUNCPTR(glScissorIndexedv);
-    LOAD_FUNCPTR(glGetIntegeri_v);
 #undef LOAD_FUNCPTR

     if(!X11DRV_WineGL_InitOpenglInfo()) goto failed;
@@ -781,13 +853,6 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
         pglXSwapBuffersMscOML = pglXGetProcAddressARB( (const GLubyte *)"glXSwapBuffersMscOML" );
     }

-    if (has_extension( glExtensions, "GL_ARB_viewport_array"))
-    {
-        opengl_funcs.ext.p_glGetIntegeri_v = pglGetIntegeri_v;
-        opengl_funcs.ext.p_glScissorIndexed = pglScissorIndexed;
-        opengl_funcs.ext.p_glScissorIndexedv = pglScissorIndexedv;
-    }
-
     X11DRV_WineGL_LoadExtensions();
     init_pixel_formats( gdi_display );
     return TRUE;
@@ -1554,7 +1619,7 @@ void sync_gl_drawable( HWND hwnd, BOOL known_child )

     if (DC_GL_PIXMAP_WIN != old->type) {
         data = get_win_data( hwnd );
-        old->fs_hack = data->fs_hack;
+        old->fs_hack = data->fs_hack || fs_hack_get_gamma_ramp(NULL) != NULL;
         if (old->fs_hack)
             TRACE( "Window %p has the fullscreen hack enabled\n", hwnd );
         release_win_data( data );
@@ -1902,7 +1967,6 @@ struct fs_hack_fbconfig_attribs
     int stencil_size;
     int doublebuffer;
     int samples;
-    int srgb;
 };

 struct fs_hack_fbo_attachments_config
@@ -1924,10 +1988,7 @@ static void fs_hack_get_attachments_config( struct gl_drawable *gl, struct fs_ha
     if (attribs->red_size != 8 || attribs->green_size != 8 || attribs->blue_size != 8)
         FIXME( "Unsupported RGBA color sizes {%u, %u, %u, %u}.\n",
                 attribs->red_size, attribs->green_size, attribs->blue_size, attribs->alpha_size );
-    if (attribs->srgb)
-        config->color_internalformat = attribs->alpha_size ? GL_SRGB8_ALPHA8 : GL_SRGB8;
-    else
-        config->color_internalformat = attribs->alpha_size ? GL_RGBA8 : GL_RGB8;
+    config->color_internalformat = attribs->alpha_size ? GL_SRGB8_ALPHA8 : GL_SRGB8;
     config->color_format = GL_BGRA;
     config->color_type = GL_UNSIGNED_INT_8_8_8_8_REV;
     if (attribs->depth_size || attribs->stencil_size)
@@ -1947,6 +2008,161 @@ static void fs_hack_get_attachments_config( struct gl_drawable *gl, struct fs_ha
     config->samples = attribs->samples;
 }

+static const float *fs_hack_get_default_gamma_ramp(void)
+{
+    static float default_gamma_ramp[GAMMA_RAMP_SIZE * 4];
+    static BOOL initialized;
+    unsigned int i;
+
+    if (!initialized)
+    {
+        for (i = 0; i < GAMMA_RAMP_SIZE; i++)
+            default_gamma_ramp[i * 4    ] =
+            default_gamma_ramp[i * 4 + 1] =
+            default_gamma_ramp[i * 4 + 2] =
+                i / (float)(GAMMA_RAMP_SIZE - 1);
+        initialized = TRUE;
+    }
+    return default_gamma_ramp;
+}
+
+static const char *fs_hack_gamma_vertex_shader_src =
+"#version 330\n"
+"\n"
+"const vec4 square[4] = vec4[4](\n"
+"    vec4(-1.0, -1.0, 0.0, 1.0),\n"
+"    vec4(-1.0, 1.0, 0.0, 1.0),\n"
+"    vec4(1.0, -1.0, 0.0, 1.0),\n"
+"    vec4(1.0, 1.0, 0.0, 1.0)\n"
+");\n"
+"const vec2 texsq[4] = vec2[4](\n"
+"    vec2(0.0, 0.0),\n"
+"    vec2(0.0, 1.0),\n"
+"    vec2(1.0, 0.0),\n"
+"    vec2(1.0, 1.0)\n"
+");\n"
+"\n"
+"out vec2 texCoord;\n"
+"\n"
+"void main(void)\n"
+"{\n"
+"    gl_Position = square[gl_VertexID];\n"
+"    texCoord = texsq[gl_VertexID];\n"
+"}\n"
+;
+
+static const char *fs_hack_gamma_frag_shader_src =
+"#version 330\n"
+"\n"
+"uniform sampler2D tex;\n"
+"in vec2 texCoord;\n"
+"layout (std140) uniform ramp {\n"
+"    vec3 values[256];\n"
+"};\n"
+"\n"
+"layout(location = 0) out vec4 outColor;\n"
+"\n"
+"void main(void)\n"
+"{\n"
+"    vec4 lookup = texture(tex, texCoord) * 255.0;\n"
+"    outColor.r = values[int(lookup.r)].r;\n"
+"    outColor.g = values[int(lookup.g)].g;\n"
+"    outColor.b = values[int(lookup.b)].b;\n"
+"    outColor.a = 1.0;\n"
+"}\n"
+;
+
+static void fs_hack_setup_gamma_shader( struct wgl_context *ctx, struct gl_drawable *gl )
+{
+    GLint success;
+    GLuint vshader, fshader, program, ramp_index, tex_loc, prev_program;
+    char errstr[512];
+    const float *default_gamma_ramp = fs_hack_get_default_gamma_ramp();
+
+    opengl_funcs.gl.p_glGetIntegerv( GL_CURRENT_PROGRAM, (GLint *)&prev_program );
+    /* vertex shader */
+    vshader = pglCreateShader(GL_VERTEX_SHADER);
+    if(vshader == 0){
+        ERR("Failed to create gamma vertex shader\n");
+        return;
+    }
+    pglShaderSource(vshader, 1, &fs_hack_gamma_vertex_shader_src, NULL);
+    pglCompileShader(vshader);
+
+    pglGetShaderiv(vshader, GL_COMPILE_STATUS, &success);
+    if(!success){
+        pglGetShaderInfoLog(vshader, sizeof(errstr), NULL, errstr);
+        ERR("Compiling gamma vertex shader failed: %s\n", errstr);
+        pglDeleteShader(vshader);
+        return;
+    }
+
+
+    /* fragment shader */
+    fshader = pglCreateShader(GL_FRAGMENT_SHADER);
+    if(fshader == 0){
+        ERR("Failed to create gamma fragment shader\n");
+        pglDeleteShader(vshader);
+        return;
+    }
+    pglShaderSource(fshader, 1, &fs_hack_gamma_frag_shader_src, NULL);
+    pglCompileShader(fshader);
+
+    pglGetShaderiv(fshader, GL_COMPILE_STATUS, &success);
+    if(!success){
+        pglGetShaderInfoLog(fshader, sizeof(errstr), NULL, errstr);
+        ERR("Compiling gamma fragment shader failed: %s\n", errstr);
+        pglDeleteShader(fshader);
+        pglDeleteShader(vshader);
+        return;
+    }
+
+
+    /* gamma program */
+    program = pglCreateProgram();
+    if(program == 0){
+        ERR("Failed to create gamma program\n");
+        pglDeleteShader(fshader);
+        pglDeleteShader(vshader);
+        return;
+    }
+
+    pglAttachShader(program, vshader);
+    pglAttachShader(program, fshader);
+
+    pglLinkProgram(program);
+
+    pglGetProgramiv(program, GL_LINK_STATUS, &success);
+    if(!success){
+        pglGetProgramInfoLog(program, sizeof(errstr), NULL, errstr);
+        ERR("Linking gamma shader failed: %s\n", errstr);
+        pglDeleteProgram(program);
+        pglDeleteShader(fshader);
+        pglDeleteShader(vshader);
+        return;
+    }
+
+    pglDeleteShader(fshader);
+    pglDeleteShader(vshader);
+
+    pglGenBuffers(1, &ctx->ramp_ubo);
+    pglBindBuffer(GL_UNIFORM_BUFFER, ctx->ramp_ubo);
+    pglBufferData(GL_UNIFORM_BUFFER, sizeof(float) * 4 * GAMMA_RAMP_SIZE, default_gamma_ramp, GL_DYNAMIC_DRAW);
+    gl->last_gamma_serial = 0;
+
+    ramp_index = pglGetUniformBlockIndex(program, "ramp");
+    pglUniformBlockBinding(program, ramp_index, 0);
+
+    pglUseProgram( program );
+
+    tex_loc = pglGetUniformLocation(program, "tex");
+    pglUniform1i(tex_loc, 0);
+
+    ctx->fs_hack_gamma_pgm = program;
+
+    pglUseProgram( prev_program );
+}
+
 static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *gl )
 {
     GLuint prev_draw_fbo, prev_read_fbo, prev_texture, prev_renderbuffer;
@@ -1972,7 +2188,6 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         {GLX_STENCIL_SIZE, offsetof(struct fs_hack_fbconfig_attribs, stencil_size)},
         {GLX_DOUBLEBUFFER, offsetof(struct fs_hack_fbconfig_attribs, doublebuffer)},
         {GLX_SAMPLES_ARB, offsetof(struct fs_hack_fbconfig_attribs, samples)},
-        {GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT, offsetof(struct fs_hack_fbconfig_attribs, srgb)},
     };
     BYTE *ptr = (BYTE *)&attribs;

@@ -1981,6 +2196,7 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         MONITORINFO monitor_info;
         HMONITOR monitor;
         int width, height;
+        GLuint profile;

         monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
         memset(&monitor_info, 0, sizeof(monitor_info));
@@ -1991,6 +2207,9 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *

         TRACE("Render buffer width:%d height:%d\n", width, height);

+        opengl_funcs.gl.p_glGetIntegerv( GL_CONTEXT_PROFILE_MASK, (GLint *)&profile );
+        ctx->is_core = (profile & GL_CONTEXT_CORE_PROFILE_BIT) != 0;
+
         opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&prev_draw_fbo );
         opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&prev_read_fbo );
         opengl_funcs.gl.p_glGetIntegerv( GL_TEXTURE_BINDING_2D, (GLint *)&prev_texture );
@@ -2006,13 +2225,27 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
             pglGenFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
             TRACE( "Created FBO %u for fullscreen hack.\n", ctx->fs_hack_fbo );
         }
-        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0);

         for (i = 0; i < ARRAY_SIZE(queries); ++i)
             pglXGetFBConfigAttrib( gdi_display, gl->format->fbconfig, queries[i].attribute,
                     (int *)&ptr[queries[i].offset] );
+
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
+
         fs_hack_get_attachments_config( gl, &attribs, &config );

+        if (!ctx->fs_hack_color_texture)
+            opengl_funcs.gl.p_glGenTextures( 1, &ctx->fs_hack_color_texture );
+        opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_color_texture );
+        opengl_funcs.gl.p_glTexImage2D( GL_TEXTURE_2D, 0, config.color_internalformat, width, height,
+                0, config.color_format, config.color_type, NULL);
+        opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
+        opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
+                ctx->fs_hack_integer ? GL_NEAREST : GL_LINEAR);
+        opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, prev_texture );
+        TRACE( "Created texture %u for fullscreen hack.\n", ctx->fs_hack_color_texture );
+
         if (config.samples)
         {
             if (!ctx->fs_hack_color_renderbuffer)
@@ -2022,30 +2255,17 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
                     config.color_internalformat, width, height );
             pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                     GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
-            TRACE( "Created renderbuffer %u for fullscreen hack.\n", ctx->fs_hack_color_renderbuffer );
-            pglGenRenderbuffers( 1, &ctx->fs_hack_color_resolve_renderbuffer );
-            pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_resolve_renderbuffer );
-            pglRenderbufferStorage( GL_RENDERBUFFER, config.color_internalformat, width, height );
+            TRACE( "Created renderbuffer %u and FBO %u for fullscreen hack.\n", ctx->fs_hack_color_renderbuffer, ctx->fs_hack_resolve_fbo );
             pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
-            pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                    GL_RENDERBUFFER, ctx->fs_hack_color_resolve_renderbuffer );
+            pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                    GL_TEXTURE_2D, ctx->fs_hack_color_texture, 0 );
             pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
             pglBindRenderbuffer( GL_RENDERBUFFER, prev_renderbuffer );
-            TRACE( "Also created renderbuffer %u and FBO %u for color resolve.\n",
-                    ctx->fs_hack_color_resolve_renderbuffer, ctx->fs_hack_resolve_fbo );
         }
         else
         {
-            if (!ctx->fs_hack_color_texture)
-                opengl_funcs.gl.p_glGenTextures( 1, &ctx->fs_hack_color_texture );
-            opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_color_texture );
-            opengl_funcs.gl.p_glTexImage2D( GL_TEXTURE_2D, 0, config.color_internalformat, width, height,
-                    0, config.color_format, config.color_type, NULL);
-            opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
-            opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, prev_texture );
             pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                     GL_TEXTURE_2D, ctx->fs_hack_color_texture, 0 );
-            TRACE( "Created texture %u for fullscreen hack.\n", ctx->fs_hack_color_texture );
         }

         if (config.ds_internalformat)
@@ -2083,6 +2303,8 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
             }
         }

+        fs_hack_setup_gamma_shader(ctx, gl);
+
         if(!gl->fs_hack_context_set_up)
         {
             opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
@@ -2105,6 +2327,10 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         ctx->setup_for.x = width;
         ctx->setup_for.y = height;
         gl->has_scissor_indexed = has_extension(glExtensions, "GL_ARB_viewport_array");
+        gl->has_clip_control = has_extension(glExtensions, "GL_ARB_clip_control");
+        gl->has_ati_frag_shader = !ctx->is_core && has_extension(glExtensions, "GL_ATI_fragment_shader");
+        gl->has_fragment_program = !ctx->is_core && has_extension(glExtensions, "GL_ARB_fragment_program");
+        gl->has_vertex_program = !ctx->is_core && has_extension(glExtensions, "GL_ARB_vertex_program");
         ctx->fs_hack_integer = fs_hack_is_integer();
         gl->fs_hack_context_set_up = TRUE;
     }
@@ -2122,12 +2348,15 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
             ctx->current_read_fbo = 0;
         }

+        pglDeleteBuffers(1, &ctx->ramp_ubo);
+        pglDeleteProgram(ctx->fs_hack_gamma_pgm);
+        ctx->fs_hack_gamma_pgm = 0;
+
         pglDeleteRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
-        pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_resolve_renderbuffer );
         pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
         opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_ds_texture );
         opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_color_texture );
-        ctx->fs_hack_color_renderbuffer = ctx->fs_hack_color_resolve_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
+        ctx->fs_hack_color_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
         ctx->fs_hack_color_texture = ctx->fs_hack_ds_texture = 0;
         pglDeleteFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
         pglDeleteFramebuffers( 1, &ctx->fs_hack_fbo );
@@ -2349,16 +2578,264 @@ static void wglReadBuffer( GLenum buffer )
     pglReadBuffer( buffer );
 }

+struct fs_hack_gl_state {
+    GLuint draw_fbo;
+    GLuint read_fbo;
+    GLuint program;
+    GLuint bound_texture;
+    GLint active_texture;
+    GLint clip_origin, clip_depth_mode;
+    GLuint ubo;
+    GLint64 ubo_size, ubo_start;
+    GLint viewporti[4];
+    GLfloat viewportf[4];
+    float clear_color[4];
+    GLboolean scissor_test, cull_face, blend, alpha_test, depth_test, stencil_test;
+    GLboolean arb_frag, arb_vert, ati_frag, fb_srgb;
+    GLboolean clip_distance[8];
+    GLboolean color_mask[4];
+    GLuint sampler;
+};
+
+#define SET 0
+#define RESET 1
+
+static void fs_hack_handle_enable_switch(int mode, GLenum cap, GLboolean *b, BOOL new)
+{
+    if(mode == SET){
+        *b = opengl_funcs.gl.p_glIsEnabled(cap);
+        if(new)
+            opengl_funcs.gl.p_glEnable(cap);
+        else
+            opengl_funcs.gl.p_glDisable(cap);
+    }else{
+        if(*b)
+            opengl_funcs.gl.p_glEnable(cap);
+        else
+            opengl_funcs.gl.p_glDisable(cap);
+    }
+}
+
+static void fs_hack_handle_fbo_state(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(mode == SET){
+        opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&state->draw_fbo );
+        opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&state->read_fbo );
+        TRACE( "Previous draw FBO %u, read FBO %u\n", state->draw_fbo, state->read_fbo );
+
+    }else{
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, state->draw_fbo );
+        pglBindFramebuffer( GL_READ_FRAMEBUFFER, state->read_fbo );
+    }
+}
+
+static void fs_hack_handle_clip_control(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(!gl->has_clip_control)
+        return;
+
+    if(mode == SET){
+        opengl_funcs.gl.p_glGetIntegerv(GL_CLIP_ORIGIN, (GLint *)&state->clip_origin);
+        opengl_funcs.gl.p_glGetIntegerv(GL_CLIP_DEPTH_MODE, (GLint *)&state->clip_depth_mode);
+
+
+        pglClipControl(GL_LOWER_LEFT, GL_NEGATIVE_ONE_TO_ONE);
+
+    }else{
+        pglClipControl(state->clip_origin, state->clip_depth_mode);
+    }
+}
+
+static void fs_hack_handle_shaders(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if (gl->has_fragment_program)
+        fs_hack_handle_enable_switch(mode, GL_FRAGMENT_PROGRAM_ARB, &state->arb_frag, FALSE);
+    if (gl->has_vertex_program)
+        fs_hack_handle_enable_switch(mode, GL_VERTEX_PROGRAM_ARB, &state->arb_vert, FALSE);
+    fs_hack_handle_enable_switch(mode, GL_FRAMEBUFFER_SRGB, &state->fb_srgb, TRUE);
+
+    if(gl->has_ati_frag_shader)
+        fs_hack_handle_enable_switch(mode, GL_FRAGMENT_SHADER_ATI, &state->ati_frag, FALSE);
+
+    if(mode == SET){
+        opengl_funcs.gl.p_glGetIntegerv( GL_CURRENT_PROGRAM, (GLint *)&state->program );
+
+        pglGetIntegeri_v( GL_UNIFORM_BUFFER_BINDING, 0, (GLint *)&state->ubo );
+        pglGetInteger64i_v( GL_UNIFORM_BUFFER_START, 0, &state->ubo_start );
+        pglGetInteger64i_v( GL_UNIFORM_BUFFER_SIZE, 0, &state->ubo_size );
+
+        opengl_funcs.gl.p_glGetIntegerv(GL_ACTIVE_TEXTURE, &state->active_texture);
+        pglActiveTexture(GL_TEXTURE0);
+        opengl_funcs.gl.p_glGetIntegerv( GL_TEXTURE_BINDING_2D, (GLint *)&state->bound_texture );
+        pglGetIntegeri_v(GL_SAMPLER_BINDING, 0, (GLint *)&state->sampler);
+
+        pglBindBufferBase(GL_UNIFORM_BUFFER, 0, ctx->ramp_ubo);
+
+        opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_color_texture );
+        pglBindSampler( 0, 0 );
+
+        pglUseProgram( ctx->fs_hack_gamma_pgm );
+
+    }else{
+        pglUseProgram( state->program );
+
+        pglBindSampler( 0, state->sampler );
+
+        opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, state->bound_texture );
+        pglActiveTexture(state->active_texture);
+
+        pglBindBufferRange(GL_UNIFORM_BUFFER, 0, state->ubo, state->ubo_start, state->ubo_size);
+    }
+}
+
+static void fs_hack_handle_viewport(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(mode == SET){
+        if(gl->has_scissor_indexed){
+            pglGetFloati_v(GL_VIEWPORT, 0, state->viewportf);
+            pglViewportIndexedf(0, scaled_origin->x, scaled_origin->y, scaled->cx, scaled->cy);
+        }else{
+            opengl_funcs.gl.p_glGetIntegerv(GL_VIEWPORT, state->viewporti);
+            opengl_funcs.gl.p_glViewport(scaled_origin->x, scaled_origin->y, scaled->cx, scaled->cy);
+        }
+
+    }else{
+        if(gl->has_scissor_indexed){
+            pglViewportIndexedfv(0, state->viewportf);
+        }else{
+            opengl_funcs.gl.p_glViewport(state->viewporti[0], state->viewporti[1],
+                    state->viewporti[2], state->viewporti[3]);
+        }
+    }
+}
+
+static void fs_hack_handle_clear_color(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(mode == SET){
+        opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, state->clear_color );
+        opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
+    }else{
+        opengl_funcs.gl.p_glClearColor( state->clear_color[0], state->clear_color[1], state->clear_color[2], state->clear_color[3] );
+    }
+}
+
+static void fs_hack_handle_clip_distance(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    unsigned int i;
+    if(mode == SET){
+        for(i = 0; i < ARRAY_SIZE(state->clip_distance); ++i){
+            state->clip_distance[i] = opengl_funcs.gl.p_glIsEnabled(GL_CLIP_DISTANCE0 + i);
+            opengl_funcs.gl.p_glDisable(GL_CLIP_DISTANCE0 + i);
+        }
+    }else{
+        for(i = 0; i < ARRAY_SIZE(state->clip_distance); ++i){
+            if(state->clip_distance[i])
+                opengl_funcs.gl.p_glEnable(GL_CLIP_DISTANCE0 + i);
+        }
+    }
+}
+
+static void fs_hack_handle_color_mask(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(mode == SET){
+        pglGetBooleani_v(GL_COLOR_WRITEMASK, 0, state->color_mask);
+
+        pglColorMaski(0, GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+    }else{
+        pglColorMaski(0, state->color_mask[0],
+                state->color_mask[1], state->color_mask[2],
+                state->color_mask[3]);
+    }
+}
+
+static void fs_hack_handle_scissor(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state,
+        const SIZE *real, const SIZE *scaled, const POINT *scaled_origin)
+{
+    fs_hack_handle_enable_switch(mode, GL_SCISSOR_TEST, &state->scissor_test, FALSE);
+}
+
+static void fs_hack_handle_cull_face(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    fs_hack_handle_enable_switch(mode, GL_CULL_FACE, &state->cull_face, FALSE);
+}
+
+static void fs_hack_handle_blend(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    fs_hack_handle_enable_switch(mode, GL_BLEND, &state->blend, FALSE);
+}
+
+static void fs_hack_handle_alpha_test(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(ctx->is_core)
+        return;
+
+    fs_hack_handle_enable_switch(mode, GL_ALPHA_TEST, &state->alpha_test, FALSE);
+}
+
+static void fs_hack_handle_ds_test(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    fs_hack_handle_enable_switch(mode, GL_DEPTH_TEST, &state->depth_test, FALSE);
+    fs_hack_handle_enable_switch(mode, GL_STENCIL_TEST, &state->stencil_test, FALSE);
+}
+
 static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer )
 {
+    static const struct
+    {
+        void (*state_handler)(int mode, struct gl_drawable *gl, struct wgl_context *ctx,
+                struct fs_hack_gl_state *state, const SIZE *real,
+                const SIZE *scaled, const POINT *scaled_origin);
+    }
+    general_state_handlers[] =
+    {
+        {fs_hack_handle_fbo_state},
+        {fs_hack_handle_scissor},
+        {fs_hack_handle_clear_color},
+    },
+    draw_state_handlers[] =
+    {
+        {fs_hack_handle_clip_control},
+        {fs_hack_handle_shaders},
+        {fs_hack_handle_viewport},
+        {fs_hack_handle_cull_face},
+        {fs_hack_handle_clip_distance},
+        {fs_hack_handle_color_mask},
+        {fs_hack_handle_blend},
+        {fs_hack_handle_alpha_test},
+        {fs_hack_handle_ds_test},
+    };
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
     SIZE scaled, src, real;
-    GLuint prev_draw_fbo, prev_read_fbo;
-    GLint prev_scissor[4];
     RECT user_rect, real_rect;
     POINT scaled_origin;
-    float prev_clear_color[4];
     HMONITOR monitor;
+    struct fs_hack_gl_state state;
+    const float *gamma_ramp;
+    LONG gamma_serial;
+    unsigned int i;

     monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
     scaled = fs_hack_get_scaled_screen_size(monitor);
@@ -2374,6 +2851,8 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer
     scaled_origin.x -= real_rect.left;
     scaled_origin.y -= real_rect.top;

+    gamma_ramp = fs_hack_get_gamma_ramp(&gamma_serial);
+
     TRACE("scaled:%dx%d src:%dx%d real:%dx%d user_rect:%s real_rect:%s scaled_origin:%s\n", scaled.cx, scaled.cy,
           src.cx, src.cy, real.cx, real.cy, wine_dbgstr_rect(&user_rect), wine_dbgstr_rect(&real_rect),
           wine_dbgstr_point(&scaled_origin));
@@ -2382,54 +2861,68 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer
             ctx->setup_for.y != src.cy)
         fs_hack_setup_context( ctx, gl );

-    TRACE( "Blitting from FBO %u %ux%u to %ux%u\n", ctx->fs_hack_fbo, src.cx, src.cy, scaled.cx, scaled.cy );
+    /* Can't stretch blit with multisampled renderbuffers */
+    if (ctx->fs_hack_color_renderbuffer && !gamma_ramp){
+        gamma_ramp = fs_hack_get_default_gamma_ramp();
+        gamma_serial = 0;
+    }

-    opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&prev_draw_fbo );
-    opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&prev_read_fbo );
-    TRACE( "Previous draw FBO %u, read FBO %u\n", prev_draw_fbo, prev_read_fbo );
+    TRACE( "Stretching from FBO %u %ux%u to %ux%u\n", ctx->fs_hack_fbo, src.cx, src.cy, scaled.cx, scaled.cy );

-    if(gl->has_scissor_indexed){
-        opengl_funcs.ext.p_glGetIntegeri_v(GL_SCISSOR_BOX, 0, prev_scissor);
-        opengl_funcs.ext.p_glScissorIndexed(0, 0, 0, real.cx, real.cy);
-    }else{
-        opengl_funcs.gl.p_glGetIntegerv(GL_SCISSOR_BOX, prev_scissor);
-        opengl_funcs.gl.p_glScissor(0, 0, real.cx, real.cy);
+    for (i = 0; i < ARRAY_SIZE(general_state_handlers); i++)
+        general_state_handlers[i].state_handler(SET, gl, ctx, &state, &real, &scaled, &scaled_origin);
+
+    if(gamma_ramp){
+        for (i = 0; i < ARRAY_SIZE(draw_state_handlers); i++)
+            draw_state_handlers[i].state_handler(SET, gl, ctx, &state, &real, &scaled, &scaled_origin);
     }

     pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_fbo );
-    if (ctx->fs_hack_color_resolve_renderbuffer)
+
+    if (ctx->fs_hack_color_renderbuffer)
     {
         pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
+
         pglBlitFramebuffer( 0, 0, src.cx, src.cy, 0, 0, src.cx, src.cy, GL_COLOR_BUFFER_BIT, GL_NEAREST );
+
         pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
     }
+
     pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );

     //HACK
     //pglDrawBuffer( draw_buffer );
     pglDrawBuffer( GL_BACK );

-    opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, prev_clear_color );
-    opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
     opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
-    opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1], prev_clear_color[2], prev_clear_color[3] );

-    pglBlitFramebuffer( 0, 0, src.cx, src.cy,
-            scaled_origin.x, scaled_origin.y, scaled_origin.x + scaled.cx, scaled_origin.y + scaled.cy,
-            GL_COLOR_BUFFER_BIT, ctx->fs_hack_integer ? GL_NEAREST : GL_LINEAR );
+    if(gamma_ramp){
+        if(gamma_serial != gl->last_gamma_serial){
+            TRACE("updating gamma ramp (serial: %u)\n", gamma_serial);
+
+            pglBufferData(GL_UNIFORM_BUFFER, sizeof(float) * 4 * GAMMA_RAMP_SIZE, gamma_ramp, GL_DYNAMIC_DRAW);
+
+            gl->last_gamma_serial = gamma_serial;
+        }
+
+        pglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+    }else{
+        pglBlitFramebuffer( 0, 0, src.cx, src.cy,
+                scaled_origin.x, scaled_origin.y, scaled_origin.x + scaled.cx, scaled_origin.y + scaled.cy,
+                GL_COLOR_BUFFER_BIT, ctx->fs_hack_integer ? GL_NEAREST : GL_LINEAR );
+    }
+
     //HACK
     if ( draw_buffer == GL_FRONT )
         pglXSwapBuffers(gdi_display, gl->drawable);

-    if(gl->has_scissor_indexed){
-        opengl_funcs.ext.p_glScissorIndexedv(0, prev_scissor);
-    }else{
-        opengl_funcs.gl.p_glScissor(prev_scissor[0], prev_scissor[1],
-                prev_scissor[2], prev_scissor[3]);
+    if(gamma_ramp){
+        for (i = 0; i < ARRAY_SIZE(draw_state_handlers); i++)
+            draw_state_handlers[i].state_handler(RESET, gl, ctx, &state, NULL, NULL, NULL);
     }

-    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, prev_draw_fbo );
-    pglBindFramebuffer( GL_READ_FRAMEBUFFER, prev_read_fbo );
+    for (i = 0; i < ARRAY_SIZE(general_state_handlers); i++)
+        general_state_handlers[i].state_handler(RESET, gl, ctx, &state, NULL, NULL, NULL);
 }

 static void wglFinish(void)
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 55875edc788..3e162382975 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -688,6 +688,8 @@ extern double fs_hack_get_user_to_real_scale(HMONITOR) DECLSPEC_HIDDEN;
 extern SIZE fs_hack_get_scaled_screen_size(HMONITOR monitor) DECLSPEC_HIDDEN;
 extern RECT fs_hack_get_real_virtual_screen(void) DECLSPEC_HIDDEN;
 extern void fs_hack_init(void) DECLSPEC_HIDDEN;
+extern const float *fs_hack_get_gamma_ramp(LONG *serial);
+extern void fs_hack_set_gamma_ramp(const WORD *ramp);
 extern int mode_compare(const void *p1, const void *p2) DECLSPEC_HIDDEN;

 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
diff --git a/dlls/winex11.drv/xvidmode.c b/dlls/winex11.drv/xvidmode.c
index 123e5d036a9..828aeb83d0c 100644
--- a/dlls/winex11.drv/xvidmode.c
+++ b/dlls/winex11.drv/xvidmode.c
@@ -554,6 +554,25 @@ void X11DRV_XF86VM_Init(void)

 #endif /* SONAME_LIBXXF86VM */

+static BOOL CALLBACK gammahack_UpdateWindowGamma(HWND hwnd, LPARAM lparam)
+{
+    /* XXX: Technically, the ramp should only apply to windows on the given
+     * device, but I can't think of a situation in which that would matter. */
+
+    sync_gl_drawable(hwnd, FALSE);
+
+    return TRUE;
+}
+
+static BOOL gamma_hack_SetGammaRamp(PHYSDEV dev, const WORD *ramp)
+{
+    fs_hack_set_gamma_ramp(ramp);
+
+    EnumWindows(gammahack_UpdateWindowGamma, 0);
+
+    return TRUE;
+}
+
 /***********************************************************************
  *		GetDeviceGammaRamp (X11DRV.@)
  *
@@ -580,7 +599,9 @@ BOOL CDECL X11DRV_GetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp)
 BOOL CDECL X11DRV_SetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp)
 {
 #ifdef SONAME_LIBXXF86VM
-  return X11DRV_XF86VM_SetGammaRamp(ramp);
+  if(!X11DRV_XF86VM_SetGammaRamp(ramp))
+      return gamma_hack_SetGammaRamp(dev, ramp);
+  return TRUE;
 #else
   return FALSE;
 #endif
From d342a851179df02705f463d6cac444cbe6607868 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Jun 2021 18:57:49 +0300
Subject: [PATCH] fshack: Setup gamma shader only once per context.

Fixes GL objects leak and avoids unneccessary shader recreation
when the fs_hack_setup_context() is called due to switching GL
drawable.

For Star Wars - Knights of the Old Republic blank screen.

CW-Bug-Id: #19002
---
 dlls/winex11.drv/opengl.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index fab13d5b1df..db66aabff59 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -2079,6 +2079,11 @@ static void fs_hack_setup_gamma_shader( struct wgl_context *ctx, struct gl_drawa
     char errstr[512];
     const float *default_gamma_ramp = fs_hack_get_default_gamma_ramp();

+    gl->last_gamma_serial = 0;
+
+    if (ctx->fs_hack_gamma_pgm)
+        return;
+
     opengl_funcs.gl.p_glGetIntegerv( GL_CURRENT_PROGRAM, (GLint *)&prev_program );
     /* vertex shader */
     vshader = pglCreateShader(GL_VERTEX_SHADER);
@@ -2148,7 +2153,6 @@ static void fs_hack_setup_gamma_shader( struct wgl_context *ctx, struct gl_drawa
     pglGenBuffers(1, &ctx->ramp_ubo);
     pglBindBuffer(GL_UNIFORM_BUFFER, ctx->ramp_ubo);
     pglBufferData(GL_UNIFORM_BUFFER, sizeof(float) * 4 * GAMMA_RAMP_SIZE, default_gamma_ramp, GL_DYNAMIC_DRAW);
-    gl->last_gamma_serial = 0;

     ramp_index = pglGetUniformBlockIndex(program, "ramp");
     pglUniformBlockBinding(program, ramp_index, 0);
From b52e6329eb7ff2feec0ef0b4b2bb638abe57e200 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Jun 2021 23:56:20 +0300
Subject: [PATCH] fshack: Track if multisample resolve is needed in
 gl_drawable.

As that changes per drawable and not per context.
---
 dlls/winex11.drv/opengl.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index db66aabff59..5b4a7456e29 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -263,6 +263,7 @@ struct gl_drawable
     BOOL                           fs_hack;
     BOOL                           fs_hack_did_swapbuf;
     BOOL                           fs_hack_context_set_up;
+    BOOL                           fs_hack_needs_resolve;
     BOOL                           has_scissor_indexed;
     BOOL                           has_clip_control;
     BOOL                           has_ati_frag_shader;
@@ -2252,11 +2253,13 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *

         if (config.samples)
         {
+            gl->fs_hack_needs_resolve = TRUE;
             if (!ctx->fs_hack_color_renderbuffer)
                 pglGenRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
             pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
             pglRenderbufferStorageMultisample( GL_RENDERBUFFER, config.samples,
                     config.color_internalformat, width, height );
+
             pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                     GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
             TRACE( "Created renderbuffer %u and FBO %u for fullscreen hack.\n", ctx->fs_hack_color_renderbuffer, ctx->fs_hack_resolve_fbo );
@@ -2268,6 +2271,7 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         }
         else
         {
+            gl->fs_hack_needs_resolve = FALSE;
             pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                     GL_TEXTURE_2D, ctx->fs_hack_color_texture, 0 );
         }
@@ -2281,6 +2285,7 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
                 pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
                 pglRenderbufferStorageMultisample( GL_RENDERBUFFER, config.samples,
                         config.ds_internalformat, width, height );
+
                 pglBindRenderbuffer( GL_RENDERBUFFER, prev_renderbuffer );
                 if (attribs.depth_size)
                     pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
@@ -2866,7 +2871,7 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer
         fs_hack_setup_context( ctx, gl );

     /* Can't stretch blit with multisampled renderbuffers */
-    if (ctx->fs_hack_color_renderbuffer && !gamma_ramp){
+    if (gl->fs_hack_needs_resolve && !gamma_ramp){
         gamma_ramp = fs_hack_get_default_gamma_ramp();
         gamma_serial = 0;
     }
@@ -2883,7 +2888,7 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer

     pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_fbo );

-    if (ctx->fs_hack_color_renderbuffer)
+    if (gl->fs_hack_needs_resolve)
     {
         pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );

From d4eb7bd91e076ae6531fe87d83dae2ad07042caa Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 23 Jun 2021 20:26:27 +0300
Subject: [PATCH] fshack: Destroy fshack GL objects only at GL context destroy.

---
 dlls/winex11.drv/opengl.c | 59 ++++++++++++++++++++++++++++-----------
 1 file changed, 43 insertions(+), 16 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 5b4a7456e29..ff5c9969aab 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1899,6 +1899,40 @@ static struct wgl_context * WINAPI glxdrv_wglCreateContext( HDC hdc )
     return ret;
 }

+static void fs_hack_destroy_context( struct wgl_context *ctx )
+{
+    GLXContext prev_context;
+    GLXDrawable prev_drawable;
+
+    if (!ctx->drawables[0]) return;
+
+    prev_context = pglXGetCurrentContext();
+    prev_drawable = pglXGetCurrentDrawable();
+    pglXMakeCurrent(gdi_display, ctx->drawables[0]->drawable, ctx->ctx);
+
+    pglDeleteBuffers(1, &ctx->ramp_ubo);
+    pglDeleteProgram(ctx->fs_hack_gamma_pgm);
+    ctx->fs_hack_gamma_pgm = 0;
+
+    if (ctx->fs_hack_ds_renderbuffer)
+        pglDeleteRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
+    if (ctx->fs_hack_color_renderbuffer)
+        pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
+    if (ctx->fs_hack_ds_texture)
+        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_ds_texture );
+    if (ctx->fs_hack_color_texture)
+        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_color_texture );
+    ctx->fs_hack_color_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
+    ctx->fs_hack_color_texture = ctx->fs_hack_ds_texture = 0;
+    if (ctx->fs_hack_resolve_fbo)
+        pglDeleteFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
+    if (ctx->fs_hack_fbo)
+        pglDeleteFramebuffers( 1, &ctx->fs_hack_fbo );
+    ctx->fs_hack_resolve_fbo = ctx->fs_hack_fbo = 0;
+
+    pglXMakeCurrent(gdi_display, prev_drawable, prev_context);
+}
+
 /***********************************************************************
  *		glxdrv_wglDeleteContext
  */
@@ -1908,6 +1942,8 @@ static BOOL WINAPI glxdrv_wglDeleteContext(struct wgl_context *ctx)

     TRACE("(%p)\n", ctx);

+    fs_hack_destroy_context( ctx );
+
     EnterCriticalSection( &context_section );
     list_remove( &ctx->entry );
     LIST_FOR_EACH_ENTRY( pb, &pbuffer_list, struct wgl_pbuffer, entry )
@@ -2227,7 +2263,6 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         if (!ctx->fs_hack_fbo)
         {
             pglGenFramebuffers( 1, &ctx->fs_hack_fbo );
-            pglGenFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
             TRACE( "Created FBO %u for fullscreen hack.\n", ctx->fs_hack_fbo );
         }
         pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0);
@@ -2254,6 +2289,13 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         if (config.samples)
         {
             gl->fs_hack_needs_resolve = TRUE;
+
+            if (!ctx->fs_hack_resolve_fbo)
+            {
+                pglGenFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
+                TRACE( "Created resolve FBO %u for fullscreen hack.\n", ctx->fs_hack_resolve_fbo );
+            }
+
             if (!ctx->fs_hack_color_renderbuffer)
                 pglGenRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
             pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
@@ -2356,21 +2398,6 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
             pglBindFramebuffer( GL_READ_FRAMEBUFFER, 0 );
             ctx->current_read_fbo = 0;
         }
-
-        pglDeleteBuffers(1, &ctx->ramp_ubo);
-        pglDeleteProgram(ctx->fs_hack_gamma_pgm);
-        ctx->fs_hack_gamma_pgm = 0;
-
-        pglDeleteRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
-        pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
-        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_ds_texture );
-        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_color_texture );
-        ctx->fs_hack_color_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
-        ctx->fs_hack_color_texture = ctx->fs_hack_ds_texture = 0;
-        pglDeleteFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
-        pglDeleteFramebuffers( 1, &ctx->fs_hack_fbo );
-        ctx->fs_hack_fbo = 0;
-
         gl->fs_hack_context_set_up = FALSE;
     }
 }
From f4dc9634f2036de04260193c2beca61aa1bf8dd1 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Jun 2021 00:36:17 +0300
Subject: [PATCH] fshack: Set viewport in fs_hack_setup_context().

For Star Wars - Knights of the Old Republic blank screen.

CW-Bug-Id: #19002
---
 dlls/winex11.drv/opengl.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index ff5c9969aab..d0089806155 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -2356,6 +2356,9 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *

         fs_hack_setup_gamma_shader(ctx, gl);

+        if (!ctx->has_been_current)
+            opengl_funcs.gl.p_glViewport(0, 0, width, height);
+
         if(!gl->fs_hack_context_set_up)
         {
             opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
@@ -2383,6 +2386,7 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         gl->has_fragment_program = !ctx->is_core && has_extension(glExtensions, "GL_ARB_fragment_program");
         gl->has_vertex_program = !ctx->is_core && has_extension(glExtensions, "GL_ARB_vertex_program");
         ctx->fs_hack_integer = fs_hack_is_integer();
+
         gl->fs_hack_context_set_up = TRUE;
     }
     else
From 79f3013b06b7502fa2875aac989335ec0d8576b5 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Jun 2021 19:03:16 +0300
Subject: [PATCH] fshack: Also enable fshack for drawable due to gamma in
 create_gl_drawable().

For Star Wars - Knights of the Old Republic blank screen.

CW-Bug-Id: #19002
---
 dlls/winex11.drv/opengl.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index d0089806155..0a08c0a2261 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1471,7 +1471,7 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel
         if (gl->window)
             gl->drawable = pglXCreateWindow( gdi_display, gl->format->fbconfig, gl->window, NULL );
         data = get_win_data( hwnd );
-        gl->fs_hack = data->fs_hack;
+        gl->fs_hack = data->fs_hack || fs_hack_get_gamma_ramp(NULL);
         if (gl->fs_hack)
             TRACE( "Window %p has the fullscreen hack enabled\n", hwnd );
         release_win_data( data );
From a770d875cd09a714bedcbfeef16062a62a77c169 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Jun 2021 18:54:20 +0300
Subject: [PATCH] fshack: Use window dimensions in GL if fshack is enabled for
 gamma only.

For Star Wars - Knights of the Old Republic blank screen.

CW-Bug-Id: #19002
---
 dlls/winex11.drv/opengl.c | 49 ++++++++++++++++++++++++++++++---------
 1 file changed, 38 insertions(+), 11 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 0a08c0a2261..175b183dc44 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -2237,14 +2237,27 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         MONITORINFO monitor_info;
         HMONITOR monitor;
         int width, height;
+        RECT rect = {0};
         GLuint profile;
+        HWND hwnd;

-        monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
-        memset(&monitor_info, 0, sizeof(monitor_info));
-        monitor_info.cbSize = sizeof(monitor_info);
-        GetMonitorInfoW(monitor, &monitor_info);
-        width = monitor_info.rcMonitor.right - monitor_info.rcMonitor.left;
-        height = monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top;
+        hwnd = WindowFromDC(ctx->hdc);
+        monitor = fs_hack_monitor_from_hwnd(hwnd);
+
+        if (fs_hack_enabled(monitor))
+        {
+            memset(&monitor_info, 0, sizeof(monitor_info));
+            monitor_info.cbSize = sizeof(monitor_info);
+            GetMonitorInfoW(monitor, &monitor_info);
+            rect = monitor_info.rcMonitor;
+        }
+        else
+        {
+            GetClientRect(hwnd, &rect);
+        }
+
+        width = rect.right - rect.left;
+        height = rect.bottom - rect.top;

         TRACE("Render buffer width:%d height:%d\n", width, height);

@@ -2869,18 +2882,32 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer
     };
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
     SIZE scaled, src, real;
-    RECT user_rect, real_rect;
+    RECT user_rect = {0}, real_rect;
     POINT scaled_origin;
     HMONITOR monitor;
     struct fs_hack_gl_state state;
     const float *gamma_ramp;
     LONG gamma_serial;
     unsigned int i;
+    HWND hwnd;
+
+    hwnd = WindowFromDC(ctx->hdc);
+    monitor = fs_hack_monitor_from_hwnd(hwnd);
+
+    if (fs_hack_enabled(monitor))
+    {
+        user_rect = fs_hack_current_mode(monitor);
+        real_rect = fs_hack_real_mode(monitor);
+        scaled = fs_hack_get_scaled_screen_size(monitor);
+    }
+    else
+    {
+        GetClientRect(hwnd, &user_rect);
+        real_rect = user_rect;
+        scaled.cx = user_rect.right - user_rect.left;
+        scaled.cy = user_rect.bottom - user_rect.top;
+    }

-    monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
-    scaled = fs_hack_get_scaled_screen_size(monitor);
-    user_rect = fs_hack_current_mode(monitor);
-    real_rect = fs_hack_real_mode(monitor);
     src.cx = user_rect.right - user_rect.left;
     src.cy = user_rect.bottom - user_rect.top;
     real.cx = real_rect.right - real_rect.left;
From 2452e8f4855dbd27e2f1a951fad2da7d21ddf711 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 23 Jun 2021 00:01:57 +0300
Subject: [PATCH] fshack: Use window size for texture and framebuffers in
 fs_hack_setup_context().

For Star Wars - Knights of the Old Republic blank screen.

CW-Bug-Id: #19002
---
 dlls/winex11.drv/opengl.c | 16 +---------------
 1 file changed, 1 insertion(+), 15 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 175b183dc44..91119e8d393 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -2234,27 +2234,13 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *

     if (ctx->fs_hack)
     {
-        MONITORINFO monitor_info;
-        HMONITOR monitor;
         int width, height;
         RECT rect = {0};
         GLuint profile;
         HWND hwnd;

         hwnd = WindowFromDC(ctx->hdc);
-        monitor = fs_hack_monitor_from_hwnd(hwnd);
-
-        if (fs_hack_enabled(monitor))
-        {
-            memset(&monitor_info, 0, sizeof(monitor_info));
-            monitor_info.cbSize = sizeof(monitor_info);
-            GetMonitorInfoW(monitor, &monitor_info);
-            rect = monitor_info.rcMonitor;
-        }
-        else
-        {
-            GetClientRect(hwnd, &rect);
-        }
+        GetClientRect(hwnd, &rect);

         width = rect.right - rect.left;
         height = rect.bottom - rect.top;
From 3b91dfd727758caf874bbcfaedd8a0f4d4822320 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 23 Feb 2021 11:28:28 +0100
Subject: [PATCH] HACK: fshack: winex11.drv: Use gdi_display for client_window
 requests.

CW-Bug-Id: 16608
---
 dlls/winex11.drv/window.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index bbe2a1728b5..e785e0c0563 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2659,7 +2659,7 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
         if(data->whole_window)
             XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
         if(data->client_window)
-            XMoveResizeWindow(data->display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+            XMoveResizeWindow(gdi_display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
     }else if(data->fs_hack && (!fs_hack_enabled(monitor) ||
             !fs_hack_matches_current_mode(monitor,
                 window_rect->right - window_rect->left,
@@ -2672,7 +2672,7 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
                     window_rect->right - window_rect->left,
                     window_rect->bottom - window_rect->top);
         if(data->client_window){
-            XMoveResizeWindow(data->display, data->client_window,
+            XMoveResizeWindow(gdi_display, data->client_window,
                     data->client_rect.left - data->whole_rect.left,
                     data->client_rect.top - data->whole_rect.top,
                     data->client_rect.right - data->client_rect.left,
From 4640b0cc2479c0a78e151bd0459d3ffa160ca73b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 26 Feb 2021 17:34:56 +0100
Subject: [PATCH] HACK: fshack: winex11.drv: Simply scale offscreen vulkan
 surfaces.

They will be copied manually onto the screen, so we don't need to scale
them to the screen dimensions.

CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 34 +++++++++++++++++++++++++++++++++-
 1 file changed, 33 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 6bfbb9dc7bc..1afb62c0b7d 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -854,7 +854,7 @@ static VkBool32 X11DRV_query_fs_hack(VkSurfaceKHR surface, VkExtent2D *real_sz,
     }

     monitor = fs_hack_monitor_from_hwnd(hwnd);
-    if(fs_hack_enabled(monitor)){
+    if(fs_hack_enabled(monitor) && !x11_surface->offscreen){
         RECT real_rect = fs_hack_real_mode(monitor);
         RECT user_rect = fs_hack_current_mode(monitor);
         SIZE scaled = fs_hack_get_scaled_screen_size(monitor);
@@ -886,6 +886,38 @@ static VkBool32 X11DRV_query_fs_hack(VkSurfaceKHR surface, VkExtent2D *real_sz,
             dst_blit->extent.height = scaled.cy;
         }

+        if (filter)
+            *filter = fs_hack_is_integer() ? VK_FILTER_NEAREST : VK_FILTER_LINEAR;
+
+        return VK_TRUE;
+    }
+    else if (fs_hack_enabled(monitor))
+    {
+        double scale = fs_hack_get_user_to_real_scale( monitor );
+        RECT client_rect;
+
+        GetClientRect( hwnd, &client_rect );
+
+        if (real_sz)
+        {
+            real_sz->width = (client_rect.right - client_rect.left) * scale;
+            real_sz->height = (client_rect.bottom - client_rect.top) * scale;
+        }
+
+        if (user_sz)
+        {
+            user_sz->width = client_rect.right - client_rect.left;
+            user_sz->height = client_rect.bottom - client_rect.top;
+        }
+
+        if (dst_blit)
+        {
+            dst_blit->offset.x = client_rect.left * scale;
+            dst_blit->offset.y = client_rect.top * scale;
+            dst_blit->extent.width = (client_rect.right - client_rect.left) * scale;
+            dst_blit->extent.height = (client_rect.bottom - client_rect.top) * scale;
+        }
+
         if(filter)
             *filter = fs_hack_is_integer() ? VK_FILTER_NEAREST : VK_FILTER_LINEAR;

From 65ee4143317ed95b33ee67a9714b1269de7dc17e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 25 Feb 2021 19:12:10 +0100
Subject: [PATCH] HACK: fshack: winex11.drv: Resize child window client_windows
 too.

CW-Bug-Id: 16608
---
 dlls/winex11.drv/display.c | 40 ++++++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/window.c  |  2 ++
 dlls/winex11.drv/x11drv.h  |  1 +
 3 files changed, 43 insertions(+)

diff --git a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
index cf638ff43a0..56a0bf35070 100644
--- a/dlls/winex11.drv/display.c
+++ b/dlls/winex11.drv/display.c
@@ -308,6 +308,44 @@ void X11DRV_DisplayDevices_RegisterEventHandlers(void)
         handler->register_event_handlers();
 }

+BOOL CALLBACK fs_hack_update_child_window_client_surface(HWND hwnd, LPARAM enable_fs_hack)
+{
+    struct x11drv_win_data *data;
+    RECT client_rect;
+
+    if (!(data = get_win_data( hwnd )))
+        return TRUE;
+
+    if (enable_fs_hack && data->client_window)
+    {
+        client_rect = data->client_rect;
+        ClientToScreen( hwnd, (POINT *)&client_rect.left );
+        ClientToScreen( hwnd, (POINT *)&client_rect.right );
+        fs_hack_rect_user_to_real( &client_rect );
+
+        FIXME( "Enabling child fshack, resizing window %p to %s.\n", hwnd, wine_dbgstr_rect( &client_rect ) );
+        XMoveResizeWindow( gdi_display, data->client_window,
+                           client_rect.left, client_rect.top,
+                           client_rect.right - client_rect.left,
+                           client_rect.bottom - client_rect.top );
+        data->fs_hack = TRUE;
+    }
+    else if (!enable_fs_hack && data->client_window)
+    {
+        FIXME( "Disabling child fshack, restoring window %p.\n", hwnd );
+        XMoveResizeWindow( gdi_display, data->client_window,
+                           data->client_rect.left - data->whole_rect.left,
+                           data->client_rect.top - data->whole_rect.top,
+                           data->client_rect.right - data->client_rect.left,
+                           data->client_rect.bottom - data->client_rect.top );
+        data->fs_hack = FALSE;
+    }
+
+    if (data->client_window) sync_gl_drawable( hwnd, TRUE );
+    release_win_data( data );
+    return TRUE;
+}
+
 static BOOL CALLBACK update_windows_on_display_change(HWND hwnd, LPARAM lparam)
 {
     struct x11drv_win_data *data;
@@ -342,6 +380,7 @@ static BOOL CALLBACK update_windows_on_display_change(HWND hwnd, LPARAM lparam)
                 XMoveResizeWindow(gdi_display, data->client_window, 0, 0, width, height);
             sync_gl_drawable(hwnd, FALSE);
             update_net_wm_states( data );
+            EnumChildWindows( hwnd, fs_hack_update_child_window_client_surface, TRUE );
         }
     } else {
         /* update the full screen state */
@@ -373,6 +412,7 @@ static BOOL CALLBACK update_windows_on_display_change(HWND hwnd, LPARAM lparam)
                         data->client_rect.bottom - data->client_rect.top);
             }
             sync_gl_drawable(hwnd, FALSE);
+            EnumChildWindows( hwnd, fs_hack_update_child_window_client_surface, FALSE );
         }
     }
     release_win_data(data);
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index e785e0c0563..4cd2324bff2 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2660,6 +2660,7 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
             XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
         if(data->client_window)
             XMoveResizeWindow(gdi_display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+        EnumChildWindows( hwnd, fs_hack_update_child_window_client_surface, TRUE );
     }else if(data->fs_hack && (!fs_hack_enabled(monitor) ||
             !fs_hack_matches_current_mode(monitor,
                 window_rect->right - window_rect->left,
@@ -2678,6 +2679,7 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
                     data->client_rect.right - data->client_rect.left,
                     data->client_rect.bottom - data->client_rect.top);
         }
+        EnumChildWindows( hwnd, fs_hack_update_child_window_client_surface, FALSE );
     }

     /* check if we need to switch the window to managed */
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 3e162382975..4e7d602ee73 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -691,6 +691,7 @@ extern void fs_hack_init(void) DECLSPEC_HIDDEN;
 extern const float *fs_hack_get_gamma_ramp(LONG *serial);
 extern void fs_hack_set_gamma_ramp(const WORD *ramp);
 extern int mode_compare(const void *p1, const void *p2) DECLSPEC_HIDDEN;
+BOOL CALLBACK fs_hack_update_child_window_client_surface(HWND hwnd, LPARAM enable_fs_hack) DECLSPEC_HIDDEN;

 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 {
From b7eccbd7f418ad20822b5113277963e001368640 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 17 May 2021 10:54:27 +0200
Subject: [PATCH] HACK: fshack: winex11.drv: Transform X11DRV_FLUSH_VK_DRAWABLE
 rects.

CW-Bug-Id: #16608
---
 dlls/winex11.drv/init.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 8f152eedc69..095a3778089 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -227,13 +227,15 @@ static INT CDECL X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOI
                 {
                     const struct x11drv_escape_present_drawable *data = in_data;
                     RECT rect = physDev->dc_rect;
+                    RECT real_rect = physDev->dc_rect;

+                    fs_hack_rect_user_to_real( &real_rect );
                     OffsetRect( &rect, -physDev->dc_rect.left, -physDev->dc_rect.top );
                     if (data->flush) XFlush( gdi_display );
                     XSetFunction( gdi_display, physDev->gc, GXcopy );
                     XCopyArea( gdi_display, data->drawable, physDev->drawable, physDev->gc,
-                               0, 0, rect.right, rect.bottom,
-                               physDev->dc_rect.left, physDev->dc_rect.top );
+                               0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top,
+                               real_rect.left, real_rect.top );
                     add_device_bounds( physDev, &rect );
                     return TRUE;
                 }
From 9e86e5142b754c7265fb505ea1208e3b2d34a23e Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Sat, 11 Dec 2021 12:38:26 +0100
Subject: [PATCH] HACK: winevulkan: Add vkGetPhysicalDeviceProperties thunks to
 fake NVIDIA PCI IDs as AMD

Needed for RDR2 with NVIDIA cards, otherwise game crashes or gets stuck
trying to load nvapi64.dll
---
 dlls/winevulkan/loader.c        | 48 +++++++++++++++++++++++++++++++++
 dlls/winevulkan/make_vulkan     |  1 +
 dlls/winevulkan/vulkan_loader.h |  3 +++
 3 files changed, 52 insertions(+)

diff --git a/dlls/winevulkan/loader.c b/dlls/winevulkan/loader.c
index 0b2c4241f75..d3ac9f57763 100644
--- a/dlls/winevulkan/loader.c
+++ b/dlls/winevulkan/loader.c
@@ -368,6 +368,30 @@ static void fill_luid_property(VkPhysicalDeviceProperties2 *properties2)
             id->deviceNodeMask);
 }

+void WINAPI vkGetPhysicalDeviceProperties(VkPhysicalDevice physical_device,
+        VkPhysicalDeviceProperties *properties)
+{
+    struct vkGetPhysicalDeviceProperties_params params;
+
+    TRACE("%p, %p\n", physical_device, properties);
+
+    params.physicalDevice = physical_device;
+    params.pProperties = properties;
+    vk_unix_call(unix_vkGetPhysicalDeviceProperties, &params);
+
+    {
+        const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+        if (sgi && *sgi != '0')
+        {
+            if (properties->vendorID == 0x10de /* NVIDIA */)
+            {
+                properties->vendorID = 0x1002; /* AMD */
+                properties->deviceID = 0x67df; /* RX 480 */
+            }
+        }
+    }
+}
+
 void WINAPI vkGetPhysicalDeviceProperties2(VkPhysicalDevice phys_dev,
         VkPhysicalDeviceProperties2 *properties2)
 {
@@ -379,6 +403,18 @@ void WINAPI vkGetPhysicalDeviceProperties2(VkPhysicalDevice phys_dev,
     params.pProperties = properties2;
     vk_unix_call(unix_vkGetPhysicalDeviceProperties2, &params);
     fill_luid_property(properties2);
+
+    {
+        const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+        if (sgi && *sgi != '0')
+        {
+            if (properties2->properties.vendorID == 0x10de /* NVIDIA */)
+            {
+                properties2->properties.vendorID = 0x1002; /* AMD */
+                properties2->properties.deviceID = 0x67df; /* RX 480 */
+            }
+        }
+    }
 }

 void WINAPI vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice phys_dev,
@@ -392,6 +428,18 @@ void WINAPI vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice phys_dev,
     params.pProperties = properties2;
     vk_unix_call(unix_vkGetPhysicalDeviceProperties2KHR, &params);
     fill_luid_property(properties2);
+
+    {
+        const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+        if (sgi && *sgi != '0')
+        {
+            if (properties2->properties.vendorID == 0x10de /* NVIDIA */)
+            {
+                properties2->properties.vendorID = 0x1002; /* AMD */
+                properties2->properties.deviceID = 0x67df; /* RX 480 */
+            }
+        }
+    }
 }

 static BOOL WINAPI call_vulkan_debug_report_callback( struct wine_vk_debug_report_params *params, ULONG size )
diff --git a/dlls/winevulkan/vulkan_loader.h b/dlls/winevulkan/vulkan_loader.h
index 05913756fbc..275242657e3 100644
--- a/dlls/winevulkan/vulkan_loader.h
+++ b/dlls/winevulkan/vulkan_loader.h
@@ -20,6 +20,9 @@
 #ifndef __WINE_VULKAN_LOADER_H
 #define __WINE_VULKAN_LOADER_H

+#include <stdarg.h>
+#include <stdlib.h>
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include <stdarg.h>
From 398e397881820bff2add3dd68f1bbc4207294318 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Wed, 15 Jul 2020 11:25:13 -0700
Subject: [PATCH] HACK: winex11: Support faking AMD PCI IDs for NVIDIA cards

---
 dlls/winex11.drv/display.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
index 56a0bf35070..b3ed448c43f 100644
--- a/dlls/winex11.drv/display.c
+++ b/dlls/winex11.drv/display.c
@@ -21,6 +21,7 @@
 #include "config.h"

 #include <stdarg.h>
+#include <stdlib.h>

 #include "windef.h"
 #include "winbase.h"
@@ -474,6 +475,18 @@ void CDECL X11DRV_UpdateDisplayDevices( const struct gdi_device_manager *device_

     for (gpu = 0; gpu < gpu_count; gpu++)
     {
+        {
+            const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+            if (sgi && *sgi != '0')
+            {
+                if (gpus[gpu].vendor_id == 0x10de /* NVIDIA */)
+                {
+                    gpus[gpu].vendor_id = 0x1002; /* AMD */
+                    gpus[gpu].device_id = 0x67df; /* RX 480 */
+                }
+            }
+        }
+
         device_manager->add_gpu( &gpus[gpu], param );

         /* Initialize adapters */
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index f584330dc6e..3efdcb4c88c 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -169,6 +169,7 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceImageFormatProperties2" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
+    "vkGetPhysicalDeviceProperties" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},
     "vkGetPhysicalDeviceProperties2" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},
     "vkGetPhysicalDeviceProperties2KHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},

From c5a21ea2930f5e391b62c492bdf3f2fd075f310d Mon Sep 17 00:00:00 2001
From: Giovanni Mascellani <gmascellani@codeweavers.com>
Date: Tue, 27 Apr 2021 10:51:12 +0200
Subject: [PATCH] HACK: winex11.drv: Fix drawing of layered windows with a
 client window.

CW-Bug-Id: #18807
---
 dlls/winex11.drv/event.c       |  5 ++++-
 dlls/winex11.drv/x11drv.h      |  2 ++
 dlls/winex11.drv/x11drv_main.c | 12 ++++++++++++
 3 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 5cb08de99eb..b0ef922ca5d 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -992,7 +992,10 @@ static BOOL X11DRV_Expose( HWND hwnd, XEvent *xev )
     rect.right  = pos.x + event->width;
     rect.bottom = pos.y + event->height;

-    if (event->window != data->client_window)
+    if (layered_window_client_hack && event->window == data->client_window)
+        OffsetRect( &rect, data->client_rect.left - data->whole_rect.left,
+                    data->client_rect.top - data->whole_rect.top );
+    if (layered_window_client_hack || event->window != data->client_window)
     {
         if (data->surface)
         {
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index fb4546e302c..ed4abd802c1 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -890,4 +890,6 @@ static inline BOOL is_window_rect_mapped( const RECT *rect )
             max( rect->bottom, rect->top + 1 ) > virtual_rect.top);
 }

+extern BOOL layered_window_client_hack;
+
 #endif  /* __WINE_X11DRV_H */
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 4e49de12138..a03eb52ad46 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -90,6 +90,7 @@ int xfixes_event_base = 0;
 HMODULE x11drv_module = 0;
 char *process_name = NULL;
 HANDLE steam_overlay_event;
+BOOL layered_window_client_hack = FALSE;

 static x11drv_error_callback err_callback;   /* current callback for error */
 static Display *err_callback_display;        /* display callback is set for */
@@ -713,6 +714,17 @@ static BOOL process_attach(void)

     fs_hack_init();

+    {
+        const char *sgi = getenv("SteamGameId");
+        const char *e = getenv("WINE_LAYERED_WINDOW_CLIENT_HACK");
+        layered_window_client_hack =
+            (sgi && (
+                strcmp(sgi, "435150") == 0 || /* Divinity: Original Sin 2 launcher */
+                strcmp(sgi, "227020") == 0 /* Rise of Venice launcher */
+            )) ||
+            (e && *e != '\0' && *e != '0');
+    }
+
     init_user_driver();
     X11DRV_DisplayDevices_Init(FALSE);
     return TRUE;
From c5aa20a70a5e681ba718feb7db9adc357cb7bec0 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 31 Aug 2021 00:41:15 +0300
Subject: [PATCH] winex11.drv: HACK: Mind insert_after X11DRV_WindowPosChanged
 in some cases.

Fixes FH4 rendering black window until focus is lost.

CW-Bug-Id: #19335
---
 dlls/winex11.drv/window.c | 51 ++++++++++++++++++++++++++++++++++-----
 1 file changed, 45 insertions(+), 6 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 4cd2324bff2..815a6279e59 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1481,17 +1481,18 @@ void X11DRV_X_to_window_rect( struct x11drv_win_data *data, RECT *rect, int x, i
  *
  * Synchronize the X window position with the Windows one
  */
-static void sync_window_position( struct x11drv_win_data *data,
+static HWND sync_window_position( struct x11drv_win_data *data,
                                   UINT swp_flags, const RECT *old_window_rect,
                                   const RECT *old_whole_rect, const RECT *old_client_rect )
 {
     DWORD style = GetWindowLongW( data->hwnd, GWL_STYLE );
     DWORD ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
+    HWND prev_window = NULL;
     RECT original_rect = {0};
     XWindowChanges changes;
     unsigned int mask = 0;

-    if (data->managed && data->iconic) return;
+    if (data->managed && data->iconic) return NULL;

     /* resizing a managed maximized window is not allowed */
     if (!(style & WS_MAXIMIZE) || !data->managed)
@@ -1529,9 +1530,10 @@ static void sync_window_position( struct x11drv_win_data *data,
     {
         /* find window that this one must be after */
         HWND prev = GetWindow( data->hwnd, GW_HWNDPREV );
+
         while (prev && !(GetWindowLongW( prev, GWL_STYLE ) & WS_VISIBLE))
             prev = GetWindow( prev, GW_HWNDPREV );
-        if (!prev)  /* top child */
+        if (!(prev_window = prev))  /* top child */
         {
             changes.stack_mode = Above;
             mask |= CWStackMode;
@@ -1552,6 +1554,7 @@ static void sync_window_position( struct x11drv_win_data *data,
     update_net_wm_states( data );
     data->configure_serial = NextRequest( data->display );
     XReconfigureWMWindow( data->display, data->whole_window, data->vis.screen, mask, &changes );
+
     if (!IsRectEmpty( &original_rect ))
     {
         data->whole_rect = original_rect;
@@ -1577,6 +1580,8 @@ static void sync_window_position( struct x11drv_win_data *data,
            data->whole_rect.right - data->whole_rect.left,
            data->whole_rect.bottom - data->whole_rect.top,
            changes.sibling, mask, data->configure_serial );
+
+    return prev_window;
 }


@@ -2733,6 +2738,25 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
 }


+static void restack_windows( struct x11drv_win_data *data, HWND prev )
+{
+    struct x11drv_win_data *prev_data;
+
+    TRACE("data->hwnd %p, prev %p.\n", data->hwnd, prev);
+
+    while (prev)
+    {
+        if (!(prev_data = get_win_data( prev ))) break;
+
+        TRACE( "Raising window %p.\n", prev );
+
+        if (prev_data->whole_window && data->display == prev_data->display)
+            XRaiseWindow( prev_data->display, prev_data->whole_window );
+        release_win_data( prev_data );
+        prev = GetWindow( prev, GW_HWNDPREV );
+    }
+}
+
 /***********************************************************************
  *		WindowPosChanged   (X11DRV.@)
  */
@@ -2745,6 +2769,7 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
     struct x11drv_win_data *data;
     DWORD new_style = GetWindowLongW( hwnd, GWL_STYLE );
     RECT old_window_rect, old_whole_rect, old_client_rect;
+    HWND prev_window = NULL;
     int event_type;

     if (!(data = get_win_data( hwnd ))) return;
@@ -2847,8 +2872,8 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags

     /* don't change position if we are about to minimize or maximize a managed window */
     if ((!event_type || event_type == PropertyNotify) &&
-        !(data->managed && (swp_flags & SWP_STATECHANGED) && (new_style & (WS_MINIMIZE|WS_MAXIMIZE))))
-        sync_window_position( data, swp_flags, &old_window_rect, &old_whole_rect, &old_client_rect );
+            !(data->managed && (swp_flags & SWP_STATECHANGED) && (new_style & (WS_MINIMIZE|WS_MAXIMIZE))))
+        prev_window = sync_window_position( data, swp_flags, &old_window_rect, &old_whole_rect, &old_client_rect );

     if ((new_style & WS_VISIBLE) &&
         ((new_style & WS_MINIMIZE) || is_window_rect_mapped( rectWindow )))
@@ -2864,6 +2889,10 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
             release_win_data( data );
             if (needs_icon) fetch_icon_data( hwnd, 0, 0 );
             if (needs_map) map_window( hwnd, new_style );
+
+            if (!(data = get_win_data( hwnd ))) return;
+            restack_windows( data, prev_window );
+            release_win_data( data );
             return;
         }
         else if ((swp_flags & SWP_STATECHANGED) && (!data->iconic != !(new_style & WS_MINIMIZE)))
@@ -2880,10 +2909,20 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
         else
         {
             if (swp_flags & (SWP_FRAMECHANGED|SWP_STATECHANGED)) set_wm_hints( data );
-            if (!event_type || event_type == PropertyNotify) update_net_wm_states( data );
+            if (!event_type || event_type == PropertyNotify)
+            {
+                update_net_wm_states( data );
+                if (!prev_window && insert_after && data->net_wm_state & (1 << NET_WM_STATE_FULLSCREEN))
+                {
+                    prev_window = GetWindow( hwnd, GW_HWNDPREV );
+                    if (prev_window != insert_after) prev_window = NULL;
+                }
+            }
         }
     }

+    restack_windows( data, prev_window );
+
     XFlush( data->display );  /* make sure changes are done before we start painting again */
     if (data->surface && data->vis.visualid != default_visual.visualid)
         data->surface->funcs->flush( data->surface );
