From 6a6822aaf5aede791baf4e582ebe2341fb7e9db8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 16 Sep 2020 16:03:25 +0200
Subject: [PATCH] gdi32: Introduce and use debugstr_faceid helper.

---
 dlls/gdi32/freetype.c | 42 ++++++++++++++++++++----------------------
 1 file changed, 20 insertions(+), 22 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index cf8b2c66e22..0ada3c09942 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -274,6 +274,12 @@ typedef struct tagFace {
     struct enum_data *cached_enum_data;
 } Face;
 
+static inline const char *debugstr_faceid( Face *face )
+{
+    if (face->file) return wine_dbg_sprintf( "%s (%ld)", debugstr_w(face->file), face->face_index );
+    else return wine_dbg_sprintf( "%p-%p (%ld)", face->font_data_ptr, (char *)face->font_data_ptr + face->font_data_size, face->face_index );
+}
+
 #define FS_DBCS_MASK (FS_JISJAPAN|FS_CHINESESIMP|FS_WANSUNG|FS_CHINESETRAD|FS_JOHAB)
 
 #define ADDFONT_EXTERNAL_FONT 0x01
@@ -1412,20 +1418,17 @@ static BOOL insert_face_in_family_list( Face *face, Family *family )
             if (face->file && !strcmpiW( face->file, cursor->file ))
             {
                 cursor->refcount++;
-                TRACE("Font %s already in list, refcount now %d\n",
-                      debugstr_w(face->file), cursor->refcount);
+                TRACE( "face %s already in list, refcount now %d\n", debugstr_faceid(face), cursor->refcount );
                 return FALSE;
             }
             if (face->font_version <= cursor->font_version)
             {
-                TRACE("Original font %s is newer so skipping %s\n",
-                      debugstr_w(cursor->file), debugstr_w(face->file));
+                TRACE( "Original %s is newer so skipping %s\n", debugstr_faceid(cursor), debugstr_faceid(face) );
                 return FALSE;
             }
             else
             {
-                TRACE("Replacing original %s with %s\n",
-                      debugstr_w(cursor->file), debugstr_w(face->file));
+                TRACE( "Replacing original %s with %s\n", debugstr_faceid(cursor), debugstr_faceid(face) );
                 list_add_before( &cursor->entry, &face->entry );
                 face->family = family;
                 family->refcount++;
@@ -1439,7 +1442,7 @@ static BOOL insert_face_in_family_list( Face *face, Family *family )
     }
 
     TRACE( "Adding face %s in family %s from %s\n", debugstr_w(face->full_name),
-           debugstr_w(family->family_name), debugstr_w(face->file) );
+           debugstr_w(family->family_name), debugstr_faceid(face) );
     list_add_before( &cursor->entry, &face->entry );
     face->family = family;
     family->refcount++;
@@ -2134,7 +2137,7 @@ static int remove_font_resource( const WCHAR *file, DWORD flags )
             if (LOWORD(face->flags) != LOWORD(flags)) continue;
             if (!strcmpiW( face->file, file ))
             {
-                TRACE( "removing matching face %s refcount %d\n", debugstr_w(face->file), face->refcount );
+                TRACE( "removing matching face %s refcount %d\n", debugstr_faceid(face), face->refcount );
                 release_face( face );
                 count++;
             }
@@ -2399,8 +2402,7 @@ static void populate_system_links(const WCHAR *name, const WCHAR *const *values)
             child_font->font = NULL;
             font_link->fs.fsCsb[0] |= face->fs.fsCsb[0];
             font_link->fs.fsCsb[1] |= face->fs.fsCsb[1];
-            TRACE("Adding file %s index %ld\n", debugstr_w(child_font->face->file),
-                  child_font->face->face_index);
+            TRACE( "Adding %s\n", debugstr_faceid(child_font->face) );
             list_add_tail(&font_link->links, &child_font->entry);
 
             TRACE("added internal SystemLink for %s to %s in %s\n", debugstr_w(name), debugstr_w(value),debugstr_w(file));
@@ -2480,8 +2482,7 @@ static void init_system_links(void)
                 child_font->font = NULL;
                 font_link->fs.fsCsb[0] |= face->fs.fsCsb[0];
                 font_link->fs.fsCsb[1] |= face->fs.fsCsb[1];
-                TRACE("Adding file %s index %ld\n",
-                      debugstr_w(child_font->face->file), child_font->face->face_index);
+                TRACE( "Adding %s\n", debugstr_faceid(child_font->face) );
                 list_add_tail(&font_link->links, &child_font->entry);
             }
             list_add_tail(&system_links, &font_link->entry);
@@ -2539,8 +2540,7 @@ static void init_system_links(void)
         child_font->font = NULL;
         system_font_link->fs.fsCsb[0] |= face->fs.fsCsb[0];
         system_font_link->fs.fsCsb[1] |= face->fs.fsCsb[1];
-        TRACE("Found Tahoma in %s index %ld\n",
-              debugstr_w(child_font->face->file), child_font->face->face_index);
+        TRACE( "Found Tahoma in %s\n", debugstr_faceid(child_font->face) );
         list_add_tail(&system_font_link->links, &child_font->entry);
     }
     font_link = find_font_link(Tahoma);
@@ -3908,7 +3908,7 @@ static FT_Face OpenFontFace(GdiFont *font, Face *face, LONG width, LONG height)
     void *data_ptr;
     DWORD data_size;
 
-    TRACE("%s/%p, %ld, %d x %d\n", debugstr_w(face->file), face->font_data_ptr, face->face_index, width, height);
+    TRACE( "%s, %d x %d\n", debugstr_faceid(face), width, height );
 
     if (face->file)
     {
@@ -3917,7 +3917,7 @@ static FT_Face OpenFontFace(GdiFont *font, Face *face, LONG width, LONG height)
         HeapFree( GetProcessHeap(), 0, filename );
         if (!font->mapping)
         {
-            WARN("failed to map %s\n", debugstr_w(face->file));
+            WARN( "failed to map %s\n", debugstr_faceid(face) );
             return 0;
         }
         data_ptr = font->mapping->data;
@@ -4011,8 +4011,7 @@ static UINT get_nearest_charset(const WCHAR *family_name, Face *face, UINT *cp)
 	}
     }
 
-    FIXME("returning DEFAULT_CHARSET face->fs.fsCsb[0] = %08x file = %s\n",
-	  face->fs.fsCsb[0], debugstr_w(face->file));
+    FIXME( "returning DEFAULT_CHARSET face->fs.fsCsb[0] = %08x %s\n", face->fs.fsCsb[0], debugstr_faceid(face) );
     *cp = acp;
     return DEFAULT_CHARSET;
 }
@@ -4290,7 +4289,7 @@ static BOOL create_child_font_list(GdiFont *font)
             new_child->font = NULL;
             new_child->face->refcount++;
             list_add_tail(&font->child_fonts, &new_child->entry);
-            TRACE("font %s %ld\n", debugstr_w(new_child->face->file), new_child->face->face_index);
+            TRACE( "face %s\n", debugstr_faceid(new_child->face) );
         }
         ret = TRUE;
     }
@@ -4313,7 +4312,7 @@ static BOOL create_child_font_list(GdiFont *font)
                 new_child->font = NULL;
                 new_child->face->refcount++;
                 list_add_tail(&font->child_fonts, &new_child->entry);
-                TRACE("font %s %ld\n", debugstr_w(new_child->face->file), new_child->face->face_index);
+                TRACE( "face %s\n", debugstr_faceid(new_child->face) );
             }
             ret = TRUE;
         }
@@ -4992,8 +4991,7 @@ static struct gdi_font * CDECL freetype_SelectFont( DC *dc, HFONT hfont, UINT *a
     else
         gdi_font->charset = get_nearest_charset( family->family_name, face, &gdi_font->codepage );
 
-    TRACE( "Chosen: %s (%s/%p:%ld)\n", debugstr_w(face->full_name), debugstr_w(face->file),
-           face->font_data_ptr, face->face_index );
+    TRACE( "Chosen: %s from %s\n", debugstr_w(face->full_name), debugstr_faceid(face) );
 
     gdi_font->aveWidth = height ? lf.lfWidth : 0;
 
From d8ea64df036d2683c32bf89c372a2bb7556dc165 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Oct 2020 11:36:42 +0200
Subject: [PATCH] gdi32: Introduce struct unix_face as a ft_face wrapper.

---
 dlls/gdi32/freetype.c | 114 ++++++++++++++++++++++++++++++------------
 1 file changed, 83 insertions(+), 31 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 0ada3c09942..8ef9e0962e6 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -1369,6 +1369,59 @@ static void release_family( Family *family )
     HeapFree( GetProcessHeap(), 0, family );
 }
 
+struct unix_face
+{
+    FT_Face ft_face;
+    BOOL scalable;
+    DWORD num_faces;
+};
+
+static FT_Face new_ft_face( const char *file, void *font_data_ptr, DWORD font_data_size,
+                            FT_Long face_index, BOOL allow_bitmap );
+
+static struct unix_face *unix_face_create( const char *unix_name, void *font_data_ptr, DWORD font_data_size, DWORD face_index, DWORD flags )
+{
+    struct unix_face *This;
+    struct stat st;
+    int fd;
+
+    TRACE( "unix_name %s, face_index %u, font_data_ptr %p, font_data_size %u, flags %#x\n",
+           unix_name, face_index, font_data_ptr, font_data_size, flags );
+
+    if (unix_name)
+    {
+        if ((fd = open( unix_name, O_RDONLY )) == -1) return NULL;
+        if (fstat( fd, &st ) == -1) return NULL;
+        font_data_size = st.st_size;
+        font_data_ptr = mmap( NULL, font_data_size, PROT_READ, MAP_PRIVATE, fd, 0 );
+        close( fd );
+        if (font_data_ptr == MAP_FAILED) return NULL;
+    }
+
+    if (!(This = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This) ))) goto done;
+
+    if (!(This->ft_face = new_ft_face( unix_name, font_data_ptr, font_data_size, face_index, flags & ADDFONT_ALLOW_BITMAP )))
+    {
+        HeapFree(GetProcessHeap(), 0, This);
+        This = NULL;
+    }
+    else
+    {
+        This->scalable = FT_IS_SCALABLE( This->ft_face );
+        This->num_faces = This->ft_face->num_faces;
+    }
+
+done:
+    if (unix_name) munmap(font_data_ptr, font_data_size);
+    return This;
+}
+
+static void unix_face_destroy(struct unix_face *This)
+{
+    pFT_Done_Face(This->ft_face);
+    HeapFree(GetProcessHeap(), 0, This);
+}
+
 static void release_face( Face *face )
 {
     if (--face->refcount) return;
@@ -1733,19 +1786,19 @@ static WCHAR *get_vertical_name( WCHAR *name )
     return name;
 }
 
-static Family *get_family( FT_Face ft_face, BOOL vertical )
+static Family *get_family( struct unix_face *unix_face, BOOL vertical )
 {
     Family *family;
     WCHAR *family_name, *second_name;
 
-    family_name = ft_face_get_family_name( ft_face, GetSystemDefaultLCID() );
-    second_name = ft_face_get_family_name( ft_face, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT) );
+    family_name = ft_face_get_family_name( unix_face->ft_face, GetSystemDefaultLCID() );
+    second_name = ft_face_get_family_name( unix_face->ft_face, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT) );
 
     /* try to find another secondary name, preferring the lowest langids */
     if (!strcmpiW( family_name, second_name ))
     {
         HeapFree( GetProcessHeap(), 0, second_name );
-        second_name = ft_face_get_family_name( ft_face, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) );
+        second_name = ft_face_get_family_name( unix_face->ft_face, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) );
     }
 
     if (!strcmpiW( family_name, second_name ))
@@ -1897,14 +1950,14 @@ static inline void get_fontsig( FT_Face ft_face, FONTSIGNATURE *fs )
     }
 }
 
-static Face *create_face( FT_Face ft_face, FT_Long face_index, const WCHAR *filename,
+static Face *create_face( struct unix_face *unix_face, FT_Long face_index, const WCHAR *filename,
                           void *font_data_ptr, DWORD font_data_size, DWORD flags )
 {
     Face *face = HeapAlloc( GetProcessHeap(), 0, sizeof(*face) );
 
     face->refcount = 1;
-    face->style_name = ft_face_get_style_name( ft_face, GetSystemDefaultLangID() );
-    face->full_name = ft_face_get_full_name( ft_face, GetSystemDefaultLangID() );
+    face->style_name = ft_face_get_style_name( unix_face->ft_face, GetSystemDefaultLangID() );
+    face->full_name = ft_face_get_full_name( unix_face->ft_face, GetSystemDefaultLangID() );
     if (flags & ADDFONT_VERTICAL_FONT) face->full_name = get_vertical_name( face->full_name );
 
     if (filename)
@@ -1921,18 +1974,18 @@ static Face *create_face( FT_Face ft_face, FT_Long face_index, const WCHAR *file
     }
 
     face->face_index = face_index;
-    get_fontsig( ft_face, &face->fs );
-    face->ntmFlags = get_ntm_flags( ft_face );
-    face->font_version = get_font_version( ft_face );
+    get_fontsig( unix_face->ft_face, &face->fs );
+    face->ntmFlags = get_ntm_flags( unix_face->ft_face );
+    face->font_version = get_font_version( unix_face->ft_face );
 
-    if (FT_IS_SCALABLE( ft_face ))
+    if (unix_face->scalable)
     {
         memset( &face->size, 0, sizeof(face->size) );
         face->scalable = TRUE;
     }
     else
     {
-        get_bitmap_size( ft_face, &face->size );
+        get_bitmap_size( unix_face->ft_face, &face->size );
         face->scalable = FALSE;
     }
 
@@ -1949,14 +2002,14 @@ static Face *create_face( FT_Face ft_face, FT_Long face_index, const WCHAR *file
     return face;
 }
 
-static void AddFaceToList(FT_Face ft_face, const WCHAR *file, void *font_data_ptr, DWORD font_data_size,
+static void AddFaceToList(struct unix_face *unix_face, const WCHAR *file, void *font_data_ptr, DWORD font_data_size,
                           FT_Long face_index, DWORD flags )
 {
     Face *face;
     Family *family;
 
-    face = create_face( ft_face, face_index, file, font_data_ptr, font_data_size, flags );
-    family = get_family( ft_face, flags & ADDFONT_VERTICAL_FONT );
+    face = create_face( unix_face, face_index, file, font_data_ptr, font_data_size, flags );
+    family = get_family( unix_face, flags & ADDFONT_VERTICAL_FONT );
 
     if (insert_face_in_family_list( face, family ))
     {
@@ -2047,7 +2100,7 @@ static FT_Face new_ft_face( const char *file, void *font_data_ptr, DWORD font_da
 static INT AddFontToList(const WCHAR *dos_name, const char *unix_name, void *font_data_ptr,
                          DWORD font_data_size, DWORD flags)
 {
-    FT_Face ft_face;
+    struct unix_face *unix_face;
     FT_Long face_index = 0, num_faces;
     INT ret = 0;
     WCHAR *filename = NULL;
@@ -2081,29 +2134,28 @@ static INT AddFontToList(const WCHAR *dos_name, const char *unix_name, void *fon
     do {
         FONTSIGNATURE fs;
 
-        ft_face = new_ft_face( unix_name, font_data_ptr, font_data_size, face_index, flags & ADDFONT_ALLOW_BITMAP );
-        if (!ft_face) break;
+        if (!(unix_face = unix_face_create( unix_name, font_data_ptr, font_data_size, face_index, flags ))) break;
 
-        if(ft_face->family_name[0] == '.') /* Ignore fonts with names beginning with a dot */
+        if(unix_face->ft_face->family_name[0] == '.') /* Ignore fonts with names beginning with a dot */
         {
             TRACE("Ignoring %s since its family name begins with a dot\n", debugstr_a(unix_name));
-            pFT_Done_Face(ft_face);
+            unix_face_destroy(unix_face);
             break;
         }
 
-        AddFaceToList(ft_face, dos_name, font_data_ptr, font_data_size, face_index, flags);
+        AddFaceToList(unix_face, dos_name, font_data_ptr, font_data_size, face_index, flags);
         ++ret;
 
-        get_fontsig(ft_face, &fs);
+        get_fontsig(unix_face->ft_face, &fs);
         if (fs.fsCsb[0] & FS_DBCS_MASK)
         {
-            AddFaceToList(ft_face, dos_name, font_data_ptr, font_data_size, face_index,
+            AddFaceToList(unix_face, dos_name, font_data_ptr, font_data_size, face_index,
                           flags | ADDFONT_VERTICAL_FONT);
             ++ret;
         }
 
-	num_faces = ft_face->num_faces;
-	pFT_Done_Face(ft_face);
+        num_faces = unix_face->num_faces;
+        unix_face_destroy(unix_face);
     } while(num_faces > ++face_index);
     HeapFree( GetProcessHeap(), 0, filename );
     return ret;
@@ -3243,7 +3295,7 @@ static void GetEnumStructs(Face *face, const WCHAR *family_name, LPENUMLOGFONTEX
 
 static BOOL get_fontdir( const WCHAR *dos_name, struct fontdir *fd )
 {
-    FT_Face ft_face;
+    struct unix_face *unix_face;
     Face *face = NULL;
     char *unix_name;
     WCHAR *family_name;
@@ -3251,18 +3303,18 @@ static BOOL get_fontdir( const WCHAR *dos_name, struct fontdir *fd )
     NEWTEXTMETRICEXW ntm;
 
     if (!(unix_name = wine_get_unix_file_name( dos_name ))) return FALSE;
-    ft_face = new_ft_face( unix_name, NULL, 0, 0, FALSE );
+    unix_face = unix_face_create( unix_name, NULL, 0, 0, 0 );
     HeapFree( GetProcessHeap(), 0, unix_name );
-    if (!ft_face) return FALSE;
-    face = create_face( ft_face, 0, dos_name, NULL, 0, 0 );
+    if (!unix_face) return FALSE;
+    face = create_face( unix_face, 0, dos_name, NULL, 0, 0 );
     if (face)
     {
-        family_name = ft_face_get_family_name( ft_face, GetSystemDefaultLCID() );
+        family_name = ft_face_get_family_name( unix_face->ft_face, GetSystemDefaultLCID() );
         GetEnumStructs( face, family_name, &elf, &ntm );
         release_face( face );
         HeapFree( GetProcessHeap(), 0, family_name );
     }
-    pFT_Done_Face( ft_face );
+    unix_face_destroy( unix_face );
 
     if (!face) return FALSE;
     if (!(ntm.ntmTm.tmPitchAndFamily & TMPF_TRUETYPE)) return FALSE;
From c6ec053787f5344a304c40b500eec52c63593444 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Oct 2020 15:44:27 +0200
Subject: [PATCH] gdi32: Store family and second names on unix_face.

Keeping these names on the face will allow us to fill them when parsing
the face by hand, or in the FreeType parsing fallback, making family
creation independent of FreeType usage.

This also saves the GetEnumStructs family name parameter, making it
independent of FreeType parsing too.
---
 dlls/gdi32/freetype.c | 45 +++++++++++++++++++++++--------------------
 1 file changed, 24 insertions(+), 21 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 8ef9e0962e6..bbd06a479de 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -1374,6 +1374,8 @@ struct unix_face
     FT_Face ft_face;
     BOOL scalable;
     DWORD num_faces;
+    WCHAR *family_name;
+    WCHAR *second_name;
 };
 
 static FT_Face new_ft_face( const char *file, void *font_data_ptr, DWORD font_data_size,
@@ -1409,6 +1411,22 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
     {
         This->scalable = FT_IS_SCALABLE( This->ft_face );
         This->num_faces = This->ft_face->num_faces;
+
+        This->family_name = ft_face_get_family_name( This->ft_face, GetSystemDefaultLCID() );
+        This->second_name = ft_face_get_family_name( This->ft_face, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT) );
+
+        /* try to find another secondary name, preferring the lowest langids */
+        if (!strcmpiW( This->family_name, This->second_name ))
+        {
+            HeapFree( GetProcessHeap(), 0, This->second_name );
+            This->second_name = ft_face_get_family_name( This->ft_face, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) );
+        }
+
+        if (!strcmpiW( This->family_name, This->second_name ))
+        {
+            HeapFree( GetProcessHeap(), 0, This->second_name );
+            This->second_name = NULL;
+        }
     }
 
 done:
@@ -1419,6 +1437,8 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
 static void unix_face_destroy(struct unix_face *This)
 {
     pFT_Done_Face(This->ft_face);
+    HeapFree(GetProcessHeap(), 0, This->second_name);
+    HeapFree(GetProcessHeap(), 0, This->family_name);
     HeapFree(GetProcessHeap(), 0, This);
 }
 
@@ -1791,22 +1811,8 @@ static Family *get_family( struct unix_face *unix_face, BOOL vertical )
     Family *family;
     WCHAR *family_name, *second_name;
 
-    family_name = ft_face_get_family_name( unix_face->ft_face, GetSystemDefaultLCID() );
-    second_name = ft_face_get_family_name( unix_face->ft_face, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT) );
-
-    /* try to find another secondary name, preferring the lowest langids */
-    if (!strcmpiW( family_name, second_name ))
-    {
-        HeapFree( GetProcessHeap(), 0, second_name );
-        second_name = ft_face_get_family_name( unix_face->ft_face, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) );
-    }
-
-    if (!strcmpiW( family_name, second_name ))
-    {
-        HeapFree( GetProcessHeap(), 0, second_name );
-        second_name = NULL;
-    }
-
+    family_name = strdupW( unix_face->family_name );
+    second_name = unix_face->second_name ? strdupW( unix_face->second_name ) : NULL;
     if (vertical)
     {
         family_name = get_vertical_name( family_name );
@@ -2136,7 +2142,7 @@ static INT AddFontToList(const WCHAR *dos_name, const char *unix_name, void *fon
 
         if (!(unix_face = unix_face_create( unix_name, font_data_ptr, font_data_size, face_index, flags ))) break;
 
-        if(unix_face->ft_face->family_name[0] == '.') /* Ignore fonts with names beginning with a dot */
+        if(unix_face->family_name[0] == '.') /* Ignore fonts with names beginning with a dot */
         {
             TRACE("Ignoring %s since its family name begins with a dot\n", debugstr_a(unix_name));
             unix_face_destroy(unix_face);
@@ -3298,7 +3304,6 @@ static BOOL get_fontdir( const WCHAR *dos_name, struct fontdir *fd )
     struct unix_face *unix_face;
     Face *face = NULL;
     char *unix_name;
-    WCHAR *family_name;
     ENUMLOGFONTEXW elf;
     NEWTEXTMETRICEXW ntm;
 
@@ -3309,10 +3314,8 @@ static BOOL get_fontdir( const WCHAR *dos_name, struct fontdir *fd )
     face = create_face( unix_face, 0, dos_name, NULL, 0, 0 );
     if (face)
     {
-        family_name = ft_face_get_family_name( unix_face->ft_face, GetSystemDefaultLCID() );
-        GetEnumStructs( face, family_name, &elf, &ntm );
+        GetEnumStructs( face, unix_face->family_name, &elf, &ntm );
         release_face( face );
-        HeapFree( GetProcessHeap(), 0, family_name );
     }
     unix_face_destroy( unix_face );
 
From 6aab088c70418f52520a5c7e4bdac49af728ea75 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Oct 2020 15:45:20 +0200
Subject: [PATCH] gdi32: Store other ft_face info on unix_face.

---
 dlls/gdi32/freetype.c | 273 ++++++++++++++++++++++--------------------
 1 file changed, 143 insertions(+), 130 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index bbd06a479de..c7dd069d9f2 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -1369,6 +1369,126 @@ static void release_family( Family *family )
     HeapFree( GetProcessHeap(), 0, family );
 }
 
+static inline FT_Fixed get_font_version( FT_Face ft_face )
+{
+    FT_Fixed version = 0;
+    TT_Header *header;
+
+    header = pFT_Get_Sfnt_Table( ft_face, ft_sfnt_head );
+    if (header) version = header->Font_Revision;
+
+    return version;
+}
+
+static inline DWORD get_ntm_flags( FT_Face ft_face )
+{
+    DWORD flags = 0;
+    FT_ULong table_size = 0;
+    FT_WinFNT_HeaderRec winfnt_header;
+
+    if (ft_face->style_flags & FT_STYLE_FLAG_ITALIC) flags |= NTM_ITALIC;
+    if (ft_face->style_flags & FT_STYLE_FLAG_BOLD)   flags |= NTM_BOLD;
+
+    /* fixup the flag for our fake-bold implementation. */
+    if (!FT_IS_SCALABLE( ft_face ) &&
+        !pFT_Get_WinFNT_Header( ft_face, &winfnt_header ) &&
+        winfnt_header.weight > FW_NORMAL )
+        flags |= NTM_BOLD;
+
+    if (flags == 0) flags = NTM_REGULAR;
+
+    if (!pFT_Load_Sfnt_Table( ft_face, FT_MAKE_TAG( 'C','F','F',' ' ), 0, NULL, &table_size ))
+        flags |= NTM_PS_OPENTYPE;
+
+    return flags;
+}
+
+static inline void get_bitmap_size( FT_Face ft_face, Bitmap_Size *face_size )
+{
+    My_FT_Bitmap_Size *size;
+    FT_WinFNT_HeaderRec winfnt_header;
+
+    size = (My_FT_Bitmap_Size *)ft_face->available_sizes;
+    TRACE("Adding bitmap size h %d w %d size %ld x_ppem %ld y_ppem %ld\n",
+          size->height, size->width, size->size >> 6,
+          size->x_ppem >> 6, size->y_ppem >> 6);
+    face_size->height = size->height;
+    face_size->width = size->width;
+    face_size->size = size->size;
+    face_size->x_ppem = size->x_ppem;
+    face_size->y_ppem = size->y_ppem;
+
+    if (!pFT_Get_WinFNT_Header( ft_face, &winfnt_header )) {
+        face_size->internal_leading = winfnt_header.internal_leading;
+        if (winfnt_header.external_leading > 0 &&
+            (face_size->height ==
+             winfnt_header.pixel_height + winfnt_header.external_leading))
+            face_size->height = winfnt_header.pixel_height;
+    }
+}
+
+static inline void get_fontsig( FT_Face ft_face, FONTSIGNATURE *fs )
+{
+    TT_OS2 *os2;
+    CHARSETINFO csi;
+    FT_WinFNT_HeaderRec winfnt_header;
+    int i;
+
+    memset( fs, 0, sizeof(*fs) );
+
+    os2 = pFT_Get_Sfnt_Table( ft_face, ft_sfnt_os2 );
+    if (os2)
+    {
+        fs->fsUsb[0] = os2->ulUnicodeRange1;
+        fs->fsUsb[1] = os2->ulUnicodeRange2;
+        fs->fsUsb[2] = os2->ulUnicodeRange3;
+        fs->fsUsb[3] = os2->ulUnicodeRange4;
+
+        if (os2->version == 0)
+        {
+            if (os2->usFirstCharIndex >= 0xf000 && os2->usFirstCharIndex < 0xf100)
+                fs->fsCsb[0] = FS_SYMBOL;
+            else
+                fs->fsCsb[0] = FS_LATIN1;
+        }
+        else
+        {
+            fs->fsCsb[0] = os2->ulCodePageRange1;
+            fs->fsCsb[1] = os2->ulCodePageRange2;
+        }
+    }
+    else
+    {
+        if (!pFT_Get_WinFNT_Header( ft_face, &winfnt_header ))
+        {
+            TRACE("pix_h %d charset %d dpi %dx%d pt %d\n", winfnt_header.pixel_height, winfnt_header.charset,
+                  winfnt_header.vertical_resolution,winfnt_header.horizontal_resolution, winfnt_header.nominal_point_size);
+            if (TranslateCharsetInfo( (DWORD*)(UINT_PTR)winfnt_header.charset, &csi, TCI_SRCCHARSET ))
+                *fs = csi.fs;
+        }
+    }
+
+    if (fs->fsCsb[0] == 0)
+    {
+        /* let's see if we can find any interesting cmaps */
+        for (i = 0; i < ft_face->num_charmaps; i++)
+        {
+            switch (ft_face->charmaps[i]->encoding)
+            {
+            case FT_ENCODING_UNICODE:
+            case FT_ENCODING_APPLE_ROMAN:
+                fs->fsCsb[0] |= FS_LATIN1;
+                break;
+            case FT_ENCODING_MS_SYMBOL:
+                fs->fsCsb[0] |= FS_SYMBOL;
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+
 struct unix_face
 {
     FT_Face ft_face;
@@ -1376,6 +1496,12 @@ struct unix_face
     DWORD num_faces;
     WCHAR *family_name;
     WCHAR *second_name;
+    WCHAR *style_name;
+    WCHAR *full_name;
+    DWORD ntm_flags;
+    DWORD font_version;
+    FONTSIGNATURE fs;
+    Bitmap_Size size;
 };
 
 static FT_Face new_ft_face( const char *file, void *font_data_ptr, DWORD font_data_size,
@@ -1427,6 +1553,14 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
             HeapFree( GetProcessHeap(), 0, This->second_name );
             This->second_name = NULL;
         }
+
+        This->style_name = ft_face_get_style_name( This->ft_face, GetSystemDefaultLangID() );
+        This->full_name = ft_face_get_full_name( This->ft_face, GetSystemDefaultLangID() );
+
+        This->ntm_flags = get_ntm_flags( This->ft_face );
+        This->font_version = get_font_version( This->ft_face );
+        if (!This->scalable) get_bitmap_size( This->ft_face, &This->size );
+        get_fontsig(This->ft_face, &This->fs);
     }
 
 done:
@@ -1437,6 +1571,8 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
 static void unix_face_destroy(struct unix_face *This)
 {
     pFT_Done_Face(This->ft_face);
+    HeapFree(GetProcessHeap(), 0, This->full_name);
+    HeapFree(GetProcessHeap(), 0, This->style_name);
     HeapFree(GetProcessHeap(), 0, This->second_name);
     HeapFree(GetProcessHeap(), 0, This->family_name);
     HeapFree(GetProcessHeap(), 0, This);
@@ -1836,134 +1972,14 @@ static Family *get_family( struct unix_face *unix_face, BOOL vertical )
     return family;
 }
 
-static inline FT_Fixed get_font_version( FT_Face ft_face )
-{
-    FT_Fixed version = 0;
-    TT_Header *header;
-
-    header = pFT_Get_Sfnt_Table( ft_face, ft_sfnt_head );
-    if (header) version = header->Font_Revision;
-
-    return version;
-}
-
-static inline DWORD get_ntm_flags( FT_Face ft_face )
-{
-    DWORD flags = 0;
-    FT_ULong table_size = 0;
-    FT_WinFNT_HeaderRec winfnt_header;
-
-    if (ft_face->style_flags & FT_STYLE_FLAG_ITALIC) flags |= NTM_ITALIC;
-    if (ft_face->style_flags & FT_STYLE_FLAG_BOLD)   flags |= NTM_BOLD;
-
-    /* fixup the flag for our fake-bold implementation. */
-    if (!FT_IS_SCALABLE( ft_face ) &&
-        !pFT_Get_WinFNT_Header( ft_face, &winfnt_header ) &&
-        winfnt_header.weight > FW_NORMAL )
-        flags |= NTM_BOLD;
-
-    if (flags == 0) flags = NTM_REGULAR;
-
-    if (!pFT_Load_Sfnt_Table( ft_face, FT_MAKE_TAG( 'C','F','F',' ' ), 0, NULL, &table_size ))
-        flags |= NTM_PS_OPENTYPE;
-
-    return flags;
-}
-
-static inline void get_bitmap_size( FT_Face ft_face, Bitmap_Size *face_size )
-{
-    My_FT_Bitmap_Size *size;
-    FT_WinFNT_HeaderRec winfnt_header;
-
-    size = (My_FT_Bitmap_Size *)ft_face->available_sizes;
-    TRACE("Adding bitmap size h %d w %d size %ld x_ppem %ld y_ppem %ld\n",
-          size->height, size->width, size->size >> 6,
-          size->x_ppem >> 6, size->y_ppem >> 6);
-    face_size->height = size->height;
-    face_size->width = size->width;
-    face_size->size = size->size;
-    face_size->x_ppem = size->x_ppem;
-    face_size->y_ppem = size->y_ppem;
-
-    if (!pFT_Get_WinFNT_Header( ft_face, &winfnt_header )) {
-        face_size->internal_leading = winfnt_header.internal_leading;
-        if (winfnt_header.external_leading > 0 &&
-            (face_size->height ==
-             winfnt_header.pixel_height + winfnt_header.external_leading))
-            face_size->height = winfnt_header.pixel_height;
-    }
-}
-
-static inline void get_fontsig( FT_Face ft_face, FONTSIGNATURE *fs )
-{
-    TT_OS2 *os2;
-    CHARSETINFO csi;
-    FT_WinFNT_HeaderRec winfnt_header;
-    int i;
-
-    memset( fs, 0, sizeof(*fs) );
-
-    os2 = pFT_Get_Sfnt_Table( ft_face, ft_sfnt_os2 );
-    if (os2)
-    {
-        fs->fsUsb[0] = os2->ulUnicodeRange1;
-        fs->fsUsb[1] = os2->ulUnicodeRange2;
-        fs->fsUsb[2] = os2->ulUnicodeRange3;
-        fs->fsUsb[3] = os2->ulUnicodeRange4;
-
-        if (os2->version == 0)
-        {
-            if (os2->usFirstCharIndex >= 0xf000 && os2->usFirstCharIndex < 0xf100)
-                fs->fsCsb[0] = FS_SYMBOL;
-            else
-                fs->fsCsb[0] = FS_LATIN1;
-        }
-        else
-        {
-            fs->fsCsb[0] = os2->ulCodePageRange1;
-            fs->fsCsb[1] = os2->ulCodePageRange2;
-        }
-    }
-    else
-    {
-        if (!pFT_Get_WinFNT_Header( ft_face, &winfnt_header ))
-        {
-            TRACE("pix_h %d charset %d dpi %dx%d pt %d\n", winfnt_header.pixel_height, winfnt_header.charset,
-                  winfnt_header.vertical_resolution,winfnt_header.horizontal_resolution, winfnt_header.nominal_point_size);
-            if (TranslateCharsetInfo( (DWORD*)(UINT_PTR)winfnt_header.charset, &csi, TCI_SRCCHARSET ))
-                *fs = csi.fs;
-        }
-    }
-
-    if (fs->fsCsb[0] == 0)
-    {
-        /* let's see if we can find any interesting cmaps */
-        for (i = 0; i < ft_face->num_charmaps; i++)
-        {
-            switch (ft_face->charmaps[i]->encoding)
-            {
-            case FT_ENCODING_UNICODE:
-            case FT_ENCODING_APPLE_ROMAN:
-                fs->fsCsb[0] |= FS_LATIN1;
-                break;
-            case FT_ENCODING_MS_SYMBOL:
-                fs->fsCsb[0] |= FS_SYMBOL;
-                break;
-            default:
-                break;
-            }
-        }
-    }
-}
-
 static Face *create_face( struct unix_face *unix_face, FT_Long face_index, const WCHAR *filename,
                           void *font_data_ptr, DWORD font_data_size, DWORD flags )
 {
     Face *face = HeapAlloc( GetProcessHeap(), 0, sizeof(*face) );
 
     face->refcount = 1;
-    face->style_name = ft_face_get_style_name( unix_face->ft_face, GetSystemDefaultLangID() );
-    face->full_name = ft_face_get_full_name( unix_face->ft_face, GetSystemDefaultLangID() );
+    face->style_name = strdupW( unix_face->style_name );
+    face->full_name = strdupW( unix_face->full_name );
     if (flags & ADDFONT_VERTICAL_FONT) face->full_name = get_vertical_name( face->full_name );
 
     if (filename)
@@ -1980,9 +1996,9 @@ static Face *create_face( struct unix_face *unix_face, FT_Long face_index, const
     }
 
     face->face_index = face_index;
-    get_fontsig( unix_face->ft_face, &face->fs );
-    face->ntmFlags = get_ntm_flags( unix_face->ft_face );
-    face->font_version = get_font_version( unix_face->ft_face );
+    face->fs = unix_face->fs;
+    face->ntmFlags = unix_face->ntm_flags;
+    face->font_version = unix_face->font_version;
 
     if (unix_face->scalable)
     {
@@ -1991,7 +2007,7 @@ static Face *create_face( struct unix_face *unix_face, FT_Long face_index, const
     }
     else
     {
-        get_bitmap_size( unix_face->ft_face, &face->size );
+        face->size = unix_face->size;
         face->scalable = FALSE;
     }
 
@@ -2138,8 +2154,6 @@ static INT AddFontToList(const WCHAR *dos_name, const char *unix_name, void *fon
     if (!dos_name && unix_name) dos_name = filename = wine_get_dos_file_name( unix_name );
 
     do {
-        FONTSIGNATURE fs;
-
         if (!(unix_face = unix_face_create( unix_name, font_data_ptr, font_data_size, face_index, flags ))) break;
 
         if(unix_face->family_name[0] == '.') /* Ignore fonts with names beginning with a dot */
@@ -2152,8 +2166,7 @@ static INT AddFontToList(const WCHAR *dos_name, const char *unix_name, void *fon
         AddFaceToList(unix_face, dos_name, font_data_ptr, font_data_size, face_index, flags);
         ++ret;
 
-        get_fontsig(unix_face->ft_face, &fs);
-        if (fs.fsCsb[0] & FS_DBCS_MASK)
+        if (unix_face->fs.fsCsb[0] & FS_DBCS_MASK)
         {
             AddFaceToList(unix_face, dos_name, font_data_ptr, font_data_size, face_index,
                           flags | ADDFONT_VERTICAL_FONT);
From 6beb356b6e556d084d5f385f46db1d0d01bc70ef Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Oct 2020 15:50:33 +0200
Subject: [PATCH] gdi32: Introduce new opentype font parsing helpers.

Mostly taken from dwrite source, adapted to make it more flexible.
---
 dlls/gdi32/Makefile.in   |   1 +
 dlls/gdi32/freetype.c    |  11 ++
 dlls/gdi32/gdi_private.h |   7 ++
 dlls/gdi32/opentype.c    | 223 +++++++++++++++++++++++++++++++++++++++
 4 files changed, 242 insertions(+)
 create mode 100644 dlls/gdi32/opentype.c

diff --git a/dlls/gdi32/Makefile.in b/dlls/gdi32/Makefile.in
index a94abad599d..4561e1960b5 100644
--- a/dlls/gdi32/Makefile.in
+++ b/dlls/gdi32/Makefile.in
@@ -41,6 +41,7 @@ C_SRCS = \
 	mfdrv/objects.c \
 	mfdrv/text.c \
 	opengl.c \
+	opentype.c \
 	painting.c \
 	palette.c \
 	path.c \
diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index c7dd069d9f2..c2e2e665c0d 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -1509,8 +1509,10 @@ static FT_Face new_ft_face( const char *file, void *font_data_ptr, DWORD font_da
 
 static struct unix_face *unix_face_create( const char *unix_name, void *font_data_ptr, DWORD font_data_size, DWORD face_index, DWORD flags )
 {
+    const struct ttc_sfnt_v1 *ttc_sfnt_v1;
     struct unix_face *This;
     struct stat st;
+    DWORD face_count;
     int fd;
 
     TRACE( "unix_name %s, face_index %u, font_data_ptr %p, font_data_size %u, flags %#x\n",
@@ -1533,11 +1535,20 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
         HeapFree(GetProcessHeap(), 0, This);
         This = NULL;
     }
+    else if (opentype_get_ttc_sfnt_v1( font_data_ptr, font_data_size, face_index, &face_count, &ttc_sfnt_v1 ))
+    {
+        This->scalable = TRUE;
+        This->num_faces = face_count;
+    }
     else
     {
+        WARN( "unable to parse font, falling back to FreeType\n" );
         This->scalable = FT_IS_SCALABLE( This->ft_face );
         This->num_faces = This->ft_face->num_faces;
+    }
 
+    if (This)
+    {
         This->family_name = ft_face_get_family_name( This->ft_face, GetSystemDefaultLCID() );
         This->second_name = ft_face_get_family_name( This->ft_face, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT) );
 
diff --git a/dlls/gdi32/gdi_private.h b/dlls/gdi32/gdi_private.h
index 6d1caf6c65e..6f148a37956 100644
--- a/dlls/gdi32/gdi_private.h
+++ b/dlls/gdi32/gdi_private.h
@@ -395,6 +395,13 @@ extern CRITICAL_SECTION font_cs DECLSPEC_HIDDEN;
 
 extern BOOL WineEngInit( const struct font_backend_funcs **funcs ) DECLSPEC_HIDDEN;
 
+/* opentype.c */
+
+struct ttc_sfnt_v1;
+
+extern BOOL opentype_get_ttc_sfnt_v1( const void *data, size_t size, DWORD index, DWORD *count,
+                                      const struct ttc_sfnt_v1 **ttc_sfnt_v1 ) DECLSPEC_HIDDEN;
+
 /* gdiobj.c */
 extern HGDIOBJ alloc_gdi_handle( void *obj, WORD type, const struct gdi_obj_funcs *funcs ) DECLSPEC_HIDDEN;
 extern void *free_gdi_handle( HGDIOBJ handle ) DECLSPEC_HIDDEN;
diff --git a/dlls/gdi32/opentype.c b/dlls/gdi32/opentype.c
new file mode 100644
index 00000000000..4d6a4f81e32
--- /dev/null
+++ b/dlls/gdi32/opentype.c
@@ -0,0 +1,223 @@
+/*
+ * Copyright 2020 RÃ©mi Bernon for CodeWeavers
+ * Copyright 2014 Aric Stewart for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdarg.h>
+#include <stdlib.h>
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef HAVE_SYS_MMAN_H
+# include <sys/mman.h>
+#endif
+#include <stdio.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "winnls.h"
+
+#include "gdi_private.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(font);
+
+#define MS_MAKE_TAG( a, b, c, d ) \
+    (((UINT32)(d) << 24) | ((UINT32)(c) << 16) | ((UINT32)(b) << 8) | (UINT32)(a))
+
+#define MS_OTTO_TAG MS_MAKE_TAG('O','T','T','O')
+#define MS_TTCF_TAG MS_MAKE_TAG('t','t','c','f')
+#define MS_HEAD_TAG MS_MAKE_TAG('h','e','a','d')
+#define MS_HHEA_TAG MS_MAKE_TAG('h','h','e','a')
+#define MS_OS_2_TAG MS_MAKE_TAG('O','S','/','2')
+#define MS_EBSC_TAG MS_MAKE_TAG('E','B','S','C')
+
+#ifdef WORDS_BIGENDIAN
+#define GET_BE_WORD(x) (x)
+#define GET_BE_DWORD(x) (x)
+#else
+#define GET_BE_WORD(x)  RtlUshortByteSwap(x)
+#define GET_BE_DWORD(x) RtlUlongByteSwap(x)
+#endif
+
+#include "pshpack2.h"
+struct ttc_header_v1
+{
+    CHAR TTCTag[4];
+    DWORD Version;
+    DWORD numFonts;
+    DWORD OffsetTable[1];
+};
+
+struct ttc_sfnt_v1
+{
+    DWORD version;
+    WORD numTables;
+    WORD searchRange;
+    WORD entrySelector;
+    WORD rangeShift;
+};
+
+struct tt_tablerecord
+{
+    DWORD tag;
+    DWORD checkSum;
+    DWORD offset;
+    DWORD length;
+};
+
+struct tt_os2_v1
+{
+    USHORT version;
+    SHORT xAvgCharWidth;
+    USHORT usWeightClass;
+    USHORT usWidthClass;
+    SHORT fsType;
+    SHORT ySubscriptXSize;
+    SHORT ySubscriptYSize;
+    SHORT ySubscriptXOffset;
+    SHORT ySubscriptYOffset;
+    SHORT ySuperscriptXSize;
+    SHORT ySuperscriptYSize;
+    SHORT ySuperscriptXOffset;
+    SHORT ySuperscriptYOffset;
+    SHORT yStrikeoutSize;
+    SHORT yStrikeoutPosition;
+    SHORT sFamilyClass;
+    PANOSE panose;
+    ULONG ulUnicodeRange1;
+    ULONG ulUnicodeRange2;
+    ULONG ulUnicodeRange3;
+    ULONG ulUnicodeRange4;
+    CHAR achVendID[4];
+    USHORT fsSelection;
+    USHORT usFirstCharIndex;
+    USHORT usLastCharIndex;
+    /* According to the Apple spec, original version didn't have the below fields,
+     * version numbers were taken from the OpenType spec.
+     */
+    /* version 0 (TrueType 1.5) */
+    USHORT sTypoAscender;
+    USHORT sTypoDescender;
+    USHORT sTypoLineGap;
+    USHORT usWinAscent;
+    USHORT usWinDescent;
+    /* version 1 (TrueType 1.66) */
+    ULONG ulCodePageRange1;
+    ULONG ulCodePageRange2;
+};
+#include "poppack.h"
+
+static BOOL opentype_get_table_ptr( const void *data, size_t size, const struct ttc_sfnt_v1 *ttc_sfnt_v1,
+                                    UINT32 table_tag, const void **table_ptr, UINT32 *table_size )
+{
+    const struct tt_tablerecord *table_record;
+    UINT16 i, table_count;
+    UINT32 offset, length;
+
+    if (!ttc_sfnt_v1) return FALSE;
+
+    table_record = (const struct tt_tablerecord *)(ttc_sfnt_v1 + 1);
+    table_count = GET_BE_WORD( ttc_sfnt_v1->numTables );
+    for (i = 0; i < table_count; i++, table_record++)
+    {
+        if (table_record->tag != table_tag) continue;
+        offset = GET_BE_DWORD( table_record->offset );
+        length = GET_BE_DWORD( table_record->length );
+        if (size < offset + length) return FALSE;
+        if (table_size && length < *table_size) return FALSE;
+
+        if (table_ptr) *table_ptr = (const char *)data + offset;
+        if (table_size) *table_size = length;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static BOOL opentype_get_tt_os2_v1( const void *data, size_t size, const struct ttc_sfnt_v1 *ttc_sfnt_v1,
+                                    const struct tt_os2_v1 **tt_os2_v1 )
+{
+    UINT32 table_size = sizeof(**tt_os2_v1);
+    return opentype_get_table_ptr( data, size, ttc_sfnt_v1, MS_OS_2_TAG, (const void **)tt_os2_v1, &table_size );
+}
+
+BOOL opentype_get_ttc_sfnt_v1( const void *data, size_t size, DWORD index, DWORD *count, const struct ttc_sfnt_v1 **ttc_sfnt_v1 )
+{
+    const struct ttc_header_v1 *ttc_header_v1 = data;
+    const struct tt_os2_v1 *tt_os2_v1;
+    UINT32 offset, fourcc;
+
+    *ttc_sfnt_v1 = NULL;
+    *count = 1;
+
+    if (size < sizeof(fourcc)) return FALSE;
+    memcpy( &fourcc, data, sizeof(fourcc) );
+
+    switch (fourcc)
+    {
+    default:
+        WARN( "unsupported font format %x\n", fourcc );
+        return FALSE;
+    case MS_TTCF_TAG:
+        if (size < sizeof(ttc_header_v1)) return FALSE;
+        if (index >= (*count = GET_BE_DWORD( ttc_header_v1->numFonts ))) return FALSE;
+        offset = GET_BE_DWORD( ttc_header_v1->OffsetTable[index] );
+        break;
+    case 0x00000100:
+    case MS_OTTO_TAG:
+        offset = 0;
+        break;
+    }
+
+    if (size < offset + sizeof(**ttc_sfnt_v1)) return FALSE;
+    *ttc_sfnt_v1 = (const struct ttc_sfnt_v1 *)((const char *)data + offset);
+
+    if (!opentype_get_table_ptr( data, size, *ttc_sfnt_v1, MS_HEAD_TAG, NULL, NULL ))
+    {
+        WARN( "ignoring sfnt font without head table\n" );
+        return FALSE;
+    }
+
+    if (!opentype_get_table_ptr( data, size, *ttc_sfnt_v1, MS_HHEA_TAG, NULL, NULL ))
+    {
+        WARN( "ignoring sfnt font without hhea table\n" );
+        return FALSE;
+    }
+
+    if (!opentype_get_tt_os2_v1( data, size, *ttc_sfnt_v1, &tt_os2_v1 ))
+    {
+        WARN( "ignoring sfnt font without OS/2 table\n" );
+        return FALSE;
+    }
+
+    /* Wine uses ttfs as an intermediate step in building its bitmap fonts;
+       we don't want to load these. */
+    if (!memcmp( tt_os2_v1->achVendID, "Wine", sizeof(tt_os2_v1->achVendID) ) &&
+        opentype_get_table_ptr( data, size, *ttc_sfnt_v1, MS_EBSC_TAG, NULL, NULL ))
+    {
+        TRACE("ignoring wine bitmap-only sfnt font\n");
+        return FALSE;
+    }
+
+    return TRUE;
+}
From ed96d457187660ec570dfec166d152c7b0295ef2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Oct 2020 16:15:28 +0200
Subject: [PATCH] gdi32: Try to parse font names without FreeType.

---
 dlls/gdi32/freetype.c    | 112 +++++++++-
 dlls/gdi32/gdi_private.h |  11 +
 dlls/gdi32/opentype.c    | 468 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 586 insertions(+), 5 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index c2e2e665c0d..76ad6d34a84 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -1489,6 +1489,67 @@ static inline void get_fontsig( FT_Face ft_face, FONTSIGNATURE *fs )
     }
 }
 
+struct family_names_data
+{
+    LANGID primary_langid;
+    WCHAR *family_name;
+    WCHAR *second_name;
+    BOOL primary_seen;
+    BOOL english_seen;
+};
+
+static BOOL search_family_names_callback( LANGID langid, const WCHAR *str, void *user )
+{
+    struct family_names_data *data = user;
+
+    if (langid == MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT))
+    {
+        data->english_seen = TRUE;
+        if (data->primary_langid == langid) data->primary_seen = TRUE;
+
+        if (!data->family_name) data->family_name = strdupW( str );
+        else if (data->primary_langid != langid)
+        {
+            if (data->second_name) HeapFree( GetProcessHeap(), 0, data->second_name );
+            data->second_name = strdupW( str );
+        }
+    }
+    else if (data->primary_langid == langid)
+    {
+        data->primary_seen = TRUE;
+        if (!data->second_name) data->second_name = data->family_name;
+        else if (data->family_name) HeapFree( GetProcessHeap(), 0, data->family_name );
+        data->family_name = strdupW( str );
+    }
+    else if (!data->second_name) data->second_name = strdupW( str );
+
+    if (data->family_name && data->second_name && data->primary_seen && data->english_seen)
+        return TRUE;
+    return FALSE;
+}
+
+struct face_name_data
+{
+    WCHAR *face_name;
+    LANGID primary_langid;
+};
+
+static BOOL search_face_name_callback( LANGID langid, const WCHAR *str, void *user )
+{
+    struct face_name_data *data = user;
+
+    if (data->primary_langid == langid)
+    {
+        if (data->face_name) HeapFree( GetProcessHeap(), 0, data->face_name );
+        data->face_name = strdupW( str );
+        return TRUE;
+    }
+    else if (!data->face_name && langid == MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT))
+        data->face_name = strdupW( str );
+
+    return FALSE;
+}
+
 struct unix_face
 {
     FT_Face ft_face;
@@ -1509,11 +1570,14 @@ static FT_Face new_ft_face( const char *file, void *font_data_ptr, DWORD font_da
 
 static struct unix_face *unix_face_create( const char *unix_name, void *font_data_ptr, DWORD font_data_size, DWORD face_index, DWORD flags )
 {
+    static const WCHAR space_w[] = {' ',0};
+
     const struct ttc_sfnt_v1 *ttc_sfnt_v1;
+    const struct tt_name_v0 *tt_name_v0;
     struct unix_face *This;
     struct stat st;
     DWORD face_count;
-    int fd;
+    int fd, length;
 
     TRACE( "unix_name %s, face_index %u, font_data_ptr %p, font_data_size %u, flags %#x\n",
            unix_name, face_index, font_data_ptr, font_data_size, flags );
@@ -1535,20 +1599,55 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
         HeapFree(GetProcessHeap(), 0, This);
         This = NULL;
     }
-    else if (opentype_get_ttc_sfnt_v1( font_data_ptr, font_data_size, face_index, &face_count, &ttc_sfnt_v1 ))
+    else if (opentype_get_ttc_sfnt_v1( font_data_ptr, font_data_size, face_index, &face_count, &ttc_sfnt_v1 ) &&
+             opentype_get_tt_name_v0( font_data_ptr, font_data_size, ttc_sfnt_v1, &tt_name_v0 ))
     {
+        struct family_names_data family_names;
+        struct face_name_data style_name;
+        struct face_name_data full_name;
+        LANGID primary_langid = GetSystemDefaultLangID();
+
         This->scalable = TRUE;
         This->num_faces = face_count;
+
+        memset( &family_names, 0, sizeof(family_names) );
+        family_names.primary_langid = primary_langid;
+        opentype_enum_family_names( tt_name_v0, search_family_names_callback, &family_names );
+        This->family_name = family_names.family_name;
+        This->second_name = family_names.second_name;
+
+        memset( &style_name, 0, sizeof(style_name) );
+        style_name.primary_langid = primary_langid;
+        opentype_enum_style_names( tt_name_v0, search_face_name_callback, &style_name );
+        This->style_name = style_name.face_name;
+
+        memset( &full_name, 0, sizeof(full_name) );
+        style_name.primary_langid = primary_langid;
+        opentype_enum_full_names( tt_name_v0, search_face_name_callback, &full_name );
+        This->full_name = full_name.face_name;
+
+        TRACE( "parsed font names family_name %s, second_name %s, primary_seen %d, english_seen %d, "
+               "full_name %s, style_name %s\n",
+               debugstr_w(family_names.family_name), debugstr_w(family_names.second_name),
+               family_names.primary_seen, family_names.english_seen,
+               debugstr_w(full_name.face_name), debugstr_w(style_name.face_name) );
+
+        if (!This->full_name && This->family_name && This->style_name)
+        {
+            length = strlenW( This->family_name ) + strlenW( space_w ) + strlenW( This->style_name ) + 1;
+            This->full_name = HeapAlloc( GetProcessHeap(), 0, length * sizeof(WCHAR) );
+            strcpyW( This->full_name, This->family_name );
+            strcatW( This->full_name, space_w );
+            strcatW( This->full_name, This->style_name );
+            WARN( "full name not found, using %s instead\n", debugstr_w(This->full_name) );
+        }
     }
     else
     {
         WARN( "unable to parse font, falling back to FreeType\n" );
         This->scalable = FT_IS_SCALABLE( This->ft_face );
         This->num_faces = This->ft_face->num_faces;
-    }
 
-    if (This)
-    {
         This->family_name = ft_face_get_family_name( This->ft_face, GetSystemDefaultLCID() );
         This->second_name = ft_face_get_family_name( This->ft_face, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT) );
 
@@ -1567,7 +1666,10 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
 
         This->style_name = ft_face_get_style_name( This->ft_face, GetSystemDefaultLangID() );
         This->full_name = ft_face_get_full_name( This->ft_face, GetSystemDefaultLangID() );
+    }
 
+    if (This)
+    {
         This->ntm_flags = get_ntm_flags( This->ft_face );
         This->font_version = get_font_version( This->ft_face );
         if (!This->scalable) get_bitmap_size( This->ft_face, &This->size );
diff --git a/dlls/gdi32/gdi_private.h b/dlls/gdi32/gdi_private.h
index 6f148a37956..683802f2498 100644
--- a/dlls/gdi32/gdi_private.h
+++ b/dlls/gdi32/gdi_private.h
@@ -398,9 +398,20 @@ extern BOOL WineEngInit( const struct font_backend_funcs **funcs ) DECLSPEC_HIDD
 /* opentype.c */
 
 struct ttc_sfnt_v1;
+struct tt_name_v0;
 
 extern BOOL opentype_get_ttc_sfnt_v1( const void *data, size_t size, DWORD index, DWORD *count,
                                       const struct ttc_sfnt_v1 **ttc_sfnt_v1 ) DECLSPEC_HIDDEN;
+extern BOOL opentype_get_tt_name_v0( const void *data, size_t size, const struct ttc_sfnt_v1 *ttc_sfnt_v1,
+                                     const struct tt_name_v0 **tt_name_v0 ) DECLSPEC_HIDDEN;
+
+typedef BOOL ( *opentype_enum_names_cb )(LANGID langid, const WCHAR *str, void *user);
+extern BOOL opentype_enum_family_names( const struct tt_name_v0 *tt_name_v0,
+                                        opentype_enum_names_cb callback, void *user ) DECLSPEC_HIDDEN;
+extern BOOL opentype_enum_style_names( const struct tt_name_v0 *tt_name_v0,
+                                       opentype_enum_names_cb callback, void *user ) DECLSPEC_HIDDEN;
+extern BOOL opentype_enum_full_names( const struct tt_name_v0 *tt_name_v0,
+                                      opentype_enum_names_cb callback, void *user ) DECLSPEC_HIDDEN;
 
 /* gdiobj.c */
 extern HGDIOBJ alloc_gdi_handle( void *obj, WORD type, const struct gdi_obj_funcs *funcs ) DECLSPEC_HIDDEN;
diff --git a/dlls/gdi32/opentype.c b/dlls/gdi32/opentype.c
index 4d6a4f81e32..97b1ea8c92e 100644
--- a/dlls/gdi32/opentype.c
+++ b/dlls/gdi32/opentype.c
@@ -50,6 +50,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(font);
 #define MS_HHEA_TAG MS_MAKE_TAG('h','h','e','a')
 #define MS_OS_2_TAG MS_MAKE_TAG('O','S','/','2')
 #define MS_EBSC_TAG MS_MAKE_TAG('E','B','S','C')
+#define MS_NAME_TAG MS_MAKE_TAG('n','a','m','e')
 
 #ifdef WORDS_BIGENDIAN
 #define GET_BE_WORD(x) (x)
@@ -125,8 +126,125 @@ struct tt_os2_v1
     ULONG ulCodePageRange1;
     ULONG ulCodePageRange2;
 };
+
+struct tt_namerecord
+{
+    WORD platformID;
+    WORD encodingID;
+    WORD languageID;
+    WORD nameID;
+    WORD length;
+    WORD offset;
+};
+
+struct tt_name_v0
+{
+    WORD format;
+    WORD count;
+    WORD stringOffset;
+    struct tt_namerecord nameRecord[1];
+};
 #include "poppack.h"
 
+enum OPENTYPE_PLATFORM_ID
+{
+    OPENTYPE_PLATFORM_UNICODE = 0,
+    OPENTYPE_PLATFORM_MAC,
+    OPENTYPE_PLATFORM_ISO,
+    OPENTYPE_PLATFORM_WIN,
+    OPENTYPE_PLATFORM_CUSTOM
+};
+
+enum TT_NAME_WIN_ENCODING_ID
+{
+    TT_NAME_WIN_ENCODING_SYMBOL = 0,
+    TT_NAME_WIN_ENCODING_UNICODE_BMP,
+    TT_NAME_WIN_ENCODING_SJIS,
+    TT_NAME_WIN_ENCODING_PRC,
+    TT_NAME_WIN_ENCODING_BIG5,
+    TT_NAME_WIN_ENCODING_WANSUNG,
+    TT_NAME_WIN_ENCODING_JOHAB,
+    TT_NAME_WIN_ENCODING_RESERVED1,
+    TT_NAME_WIN_ENCODING_RESERVED2,
+    TT_NAME_WIN_ENCODING_RESERVED3,
+    TT_NAME_WIN_ENCODING_UNICODE_FULL
+};
+
+enum TT_NAME_UNICODE_ENCODING_ID
+{
+    TT_NAME_UNICODE_ENCODING_1_0 = 0,
+    TT_NAME_UNICODE_ENCODING_1_1,
+    TT_NAME_UNICODE_ENCODING_ISO_10646,
+    TT_NAME_UNICODE_ENCODING_2_0_BMP,
+    TT_NAME_UNICODE_ENCODING_2_0_FULL,
+    TT_NAME_UNICODE_ENCODING_VAR,
+    TT_NAME_UNICODE_ENCODING_FULL,
+};
+
+enum TT_NAME_MAC_ENCODING_ID
+{
+    TT_NAME_MAC_ENCODING_ROMAN = 0,
+    TT_NAME_MAC_ENCODING_JAPANESE,
+    TT_NAME_MAC_ENCODING_TRAD_CHINESE,
+    TT_NAME_MAC_ENCODING_KOREAN,
+    TT_NAME_MAC_ENCODING_ARABIC,
+    TT_NAME_MAC_ENCODING_HEBREW,
+    TT_NAME_MAC_ENCODING_GREEK,
+    TT_NAME_MAC_ENCODING_RUSSIAN,
+    TT_NAME_MAC_ENCODING_RSYMBOL,
+    TT_NAME_MAC_ENCODING_DEVANAGARI,
+    TT_NAME_MAC_ENCODING_GURMUKHI,
+    TT_NAME_MAC_ENCODING_GUJARATI,
+    TT_NAME_MAC_ENCODING_ORIYA,
+    TT_NAME_MAC_ENCODING_BENGALI,
+    TT_NAME_MAC_ENCODING_TAMIL,
+    TT_NAME_MAC_ENCODING_TELUGU,
+    TT_NAME_MAC_ENCODING_KANNADA,
+    TT_NAME_MAC_ENCODING_MALAYALAM,
+    TT_NAME_MAC_ENCODING_SINHALESE,
+    TT_NAME_MAC_ENCODING_BURMESE,
+    TT_NAME_MAC_ENCODING_KHMER,
+    TT_NAME_MAC_ENCODING_THAI,
+    TT_NAME_MAC_ENCODING_LAOTIAN,
+    TT_NAME_MAC_ENCODING_GEORGIAN,
+    TT_NAME_MAC_ENCODING_ARMENIAN,
+    TT_NAME_MAC_ENCODING_SIMPL_CHINESE,
+    TT_NAME_MAC_ENCODING_TIBETAN,
+    TT_NAME_MAC_ENCODING_MONGOLIAN,
+    TT_NAME_MAC_ENCODING_GEEZ,
+    TT_NAME_MAC_ENCODING_SLAVIC,
+    TT_NAME_MAC_ENCODING_VIETNAMESE,
+    TT_NAME_MAC_ENCODING_SINDHI,
+    TT_NAME_MAC_ENCODING_UNINTERPRETED
+};
+
+enum OPENTYPE_NAME_ID
+{
+    OPENTYPE_NAME_COPYRIGHT_NOTICE = 0,
+    OPENTYPE_NAME_FAMILY,
+    OPENTYPE_NAME_SUBFAMILY,
+    OPENTYPE_NAME_UNIQUE_IDENTIFIER,
+    OPENTYPE_NAME_FULLNAME,
+    OPENTYPE_NAME_VERSION_STRING,
+    OPENTYPE_NAME_POSTSCRIPT,
+    OPENTYPE_NAME_TRADEMARK,
+    OPENTYPE_NAME_MANUFACTURER,
+    OPENTYPE_NAME_DESIGNER,
+    OPENTYPE_NAME_DESCRIPTION,
+    OPENTYPE_NAME_VENDOR_URL,
+    OPENTYPE_NAME_DESIGNER_URL,
+    OPENTYPE_NAME_LICENSE_DESCRIPTION,
+    OPENTYPE_NAME_LICENSE_INFO_URL,
+    OPENTYPE_NAME_RESERVED_ID15,
+    OPENTYPE_NAME_TYPOGRAPHIC_FAMILY,
+    OPENTYPE_NAME_TYPOGRAPHIC_SUBFAMILY,
+    OPENTYPE_NAME_COMPATIBLE_FULLNAME,
+    OPENTYPE_NAME_SAMPLE_TEXT,
+    OPENTYPE_NAME_POSTSCRIPT_CID,
+    OPENTYPE_NAME_WWS_FAMILY,
+    OPENTYPE_NAME_WWS_SUBFAMILY
+};
+
 static BOOL opentype_get_table_ptr( const void *data, size_t size, const struct ttc_sfnt_v1 *ttc_sfnt_v1,
                                     UINT32 table_tag, const void **table_ptr, UINT32 *table_size )
 {
@@ -161,6 +279,316 @@ static BOOL opentype_get_tt_os2_v1( const void *data, size_t size, const struct
     return opentype_get_table_ptr( data, size, ttc_sfnt_v1, MS_OS_2_TAG, (const void **)tt_os2_v1, &table_size );
 }
 
+static UINT get_name_record_codepage( enum OPENTYPE_PLATFORM_ID platform, USHORT encoding )
+{
+    switch (platform)
+    {
+    case OPENTYPE_PLATFORM_UNICODE:
+        return 0;
+    case OPENTYPE_PLATFORM_MAC:
+        switch (encoding)
+        {
+        case TT_NAME_MAC_ENCODING_ROMAN:
+            return 10000;
+        case TT_NAME_MAC_ENCODING_JAPANESE:
+            return 10001;
+        case TT_NAME_MAC_ENCODING_TRAD_CHINESE:
+            return 10002;
+        case TT_NAME_MAC_ENCODING_KOREAN:
+            return 10003;
+        case TT_NAME_MAC_ENCODING_ARABIC:
+            return 10004;
+        case TT_NAME_MAC_ENCODING_HEBREW:
+            return 10005;
+        case TT_NAME_MAC_ENCODING_GREEK:
+            return 10006;
+        case TT_NAME_MAC_ENCODING_RUSSIAN:
+            return 10007;
+        case TT_NAME_MAC_ENCODING_SIMPL_CHINESE:
+            return 10008;
+        case TT_NAME_MAC_ENCODING_THAI:
+            return 10021;
+        default:
+            FIXME( "encoding %u not handled, platform %d.\n", encoding, platform );
+            break;
+        }
+        break;
+    case OPENTYPE_PLATFORM_WIN:
+        switch (encoding)
+        {
+        case TT_NAME_WIN_ENCODING_SYMBOL:
+        case TT_NAME_WIN_ENCODING_UNICODE_BMP:
+        case TT_NAME_WIN_ENCODING_UNICODE_FULL:
+            return 0;
+        case TT_NAME_WIN_ENCODING_SJIS:
+            return 932;
+        case TT_NAME_WIN_ENCODING_PRC:
+            return 936;
+        case TT_NAME_WIN_ENCODING_BIG5:
+            return 950;
+        case TT_NAME_WIN_ENCODING_WANSUNG:
+            return 20949;
+        case TT_NAME_WIN_ENCODING_JOHAB:
+            return 1361;
+        default:
+            FIXME( "encoding %u not handled, platform %d.\n", encoding, platform );
+            break;
+        }
+        break;
+    default:
+        FIXME( "unknown platform %d\n", platform );
+        break;
+    }
+
+    return 0;
+}
+
+static const LANGID mac_langid_table[] =
+{
+    MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_FRENCH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_GERMAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_ITALIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_DUTCH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_SWEDISH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_SPANISH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_DANISH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_PORTUGUESE, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_NORWEGIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_ARABIC, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_FINNISH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_GREEK, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_ICELANDIC, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_MALTESE, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_TURKISH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_CROATIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_CHINESE_TRADITIONAL, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_URDU, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_HINDI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_THAI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_LITHUANIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_POLISH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_HUNGARIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_ESTONIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_LATVIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_SAMI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_FAEROESE, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_FARSI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_RUSSIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_CHINESE_SIMPLIFIED, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH_BELGIAN),
+    MAKELANGID(LANG_IRISH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_ALBANIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_ROMANIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_CZECH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_SLOVAK, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_SLOVENIAN, SUBLANG_DEFAULT),
+    0,
+    MAKELANGID(LANG_SERBIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_MACEDONIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_BULGARIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_UKRAINIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_BELARUSIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_UZBEK, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_KAZAK, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_AZERI, SUBLANG_AZERI_CYRILLIC),
+    0,
+    MAKELANGID(LANG_ARMENIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_GEORGIAN, SUBLANG_DEFAULT),
+    0,
+    MAKELANGID(LANG_KYRGYZ, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_TAJIK, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_TURKMEN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_MONGOLIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_MONGOLIAN, SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA),
+    MAKELANGID(LANG_PASHTO, SUBLANG_DEFAULT),
+    0,
+    MAKELANGID(LANG_KASHMIRI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_SINDHI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_TIBETAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_NEPALI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_SANSKRIT, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_MARATHI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_BENGALI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_ASSAMESE, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_GUJARATI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_PUNJABI, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_ORIYA, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_MALAYALAM, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_KANNADA, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_TAMIL, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_TELUGU, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_SINHALESE, SUBLANG_DEFAULT),
+    0,
+    MAKELANGID(LANG_KHMER, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_LAO, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_VIETNAMESE, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_INDONESIAN, SUBLANG_DEFAULT),
+    0,
+    MAKELANGID(LANG_MALAY, SUBLANG_DEFAULT),
+    0,
+    MAKELANGID(LANG_AMHARIC, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_TIGRIGNA, SUBLANG_DEFAULT),
+    0,
+    0,
+    MAKELANGID(LANG_SWAHILI, SUBLANG_DEFAULT),
+    0,
+    0,
+    0,
+    MAKELANGID(LANG_MALAGASY, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_ESPERANTO, SUBLANG_DEFAULT),
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    MAKELANGID(LANG_WELSH, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_BASQUE, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_CATALAN, SUBLANG_DEFAULT),
+    0,
+    MAKELANGID(LANG_QUECHUA, SUBLANG_DEFAULT),
+    0,
+    0,
+    MAKELANGID(LANG_TATAR, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_UIGHUR, SUBLANG_DEFAULT),
+    0,
+    0,
+    0,
+    MAKELANGID(LANG_GALICIAN, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_AFRIKAANS, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_BRETON, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_INUKTITUT, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_SCOTTISH_GAELIC, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_MANX_GAELIC, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_IRISH, SUBLANG_IRISH_IRELAND),
+    0,
+    0,
+    MAKELANGID(LANG_GREENLANDIC, SUBLANG_DEFAULT),
+    MAKELANGID(LANG_AZERI, SUBLANG_AZERI_LATIN),
+};
+
+static LANGID get_name_record_langid( enum OPENTYPE_PLATFORM_ID platform, USHORT encoding, USHORT language )
+{
+    switch (platform)
+    {
+    case OPENTYPE_PLATFORM_WIN:
+        return language;
+    case OPENTYPE_PLATFORM_MAC:
+        if (language < ARRAY_SIZE(mac_langid_table)) return mac_langid_table[language];
+        WARN( "invalid mac lang id %d\n", language );
+        break;
+    case OPENTYPE_PLATFORM_UNICODE:
+        switch (encoding)
+        {
+        case TT_NAME_UNICODE_ENCODING_1_0:
+        case TT_NAME_UNICODE_ENCODING_ISO_10646:
+        case TT_NAME_UNICODE_ENCODING_2_0_BMP:
+            if (language < ARRAY_SIZE(mac_langid_table)) return mac_langid_table[language];
+            WARN( "invalid unicode lang id %d\n", language );
+            break;
+        default:
+            break;
+        }
+    default:
+        FIXME( "unknown platform %d\n", platform );
+        break;
+    }
+
+    return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
+}
+
+static BOOL opentype_enum_font_names( const struct tt_name_v0 *header, enum OPENTYPE_PLATFORM_ID platform,
+                                      enum OPENTYPE_NAME_ID name, opentype_enum_names_cb callback, void *user )
+{
+    const char *name_data, buffer[128];
+    USHORT i, name_count, encoding, language, length, offset;
+    USHORT platform_id = GET_BE_WORD( platform ), name_id = GET_BE_WORD( name );
+    LANGID langid;
+    DWORD codepage, len;
+    WCHAR *str;
+    BOOL ret = FALSE;
+
+    switch (GET_BE_WORD( header->format ))
+    {
+    case 0:
+    case 1:
+        break;
+    default:
+        FIXME( "unsupported name format %d\n", GET_BE_WORD( header->format ) );
+        return FALSE;
+    }
+
+    name_data = (const char *)header + GET_BE_WORD( header->stringOffset );
+    name_count = GET_BE_WORD( header->count );
+    for (i = 0; i < name_count; i++)
+    {
+        const struct tt_namerecord *record = &header->nameRecord[i];
+        if (record->nameID != name_id) continue;
+        if (record->platformID != platform_id) continue;
+
+        language = GET_BE_WORD( record->languageID );
+        if (language >= 0x8000)
+        {
+            FIXME( "handle name format 1\n" );
+            continue;
+        }
+
+        encoding = GET_BE_WORD( record->encodingID );
+        length = GET_BE_WORD( record->length );
+        offset = GET_BE_WORD( record->offset );
+
+        codepage = get_name_record_codepage( platform, encoding );
+        langid = get_name_record_langid( platform, encoding, language );
+
+        if (!codepage) len = (length / sizeof(WCHAR));
+        else len = MultiByteToWideChar( codepage, 0, name_data + offset, length, NULL, 0 );
+
+        if ((len + 1) * sizeof(WCHAR) <= sizeof(buffer)) str = (WCHAR *)buffer;
+        else str = HeapAlloc( GetProcessHeap(), 0, sizeof(WCHAR) * (len + 1) );
+        str[len] = 0;
+
+        if (!codepage) while (len--) str[len] = GET_BE_WORD( ((WORD *)(name_data + offset))[len] );
+        else MultiByteToWideChar( codepage, 0, name_data + offset, length, str, len );
+
+        ret = callback( langid, str, user );
+        if (str != (WCHAR *)buffer) HeapFree( GetProcessHeap(), 0, str );
+        if (ret) break;
+    }
+
+    return ret;
+}
+
 BOOL opentype_get_ttc_sfnt_v1( const void *data, size_t size, DWORD index, DWORD *count, const struct ttc_sfnt_v1 **ttc_sfnt_v1 )
 {
     const struct ttc_header_v1 *ttc_header_v1 = data;
@@ -221,3 +649,43 @@ BOOL opentype_get_ttc_sfnt_v1( const void *data, size_t size, DWORD index, DWORD
 
     return TRUE;
 }
+
+BOOL opentype_get_tt_name_v0( const void *data, size_t size, const struct ttc_sfnt_v1 *ttc_sfnt_v1,
+                              const struct tt_name_v0 **tt_name_v0 )
+{
+    UINT32 table_size = sizeof(**tt_name_v0);
+    return opentype_get_table_ptr( data, size, ttc_sfnt_v1, MS_NAME_TAG, (const void **)tt_name_v0, &table_size );
+}
+
+BOOL opentype_enum_family_names( const struct tt_name_v0 *header, opentype_enum_names_cb callback, void *user )
+{
+    if (opentype_enum_font_names( header, OPENTYPE_PLATFORM_WIN, OPENTYPE_NAME_FAMILY, callback, user ))
+        return TRUE;
+    if (opentype_enum_font_names( header, OPENTYPE_PLATFORM_MAC, OPENTYPE_NAME_FAMILY, callback, user ))
+        return TRUE;
+    if (opentype_enum_font_names( header, OPENTYPE_PLATFORM_UNICODE, OPENTYPE_NAME_FAMILY, callback, user ))
+        return TRUE;
+    return FALSE;
+}
+
+BOOL opentype_enum_style_names( const struct tt_name_v0 *header, opentype_enum_names_cb callback, void *user )
+{
+    if (opentype_enum_font_names( header, OPENTYPE_PLATFORM_WIN, OPENTYPE_NAME_SUBFAMILY, callback, user ))
+        return TRUE;
+    if (opentype_enum_font_names( header, OPENTYPE_PLATFORM_MAC, OPENTYPE_NAME_SUBFAMILY, callback, user ))
+        return TRUE;
+    if (opentype_enum_font_names( header, OPENTYPE_PLATFORM_UNICODE, OPENTYPE_NAME_SUBFAMILY, callback, user ))
+        return TRUE;
+    return FALSE;
+}
+
+BOOL opentype_enum_full_names( const struct tt_name_v0 *header, opentype_enum_names_cb callback, void *user )
+{
+    if (opentype_enum_font_names( header, OPENTYPE_PLATFORM_WIN, OPENTYPE_NAME_FULLNAME, callback, user ))
+        return TRUE;
+    if (opentype_enum_font_names( header, OPENTYPE_PLATFORM_MAC, OPENTYPE_NAME_FULLNAME, callback, user ))
+        return TRUE;
+    if (opentype_enum_font_names( header, OPENTYPE_PLATFORM_UNICODE, OPENTYPE_NAME_FULLNAME, callback, user ))
+        return TRUE;
+    return FALSE;
+}
From 4b535fec8003f85524e7c616366eb0e14e7bf276 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Oct 2020 16:19:35 +0200
Subject: [PATCH] gdi32: Try to parse font props without FreeType.

---
 dlls/gdi32/freetype.c    |  7 ++--
 dlls/gdi32/gdi_private.h |  3 ++
 dlls/gdi32/opentype.c    | 91 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 97 insertions(+), 4 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 76ad6d34a84..d87aef47173 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -1600,7 +1600,9 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
         This = NULL;
     }
     else if (opentype_get_ttc_sfnt_v1( font_data_ptr, font_data_size, face_index, &face_count, &ttc_sfnt_v1 ) &&
-             opentype_get_tt_name_v0( font_data_ptr, font_data_size, ttc_sfnt_v1, &tt_name_v0 ))
+             opentype_get_tt_name_v0( font_data_ptr, font_data_size, ttc_sfnt_v1, &tt_name_v0 ) &&
+             opentype_get_properties( font_data_ptr, font_data_size, ttc_sfnt_v1, &This->font_version,
+                                      &This->fs, &This->ntm_flags ))
     {
         struct family_names_data family_names;
         struct face_name_data style_name;
@@ -1666,10 +1668,7 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
 
         This->style_name = ft_face_get_style_name( This->ft_face, GetSystemDefaultLangID() );
         This->full_name = ft_face_get_full_name( This->ft_face, GetSystemDefaultLangID() );
-    }
 
-    if (This)
-    {
         This->ntm_flags = get_ntm_flags( This->ft_face );
         This->font_version = get_font_version( This->ft_face );
         if (!This->scalable) get_bitmap_size( This->ft_face, &This->size );
diff --git a/dlls/gdi32/gdi_private.h b/dlls/gdi32/gdi_private.h
index 683802f2498..4c5553c9061 100644
--- a/dlls/gdi32/gdi_private.h
+++ b/dlls/gdi32/gdi_private.h
@@ -413,6 +413,9 @@ extern BOOL opentype_enum_style_names( const struct tt_name_v0 *tt_name_v0,
 extern BOOL opentype_enum_full_names( const struct tt_name_v0 *tt_name_v0,
                                       opentype_enum_names_cb callback, void *user ) DECLSPEC_HIDDEN;
 
+extern BOOL opentype_get_properties( const void *data, size_t size, const struct ttc_sfnt_v1 *ttc_sfnt_v1,
+                                     DWORD *version, FONTSIGNATURE *fs, DWORD *ntm_flags ) DECLSPEC_HIDDEN;
+
 /* gdiobj.c */
 extern HGDIOBJ alloc_gdi_handle( void *obj, WORD type, const struct gdi_obj_funcs *funcs ) DECLSPEC_HIDDEN;
 extern void *free_gdi_handle( HGDIOBJ handle ) DECLSPEC_HIDDEN;
diff --git a/dlls/gdi32/opentype.c b/dlls/gdi32/opentype.c
index 97b1ea8c92e..1c6fae7190d 100644
--- a/dlls/gdi32/opentype.c
+++ b/dlls/gdi32/opentype.c
@@ -51,6 +51,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(font);
 #define MS_OS_2_TAG MS_MAKE_TAG('O','S','/','2')
 #define MS_EBSC_TAG MS_MAKE_TAG('E','B','S','C')
 #define MS_NAME_TAG MS_MAKE_TAG('n','a','m','e')
+#define MS_CFF__TAG MS_MAKE_TAG('C','F','F',' ')
 
 #ifdef WORDS_BIGENDIAN
 #define GET_BE_WORD(x) (x)
@@ -144,6 +145,28 @@ struct tt_name_v0
     WORD stringOffset;
     struct tt_namerecord nameRecord[1];
 };
+
+struct tt_head
+{
+    USHORT majorVersion;
+    USHORT minorVersion;
+    ULONG revision;
+    ULONG checksumadj;
+    ULONG magic;
+    USHORT flags;
+    USHORT unitsPerEm;
+    ULONGLONG created;
+    ULONGLONG modified;
+    SHORT xMin;
+    SHORT yMin;
+    SHORT xMax;
+    SHORT yMax;
+    USHORT macStyle;
+    USHORT lowestRecPPEM;
+    SHORT direction_hint;
+    SHORT index_format;
+    SHORT glyphdata_format;
+};
 #include "poppack.h"
 
 enum OPENTYPE_PLATFORM_ID
@@ -245,6 +268,20 @@ enum OPENTYPE_NAME_ID
     OPENTYPE_NAME_WWS_SUBFAMILY
 };
 
+enum OS2_FSSELECTION
+{
+    OS2_FSSELECTION_ITALIC           = 1 << 0,
+    OS2_FSSELECTION_UNDERSCORE       = 1 << 1,
+    OS2_FSSELECTION_NEGATIVE         = 1 << 2,
+    OS2_FSSELECTION_OUTLINED         = 1 << 3,
+    OS2_FSSELECTION_STRIKEOUT        = 1 << 4,
+    OS2_FSSELECTION_BOLD             = 1 << 5,
+    OS2_FSSELECTION_REGULAR          = 1 << 6,
+    OS2_FSSELECTION_USE_TYPO_METRICS = 1 << 7,
+    OS2_FSSELECTION_WWS              = 1 << 8,
+    OS2_FSSELECTION_OBLIQUE          = 1 << 9
+};
+
 static BOOL opentype_get_table_ptr( const void *data, size_t size, const struct ttc_sfnt_v1 *ttc_sfnt_v1,
                                     UINT32 table_tag, const void **table_ptr, UINT32 *table_size )
 {
@@ -279,6 +316,13 @@ static BOOL opentype_get_tt_os2_v1( const void *data, size_t size, const struct
     return opentype_get_table_ptr( data, size, ttc_sfnt_v1, MS_OS_2_TAG, (const void **)tt_os2_v1, &table_size );
 }
 
+static BOOL opentype_get_tt_head( const void *data, size_t size, const struct ttc_sfnt_v1 *ttc_sfnt_v1,
+                                  const struct tt_head **tt_head )
+{
+    UINT32 table_size = sizeof(**tt_head);
+    return opentype_get_table_ptr( data, size, ttc_sfnt_v1, MS_HEAD_TAG, (const void **)tt_head, &table_size );
+}
+
 static UINT get_name_record_codepage( enum OPENTYPE_PLATFORM_ID platform, USHORT encoding )
 {
     switch (platform)
@@ -689,3 +733,50 @@ BOOL opentype_enum_full_names( const struct tt_name_v0 *header, opentype_enum_na
         return TRUE;
     return FALSE;
 }
+
+BOOL opentype_get_properties( const void *data, size_t size, const struct ttc_sfnt_v1 *ttc_sfnt_v1,
+                              DWORD *version, FONTSIGNATURE *fs, DWORD *ntm_flags )
+{
+    const struct tt_os2_v1 *tt_os2_v1;
+    const struct tt_head *tt_head;
+    const void *cff_header;
+    UINT32 table_size = 0;
+    USHORT idx, selection;
+    DWORD flags = 0;
+
+    if (!opentype_get_tt_head( data, size, ttc_sfnt_v1, &tt_head )) return FALSE;
+    if (!opentype_get_tt_os2_v1( data, size, ttc_sfnt_v1, &tt_os2_v1 )) return FALSE;
+
+    *version = GET_BE_DWORD( tt_head->revision );
+
+    fs->fsUsb[0] = GET_BE_DWORD( tt_os2_v1->ulUnicodeRange1 );
+    fs->fsUsb[1] = GET_BE_DWORD( tt_os2_v1->ulUnicodeRange2 );
+    fs->fsUsb[2] = GET_BE_DWORD( tt_os2_v1->ulUnicodeRange3 );
+    fs->fsUsb[3] = GET_BE_DWORD( tt_os2_v1->ulUnicodeRange4 );
+
+    if (tt_os2_v1->version == 0)
+    {
+        idx = GET_BE_WORD( tt_os2_v1->usFirstCharIndex );
+        if (idx >= 0xf000 && idx < 0xf100) fs->fsCsb[0] = FS_SYMBOL;
+        else fs->fsCsb[0] = FS_LATIN1;
+        fs->fsCsb[1] = 0;
+    }
+    else
+    {
+        fs->fsCsb[0] = GET_BE_DWORD( tt_os2_v1->ulCodePageRange1 );
+        fs->fsCsb[1] = GET_BE_DWORD( tt_os2_v1->ulCodePageRange2 );
+    }
+
+    selection = GET_BE_WORD( tt_os2_v1->fsSelection );
+
+    if (selection & OS2_FSSELECTION_ITALIC) flags |= NTM_ITALIC;
+    if (selection & OS2_FSSELECTION_BOLD) flags |= NTM_BOLD;
+    if (selection & OS2_FSSELECTION_REGULAR) flags |= NTM_REGULAR;
+    if (flags == 0) flags = NTM_REGULAR;
+
+    if (opentype_get_table_ptr( data, size, ttc_sfnt_v1, MS_CFF__TAG, &cff_header, &table_size ))
+        flags |= NTM_PS_OPENTYPE;
+
+    *ntm_flags = flags;
+    return TRUE;
+}
From 86feba02566a9c4f172a9c350984f562b0486605 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Oct 2020 16:20:53 +0200
Subject: [PATCH] gdi32: Use FreeType as a fallback when loading font faces.

---
 dlls/gdi32/freetype.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index d87aef47173..6388f062e15 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -1594,15 +1594,10 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
 
     if (!(This = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This) ))) goto done;
 
-    if (!(This->ft_face = new_ft_face( unix_name, font_data_ptr, font_data_size, face_index, flags & ADDFONT_ALLOW_BITMAP )))
-    {
-        HeapFree(GetProcessHeap(), 0, This);
-        This = NULL;
-    }
-    else if (opentype_get_ttc_sfnt_v1( font_data_ptr, font_data_size, face_index, &face_count, &ttc_sfnt_v1 ) &&
-             opentype_get_tt_name_v0( font_data_ptr, font_data_size, ttc_sfnt_v1, &tt_name_v0 ) &&
-             opentype_get_properties( font_data_ptr, font_data_size, ttc_sfnt_v1, &This->font_version,
-                                      &This->fs, &This->ntm_flags ))
+    if (opentype_get_ttc_sfnt_v1( font_data_ptr, font_data_size, face_index, &face_count, &ttc_sfnt_v1 ) &&
+        opentype_get_tt_name_v0( font_data_ptr, font_data_size, ttc_sfnt_v1, &tt_name_v0 ) &&
+        opentype_get_properties( font_data_ptr, font_data_size, ttc_sfnt_v1, &This->font_version,
+                                 &This->fs, &This->ntm_flags ))
     {
         struct family_names_data family_names;
         struct face_name_data style_name;
@@ -1644,7 +1639,7 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
             WARN( "full name not found, using %s instead\n", debugstr_w(This->full_name) );
         }
     }
-    else
+    else if ((This->ft_face = new_ft_face( unix_name, font_data_ptr, font_data_size, face_index, flags & ADDFONT_ALLOW_BITMAP )))
     {
         WARN( "unable to parse font, falling back to FreeType\n" );
         This->scalable = FT_IS_SCALABLE( This->ft_face );
@@ -1674,6 +1669,11 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
         if (!This->scalable) get_bitmap_size( This->ft_face, &This->size );
         get_fontsig(This->ft_face, &This->fs);
     }
+    else
+    {
+        HeapFree(GetProcessHeap(), 0, This);
+        This = NULL;
+    }
 
 done:
     if (unix_name) munmap(font_data_ptr, font_data_size);
@@ -1682,7 +1682,7 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
 
 static void unix_face_destroy(struct unix_face *This)
 {
-    pFT_Done_Face(This->ft_face);
+    if (This->ft_face) pFT_Done_Face(This->ft_face);
     HeapFree(GetProcessHeap(), 0, This->full_name);
     HeapFree(GetProcessHeap(), 0, This->style_name);
     HeapFree(GetProcessHeap(), 0, This->second_name);
From 7a2d100d3885f8b30e5b8a8f0836e013584481ce Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Oct 2020 21:12:22 +0200
Subject: [PATCH] gdi32: Add WinFNT font parser to replace FreeType.

---
 dlls/gdi32/freetype.c    |  39 ++++++++++++
 dlls/gdi32/gdi_private.h |   4 ++
 dlls/gdi32/opentype.c    | 131 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 174 insertions(+)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 6388f062e15..96d6739c6ae 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -1574,9 +1574,13 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
 
     const struct ttc_sfnt_v1 *ttc_sfnt_v1;
     const struct tt_name_v0 *tt_name_v0;
+    const char *family_name_a, *style_name_a;
     struct unix_face *This;
     struct stat st;
+    CHARSETINFO csi;
     DWORD face_count;
+    WORD width, height, points, ppem, in_leading;
+    BYTE charset;
     int fd, length;
 
     TRACE( "unix_name %s, face_index %u, font_data_ptr %p, font_data_size %u, flags %#x\n",
@@ -1639,6 +1643,41 @@ static struct unix_face *unix_face_create( const char *unix_name, void *font_dat
             WARN( "full name not found, using %s instead\n", debugstr_w(This->full_name) );
         }
     }
+    else if (winfnt_parse_font_face( font_data_ptr, font_data_size, face_index, &face_count,
+                                     &family_name_a, &style_name_a, &charset, &This->ntm_flags,
+                                     &width, &height, &points, &ppem, &in_leading ) &&
+             TranslateCharsetInfo( (DWORD*)(UINT_PTR)charset, &csi, TCI_SRCCHARSET ))
+    {
+        This->scalable = FALSE;
+        This->num_faces = face_count;
+        This->font_version = 0;
+        This->fs = csi.fs;
+
+        length = MultiByteToWideChar( CP_ACP, 0, family_name_a, -1, NULL, 0 );
+        This->family_name = HeapAlloc( GetProcessHeap(), 0, length * sizeof(WCHAR) );
+        MultiByteToWideChar( CP_ACP, 0, family_name_a, -1, This->family_name, length * sizeof(WCHAR) );
+
+        This->second_name = NULL;
+
+        length = MultiByteToWideChar( CP_ACP, 0, style_name_a, -1, NULL, 0 );
+        This->style_name = HeapAlloc( GetProcessHeap(), 0, length * sizeof(WCHAR) );
+        MultiByteToWideChar( CP_ACP, 0, style_name_a, -1, This->style_name, length * sizeof(WCHAR) );
+
+        TRACE( "parsed font names family_name %s, style_name %s\n", debugstr_w(This->family_name), debugstr_w(This->style_name) );
+
+        length = strlenW( This->family_name ) + strlenW( space_w ) + strlenW( This->style_name ) + 1;
+        This->full_name = HeapAlloc( GetProcessHeap(), 0, length * sizeof(WCHAR) );
+        strcpyW( This->full_name, This->family_name );
+        strcatW( This->full_name, space_w );
+        strcatW( This->full_name, This->style_name );
+
+        This->size.height = height;
+        This->size.width = width;
+        This->size.size = points * 64;
+        This->size.y_ppem = ppem;
+        This->size.x_ppem = ppem;
+        This->size.internal_leading = in_leading;
+    }
     else if ((This->ft_face = new_ft_face( unix_name, font_data_ptr, font_data_size, face_index, flags & ADDFONT_ALLOW_BITMAP )))
     {
         WARN( "unable to parse font, falling back to FreeType\n" );
diff --git a/dlls/gdi32/gdi_private.h b/dlls/gdi32/gdi_private.h
index 4c5553c9061..d8714edc020 100644
--- a/dlls/gdi32/gdi_private.h
+++ b/dlls/gdi32/gdi_private.h
@@ -416,6 +416,10 @@ extern BOOL opentype_enum_full_names( const struct tt_name_v0 *tt_name_v0,
 extern BOOL opentype_get_properties( const void *data, size_t size, const struct ttc_sfnt_v1 *ttc_sfnt_v1,
                                      DWORD *version, FONTSIGNATURE *fs, DWORD *ntm_flags ) DECLSPEC_HIDDEN;
 
+extern BOOL winfnt_parse_font_face( const void *data, size_t size, DWORD index, DWORD *count,
+                                    const char **family_name, const char **style_name, BYTE *charset, DWORD *ntm_flags,
+                                    WORD *width, WORD *height, WORD *points, WORD *ppem, WORD *in_leading ) DECLSPEC_HIDDEN;
+
 /* gdiobj.c */
 extern HGDIOBJ alloc_gdi_handle( void *obj, WORD type, const struct gdi_obj_funcs *funcs ) DECLSPEC_HIDDEN;
 extern void *free_gdi_handle( HGDIOBJ handle ) DECLSPEC_HIDDEN;
diff --git a/dlls/gdi32/opentype.c b/dlls/gdi32/opentype.c
index 1c6fae7190d..a4121bcd857 100644
--- a/dlls/gdi32/opentype.c
+++ b/dlls/gdi32/opentype.c
@@ -780,3 +780,134 @@ BOOL opentype_get_properties( const void *data, size_t size, const struct ttc_sf
     *ntm_flags = flags;
     return TRUE;
 }
+
+#include "pshpack1.h"
+typedef struct
+{
+    INT16 dfType;
+    INT16 dfPoints;
+    INT16 dfVertRes;
+    INT16 dfHorizRes;
+    INT16 dfAscent;
+    INT16 dfInternalLeading;
+    INT16 dfExternalLeading;
+    BYTE  dfItalic;
+    BYTE  dfUnderline;
+    BYTE  dfStrikeOut;
+    INT16 dfWeight;
+    BYTE  dfCharSet;
+    INT16 dfPixWidth;
+    INT16 dfPixHeight;
+    BYTE  dfPitchAndFamily;
+    INT16 dfAvgWidth;
+    INT16 dfMaxWidth;
+    BYTE  dfFirstChar;
+    BYTE  dfLastChar;
+    BYTE  dfDefaultChar;
+    BYTE  dfBreakChar;
+    INT16 dfWidthBytes;
+    LONG  dfDevice;
+    LONG  dfFace;
+    LONG  dfBitsPointer;
+    LONG  dfBitsOffset;
+    BYTE  dfReserved;
+    LONG  dfFlags;
+    INT16 dfAspace;
+    INT16 dfBspace;
+    INT16 dfCspace;
+    LONG  dfColorPointer;
+    LONG  dfReserved1[4];
+} FONTINFO16;
+
+typedef struct
+{
+    WORD dfVersion;
+    DWORD dfSize;
+    char dfCopyright[60];
+    FONTINFO16 fi;
+} FNT_HEADER;
+
+typedef struct
+{
+    WORD  offset;
+    WORD  length;
+    WORD  flags;
+    WORD  id;
+    WORD  handle;
+    WORD  usage;
+} NE_NAMEINFO;
+
+typedef struct
+{
+    WORD  type_id;
+    WORD  count;
+    DWORD resloader;
+} NE_TYPEINFO;
+#include "poppack.h"
+
+#define NE_RSCTYPE_FONTDIR 0x8007
+#define NE_RSCTYPE_FONT    0x8008
+
+BOOL winfnt_parse_font_face( const void *data, size_t size, DWORD index, DWORD *count,
+                             const char **family_name, const char **style_name, BYTE *charset, DWORD *ntm_flags,
+                             WORD *width, WORD *height, WORD *points, WORD *ppem, WORD *in_leading )
+{
+    const IMAGE_DOS_HEADER *dos = data;
+    const IMAGE_OS2_HEADER *os2 = (const IMAGE_OS2_HEADER *)((const char *)data + dos->e_lfanew);
+    DWORD offset, flags;
+    WORD align;
+
+    if (dos->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;
+
+    if (dos->e_lfanew <= size && dos->e_lfanew + sizeof(*os2) <= size &&
+        os2->ne_magic == IMAGE_OS2_SIGNATURE)
+    {
+        const char *rsrc_table = (const char *)os2 + os2->ne_rsrctab;
+        const char *res_table = (const char *)os2 + os2->ne_restab;
+        const NE_TYPEINFO *type = (const NE_TYPEINFO *)(rsrc_table + sizeof(align));
+        const NE_NAMEINFO *name = (const NE_NAMEINFO *)(type + 1);
+        const FNT_HEADER *fnt_header;
+
+        if ((const char *)name >= res_table) return FALSE;
+        memcpy(&align, rsrc_table, sizeof(align));
+
+        if (type->type_id != NE_RSCTYPE_FONTDIR) return FALSE;
+        if (rsrc_table + name->id >= res_table) return FALSE;
+        if (*(rsrc_table + name->id) != strlen("FONTDIR")) return FALSE;
+        if (memcmp(rsrc_table + name->id + 1, "FONTDIR", strlen("FONTDIR"))) return FALSE;
+
+        type = (const NE_TYPEINFO *)(name + 1);
+        if (type->type_id != NE_RSCTYPE_FONT) return FALSE;
+        *count = type->count;
+
+        if (index >= type->count) return FALSE;
+        name = (const NE_NAMEINFO *)(type + 1 + index);
+        offset = name->offset << align;
+
+        if (offset >= size || offset + sizeof(*fnt_header) >= size) return FALSE;
+        fnt_header = (const FNT_HEADER *)((const char *)data + offset);
+
+        *family_name = (const char *)fnt_header + fnt_header->fi.dfFace;
+        *charset = fnt_header->fi.dfCharSet;
+
+        flags = 0;
+        if (fnt_header->fi.dfItalic) flags |= NTM_ITALIC;
+        if (fnt_header->fi.dfWeight > FW_NORMAL) flags |= NTM_BOLD;
+        if (flags == 0) flags = NTM_REGULAR;
+        *ntm_flags = flags;
+
+        if (flags == (NTM_BOLD|NTM_ITALIC)) *style_name = "Bold Italic";
+        else if (flags == NTM_BOLD) *style_name = "Bold";
+        else if (flags == NTM_ITALIC) *style_name = "Italic";
+        else *style_name = "Regular";
+
+        *width = fnt_header->fi.dfAvgWidth;
+        *height = fnt_header->fi.dfPixHeight;
+        *points = fnt_header->fi.dfPoints;
+        *ppem = ((fnt_header->fi.dfPoints * fnt_header->fi.dfVertRes * 0x40) / 72
+                 + fnt_header->fi.dfInternalLeading + fnt_header->fi.dfExternalLeading + 0x20) & ~0x3f;
+        *in_leading = fnt_header->fi.dfInternalLeading;
+    }
+
+    return TRUE;
+}
From d6dfb9bfe3e03a8c9c64b08bcb5dbbf9b4bc225a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Oct 2020 13:54:38 +0200
Subject: [PATCH] gdi32: Index font families by name in rbtree.

And keep them sorted with the vertical / default family rules.
---
 dlls/gdi32/freetype.c | 223 ++++++++++++++++++++----------------------
 1 file changed, 108 insertions(+), 115 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 96d6739c6ae..122102dcf3b 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -103,6 +103,7 @@
 #include "wine/unicode.h"
 #include "wine/debug.h"
 #include "wine/list.h"
+#include "wine/rbtree.h"
 
 #include "resource.h"
 
@@ -290,7 +291,8 @@ static inline const char *debugstr_faceid( Face *face )
 #define ADDFONT_AA_FLAGS(flags) ((flags) << 16)
 
 typedef struct tagFamily {
-    struct list entry;
+    struct wine_rb_entry entry;
+    struct wine_rb_entry entry_second;
     unsigned int refcount;
     WCHAR family_name[LF_FACESIZE];
     WCHAR second_name[LF_FACESIZE];
@@ -345,8 +347,6 @@ static struct list system_links = LIST_INIT(system_links);
 
 static struct list font_subst_list = LIST_INIT(font_subst_list);
 
-static struct list font_list = LIST_INIT(font_list);
-
 static const struct font_backend_funcs font_funcs;
 
 static const WCHAR fontsW[] = {'\\','f','o','n','t','s','\0'};
@@ -424,6 +424,40 @@ static const WCHAR *default_serif = times_new_roman;
 static const WCHAR *default_fixed = courier_new;
 static const WCHAR *default_sans = arial;
 
+static int family_namecmp( const WCHAR *name_a, const WCHAR *name_b )
+{
+    const WCHAR *tmp_a = name_a, *tmp_b = name_b;
+    int res, in_front_a, in_front_b;
+
+    in_front_a = !strncmpiW( name_a, default_serif, LF_FACESIZE - 1 ) ||
+                 !strncmpiW( name_a, default_fixed, LF_FACESIZE - 1 ) ||
+                 !strncmpiW( name_a, default_sans, LF_FACESIZE - 1 );
+    in_front_b = !strncmpiW( name_b, default_serif, LF_FACESIZE - 1 ) ||
+                 !strncmpiW( name_b, default_fixed, LF_FACESIZE - 1 ) ||
+                 !strncmpiW( name_b, default_sans, LF_FACESIZE - 1 );
+    if (in_front_a != in_front_b) return in_front_b - in_front_a;
+
+    if ((name_a[0] == '@')) tmp_a++;
+    if ((name_b[0] == '@')) tmp_b++;
+    if ((res = strncmpiW( tmp_a, tmp_b, LF_FACESIZE - 1 ))) return res;
+    return (name_a[0] == '@') - (name_b[0] == '@');
+}
+
+static int family_name_compare( const void *key, const struct wine_rb_entry *entry )
+{
+    const Family *family = WINE_RB_ENTRY_VALUE( entry, const Family, entry );
+    return family_namecmp( (const WCHAR *)key, family->family_name );
+}
+
+static int family_second_name_compare( const void *key, const struct wine_rb_entry *entry )
+{
+    const Family *family = WINE_RB_ENTRY_VALUE( entry, const Family, entry_second );
+    return family_namecmp( (const WCHAR *)key, family->second_name );
+}
+
+static struct wine_rb_tree family_tree = { family_name_compare };
+static struct wine_rb_tree family_second_tree = { family_second_name_compare };
+
 typedef struct {
     WCHAR *name;
     INT charset;
@@ -878,7 +912,7 @@ static Face *find_face_from_filename(const WCHAR *file_name, const WCHAR *face_n
 
     TRACE("looking for file %s name %s\n", debugstr_w(file_name), debugstr_w(face_name));
 
-    LIST_FOR_EACH_ENTRY(family, &font_list, Family, entry)
+    WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
     {
         const struct list *face_list;
         if (face_name && strncmpiW( face_name, family->family_name, LF_FACESIZE - 1 )) continue;
@@ -902,25 +936,19 @@ static Face *find_face_from_filename(const WCHAR *file_name, const WCHAR *face_n
 
 static Family *find_family_from_name(const WCHAR *name)
 {
-    Family *family;
-
-    LIST_FOR_EACH_ENTRY(family, &font_list, Family, entry)
-        if (!strncmpiW( family->family_name, name, LF_FACESIZE - 1 )) return family;
-
-    return NULL;
+    struct wine_rb_entry *entry;
+    if (!(entry = wine_rb_get( &family_tree, name ))) return NULL;
+    return WINE_RB_ENTRY_VALUE( entry, Family, entry );
 }
 
 static Family *find_family_from_any_name(const WCHAR *name)
 {
+    struct wine_rb_entry *entry;
     Family *family;
 
-    LIST_FOR_EACH_ENTRY(family, &font_list, Family, entry)
-    {
-        if (!strncmpiW( family->family_name, name, LF_FACESIZE - 1 )) return family;
-        if (!strncmpiW( family->second_name, name, LF_FACESIZE - 1 )) return family;
-    }
-
-    return NULL;
+    if ((family = find_family_from_name( name ))) return family;
+    if (!(entry = wine_rb_get( &family_second_tree, name ))) return NULL;
+    return WINE_RB_ENTRY_VALUE( entry, Family, entry_second );
 }
 
 static void DumpSubstList(void)
@@ -1365,7 +1393,8 @@ static void release_family( Family *family )
 {
     if (--family->refcount) return;
     assert( list_empty( &family->faces ));
-    list_remove( &family->entry );
+    wine_rb_remove( &family_tree, &family->entry );
+    if (family->second_name[0]) wine_rb_remove( &family_second_tree, &family->entry_second );
     HeapFree( GetProcessHeap(), 0, family );
 }
 
@@ -1810,20 +1839,23 @@ static BOOL insert_face_in_family_list( Face *face, Family *family )
     return TRUE;
 }
 
-/****************************************************************
- * NB This function stores the ptrs to the strings to save copying.
- * Don't free them after calling.
- */
-static Family *create_family( WCHAR *family_name, WCHAR *second_name )
+static Family *create_family( const WCHAR *family_name, const WCHAR *second_name )
 {
-    Family * const family = HeapAlloc( GetProcessHeap(), 0, sizeof(*family) );
+    Family *family;
+
+    TRACE( "family_name %s, second_name %s\n", debugstr_w(family_name), debugstr_w(second_name) );
+
+    if (!(family = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*family) ))) return NULL;
     family->refcount = 1;
+
     lstrcpynW( family->family_name, family_name, LF_FACESIZE );
     if (second_name) lstrcpynW( family->second_name, second_name, LF_FACESIZE );
     else family->second_name[0] = 0;
     list_init( &family->faces );
     family->replacement = &family->faces;
-    list_add_tail( &font_list, &family->entry );
+
+    wine_rb_put( &family_tree, family->family_name, &family->entry );
+    if (family->second_name[0]) wine_rb_put( &family_second_tree, family->second_name, &family->entry_second );
 
     return family;
 }
@@ -1914,38 +1946,6 @@ static void load_face(HKEY hkey_family, Family *family, void *buffer, DWORD buff
     }
 }
 
-/* move vertical fonts after their horizontal counterpart */
-/* assumes that font_list is already sorted by family name */
-static void reorder_vertical_fonts(void)
-{
-    Family *family, *next, *vert_family;
-    struct list *ptr, *vptr;
-    struct list vertical_families = LIST_INIT( vertical_families );
-
-    LIST_FOR_EACH_ENTRY_SAFE( family, next, &font_list, Family, entry )
-    {
-        if (family->family_name[0] != '@') continue;
-        list_remove( &family->entry );
-        list_add_tail( &vertical_families, &family->entry );
-    }
-
-    ptr = list_head( &font_list );
-    vptr = list_head( &vertical_families );
-    while (ptr && vptr)
-    {
-        family = LIST_ENTRY( ptr, Family, entry );
-        vert_family = LIST_ENTRY( vptr, Family, entry );
-        if (strcmpiW( family->family_name, vert_family->family_name + 1 ) > 0)
-        {
-            list_remove( vptr );
-            list_add_before( ptr, vptr );
-            vptr = list_head( &vertical_families );
-        }
-        else ptr = list_next( &font_list, ptr );
-    }
-    list_move_tail( &font_list, &vertical_families );
-}
-
 static void load_font_list_from_cache(HKEY hkey_font_cache)
 {
     DWORD size, family_index = 0;
@@ -1986,8 +1986,6 @@ static void load_font_list_from_cache(HKEY hkey_font_cache)
         release_family( family );
         size = sizeof(buffer);
     }
-
-    reorder_vertical_fonts();
 }
 
 static LONG create_font_cache_key(HKEY *hkey, DWORD *disposition)
@@ -2350,7 +2348,7 @@ static int remove_font_resource( const WCHAR *file, DWORD flags )
     Face *face, *face_next;
     int count = 0;
 
-    LIST_FOR_EACH_ENTRY_SAFE( family, family_next, &font_list, Family, entry )
+    WINE_RB_FOR_EACH_ENTRY_DESTRUCTOR( family, family_next, &family_tree, Family, entry )
     {
         family->refcount++;
         LIST_FOR_EACH_ENTRY_SAFE( face, face_next, &family->faces, Face, entry )
@@ -2374,7 +2372,8 @@ static void DumpFontList(void)
     Family *family;
     Face *face;
 
-    LIST_FOR_EACH_ENTRY( family, &font_list, Family, entry ) {
+    WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+    {
         TRACE( "Family: %s\n", debugstr_w(family->family_name) );
         LIST_FOR_EACH_ENTRY( face, &family->faces, Face, entry ) {
             TRACE( "\t%s\t%s\t%08x", debugstr_w(face->style_name), debugstr_w(face->full_name),
@@ -2412,27 +2411,26 @@ static BOOL map_vertical_font_family(const WCHAR *orig, const WCHAR *repl, const
 
 static BOOL map_font_family(const WCHAR *orig, const WCHAR *repl)
 {
-    Family *family = find_family_from_any_name(repl);
-    if (family != NULL)
-    {
-        Family *new_family = HeapAlloc(GetProcessHeap(), 0, sizeof(*new_family));
-        if (new_family != NULL)
-        {
-            TRACE("mapping %s to %s\n", debugstr_w(repl), debugstr_w(orig));
-            lstrcpynW( new_family->family_name, orig, LF_FACESIZE );
-            new_family->second_name[0] = 0;
-            list_init(&new_family->faces);
-            new_family->replacement = &family->faces;
-            list_add_tail(&font_list, &new_family->entry);
+    Family *family, *new_family;
 
-            if (repl[0] != '@')
-                map_vertical_font_family(orig, repl, family);
+    if (!(family = find_family_from_any_name( repl )))
+    {
+        TRACE( "%s is not available. Skip this replacement.\n", debugstr_w(repl) );
+        return FALSE;
+    }
 
-            return TRUE;
-        }
+    if (!(new_family = create_family( orig, NULL )))
+    {
+        WARN( "failed to allocate new family\n" );
+        return FALSE;
     }
-    TRACE("%s is not available. Skip this replacement.\n", debugstr_w(repl));
-    return FALSE;
+
+    TRACE( "mapping %s to %s\n", debugstr_w(repl), debugstr_w(orig) );
+
+    new_family->replacement = &family->faces;
+    if (repl[0] != '@') map_vertical_font_family( orig, repl, family );
+
+    return TRUE;
 }
 
 /***********************************************************
@@ -3212,7 +3210,8 @@ static void update_reg_entries(void)
 
     /* enumerate the fonts and add external ones to the two keys */
 
-    LIST_FOR_EACH_ENTRY( family, &font_list, Family, entry ) {
+    WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+    {
         LIST_FOR_EACH_ENTRY( face, &family->faces, Face, entry ) {
             if (!(face->flags & ADDFONT_EXTERNAL_FONT)) continue;
 
@@ -3907,39 +3906,26 @@ static void init_font_list(void)
     }
 }
 
-static BOOL move_to_front(const WCHAR *name)
-{
-    Family *family, *cursor2;
-    LIST_FOR_EACH_ENTRY_SAFE(family, cursor2, &font_list, Family, entry)
-    {
-        if (!strncmpiW( family->family_name, name, LF_FACESIZE - 1 ))
-        {
-            list_remove(&family->entry);
-            list_add_head(&font_list, &family->entry);
-            return TRUE;
-        }
-    }
-    return FALSE;
-}
-
-static const WCHAR *set_default(const WCHAR **name_list)
+static void select_default( const WCHAR **list, const WCHAR **selected )
 {
-    const WCHAR **entry = name_list;
+    struct wine_rb_entry *entry;
+    const WCHAR *name;
 
-    while (*entry)
+    while ((name = *list++))
     {
-        if (move_to_front(*entry)) return *entry;
-        entry++;
+        if (!(entry = wine_rb_get( &family_tree, name ))) continue;
+        wine_rb_remove( &family_tree, entry );
+        *selected = name;
+        wine_rb_put( &family_tree, name, entry );
+        return;
     }
-
-    return *name_list;
 }
 
 static void reorder_font_list(void)
 {
-    default_serif = set_default( default_serif_list );
-    default_fixed = set_default( default_fixed_list );
-    default_sans = set_default( default_sans_list );
+    select_default( default_serif_list, &default_serif );
+    select_default( default_fixed_list, &default_fixed );
+    select_default( default_sans_list, &default_sans );
 }
 
 /*************************************************************
@@ -4990,7 +4976,8 @@ static struct gdi_font * CDECL freetype_SelectFont( DC *dc, HFONT hfont, UINT *a
 	   where we'll either use the charset of the current ansi codepage
 	   or if that's unavailable the first charset that the font supports.
 	*/
-        LIST_FOR_EACH_ENTRY( family, &font_list, Family, entry ) {
+        WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+        {
             if (!strncmpiW( family->family_name, FaceName, LF_FACESIZE - 1 ) ||
                 (psub && !strncmpiW( family->family_name, psub->to.name, LF_FACESIZE - 1 )))
             {
@@ -5008,10 +4995,11 @@ static struct gdi_font * CDECL freetype_SelectFont( DC *dc, HFONT hfont, UINT *a
                         goto found;
                 }
             }
-	}
+        }
 
         /* Search by full face name. */
-        LIST_FOR_EACH_ENTRY( family, &font_list, Family, entry ) {
+        WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+        {
             face_list = get_face_list_from_family(family);
             LIST_FOR_EACH_ENTRY( face, face_list, Face, entry ) {
                 if (!strncmpiW( face->full_name, FaceName, LF_FACESIZE - 1 ) && (face->scalable || can_use_bitmap))
@@ -5082,7 +5070,8 @@ static struct gdi_font * CDECL freetype_SelectFont( DC *dc, HFONT hfont, UINT *a
         strcpyW(lf.lfFaceName, default_sans);
     else
         strcpyW(lf.lfFaceName, default_sans);
-    LIST_FOR_EACH_ENTRY( family, &font_list, Family, entry ) {
+    WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+    {
         if (!strncmpiW( family->family_name, lf.lfFaceName, LF_FACESIZE - 1 ))
         {
             font_link = find_font_link( family->family_name );
@@ -5105,7 +5094,8 @@ static struct gdi_font * CDECL freetype_SelectFont( DC *dc, HFONT hfont, UINT *a
 #endif
 
     last_resort_family = NULL;
-    LIST_FOR_EACH_ENTRY( family, &font_list, Family, entry ) {
+    WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+    {
         font_link = find_font_link( family->family_name );
         face_list = get_face_list_from_family(family);
         LIST_FOR_EACH_ENTRY( face, face_list, Face, entry ) {
@@ -5126,7 +5116,8 @@ static struct gdi_font * CDECL freetype_SelectFont( DC *dc, HFONT hfont, UINT *a
         goto found;
     }
 
-    LIST_FOR_EACH_ENTRY( family, &font_list, Family, entry ) {
+    WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+    {
         face_list = get_face_list_from_family(family);
         LIST_FOR_EACH_ENTRY( face, face_list, Face, entry ) {
             if(face->scalable && !(face->flags & ADDFONT_VERTICAL_FONT) == !want_vertical) {
@@ -5641,20 +5632,22 @@ static BOOL CDECL freetype_EnumFonts( LPLOGFONTW plf, FONTENUMPROCW proc, LPARAM
             face_name = psub->to.name;
         }
 
-        LIST_FOR_EACH_ENTRY( family, &font_list, Family, entry ) {
+        WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+        {
             if (!family_matches(family, face_name)) continue;
             face_list = get_face_list_from_family(family);
             LIST_FOR_EACH_ENTRY( face, face_list, Face, entry ) {
                 if (!face_matches( family->family_name, face, face_name )) continue;
                 if (!enum_face_charsets(family, face, &enum_charsets, proc, lparam, psub ? psub->from.name : NULL)) return FALSE;
 	    }
-	}
+        }
     } else {
-        LIST_FOR_EACH_ENTRY( family, &font_list, Family, entry ) {
+        WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+        {
             face_list = get_face_list_from_family(family);
             face = LIST_ENTRY(list_head(face_list), Face, entry);
             if (!enum_face_charsets(family, face, &enum_charsets, proc, lparam, NULL)) return FALSE;
-	}
+        }
     }
     LeaveCriticalSection( &font_cs );
     return TRUE;
From 706451fa742171980b4dde2778c07878877265d6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Oct 2020 13:55:10 +0200
Subject: [PATCH] gdi32: Rewrite find_face_from_filename with rbtree.

---
 dlls/gdi32/freetype.c | 71 +++++++++++++++++++++++++------------------
 1 file changed, 41 insertions(+), 30 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 122102dcf3b..9190abd669f 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -904,36 +904,6 @@ static const struct list *get_face_list_from_family(const Family *family)
         return family->replacement;
 }
 
-static Face *find_face_from_filename(const WCHAR *file_name, const WCHAR *face_name)
-{
-    Family *family;
-    Face *face;
-    const WCHAR *file;
-
-    TRACE("looking for file %s name %s\n", debugstr_w(file_name), debugstr_w(face_name));
-
-    WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
-    {
-        const struct list *face_list;
-        if (face_name && strncmpiW( face_name, family->family_name, LF_FACESIZE - 1 )) continue;
-        face_list = get_face_list_from_family(family);
-        LIST_FOR_EACH_ENTRY(face, face_list, Face, entry)
-        {
-            if (!face->file)
-                continue;
-            file = strrchrW(face->file, '\\');
-            if(!file)
-                file = face->file;
-            else
-                file++;
-            if(strcmpiW(file, file_name)) continue;
-            face->refcount++;
-            return face;
-	}
-    }
-    return NULL;
-}
-
 static Family *find_family_from_name(const WCHAR *name)
 {
     struct wine_rb_entry *entry;
@@ -951,6 +921,47 @@ static Family *find_family_from_any_name(const WCHAR *name)
     return WINE_RB_ENTRY_VALUE( entry, Family, entry_second );
 }
 
+static Face *family_find_face_from_filename( Family *family, const WCHAR *file_name )
+{
+    const struct list *face_list = get_face_list_from_family( family );
+    Face *face;
+    const WCHAR *file;
+
+    LIST_FOR_EACH_ENTRY( face, face_list, Face, entry )
+    {
+        if (!face->file)
+            continue;
+        file = strrchrW(face->file, '\\');
+        if(!file)
+            file = face->file;
+        else
+            file++;
+        if(strcmpiW(file, file_name)) continue;
+        face->refcount++;
+        return face;
+    }
+
+    return NULL;
+}
+
+static Face *find_face_from_filename( const WCHAR *file_name, const WCHAR *face_name )
+{
+    Family *family;
+    Face *face;
+
+    TRACE( "looking for file %s name %s\n", debugstr_w(file_name), debugstr_w(face_name) );
+
+    if (!face_name)
+    {
+        WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+            if ((face = family_find_face_from_filename( family, file_name ))) return face;
+        return NULL;
+    }
+
+    if (!(family = find_family_from_name( face_name ))) return NULL;
+    return family_find_face_from_filename( family, file_name );
+}
+
 static void DumpSubstList(void)
 {
     FontSubst *psub;
From c71be797966517dbe922e0b0a353fba96635a864 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 4 Sep 2020 15:44:37 +0200
Subject: [PATCH] gdi32: Rewrite font family lookup with rbtree.

---
 dlls/gdi32/freetype.c | 57 ++++++++++++++++++++++---------------------
 1 file changed, 29 insertions(+), 28 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 9190abd669f..fd0b702caab 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -4987,24 +4987,29 @@ static struct gdi_font * CDECL freetype_SelectFont( DC *dc, HFONT hfont, UINT *a
 	   where we'll either use the charset of the current ansi codepage
 	   or if that's unavailable the first charset that the font supports.
 	*/
-        WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+        if (psub && (family = find_family_from_name( psub->to.name )))
         {
-            if (!strncmpiW( family->family_name, FaceName, LF_FACESIZE - 1 ) ||
-                (psub && !strncmpiW( family->family_name, psub->to.name, LF_FACESIZE - 1 )))
+            font_link = find_font_link( family->family_name );
+            face_list = get_face_list_from_family( family );
+            LIST_FOR_EACH_ENTRY( face, face_list, Face, entry )
             {
-                font_link = find_font_link( family->family_name );
-                face_list = get_face_list_from_family(family);
-                LIST_FOR_EACH_ENTRY( face, face_list, Face, entry ) {
-                    if (!(face->scalable || can_use_bitmap))
-                        continue;
-                    if (csi.fs.fsCsb[0] & face->fs.fsCsb[0])
-                        goto found;
-                    if (font_link != NULL &&
-                        csi.fs.fsCsb[0] & font_link->fs.fsCsb[0])
-                        goto found;
-                    if (!csi.fs.fsCsb[0])
-                        goto found;
-                }
+                if (!(face->scalable || can_use_bitmap)) continue;
+                if (csi.fs.fsCsb[0] & face->fs.fsCsb[0]) goto found;
+                if (font_link != NULL && csi.fs.fsCsb[0] & font_link->fs.fsCsb[0]) goto found;
+                if (!csi.fs.fsCsb[0]) goto found;
+            }
+        }
+
+        if ((family = find_family_from_name( FaceName )))
+        {
+            font_link = find_font_link( family->family_name );
+            face_list = get_face_list_from_family( family );
+            LIST_FOR_EACH_ENTRY( face, face_list, Face, entry )
+            {
+                if (!(face->scalable || can_use_bitmap)) continue;
+                if (csi.fs.fsCsb[0] & face->fs.fsCsb[0]) goto found;
+                if (font_link != NULL && csi.fs.fsCsb[0] & font_link->fs.fsCsb[0]) goto found;
+                if (!csi.fs.fsCsb[0]) goto found;
             }
         }
 
@@ -5081,20 +5086,16 @@ static struct gdi_font * CDECL freetype_SelectFont( DC *dc, HFONT hfont, UINT *a
         strcpyW(lf.lfFaceName, default_sans);
     else
         strcpyW(lf.lfFaceName, default_sans);
-    WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
+
+    if ((family = find_family_from_name( lf.lfFaceName )))
     {
-        if (!strncmpiW( family->family_name, lf.lfFaceName, LF_FACESIZE - 1 ))
+        font_link = find_font_link( family->family_name );
+        face_list = get_face_list_from_family( family );
+        LIST_FOR_EACH_ENTRY( face, face_list, Face, entry )
         {
-            font_link = find_font_link( family->family_name );
-            face_list = get_face_list_from_family(family);
-            LIST_FOR_EACH_ENTRY( face, face_list, Face, entry ) {
-                if (!(face->scalable || can_use_bitmap))
-                    continue;
-                if (csi.fs.fsCsb[0] & face->fs.fsCsb[0])
-                    goto found;
-                if (font_link != NULL && csi.fs.fsCsb[0] & font_link->fs.fsCsb[0])
-                    goto found;
-            }
+            if (!(face->scalable || can_use_bitmap)) continue;
+            if (csi.fs.fsCsb[0] & face->fs.fsCsb[0]) goto found;
+            if (font_link != NULL && csi.fs.fsCsb[0] & font_link->fs.fsCsb[0]) goto found;
         }
     }
 
From ff899ed0aebdc2a03ec60a5450e081e3084936a4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 6 Sep 2020 23:19:43 +0200
Subject: [PATCH] gdi32: Index scalable faces by full name in rbtree.

To quickly discard already loaded faces from the registry list.
---
 dlls/gdi32/freetype.c | 43 +++++++++++++++++++++++++++++++++++++++----
 1 file changed, 39 insertions(+), 4 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index fd0b702caab..6becbebe46d 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -257,6 +257,7 @@ struct enum_data
 
 typedef struct tagFace {
     struct list entry;
+    struct wine_rb_entry entry_full;
     unsigned int refcount;
     WCHAR *style_name;
     WCHAR *full_name;
@@ -424,6 +425,12 @@ static const WCHAR *default_serif = times_new_roman;
 static const WCHAR *default_fixed = courier_new;
 static const WCHAR *default_sans = arial;
 
+static int face_full_name_compare( const void *key, const struct wine_rb_entry *entry )
+{
+    const Face *face = WINE_RB_ENTRY_VALUE( entry, const Face, entry_full );
+    return strcmpiW( (const WCHAR *)key, face->full_name );
+}
+
 static int family_namecmp( const WCHAR *name_a, const WCHAR *name_b )
 {
     const WCHAR *tmp_a = name_a, *tmp_b = name_b;
@@ -455,6 +462,7 @@ static int family_second_name_compare( const void *key, const struct wine_rb_ent
     return family_namecmp( (const WCHAR *)key, family->second_name );
 }
 
+static struct wine_rb_tree face_tree = { face_full_name_compare };
 static struct wine_rb_tree family_tree = { family_name_compare };
 static struct wine_rb_tree family_second_tree = { family_second_name_compare };
 
@@ -921,6 +929,13 @@ static Family *find_family_from_any_name(const WCHAR *name)
     return WINE_RB_ENTRY_VALUE( entry, Family, entry_second );
 }
 
+static Face *find_face_from_full_name(const WCHAR *full_name)
+{
+    struct wine_rb_entry *entry;
+    if (!(entry = wine_rb_get( &face_tree, full_name ))) return NULL;
+    return WINE_RB_ENTRY_VALUE( entry, Face, entry_full );
+}
+
 static Face *family_find_face_from_filename( Family *family, const WCHAR *file_name )
 {
     const struct list *face_list = get_face_list_from_family( family );
@@ -1778,6 +1793,9 @@ static void release_face( Face *face )
         list_remove( &face->entry );
         release_family( face->family );
     }
+    if (face->entry_full.parent || face_tree.root == &face->entry_full)
+        wine_rb_remove( &face_tree, &face->entry_full );
+
     HeapFree( GetProcessHeap(), 0, face->file );
     HeapFree( GetProcessHeap(), 0, face->style_name );
     HeapFree( GetProcessHeap(), 0, face->full_name );
@@ -1833,6 +1851,11 @@ static BOOL insert_face_in_family_list( Face *face, Family *family )
                 face->family = family;
                 family->refcount++;
                 face->refcount++;
+                if (cursor->entry_full.parent || face_tree.root == &cursor->entry_full)
+                {
+                    wine_rb_replace( &face_tree, &cursor->entry_full, &face->entry_full );
+                    memset( &cursor->entry_full, 0, sizeof(cursor->entry_full) );
+                }
                 release_face( cursor );
                 return TRUE;
             }
@@ -1844,6 +1867,7 @@ static BOOL insert_face_in_family_list( Face *face, Family *family )
     TRACE( "Adding face %s in family %s from %s\n", debugstr_w(face->full_name),
            debugstr_w(family->family_name), debugstr_faceid(face) );
     list_add_before( &cursor->entry, &face->entry );
+    if (face->scalable) wine_rb_put( &face_tree, face->full_name, &face->entry_full );
     face->family = family;
     family->refcount++;
     face->refcount++;
@@ -1908,6 +1932,7 @@ static void load_face(HKEY hkey_family, Family *family, void *buffer, DWORD buff
             face->cached_enum_data = NULL;
             face->family = NULL;
             face->refcount = 1;
+            memset( &face->entry_full, 0, sizeof(face->entry_full) );
             face->style_name = strdupW( name );
             face->face_index = cached->index;
             face->flags = cached->flags;
@@ -2138,6 +2163,7 @@ static Face *create_face( struct unix_face *unix_face, FT_Long face_index, const
     Face *face = HeapAlloc( GetProcessHeap(), 0, sizeof(*face) );
 
     face->refcount = 1;
+    memset( &face->entry_full, 0, sizeof(face->entry_full) );
     face->style_name = strdupW( unix_face->style_name );
     face->full_name = strdupW( unix_face->full_name );
     if (flags & ADDFONT_VERTICAL_FONT) face->full_name = get_vertical_name( face->full_name );
@@ -3797,6 +3823,7 @@ static BOOL init_freetype(void)
 
 static void init_font_list(void)
 {
+    static const WCHAR truetype_w[] = {' ','(','T','r','u','e','T','y','p','e',')','\0'};
     static const WCHAR dot_fonW[] = {'.','f','o','n','\0'};
     static const WCHAR pathW[] = {'P','a','t','h',0};
     HKEY hkey;
@@ -3826,21 +3853,28 @@ static void init_font_list(void)
                    is_win9x() ? win9x_font_reg_key : winnt_font_reg_key,
                    &hkey) == ERROR_SUCCESS)
     {
-        LPWSTR data, valueW;
+        LPWSTR data, valueW, full_name, tmp;
         RegQueryInfoKeyW(hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          &valuelen, &datalen, NULL, NULL);
 
         valuelen++; /* returned value doesn't include room for '\0' */
+        full_name = HeapAlloc(GetProcessHeap(), 0, valuelen * sizeof(WCHAR));
         valueW = HeapAlloc(GetProcessHeap(), 0, valuelen * sizeof(WCHAR));
         data = HeapAlloc(GetProcessHeap(), 0, datalen * sizeof(WCHAR));
         if (valueW && data)
         {
             dlen = datalen * sizeof(WCHAR);
             vlen = valuelen;
-            while(RegEnumValueW(hkey, i++, valueW, &vlen, NULL, &type, (LPBYTE)data,
-                                &dlen) == ERROR_SUCCESS)
+            while (RegEnumValueW(hkey, i++, valueW, &vlen, NULL, &type, NULL, NULL) == ERROR_SUCCESS)
             {
-                if(data[0] && (data[1] == ':'))
+                strcpyW(full_name, valueW);
+                if ((tmp = strrchrW( full_name, ' ' )) && !strcmpiW(tmp, truetype_w)) *tmp = '\0';
+
+                if (find_face_from_full_name( full_name ))
+                    WARN("Skipping already loaded face %s\n", debugstr_w(full_name));
+                else if (RegQueryValueExW( hkey, valueW, NULL, NULL, (LPBYTE)data, &dlen ) != ERROR_SUCCESS)
+                    WARN("Unable to get face path %s\n", debugstr_w(valueW));
+                else if(data[0] && (data[1] == ':'))
                 {
                     add_font_resource( data, ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_TO_CACHE);
                 }
@@ -3862,6 +3896,7 @@ static void init_font_list(void)
         }
         HeapFree(GetProcessHeap(), 0, data);
         HeapFree(GetProcessHeap(), 0, valueW);
+        HeapFree(GetProcessHeap(), 0, full_name);
         RegCloseKey(hkey);
     }
 
From 06c3b24b2f99a26fa910d32cb1ace120f3bd0213 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 6 Sep 2020 12:23:10 +0200
Subject: [PATCH] gdi32: Get rid of the external fonts registry key.

Load the system fonts first, then additional fonts from the windows
registry keys. Any already loaded face will just be ignored.
---
 dlls/gdi32/freetype.c | 97 ++++---------------------------------------
 1 file changed, 9 insertions(+), 88 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 6becbebe46d..12c0d04bf2e 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -373,9 +373,6 @@ static const WCHAR * const SystemFontValues[] = {
     NULL
 };
 
-static const WCHAR external_fonts_reg_key[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e','\\',
-                                               'F','o','n','t','s','\\','E','x','t','e','r','n','a','l',' ','F','o','n','t','s','\0'};
-
 /* Interesting and well-known (frequently-assumed!) font names */
 static const WCHAR Lucida_Sans_Unicode[] = {'L','u','c','i','d','a',' ','S','a','n','s',' ','U','n','i','c','o','d','e',0};
 static const WCHAR Microsoft_Sans_Serif[] = {'M','i','c','r','o','s','o','f','t',' ','S','a','n','s',' ','S','e','r','i','f',0 };
@@ -3219,7 +3216,7 @@ static WCHAR *get_full_path_name(const WCHAR *name)
  */
 static void update_reg_entries(void)
 {
-    HKEY winnt_key = 0, win9x_key = 0, external_key = 0;
+    HKEY winnt_key = 0, win9x_key = 0;
     LPWSTR valueW;
     DWORD len;
     Family *family;
@@ -3239,12 +3236,6 @@ static void update_reg_entries(void)
         goto end;
     }
 
-    if(RegCreateKeyExW(HKEY_CURRENT_USER, external_fonts_reg_key,
-                       0, NULL, 0, KEY_ALL_ACCESS, NULL, &external_key, NULL) != ERROR_SUCCESS) {
-        ERR("Can't create external font reg key\n");
-        goto end;
-    }
-
     /* enumerate the fonts and add external ones to the two keys */
 
     WINE_RB_FOR_EACH_ENTRY( family, &family_tree, Family, entry )
@@ -3278,79 +3269,11 @@ static void update_reg_entries(void)
             len = strlenW(file) + 1;
             RegSetValueExW(winnt_key, valueW, 0, REG_SZ, (BYTE*)file, len * sizeof(WCHAR));
             RegSetValueExW(win9x_key, valueW, 0, REG_SZ, (BYTE*)file, len * sizeof(WCHAR));
-            RegSetValueExW(external_key, valueW, 0, REG_SZ, (BYTE*)file, len * sizeof(WCHAR));
 
             HeapFree(GetProcessHeap(), 0, path);
             HeapFree(GetProcessHeap(), 0, valueW);
         }
     }
- end:
-    if(external_key) RegCloseKey(external_key);
-    if(win9x_key) RegCloseKey(win9x_key);
-    if(winnt_key) RegCloseKey(winnt_key);
-}
-
-static void delete_external_font_keys(void)
-{
-    HKEY winnt_key = 0, win9x_key = 0, external_key = 0;
-    DWORD dlen, plen, vlen, datalen, valuelen, i, type, path_type;
-    LPWSTR valueW;
-    LPVOID data;
-    BYTE *path;
-
-    if(RegCreateKeyExW(HKEY_LOCAL_MACHINE, winnt_font_reg_key,
-                       0, NULL, 0, KEY_ALL_ACCESS, NULL, &winnt_key, NULL) != ERROR_SUCCESS) {
-        ERR("Can't create Windows font reg key\n");
-        goto end;
-    }
-
-    if(RegCreateKeyExW(HKEY_LOCAL_MACHINE, win9x_font_reg_key,
-                       0, NULL, 0, KEY_ALL_ACCESS, NULL, &win9x_key, NULL) != ERROR_SUCCESS) {
-        ERR("Can't create Windows font reg key\n");
-        goto end;
-    }
-
-    if(RegCreateKeyW(HKEY_CURRENT_USER, external_fonts_reg_key, &external_key) != ERROR_SUCCESS) {
-        ERR("Can't create external font reg key\n");
-        goto end;
-    }
-
-    /* Delete all external fonts added last time */
-
-    RegQueryInfoKeyW(external_key, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
-                     &valuelen, &datalen, NULL, NULL);
-    valuelen++; /* returned value doesn't include room for '\0' */
-    valueW = HeapAlloc(GetProcessHeap(), 0, valuelen * sizeof(WCHAR));
-    data = HeapAlloc(GetProcessHeap(), 0, datalen);
-    path = HeapAlloc(GetProcessHeap(), 0, datalen);
-
-    dlen = datalen;
-    vlen = valuelen;
-    i = 0;
-    while(RegEnumValueW(external_key, i++, valueW, &vlen, NULL, &type, data,
-                        &dlen) == ERROR_SUCCESS) {
-        plen = dlen;
-        if (RegQueryValueExW(winnt_key, valueW, 0, &path_type, path, &plen) == ERROR_SUCCESS &&
-            type == path_type && dlen == plen && !memcmp(data, path, plen))
-            RegDeleteValueW(winnt_key, valueW);
-
-        plen = dlen;
-        if (RegQueryValueExW(win9x_key, valueW, 0, &path_type, path, &plen) == ERROR_SUCCESS &&
-            type == path_type && dlen == plen && !memcmp(data, path, plen))
-            RegDeleteValueW(win9x_key, valueW);
-
-        /* reset dlen and vlen */
-        dlen = datalen;
-        vlen = valuelen;
-    }
-    HeapFree(GetProcessHeap(), 0, path);
-    HeapFree(GetProcessHeap(), 0, data);
-    HeapFree(GetProcessHeap(), 0, valueW);
-
-    /* Delete the old external fonts key */
-    RegCloseKey(external_key);
-    RegDeleteKeyW(HKEY_CURRENT_USER, external_fonts_reg_key);
-
  end:
     if(win9x_key) RegCloseKey(win9x_key);
     if(winnt_key) RegCloseKey(winnt_key);
@@ -3831,8 +3754,6 @@ static void init_font_list(void)
     WCHAR path[MAX_PATH];
     char *unixname;
 
-    delete_external_font_keys();
-
     /* load the system bitmap fonts */
     load_system_fonts();
 
@@ -3845,6 +3766,14 @@ static void init_font_list(void)
     get_font_dir( path );
     read_font_dir( path, TRUE );
 
+#ifdef SONAME_LIBFONTCONFIG
+    load_fontconfig_fonts();
+#elif defined(HAVE_CARBON_CARBON_H)
+    load_mac_fonts();
+#elif defined(__ANDROID__)
+    ReadFontDir("/system/fonts", TRUE);
+#endif
+
     /* now look under HKLM\Software\Microsoft\Windows[ NT]\CurrentVersion\Fonts
        for any fonts not installed in %WINDOWSDIR%\Fonts.  They will have their
        full path as the entry.  Also look for any .fon fonts, since ReadFontDir
@@ -3900,14 +3829,6 @@ static void init_font_list(void)
         RegCloseKey(hkey);
     }
 
-#ifdef SONAME_LIBFONTCONFIG
-    load_fontconfig_fonts();
-#elif defined(HAVE_CARBON_CARBON_H)
-    load_mac_fonts();
-#elif defined(__ANDROID__)
-    ReadFontDir("/system/fonts", TRUE);
-#endif
-
     /* then look in any directories that we've specified in the config file */
     /* @@ Wine registry key: HKCU\Software\Wine\Fonts */
     if(RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Fonts", &hkey) == ERROR_SUCCESS)
From f4bc7143868ca6ee56e2dc440599cf0f93b00352 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 17 Sep 2020 10:29:15 +0200
Subject: [PATCH] gdi32: Only use the registry cache for application fonts.

---
 dlls/gdi32/freetype.c | 22 ++++++++++------------
 1 file changed, 10 insertions(+), 12 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 12c0d04bf2e..2ab86f5e23d 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -2848,7 +2848,7 @@ static BOOL ReadFontDir(const char *dirname, BOOL external_fonts)
 	    ReadFontDir(path, external_fonts);
 	else
         {
-            DWORD addfont_flags = ADDFONT_ADD_TO_CACHE;
+            DWORD addfont_flags = 0;
             if(external_fonts) addfont_flags |= ADDFONT_EXTERNAL_FONT;
             AddFontToList(NULL, path, NULL, 0, addfont_flags);
         }
@@ -2986,7 +2986,7 @@ static void load_fontconfig_fonts(void)
         ext = &file[ len - 3 ];
         if(_strnicmp(ext, "pfa", -1) && _strnicmp(ext, "pfb", -1))
             AddFontToList(NULL, file, NULL, 0,
-                          ADDFONT_EXTERNAL_FONT | ADDFONT_ADD_TO_CACHE | ADDFONT_AA_FLAGS(aa_flags) );
+                          ADDFONT_EXTERNAL_FONT | ADDFONT_AA_FLAGS(aa_flags) );
     }
     pFcFontSetDestroy(fontset);
     pFcPatternDestroy(pat);
@@ -3005,7 +3005,7 @@ static void load_mac_font_callback(const void *value, void *context)
     if (path && CFStringGetFileSystemRepresentation(pathStr, path, len))
     {
         TRACE("font file %s\n", path);
-        AddFontToList(NULL, path, NULL, 0, ADDFONT_EXTERNAL_FONT | ADDFONT_ADD_TO_CACHE);
+        AddFontToList(NULL, path, NULL, 0, ADDFONT_EXTERNAL_FONT);
     }
     HeapFree(GetProcessHeap(), 0, path);
 }
@@ -3169,10 +3169,10 @@ static void load_system_fonts(void)
             if(RegQueryValueExW(hkey, *value, 0, &type, (void*)data, &dlen) == ERROR_SUCCESS &&
                type == REG_SZ) {
                 get_winfonts_dir_path( data, pathW );
-                if (!add_font_resource( pathW, ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_TO_CACHE ))
+                if (!add_font_resource( pathW, ADDFONT_ALLOW_BITMAP ))
                 {
                     get_data_dir_path( data, pathW );
-                    add_font_resource( pathW, ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_TO_CACHE );
+                    add_font_resource( pathW, ADDFONT_ALLOW_BITMAP );
                 }
             }
         }
@@ -3805,17 +3805,17 @@ static void init_font_list(void)
                     WARN("Unable to get face path %s\n", debugstr_w(valueW));
                 else if(data[0] && (data[1] == ':'))
                 {
-                    add_font_resource( data, ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_TO_CACHE);
+                    add_font_resource( data, ADDFONT_ALLOW_BITMAP);
                 }
                 else if(dlen / 2 >= 6 && !strcmpiW(data + dlen / 2 - 5, dot_fonW))
                 {
                     WCHAR pathW[MAX_PATH];
 
                     get_winfonts_dir_path( data, pathW );
-                    if (!add_font_resource( pathW, ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_TO_CACHE ))
+                    if (!add_font_resource( pathW, ADDFONT_ALLOW_BITMAP ))
                     {
                         get_data_dir_path( data, pathW );
-                        add_font_resource( pathW, ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_TO_CACHE );
+                        add_font_resource( pathW, ADDFONT_ALLOW_BITMAP );
                     }
                 }
                 /* reset dlen and vlen */
@@ -3940,10 +3940,8 @@ BOOL WineEngInit( const struct font_backend_funcs **funcs )
 
     create_font_cache_key(&hkey_font_cache, &disposition);
 
-    if(disposition == REG_CREATED_NEW_KEY)
-        init_font_list();
-    else
-        load_font_list_from_cache(hkey_font_cache);
+    init_font_list();
+    load_font_list_from_cache(hkey_font_cache);
 
     reorder_font_list();
 
From f18a5d5007c360b8869678711966bcb8f3f6923a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 25 Aug 2020 17:49:50 +0200
Subject: [PATCH] gdi32: Load font list directly from fontconfig cache.

---
 dlls/gdi32/freetype.c | 170 ++++++++++++++++++++++++++++++++----------
 1 file changed, 130 insertions(+), 40 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 2ab86f5e23d..68f9d0829cd 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -185,6 +185,20 @@ MAKE_FUNCPTR(FcPatternDestroy);
 MAKE_FUNCPTR(FcPatternGetBool);
 MAKE_FUNCPTR(FcPatternGetInteger);
 MAKE_FUNCPTR(FcPatternGetString);
+MAKE_FUNCPTR(FcConfigGetFontDirs);
+MAKE_FUNCPTR(FcConfigGetCurrent);
+MAKE_FUNCPTR(FcCacheCopySet);
+MAKE_FUNCPTR(FcCacheNumSubdir);
+MAKE_FUNCPTR(FcCacheSubdir);
+MAKE_FUNCPTR(FcDirCacheRead);
+MAKE_FUNCPTR(FcDirCacheUnload);
+MAKE_FUNCPTR(FcStrListCreate);
+MAKE_FUNCPTR(FcStrListDone);
+MAKE_FUNCPTR(FcStrListNext);
+MAKE_FUNCPTR(FcStrSetAdd);
+MAKE_FUNCPTR(FcStrSetCreate);
+MAKE_FUNCPTR(FcStrSetDestroy);
+MAKE_FUNCPTR(FcStrSetMember);
 #ifndef FC_NAMELANG
 #define FC_NAMELANG "namelang"
 #endif
@@ -2894,6 +2908,56 @@ static UINT parse_aa_pattern( FcPattern *pattern )
     return aa_flags;
 }
 
+static void fontconfig_add_font( FcPattern *pattern, DWORD flags )
+{
+    struct unix_face *unix_face;
+    const char *unix_name;
+    WCHAR *dos_name;
+    FcBool scalable;
+    DWORD aa_flags;
+    int face_index;
+
+    TRACE( "(%p %#x)\n", pattern, flags );
+
+    if (pFcPatternGetString( pattern, FC_FILE, 0, (FcChar8 **)&unix_name ) != FcResultMatch)
+    {
+        ERR( "%s:%d\n", __FILE__, __LINE__ );
+        return;
+    }
+
+    if (pFcPatternGetBool( pattern, FC_SCALABLE, 0, &scalable ) != FcResultMatch)
+        scalable = FALSE;
+
+    if (!scalable && !(flags & ADDFONT_ALLOW_BITMAP))
+    {
+        TRACE( "ignoring non-scalable font %s\n", debugstr_a(unix_name) );
+        return;
+    }
+
+    if (!(aa_flags = parse_aa_pattern( pattern ))) aa_flags = default_aa_flags;
+    flags |= ADDFONT_AA_FLAGS(aa_flags);
+
+    if (pFcPatternGetInteger( pattern, FC_INDEX, 0, &face_index ) != FcResultMatch)
+        face_index = 0;
+
+    if (!(unix_face = unix_face_create( unix_name, NULL, 0, face_index, flags )))
+        return;
+
+    if (unix_face->family_name[0] == '.') /* Ignore fonts with names beginning with a dot */
+        TRACE("Ignoring %s since its family name begins with a dot\n", debugstr_a(unix_name));
+    else
+    {
+        dos_name = wine_get_dos_file_name( unix_name );
+        AddFaceToList(unix_face, dos_name, NULL, 0, face_index, flags);
+        if (unix_face->fs.fsCsb[0] & FS_DBCS_MASK)
+            AddFaceToList(unix_face, dos_name, NULL, 0, face_index,
+                          flags | ADDFONT_VERTICAL_FONT);
+        HeapFree( GetProcessHeap(), 0, dos_name );
+    }
+
+    unix_face_destroy(unix_face);
+}
+
 static void init_fontconfig(void)
 {
     void *fc_handle = dlopen(SONAME_LIBFONTCONFIG, RTLD_NOW);
@@ -2917,6 +2981,20 @@ static void init_fontconfig(void)
     LOAD_FUNCPTR(FcPatternGetBool);
     LOAD_FUNCPTR(FcPatternGetInteger);
     LOAD_FUNCPTR(FcPatternGetString);
+    LOAD_FUNCPTR(FcConfigGetFontDirs);
+    LOAD_FUNCPTR(FcConfigGetCurrent);
+    LOAD_FUNCPTR(FcCacheCopySet);
+    LOAD_FUNCPTR(FcCacheNumSubdir);
+    LOAD_FUNCPTR(FcCacheSubdir);
+    LOAD_FUNCPTR(FcDirCacheRead);
+    LOAD_FUNCPTR(FcDirCacheUnload);
+    LOAD_FUNCPTR(FcStrListCreate);
+    LOAD_FUNCPTR(FcStrListDone);
+    LOAD_FUNCPTR(FcStrListNext);
+    LOAD_FUNCPTR(FcStrSetAdd);
+    LOAD_FUNCPTR(FcStrSetCreate);
+    LOAD_FUNCPTR(FcStrSetDestroy);
+    LOAD_FUNCPTR(FcStrSetMember);
 #undef LOAD_FUNCPTR
 
     if (pFcInit())
@@ -2939,57 +3017,69 @@ static void init_fontconfig(void)
     }
 }
 
-static void load_fontconfig_fonts(void)
+static void fontconfig_add_fonts_from_dir_list( FcConfig *config, FcStrList *dir_list, FcStrSet *done_set, DWORD flags )
 {
-    FcPattern *pat;
-    FcFontSet *fontset;
-    int i, len;
-    char *file;
-    const char *ext;
-
-    if (!fontconfig_enabled) return;
+    const FcChar8 *dir;
+    FcFontSet *font_set;
+    FcStrList *subdir_list = NULL;
+    FcStrSet *subdir_set = NULL;
+    FcCache *cache = NULL;
+    int i;
 
-    pat = pFcPatternCreate();
-    if (!pat) return;
+    TRACE( "(%p %p %p %#x)\n", config, dir_list, done_set, flags );
 
-    fontset = pFcFontList(NULL, pat, NULL);
-    if (!fontset)
+    while ((dir = pFcStrListNext( dir_list )))
     {
-        pFcPatternDestroy(pat);
-        return;
-    }
+        if (pFcStrSetMember( done_set, dir )) continue;
 
-    for(i = 0; i < fontset->nfont; i++) {
-        FcBool scalable;
-        DWORD aa_flags;
+        TRACE( "adding fonts from %s\n", dir );
+        if (!(cache = pFcDirCacheRead( dir, FcFalse, config ))) continue;
 
-        if(pFcPatternGetString(fontset->fonts[i], FC_FILE, 0, (FcChar8**)&file) != FcResultMatch)
-            continue;
+        if (!(font_set = pFcCacheCopySet( cache ))) goto done;
+        for (i = 0; i < font_set->nfont; i++)
+            fontconfig_add_font( font_set->fonts[i], flags );
+        pFcFontSetDestroy( font_set );
+        font_set = NULL;
 
-        pFcConfigSubstitute( NULL, fontset->fonts[i], FcMatchFont );
+        if (!(subdir_set = pFcStrSetCreate())) goto done;
+        for (i = 0; i < pFcCacheNumSubdir( cache ); i++)
+            pFcStrSetAdd( subdir_set, pFcCacheSubdir( cache, i ) );
+        pFcDirCacheUnload( cache );
+        cache = NULL;
 
-        /* We're just interested in OT/TT fonts for now, so this hack just
-           picks up the scalable fonts without extensions .pf[ab] to save time
-           loading every other font */
+        if (!(subdir_list = pFcStrListCreate( subdir_set ))) goto done;
+        pFcStrSetDestroy( subdir_set );
+        subdir_set = NULL;
 
-        if(pFcPatternGetBool(fontset->fonts[i], FC_SCALABLE, 0, &scalable) == FcResultMatch && !scalable)
-        {
-            TRACE("not scalable\n");
-            continue;
-        }
+        pFcStrSetAdd( done_set, dir );
+        fontconfig_add_fonts_from_dir_list( config, subdir_list, done_set, flags );
+        pFcStrListDone( subdir_list );
+        subdir_list = NULL;
+    }
 
-        aa_flags = parse_aa_pattern( fontset->fonts[i] );
-        TRACE("fontconfig: %s aa %x\n", file, aa_flags);
+done:
+    if (font_set) pFcFontSetDestroy( font_set );
+    if (subdir_list) pFcStrListDone( subdir_list );
+    if (subdir_set) pFcStrSetDestroy( subdir_set );
+    if (cache) pFcDirCacheUnload( cache );
+}
 
-        len = strlen( file );
-        if(len < 4) continue;
-        ext = &file[ len - 3 ];
-        if(_strnicmp(ext, "pfa", -1) && _strnicmp(ext, "pfb", -1))
-            AddFontToList(NULL, file, NULL, 0,
-                          ADDFONT_EXTERNAL_FONT | ADDFONT_AA_FLAGS(aa_flags) );
-    }
-    pFcFontSetDestroy(fontset);
-    pFcPatternDestroy(pat);
+static void load_fontconfig_fonts( void )
+{
+    FcStrList *dir_list = NULL;
+    FcStrSet *done_set = NULL;
+    FcConfig *config;
+
+    if (!fontconfig_enabled) return;
+    if (!(config = pFcConfigGetCurrent())) goto done;
+    if (!(done_set = pFcStrSetCreate())) goto done;
+    if (!(dir_list = pFcConfigGetFontDirs( config ))) goto done;
+
+    fontconfig_add_fonts_from_dir_list( config, dir_list, done_set, ADDFONT_EXTERNAL_FONT );
+
+done:
+    if (dir_list) pFcStrListDone( dir_list );
+    if (done_set) pFcStrSetDestroy( done_set );
 }
 
 #elif defined(HAVE_CARBON_CARBON_H)
From f18a5d5007c360b8869678711966bcb8f3f6923a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 25 Aug 2020 17:49:50 +0200
Subject: [PATCH] gdi32: Load font list directly from fontconfig cache.

---
 dlls/gdi32/freetype.c | 170 ++++++++++++++++++++++++++++++++----------
 1 file changed, 130 insertions(+), 40 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 2ab86f5e23d..68f9d0829cd 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -185,6 +185,20 @@ MAKE_FUNCPTR(FcPatternDestroy);
 MAKE_FUNCPTR(FcPatternGetBool);
 MAKE_FUNCPTR(FcPatternGetInteger);
 MAKE_FUNCPTR(FcPatternGetString);
+MAKE_FUNCPTR(FcConfigGetFontDirs);
+MAKE_FUNCPTR(FcConfigGetCurrent);
+MAKE_FUNCPTR(FcCacheCopySet);
+MAKE_FUNCPTR(FcCacheNumSubdir);
+MAKE_FUNCPTR(FcCacheSubdir);
+MAKE_FUNCPTR(FcDirCacheRead);
+MAKE_FUNCPTR(FcDirCacheUnload);
+MAKE_FUNCPTR(FcStrListCreate);
+MAKE_FUNCPTR(FcStrListDone);
+MAKE_FUNCPTR(FcStrListNext);
+MAKE_FUNCPTR(FcStrSetAdd);
+MAKE_FUNCPTR(FcStrSetCreate);
+MAKE_FUNCPTR(FcStrSetDestroy);
+MAKE_FUNCPTR(FcStrSetMember);
 #ifndef FC_NAMELANG
 #define FC_NAMELANG "namelang"
 #endif
@@ -2894,6 +2908,56 @@ static UINT parse_aa_pattern( FcPattern *pattern )
     return aa_flags;
 }
 
+static void fontconfig_add_font( FcPattern *pattern, DWORD flags )
+{
+    struct unix_face *unix_face;
+    const char *unix_name;
+    WCHAR *dos_name;
+    FcBool scalable;
+    DWORD aa_flags;
+    int face_index;
+
+    TRACE( "(%p %#x)\n", pattern, flags );
+
+    if (pFcPatternGetString( pattern, FC_FILE, 0, (FcChar8 **)&unix_name ) != FcResultMatch)
+    {
+        ERR( "%s:%d\n", __FILE__, __LINE__ );
+        return;
+    }
+
+    if (pFcPatternGetBool( pattern, FC_SCALABLE, 0, &scalable ) != FcResultMatch)
+        scalable = FALSE;
+
+    if (!scalable && !(flags & ADDFONT_ALLOW_BITMAP))
+    {
+        TRACE( "ignoring non-scalable font %s\n", debugstr_a(unix_name) );
+        return;
+    }
+
+    if (!(aa_flags = parse_aa_pattern( pattern ))) aa_flags = default_aa_flags;
+    flags |= ADDFONT_AA_FLAGS(aa_flags);
+
+    if (pFcPatternGetInteger( pattern, FC_INDEX, 0, &face_index ) != FcResultMatch)
+        face_index = 0;
+
+    if (!(unix_face = unix_face_create( unix_name, NULL, 0, face_index, flags )))
+        return;
+
+    if (unix_face->family_name[0] == '.') /* Ignore fonts with names beginning with a dot */
+        TRACE("Ignoring %s since its family name begins with a dot\n", debugstr_a(unix_name));
+    else
+    {
+        dos_name = wine_get_dos_file_name( unix_name );
+        AddFaceToList(unix_face, dos_name, NULL, 0, face_index, flags);
+        if (unix_face->fs.fsCsb[0] & FS_DBCS_MASK)
+            AddFaceToList(unix_face, dos_name, NULL, 0, face_index,
+                          flags | ADDFONT_VERTICAL_FONT);
+        HeapFree( GetProcessHeap(), 0, dos_name );
+    }
+
+    unix_face_destroy(unix_face);
+}
+
 static void init_fontconfig(void)
 {
     void *fc_handle = dlopen(SONAME_LIBFONTCONFIG, RTLD_NOW);
@@ -2917,6 +2981,20 @@ static void init_fontconfig(void)
     LOAD_FUNCPTR(FcPatternGetBool);
     LOAD_FUNCPTR(FcPatternGetInteger);
     LOAD_FUNCPTR(FcPatternGetString);
+    LOAD_FUNCPTR(FcConfigGetFontDirs);
+    LOAD_FUNCPTR(FcConfigGetCurrent);
+    LOAD_FUNCPTR(FcCacheCopySet);
+    LOAD_FUNCPTR(FcCacheNumSubdir);
+    LOAD_FUNCPTR(FcCacheSubdir);
+    LOAD_FUNCPTR(FcDirCacheRead);
+    LOAD_FUNCPTR(FcDirCacheUnload);
+    LOAD_FUNCPTR(FcStrListCreate);
+    LOAD_FUNCPTR(FcStrListDone);
+    LOAD_FUNCPTR(FcStrListNext);
+    LOAD_FUNCPTR(FcStrSetAdd);
+    LOAD_FUNCPTR(FcStrSetCreate);
+    LOAD_FUNCPTR(FcStrSetDestroy);
+    LOAD_FUNCPTR(FcStrSetMember);
 #undef LOAD_FUNCPTR
 
     if (pFcInit())
@@ -2939,57 +3017,69 @@ static void init_fontconfig(void)
     }
 }
 
-static void load_fontconfig_fonts(void)
+static void fontconfig_add_fonts_from_dir_list( FcConfig *config, FcStrList *dir_list, FcStrSet *done_set, DWORD flags )
 {
-    FcPattern *pat;
-    FcFontSet *fontset;
-    int i, len;
-    char *file;
-    const char *ext;
-
-    if (!fontconfig_enabled) return;
+    const FcChar8 *dir;
+    FcFontSet *font_set;
+    FcStrList *subdir_list = NULL;
+    FcStrSet *subdir_set = NULL;
+    FcCache *cache = NULL;
+    int i;
 
-    pat = pFcPatternCreate();
-    if (!pat) return;
+    TRACE( "(%p %p %p %#x)\n", config, dir_list, done_set, flags );
 
-    fontset = pFcFontList(NULL, pat, NULL);
-    if (!fontset)
+    while ((dir = pFcStrListNext( dir_list )))
     {
-        pFcPatternDestroy(pat);
-        return;
-    }
+        if (pFcStrSetMember( done_set, dir )) continue;
 
-    for(i = 0; i < fontset->nfont; i++) {
-        FcBool scalable;
-        DWORD aa_flags;
+        TRACE( "adding fonts from %s\n", dir );
+        if (!(cache = pFcDirCacheRead( dir, FcFalse, config ))) continue;
 
-        if(pFcPatternGetString(fontset->fonts[i], FC_FILE, 0, (FcChar8**)&file) != FcResultMatch)
-            continue;
+        if (!(font_set = pFcCacheCopySet( cache ))) goto done;
+        for (i = 0; i < font_set->nfont; i++)
+            fontconfig_add_font( font_set->fonts[i], flags );
+        pFcFontSetDestroy( font_set );
+        font_set = NULL;
 
-        pFcConfigSubstitute( NULL, fontset->fonts[i], FcMatchFont );
+        if (!(subdir_set = pFcStrSetCreate())) goto done;
+        for (i = 0; i < pFcCacheNumSubdir( cache ); i++)
+            pFcStrSetAdd( subdir_set, pFcCacheSubdir( cache, i ) );
+        pFcDirCacheUnload( cache );
+        cache = NULL;
 
-        /* We're just interested in OT/TT fonts for now, so this hack just
-           picks up the scalable fonts without extensions .pf[ab] to save time
-           loading every other font */
+        if (!(subdir_list = pFcStrListCreate( subdir_set ))) goto done;
+        pFcStrSetDestroy( subdir_set );
+        subdir_set = NULL;
 
-        if(pFcPatternGetBool(fontset->fonts[i], FC_SCALABLE, 0, &scalable) == FcResultMatch && !scalable)
-        {
-            TRACE("not scalable\n");
-            continue;
-        }
+        pFcStrSetAdd( done_set, dir );
+        fontconfig_add_fonts_from_dir_list( config, subdir_list, done_set, flags );
+        pFcStrListDone( subdir_list );
+        subdir_list = NULL;
+    }
 
-        aa_flags = parse_aa_pattern( fontset->fonts[i] );
-        TRACE("fontconfig: %s aa %x\n", file, aa_flags);
+done:
+    if (font_set) pFcFontSetDestroy( font_set );
+    if (subdir_list) pFcStrListDone( subdir_list );
+    if (subdir_set) pFcStrSetDestroy( subdir_set );
+    if (cache) pFcDirCacheUnload( cache );
+}
 
-        len = strlen( file );
-        if(len < 4) continue;
-        ext = &file[ len - 3 ];
-        if(_strnicmp(ext, "pfa", -1) && _strnicmp(ext, "pfb", -1))
-            AddFontToList(NULL, file, NULL, 0,
-                          ADDFONT_EXTERNAL_FONT | ADDFONT_AA_FLAGS(aa_flags) );
-    }
-    pFcFontSetDestroy(fontset);
-    pFcPatternDestroy(pat);
+static void load_fontconfig_fonts( void )
+{
+    FcStrList *dir_list = NULL;
+    FcStrSet *done_set = NULL;
+    FcConfig *config;
+
+    if (!fontconfig_enabled) return;
+    if (!(config = pFcConfigGetCurrent())) goto done;
+    if (!(done_set = pFcStrSetCreate())) goto done;
+    if (!(dir_list = pFcConfigGetFontDirs( config ))) goto done;
+
+    fontconfig_add_fonts_from_dir_list( config, dir_list, done_set, ADDFONT_EXTERNAL_FONT );
+
+done:
+    if (dir_list) pFcStrListDone( dir_list );
+    if (done_set) pFcStrSetDestroy( done_set );
 }
 
 #elif defined(HAVE_CARBON_CARBON_H)
From 2601364549c9e5cdc8848f10186719626620576a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 7 Sep 2020 00:56:32 +0200
Subject: [PATCH] gdi32: Lazily initialize the font list.

When not the first process to start. It has to initialize the registry
in order to be correct.
---
 dlls/gdi32/freetype.c | 68 ++++++++++++++++++++++++++++++++-----------
 1 file changed, 51 insertions(+), 17 deletions(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index f0f2dab4832..3e6cbf5614a 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -3378,6 +3378,9 @@ static void update_reg_entries(void)
     if(winnt_key) RegCloseKey(winnt_key);
 }
 
+static RTL_RUN_ONCE font_list_init_once = RTL_RUN_ONCE_INIT;
+static DWORD WINAPI font_list_init( RTL_RUN_ONCE *once, void *param, void **context );
+
 /*************************************************************
  * freetype_AddFontResourceEx
  *
@@ -3388,6 +3391,7 @@ static INT CDECL freetype_AddFontResourceEx(LPCWSTR file, DWORD flags, PVOID pdv
     INT ret = 0;
     DWORD addfont_flags = ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_RESOURCE;
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
     if (!(flags & FR_PRIVATE)) addfont_flags |= ADDFONT_ADD_TO_CACHE;
     if (GetFullPathNameW( file, MAX_PATH, path, NULL ))
         ret = add_font_resource( path, addfont_flags );
@@ -3414,6 +3418,8 @@ static HANDLE CDECL freetype_AddFontMemResourceEx(PVOID pbFont, DWORD cbFont, PV
 {
     PVOID pFontCopy = HeapAlloc(GetProcessHeap(), 0, cbFont);
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
+
     TRACE("Copying %d bytes of data from %p to %p\n", cbFont, pbFont, pFontCopy);
     memcpy(pFontCopy, pbFont, cbFont);
 
@@ -3441,6 +3447,7 @@ static BOOL CDECL freetype_RemoveFontResourceEx(LPCWSTR file, DWORD flags, PVOID
     INT ret = 0;
     DWORD addfont_flags = ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_RESOURCE;
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
     if(!(flags & FR_PRIVATE)) addfont_flags |= ADDFONT_ADD_TO_CACHE;
     if (GetFullPathNameW( file, MAX_PATH, path, NULL ))
         ret = remove_font_resource( path, addfont_flags );
@@ -3739,6 +3746,8 @@ static BOOL CDECL freetype_CreateScalableFontResource( DWORD hidden, LPCWSTR res
     struct fontdir fontdir;
     BOOL ret = FALSE;
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
+
     if (!filename || !get_fontdir( filename, &fontdir ))
         SetLastError( ERROR_INVALID_PARAMETER );
     else
@@ -3994,6 +4003,31 @@ static void reorder_font_list(void)
     select_default( default_sans_list, &default_sans );
 }
 
+static DWORD WINAPI font_list_init( RTL_RUN_ONCE *once, void *param, void **context )
+{
+    DWORD *disposition = param;
+    HANDLE font_mutex;
+
+    if ((font_mutex = CreateMutexW( NULL, FALSE, font_mutex_nameW )) == NULL) return FALSE;
+    WaitForSingleObject( font_mutex, INFINITE );
+
+    init_font_list();
+    load_font_list_from_cache( hkey_font_cache );
+    reorder_font_list();
+
+    if (TRACE_ON( font )) DumpFontList();
+    LoadSubstList();
+    if (TRACE_ON( font )) DumpSubstList();
+    LoadReplaceList();
+
+    if (disposition && *disposition == REG_CREATED_NEW_KEY) update_reg_entries();
+
+    init_system_links();
+    ReleaseMutex( font_mutex );
+
+    return TRUE;
+}
+
 /*************************************************************
  *    WineEngInit
  *
@@ -4036,25 +4070,11 @@ BOOL WineEngInit( const struct font_backend_funcs **funcs )
         return FALSE;
     }
     WaitForSingleObject(font_mutex, INFINITE);
-
     create_font_cache_key(&hkey_font_cache, &disposition);
+    if (disposition == REG_CREATED_NEW_KEY)
+        RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, &disposition, NULL );
+    ReleaseMutex( font_mutex );
 
-    init_font_list();
-    load_font_list_from_cache(hkey_font_cache);
-
-    reorder_font_list();
-
-    DumpFontList();
-    LoadSubstList();
-    DumpSubstList();
-    LoadReplaceList();
-
-    if(disposition == REG_CREATED_NEW_KEY)
-        update_reg_entries();
-
-    init_system_links();
-    
-    ReleaseMutex(font_mutex);
     return TRUE;
 }
 
@@ -4945,6 +4965,8 @@ static struct gdi_font * CDECL freetype_SelectFont( DC *dc, HFONT hfont, UINT *a
     FontSubst *psub = NULL;
     const SYSTEM_LINKS *font_link;
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
+
     GetObjectW( hfont, sizeof(lf), &lf );
     lf.lfWidth = abs(lf.lfWidth);
 
@@ -5674,6 +5696,8 @@ static BOOL CDECL freetype_EnumFonts( LPLOGFONTW plf, FONTENUMPROCW proc, LPARAM
     LOGFONTW lf;
     struct enum_charset_list enum_charsets;
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
+
     if (!plf)
     {
         lf.lfCharSet = DEFAULT_CHARSET;
@@ -5973,6 +5997,8 @@ static UINT CDECL freetype_get_default_glyph( struct gdi_font *gdi_font )
     FT_WinFNT_HeaderRec winfnt;
     TT_OS2 *pOS2;
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
+
     if ((pOS2 = pFT_Get_Sfnt_Table( font->ft_face, ft_sfnt_os2 )))
     {
         UINT glyph = pOS2->usDefaultChar;
@@ -7613,6 +7639,8 @@ static UINT CDECL freetype_GetOutlineTextMetrics( struct gdi_font *gdi_font, UIN
     GdiFont *font = get_font_ptr(gdi_font);
     UINT ret = 0;
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
+
     TRACE("font=%p\n", font);
 
     if (font->potm || get_outline_text_metrics( font ))
@@ -7728,6 +7756,8 @@ static BOOL CDECL freetype_GetCharWidthInfo( struct gdi_font *gdi_font, struct c
     GdiFont *font = get_font_ptr(gdi_font);
     TT_HoriHeader *pHori;
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
+
     TRACE("%p, %p\n", font, info);
 
     if (gdi_font->scalable &&
@@ -7818,6 +7848,8 @@ static DWORD CDECL freetype_GetFontUnicodeRanges( struct gdi_font *font, GLYPHSE
 {
     DWORD size, num_ranges;
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
+
     num_ranges = get_font_unicode_ranges(get_font_ptr(font)->ft_face, glyphset);
     size = sizeof(GLYPHSET) + sizeof(WCRANGE) * (num_ranges - 1);
     if (glyphset)
@@ -7945,6 +7977,8 @@ static DWORD CDECL freetype_GetKerningPairs( struct gdi_font *gdi_font, DWORD cP
     USHORT i, nTables;
     USHORT *glyph_to_char;
 
+    RtlRunOnceExecuteOnce( &font_list_init_once, font_list_init, NULL, NULL );
+
     if (font->total_kern_pairs != (DWORD)-1)
     {
         if (cPairs && kern_pair)
