From 5847629e68e10f20d0ed336b78531c95b7dbcd87 Mon Sep 17 00:00:00 2001
From: Aric Stewart <aric@codeweavers.com>
Date: Thu, 28 Dec 2017 12:43:32 -0600
Subject: [PATCH] dinput: Add SDL support

v2: Include comments from Andrew including opening and closing devices more cleanly
Signed-off-by: Aric Stewart <aric@codeweavers.com>
---
 dlls/dinput/Makefile.in      |   4 +-
 dlls/dinput/dinput_main.c    |  21 ++
 dlls/dinput/dinput_private.h |   1 +
 dlls/dinput/joystick_sdl.c   | 705 +++++++++++++++++++++++++++++++++++
 dlls/dinput8/Makefile.in     |   5 +-
 5 files changed, 734 insertions(+), 2 deletions(-)
 create mode 100644 dlls/dinput/joystick_sdl.c

diff --git a/dlls/dinput/Makefile.in b/dlls/dinput/Makefile.in
index ae65fd4d93e..ee3ddc016e8 100644
--- a/dlls/dinput/Makefile.in
+++ b/dlls/dinput/Makefile.in
@@ -2,7 +2,8 @@ MODULE    = dinput.dll
 IMPORTLIB = dinput
 IMPORTS   = dinput dxguid uuid comctl32 ole32 user32 advapi32
 EXTRADEFS = -DDIRECTINPUT_VERSION=0x0700
-EXTRALIBS = $(IOKIT_LIBS) $(FORCEFEEDBACK_LIBS)
+EXTRALIBS = $(IOKIT_LIBS) $(FORCEFEEDBACK_LIBS) $(SDL2_LIBS)
+EXTRAINCL = $(SDL2_CFLAGS)
 
 C_SRCS = \
 	config.c \
@@ -14,6 +15,7 @@ C_SRCS = \
 	joystick_linux.c \
 	joystick_linuxinput.c \
 	joystick_osx.c \
+	joystick_sdl.c \
 	keyboard.c \
 	mouse.c
 
diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
index 5e03964f901..e9008635064 100644
--- a/dlls/dinput/dinput_main.c
+++ b/dlls/dinput/dinput_main.c
@@ -90,6 +90,7 @@ static const struct dinput_device *dinput_devices[] =
 {
     &mouse_device,
     &keyboard_device,
+    &joystick_sdl_device,
     &joystick_linuxinput_device,
     &joystick_linux_device,
     &joystick_osx_device
@@ -484,6 +485,7 @@ static HRESULT WINAPI IDirectInputAImpl_EnumDevices(
     unsigned int i;
     int j;
     HRESULT r;
+    BOOL found_device = FALSE;
 
     TRACE("(this=%p,0x%04x '%s',%p,%p,0x%04x)\n",
 	  This, dwDevType, _dump_DIDEVTYPE_value(dwDevType, This->dwVersion),
@@ -506,9 +508,15 @@ static HRESULT WINAPI IDirectInputAImpl_EnumDevices(
             devInstance.dwSize = sizeof(devInstance);
             r = dinput_devices[i]->enum_deviceA(dwDevType, dwFlags, &devInstance, This->dwVersion, j);
             if (r == S_OK)
+            {
+                found_device = TRUE;
                 if (enum_callback_wrapper(lpCallback, &devInstance, pvRef) == DIENUM_STOP)
                     return S_OK;
+            }
         }
+        /* If we have found devices after SDL stop enumeration */
+        if (dinput_devices[i] == &joystick_sdl_device && found_device)
+            return S_OK;
     }
 
     return S_OK;
@@ -525,6 +533,7 @@ static HRESULT WINAPI IDirectInputWImpl_EnumDevices(
     unsigned int i;
     int j;
     HRESULT r;
+    BOOL found_device = FALSE;
 
     TRACE("(this=%p,0x%04x '%s',%p,%p,0x%04x)\n",
 	  This, dwDevType, _dump_DIDEVTYPE_value(dwDevType, This->dwVersion),
@@ -546,9 +555,15 @@ static HRESULT WINAPI IDirectInputWImpl_EnumDevices(
             TRACE("  - checking device %u ('%s')\n", i, dinput_devices[i]->name);
             r = dinput_devices[i]->enum_deviceW(dwDevType, dwFlags, &devInstance, This->dwVersion, j);
             if (r == S_OK)
+            {
+                found_device = TRUE;
                 if (enum_callback_wrapper(lpCallback, &devInstance, pvRef) == DIENUM_STOP)
                     return S_OK;
+            }
         }
+        /* If we have found devices after SDL stop enumeration */
+        if (dinput_devices[i] == &joystick_sdl_device && found_device)
+            return S_OK;
     }
 
     return S_OK;
@@ -1145,6 +1160,9 @@ static HRESULT WINAPI IDirectInput8AImpl_EnumDevicesBySemantics(
                 didevis[device_count-1] = didevi;
             }
         }
+        /* If we have found devices after SDL stop enumeration */
+        if (dinput_devices[i] == &joystick_sdl_device && device_count)
+            return S_OK;
     }
 
     remain = device_count;
@@ -1250,6 +1268,9 @@ static HRESULT WINAPI IDirectInput8WImpl_EnumDevicesBySemantics(
                 didevis[device_count-1] = didevi;
             }
         }
+        /* If we have found devices after SDL stop enumeration */
+        if (dinput_devices[i] == &joystick_sdl_device && device_count)
+            return S_OK;
     }
 
     remain = device_count;
diff --git a/dlls/dinput/dinput_private.h b/dlls/dinput/dinput_private.h
index c0c88da9674..53bd7e39562 100644
--- a/dlls/dinput/dinput_private.h
+++ b/dlls/dinput/dinput_private.h
@@ -68,6 +68,7 @@ extern const struct dinput_device keyboard_device DECLSPEC_HIDDEN;
 extern const struct dinput_device joystick_linux_device DECLSPEC_HIDDEN;
 extern const struct dinput_device joystick_linuxinput_device DECLSPEC_HIDDEN;
 extern const struct dinput_device joystick_osx_device DECLSPEC_HIDDEN;
+extern const struct dinput_device joystick_sdl_device DECLSPEC_HIDDEN;
 
 extern void dinput_hooks_acquire_device(LPDIRECTINPUTDEVICE8W iface);
 extern void dinput_hooks_unacquire_device(LPDIRECTINPUTDEVICE8W iface);
diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
new file mode 100644
index 00000000000..e07d7a9004a
--- /dev/null
+++ b/dlls/dinput/joystick_sdl.c
@@ -0,0 +1,705 @@
+/*  DirectInput Joystick device from SDL
+ *
+ * Copyright 1998,2000 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ * Copyright 2000-2001 TransGaming Technologies Inc.
+ * Copyright 2005 Daniel Remenak
+ * Copyright 2017 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_SDL2_SDL_H
+# include <SDL2/SDL.h>
+#endif
+#include <errno.h>
+
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "wine/list.h"
+#include "windef.h"
+#include "winbase.h"
+#include "winerror.h"
+#include "winreg.h"
+#include "dinput.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+#include "joystick_private.h"
+
+#ifdef HAVE_SDL2_SDL_H
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+typedef struct JoystickImpl JoystickImpl;
+static const IDirectInputDevice8AVtbl JoystickAvt;
+static const IDirectInputDevice8WVtbl JoystickWvt;
+
+struct SDLDev {
+    int id;
+    WORD vendor_id;
+    WORD product_id;
+    CHAR *name;
+
+    BOOL has_ff;
+};
+
+struct JoystickImpl
+{
+    struct JoystickGenericImpl generic;
+    struct SDLDev              *sdldev;
+
+    SDL_Joystick *device;
+};
+
+static inline JoystickImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8A_iface),
+           JoystickGenericImpl, base), JoystickImpl, generic);
+}
+static inline JoystickImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface),
+           JoystickGenericImpl, base), JoystickImpl, generic);
+}
+
+static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(JoystickImpl *This)
+{
+    return &This->generic.base.IDirectInputDevice8W_iface;
+}
+
+static const GUID DInput_Wine_SDL_Joystick_GUID = { /* 001E36B7-5DBA-4C4F-A8C9-CFC8689DB403 */
+  0x001E36B7, 0x5DBA, 0x4C4F, {0xA8, 0xC9, 0xCF, 0xC8, 0x68, 0x9D, 0xB4, 0x03}
+};
+
+static int have_sdldevs = -1;
+static struct SDLDev *sdldevs = NULL;
+
+static void find_sdldevs(void)
+{
+    int i;
+
+    if (InterlockedCompareExchange(&have_sdldevs, 0, -1) != -1)
+        /* Someone beat us to it */
+        return;
+
+    SDL_Init(SDL_INIT_JOYSTICK|SDL_INIT_HAPTIC);
+    SDL_JoystickEventState(SDL_ENABLE);
+
+    for (i = 0; i < SDL_NumJoysticks(); i++)
+    {
+        struct SDLDev sdldev = {0};
+        struct SDLDev *new_sdldevs;
+        SDL_Joystick *device;
+        const CHAR* name;
+
+        sdldev.id = i;
+        device = SDL_JoystickOpen(i);
+
+        name = SDL_JoystickName(device);
+        sdldev.name = HeapAlloc(GetProcessHeap(), 0, strlen(name) + 1);
+        strcpy(sdldev.name, name);
+
+        if (device_disabled_registry(sdldev.name)) {
+            SDL_JoystickClose(device);
+            continue;
+        }
+
+        TRACE("Found a joystick (%i) on %p: %s\n", have_sdldevs, device, sdldev.name);
+
+        sdldev.vendor_id = SDL_JoystickGetVendor(device);
+        sdldev.product_id = SDL_JoystickGetProduct(device);
+
+        if (!have_sdldevs)
+            new_sdldevs = HeapAlloc(GetProcessHeap(), 0, sizeof(struct SDLDev));
+        else
+            new_sdldevs = HeapReAlloc(GetProcessHeap(), 0, sdldevs, (1 + have_sdldevs) * sizeof(struct SDLDev));
+
+        SDL_JoystickClose(device);
+        if (!new_sdldevs)
+        {
+            continue;
+        }
+        sdldevs = new_sdldevs;
+        sdldevs[have_sdldevs] = sdldev;
+        have_sdldevs++;
+    }
+}
+
+static void fill_joystick_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+{
+    DWORD dwSize = lpddi->dwSize;
+
+    TRACE("%d %p\n", dwSize, lpddi);
+    memset(lpddi, 0, dwSize);
+
+    lpddi->dwSize       = dwSize;
+    lpddi->guidInstance = DInput_Wine_SDL_Joystick_GUID;
+    lpddi->guidInstance.Data3 = id;
+    lpddi->guidProduct = DInput_PIDVID_Product_GUID;
+    lpddi->guidProduct.Data1 = MAKELONG(sdldevs[id].vendor_id, sdldevs[id].product_id);
+    lpddi->guidFFDriver = GUID_NULL;
+
+    if (version >= 0x0800)
+        lpddi->dwDevType = DI8DEVTYPE_JOYSTICK | (DI8DEVTYPEJOYSTICK_STANDARD << 8);
+    else
+        lpddi->dwDevType = DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8);
+
+    /* Assume the joystick as HID if it is attached to USB bus and has a valid VID/PID */
+    if ( sdldevs[id].vendor_id && sdldevs[id].product_id)
+    {
+        lpddi->dwDevType |= DIDEVTYPE_HID;
+        lpddi->wUsagePage = 0x01; /* Desktop */
+        if (lpddi->dwDevType == DI8DEVTYPE_JOYSTICK || lpddi->dwDevType == DIDEVTYPE_JOYSTICK)
+            lpddi->wUsage = 0x04; /* Joystick */
+        else
+            lpddi->wUsage = 0x05; /* Game Pad */
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, sdldevs[id].name, -1, lpddi->tszInstanceName, MAX_PATH);
+    MultiByteToWideChar(CP_ACP, 0, sdldevs[id].name, -1, lpddi->tszProductName, MAX_PATH);
+}
+
+static void fill_joystick_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+{
+    DIDEVICEINSTANCEW lpddiW;
+    DWORD dwSize = lpddi->dwSize;
+
+    lpddiW.dwSize = sizeof(lpddiW);
+    fill_joystick_dideviceinstanceW(&lpddiW, version, id);
+
+    TRACE("%d %p\n", dwSize, lpddi);
+    memset(lpddi, 0, dwSize);
+
+    /* Convert W->A */
+    lpddi->dwSize = dwSize;
+    lpddi->guidInstance = lpddiW.guidInstance;
+    lpddi->guidProduct = lpddiW.guidProduct;
+    lpddi->dwDevType = lpddiW.dwDevType;
+    strcpy(lpddi->tszInstanceName, sdldevs[id].name);
+    strcpy(lpddi->tszProductName,  sdldevs[id].name);
+    lpddi->guidFFDriver = lpddiW.guidFFDriver;
+    lpddi->wUsagePage = lpddiW.wUsagePage;
+    lpddi->wUsage = lpddiW.wUsage;
+}
+
+static HRESULT sdl_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+{
+  find_sdldevs();
+
+  if (id >= have_sdldevs) {
+    return E_FAIL;
+  }
+
+  if (!((dwDevType == 0) ||
+        ((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+        (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
+    return S_FALSE;
+
+  if (!(dwFlags & DIEDFL_FORCEFEEDBACK) || sdldevs[id].has_ff) {
+    fill_joystick_dideviceinstanceA(lpddi, version, id);
+    return S_OK;
+  }
+  return S_FALSE;
+}
+
+static HRESULT sdl_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+{
+  find_sdldevs();
+
+  if (id >= have_sdldevs) {
+    return E_FAIL;
+  }
+
+  if (!((dwDevType == 0) ||
+        ((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+        (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
+    return S_FALSE;
+
+  if (!(dwFlags & DIEDFL_FORCEFEEDBACK) || sdldevs[id].has_ff) {
+    fill_joystick_dideviceinstanceW(lpddi, version, id);
+    return S_OK;
+  }
+  return S_FALSE;
+}
+
+static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    int i;
+    int inst_id = 0;
+    int newVal = 0;
+
+    SDL_JoystickUpdate();
+
+    for (i = 0; i < SDL_JoystickNumButtons(This->device); i++)
+    {
+        int val = SDL_JoystickGetButton(This->device, i);
+        int oldVal = This->generic.js.rgbButtons[i];
+        newVal = val ? 0x80 : 0x0;
+        This->generic.js.rgbButtons[i] = newVal;
+        if (oldVal != newVal)
+        {
+            TRACE("Button: %i val %d oldVal %d newVal %d\n",  i, val, oldVal, newVal);
+            inst_id = DIDFT_MAKEINSTANCE(i) | DIDFT_PSHBUTTON;
+            queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
+        }
+    }
+    for (i = 0; i < SDL_JoystickNumAxes(This->device); i++)
+    {
+        int oldVal;
+        newVal = SDL_JoystickGetAxis(This->device, i);
+        newVal = joystick_map_axis(&This->generic.props[i], newVal);
+        switch (i)
+        {
+            case 0: oldVal = This->generic.js.lX;
+                    This->generic.js.lX  = newVal; break;
+            case 1: oldVal = This->generic.js.lY;
+                    This->generic.js.lY  = newVal; break;
+            case 2: oldVal = This->generic.js.lZ;
+                    This->generic.js.lZ  = newVal; break;
+            case 3: oldVal = This->generic.js.lRx;
+                    This->generic.js.lRx = newVal; break;
+            case 4: oldVal = This->generic.js.lRy;
+                    This->generic.js.lRy = newVal; break;
+            case 5: oldVal = This->generic.js.lRz;
+                    This->generic.js.lRz = newVal; break;
+            case 6: oldVal = This->generic.js.rglSlider[0];
+                    This->generic.js.rglSlider[0] = newVal; break;
+            case 7: oldVal = This->generic.js.rglSlider[1];
+                    This->generic.js.rglSlider[1] = newVal; break;
+        }
+        if (oldVal != newVal)
+        {
+            TRACE("Axis: %i oldVal %d newVal %d\n",  i, oldVal, newVal);
+            inst_id = DIDFT_MAKEINSTANCE(i) | DIDFT_ABSAXIS;
+            queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
+        }
+    }
+    for (i = 0; i < SDL_JoystickNumHats(This->device); i++)
+    {
+        int oldVal = This->generic.js.rgdwPOV[i];
+        newVal = SDL_JoystickGetHat(This->device, i);
+        switch (newVal)
+        {
+            case SDL_HAT_CENTERED: newVal = -1; break;
+            case SDL_HAT_UP: newVal = 0; break;
+            case SDL_HAT_RIGHTUP:newVal = 4500; break;
+            case SDL_HAT_RIGHT: newVal = 9000; break;
+            case SDL_HAT_RIGHTDOWN: newVal = 13500; break;
+            case SDL_HAT_DOWN: newVal = 18000; break;
+            case SDL_HAT_LEFTDOWN: newVal = 22500; break;
+            case SDL_HAT_LEFT: newVal = 27000; break;
+            case SDL_HAT_LEFTUP: newVal = 31500; break;
+        }
+        if (oldVal != newVal)
+        {
+            TRACE("Hat : %i oldVal %d newVal %d\n",  i, oldVal, newVal);
+            This->generic.js.rgdwPOV[i] = newVal;
+            inst_id = DIDFT_MAKEINSTANCE(i) | DIDFT_POV;
+            queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
+        }
+    }
+}
+
+static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsigned short index)
+{
+    JoystickImpl* newDevice;
+    LPDIDATAFORMAT df = NULL;
+    DIDEVICEINSTANCEW ddi;
+    int i,idx = 0;
+
+    newDevice = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(JoystickImpl));
+    if (!newDevice) return NULL;
+
+    newDevice->generic.guidInstance = DInput_Wine_SDL_Joystick_GUID;
+    newDevice->generic.guidInstance.Data3 = index;
+    newDevice->generic.guidProduct = DInput_PIDVID_Product_GUID;
+    newDevice->generic.guidProduct.Data1 = MAKELONG(sdldevs[index].vendor_id, sdldevs[index].product_id);
+    newDevice->generic.joy_polldev = poll_sdl_device_state;
+
+    newDevice->generic.base.IDirectInputDevice8A_iface.lpVtbl = &JoystickAvt;
+    newDevice->generic.base.IDirectInputDevice8W_iface.lpVtbl = &JoystickWvt;
+    newDevice->generic.base.ref    = 1;
+    newDevice->generic.base.guid   = *rguid;
+    newDevice->generic.base.dinput = dinput;
+    newDevice->sdldev              = &sdldevs[index];
+    newDevice->generic.name        = (char*)newDevice->sdldev->name;
+
+    InitializeCriticalSection(&newDevice->generic.base.crit);
+    newDevice->generic.base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": JoystickImpl*->base.crit");
+
+    /* Open Device */
+    newDevice->device = SDL_JoystickOpen(newDevice->sdldev->id);
+
+    /* Count number of available axes - supported Axis & POVs */
+    newDevice->generic.devcaps.dwAxes = SDL_JoystickNumAxes(newDevice->device);
+
+    if (newDevice->generic.devcaps.dwAxes > 8 )
+    {
+        WARN("Can't support %d axis. Clamping down to 8\n", newDevice->generic.devcaps.dwAxes);
+        newDevice->generic.devcaps.dwAxes = 8;
+    }
+
+    for (i = 0; i < newDevice->generic.devcaps.dwAxes; i++)
+    {
+        newDevice->generic.props[i].lDevMin = -32768;
+        newDevice->generic.props[i].lDevMax = 32767;
+        newDevice->generic.props[i].lMin =  0;
+        newDevice->generic.props[i].lMax =  0xffff;
+        newDevice->generic.props[i].lDeadZone = 0;
+        newDevice->generic.props[i].lSaturation = 0;
+    }
+
+    newDevice->generic.devcaps.dwPOVs = SDL_JoystickNumHats(newDevice->device);
+    if (newDevice->generic.devcaps.dwPOVs > 4)
+    {
+        WARN("Can't support %d POV. Clamping down to 4\n", newDevice->generic.devcaps.dwPOVs);
+        newDevice->generic.devcaps.dwPOVs = 4;
+    }
+
+    newDevice->generic.devcaps.dwButtons = SDL_JoystickNumButtons(newDevice->device);
+    if (newDevice->generic.devcaps.dwButtons > 128)
+    {
+        WARN("Can't support %d buttons. Clamping down to 128\n", newDevice->generic.devcaps.dwButtons);
+        newDevice->generic.devcaps.dwButtons = 128;
+    }
+
+    TRACE("axes %u povs %u buttons %u\n", newDevice->generic.devcaps.dwAxes, newDevice->generic.devcaps.dwPOVs, newDevice->generic.devcaps.dwButtons);
+
+    /* Create copy of default data format */
+    if (!(df = HeapAlloc(GetProcessHeap(), 0, c_dfDIJoystick2.dwSize))) goto failed;
+    memcpy(df, &c_dfDIJoystick2, c_dfDIJoystick2.dwSize);
+
+    df->dwNumObjs = newDevice->generic.devcaps.dwAxes + newDevice->generic.devcaps.dwPOVs + newDevice->generic.devcaps.dwButtons;
+    if (!(df->rgodf = HeapAlloc(GetProcessHeap(), 0, df->dwNumObjs * df->dwObjSize))) goto failed;
+
+    for (i = 0; i < newDevice->generic.devcaps.dwAxes; i++)
+    {
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[idx], df->dwObjSize);
+        df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(idx) | DIDFT_ABSAXIS;
+        ++idx;
+    }
+
+    for (i = 0; i < newDevice->generic.devcaps.dwPOVs; i++)
+    {
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[i + 8], df->dwObjSize);
+        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_POV;
+    }
+
+    for (i = 0; i < newDevice->generic.devcaps.dwButtons; i++)
+    {
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[i + 12], df->dwObjSize);
+        df->rgodf[idx].pguid = &GUID_Button;
+        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_PSHBUTTON;
+    }
+    newDevice->generic.base.data_format.wine_df = df;
+
+    /* Fill the caps */
+    newDevice->generic.devcaps.dwSize = sizeof(newDevice->generic.devcaps);
+    newDevice->generic.devcaps.dwFlags = DIDC_ATTACHED;
+
+    ddi.dwSize = sizeof(ddi);
+    fill_joystick_dideviceinstanceW(&ddi, newDevice->generic.base.dinput->dwVersion, index);
+    newDevice->generic.devcaps.dwDevType = ddi.dwDevType;
+
+    if (newDevice->sdldev->has_ff)
+        newDevice->generic.devcaps.dwFlags |= DIDC_FORCEFEEDBACK;
+
+    IDirectInput_AddRef(&newDevice->generic.base.dinput->IDirectInput7A_iface);
+
+    return newDevice;
+
+failed:
+    if (df) HeapFree(GetProcessHeap(), 0, df->rgodf);
+    HeapFree(GetProcessHeap(), 0, df);
+    HeapFree(GetProcessHeap(), 0, newDevice);
+    return NULL;
+}
+
+/******************************************************************************
+  *     get_joystick_index : Get the joystick index from a given GUID
+  */
+static unsigned short get_joystick_index(REFGUID guid)
+{
+    GUID wine_joystick = DInput_Wine_SDL_Joystick_GUID;
+    GUID dev_guid = *guid;
+
+    wine_joystick.Data3 = 0;
+    dev_guid.Data3 = 0;
+
+    /* for the standard joystick GUID use index 0 */
+    if(IsEqualGUID(&GUID_Joystick,guid)) return 0;
+
+    /* for the wine joystick GUIDs use the index stored in Data3 */
+    if(IsEqualGUID(&wine_joystick, &dev_guid)) return guid->Data3;
+
+    return 0xffff;
+}
+
+static HRESULT sdl_create_device(IDirectInputImpl *dinput, REFGUID rguid, REFIID riid, LPVOID *pdev, int unicode)
+{
+    unsigned short index;
+
+    TRACE("%p %s %s %p %i\n", dinput, debugstr_guid(rguid), debugstr_guid(riid), pdev, unicode);
+
+    find_sdldevs();
+    *pdev = NULL;
+
+    if ((index = get_joystick_index(rguid)) < 0xffff &&
+        have_sdldevs && index < have_sdldevs)
+    {
+        JoystickImpl *This;
+
+        if (riid == NULL)
+            ;/* nothing */
+        else if (IsEqualGUID(&IID_IDirectInputDeviceA,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8A, riid))
+        {
+            unicode = 0;
+        }
+        else if (IsEqualGUID(&IID_IDirectInputDeviceW,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8W, riid))
+        {
+            unicode = 1;
+        }
+        else
+        {
+            WARN("no interface\n");
+            return DIERR_NOINTERFACE;
+        }
+
+        This = alloc_device(rguid, dinput, index);
+        TRACE("Created a Joystick device (%p)\n", This);
+
+        if (!This) return DIERR_OUTOFMEMORY;
+
+        if (unicode)
+            *pdev = &This->generic.base.IDirectInputDevice8W_iface;
+        else
+            *pdev = &This->generic.base.IDirectInputDevice8A_iface;
+
+        return DI_OK;
+    }
+
+    return DIERR_DEVICENOTREG;
+}
+
+const struct dinput_device joystick_sdl_device = {
+  "Wine SDL joystick driver",
+  sdl_enum_deviceA,
+  sdl_enum_deviceW,
+  sdl_create_device
+};
+
+static ULONG WINAPI JoystickWImpl_Release(LPDIRECTINPUTDEVICE8W iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    TRACE("(this=%p)\n", iface);
+    if (This->generic.base.ref == 1 && This->device >= 0)
+    {
+        TRACE("Closing Joystick: %p\n",This);
+        SDL_JoystickClose(This->device);
+        This->device = NULL;
+    }
+    return IDirectInputDevice2WImpl_Release(iface);
+}
+
+static ULONG WINAPI JoystickAImpl_Release(LPDIRECTINPUTDEVICE8A iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_Release(IDirectInputDevice8W_from_impl(This));
+}
+
+/******************************************************************************
+  *     GetProperty : get input device properties
+  */
+static HRESULT WINAPI JoystickWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(this=%p,%s,%p)\n", iface, debugstr_guid(rguid), pdiph);
+    _dump_DIPROPHEADER(pdiph);
+
+    if (!IS_DIPROP(rguid)) return DI_OK;
+
+    switch (LOWORD(rguid)) {
+
+        case (DWORD_PTR) DIPROP_VIDPID:
+        {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+            if (!This->sdldev->product_id || !This->sdldev->vendor_id)
+                return DIERR_UNSUPPORTED;
+            pd->dwData = MAKELONG(This->sdldev->vendor_id, This->sdldev->product_id);
+            TRACE("DIPROP_VIDPID(%08x)\n", pd->dwData);
+            break;
+        }
+        case (DWORD_PTR) DIPROP_JOYSTICKID:
+        {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+            pd->dwData = This->sdldev->id;
+            TRACE("DIPROP_JOYSTICKID(%d)\n", pd->dwData);
+            break;
+        }
+
+    default:
+        return JoystickWGenericImpl_GetProperty(iface, rguid, pdiph);
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_GetProperty(IDirectInputDevice8W_from_impl(This), rguid, pdiph);
+}
+
+/******************************************************************************
+  *     GetDeviceInfo : get information about a device's identity
+  */
+static HRESULT WINAPI JoystickAImpl_GetDeviceInfo(LPDIRECTINPUTDEVICE8A iface,
+                                                  LPDIDEVICEINSTANCEA pdidi)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("(%p) %p\n", This, pdidi);
+
+    if (pdidi == NULL) return E_POINTER;
+    if ((pdidi->dwSize != sizeof(DIDEVICEINSTANCE_DX3A)) &&
+        (pdidi->dwSize != sizeof(DIDEVICEINSTANCEA)))
+        return DIERR_INVALIDPARAM;
+
+    fill_joystick_dideviceinstanceA(pdidi, This->generic.base.dinput->dwVersion,
+                                    get_joystick_index(&This->generic.base.guid));
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickWImpl_GetDeviceInfo(LPDIRECTINPUTDEVICE8W iface,
+                                                  LPDIDEVICEINSTANCEW pdidi)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p) %p\n", This, pdidi);
+
+    if (pdidi == NULL) return E_POINTER;
+    if ((pdidi->dwSize != sizeof(DIDEVICEINSTANCE_DX3W)) &&
+        (pdidi->dwSize != sizeof(DIDEVICEINSTANCEW)))
+        return DIERR_INVALIDPARAM;
+
+    fill_joystick_dideviceinstanceW(pdidi, This->generic.base.dinput->dwVersion,
+                                    get_joystick_index(&This->generic.base.guid));
+    return DI_OK;
+}
+
+static const IDirectInputDevice8AVtbl JoystickAvt =
+{
+    IDirectInputDevice2AImpl_QueryInterface,
+    IDirectInputDevice2AImpl_AddRef,
+    JoystickAImpl_Release,
+    JoystickAGenericImpl_GetCapabilities,
+    IDirectInputDevice2AImpl_EnumObjects,
+    JoystickAImpl_GetProperty,
+    JoystickAGenericImpl_SetProperty,
+    IDirectInputDevice2AImpl_Acquire,
+    IDirectInputDevice2AImpl_Unacquire,
+    JoystickAGenericImpl_GetDeviceState,
+    IDirectInputDevice2AImpl_GetDeviceData,
+    IDirectInputDevice2AImpl_SetDataFormat,
+    IDirectInputDevice2AImpl_SetEventNotification,
+    IDirectInputDevice2AImpl_SetCooperativeLevel,
+    JoystickAGenericImpl_GetObjectInfo,
+    JoystickAImpl_GetDeviceInfo,
+    IDirectInputDevice2AImpl_RunControlPanel,
+    IDirectInputDevice2AImpl_Initialize,
+    IDirectInputDevice2AImpl_CreateEffect,
+    IDirectInputDevice2AImpl_EnumEffects,
+    IDirectInputDevice2AImpl_GetEffectInfo,
+    IDirectInputDevice2AImpl_GetForceFeedbackState,
+    IDirectInputDevice2AImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2AImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2AImpl_Escape,
+    JoystickAGenericImpl_Poll,
+    IDirectInputDevice2AImpl_SendDeviceData,
+    IDirectInputDevice7AImpl_EnumEffectsInFile,
+    IDirectInputDevice7AImpl_WriteEffectToFile,
+    JoystickAGenericImpl_BuildActionMap,
+    JoystickAGenericImpl_SetActionMap,
+    IDirectInputDevice8AImpl_GetImageInfo
+};
+
+static const IDirectInputDevice8WVtbl JoystickWvt =
+{
+    IDirectInputDevice2WImpl_QueryInterface,
+    IDirectInputDevice2WImpl_AddRef,
+    JoystickWImpl_Release,
+    JoystickWGenericImpl_GetCapabilities,
+    IDirectInputDevice2WImpl_EnumObjects,
+    JoystickWImpl_GetProperty,
+    JoystickWGenericImpl_SetProperty,
+    IDirectInputDevice2WImpl_Acquire,
+    IDirectInputDevice2WImpl_Unacquire,
+    JoystickWGenericImpl_GetDeviceState,
+    IDirectInputDevice2WImpl_GetDeviceData,
+    IDirectInputDevice2WImpl_SetDataFormat,
+    IDirectInputDevice2WImpl_SetEventNotification,
+    IDirectInputDevice2WImpl_SetCooperativeLevel,
+    JoystickWGenericImpl_GetObjectInfo,
+    JoystickWImpl_GetDeviceInfo,
+    IDirectInputDevice2WImpl_RunControlPanel,
+    IDirectInputDevice2WImpl_Initialize,
+    IDirectInputDevice2WImpl_CreateEffect,
+    IDirectInputDevice2WImpl_EnumEffects,
+    IDirectInputDevice2WImpl_GetEffectInfo,
+    IDirectInputDevice2WImpl_GetForceFeedbackState,
+    IDirectInputDevice2WImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2WImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2WImpl_Escape,
+    JoystickWGenericImpl_Poll,
+    IDirectInputDevice2WImpl_SendDeviceData,
+    IDirectInputDevice7WImpl_EnumEffectsInFile,
+    IDirectInputDevice7WImpl_WriteEffectToFile,
+    JoystickWGenericImpl_BuildActionMap,
+    JoystickWGenericImpl_SetActionMap,
+    IDirectInputDevice8WImpl_GetImageInfo
+};
+
+#else
+
+const struct dinput_device joystick_sdl_device = {
+  "Wine SDL joystick driver",
+  NULL,
+  NULL,
+  NULL
+};
+
+#endif
diff --git a/dlls/dinput8/Makefile.in b/dlls/dinput8/Makefile.in
index 5f0dce97caa..0e6ef316a79 100644
--- a/dlls/dinput8/Makefile.in
+++ b/dlls/dinput8/Makefile.in
@@ -2,7 +2,8 @@ MODULE    = dinput8.dll
 IMPORTLIB = dinput8
 IMPORTS   = dinput8 dxguid uuid comctl32 ole32 user32 advapi32
 EXTRADEFS = -DDIRECTINPUT_VERSION=0x0800
-EXTRALIBS = $(IOKIT_LIBS) $(FORCEFEEDBACK_LIBS)
+EXTRALIBS = $(IOKIT_LIBS) $(FORCEFEEDBACK_LIBS) $(SDL2_LIBS)
+EXTRAINCL = $(SDL2_CFLAGS)
 PARENTSRC = ../dinput
 
 C_SRCS = \
@@ -11,9 +12,11 @@ C_SRCS = \
 	device.c \
 	dinput_main.c \
 	effect_linuxinput.c \
+	effect_sdl.c \
 	joystick.c \
 	joystick_linux.c \
 	joystick_linuxinput.c \
+	joystick_sdl.c \
 	joystick_osx.c \
 	keyboard.c \
 	mouse.c
From 7721e28a1c9076c74bf12321d158bfd370c56b7e Mon Sep 17 00:00:00 2001
From: Aric Stewart <aric@codeweavers.com>
Date: Thu, 28 Dec 2017 13:44:29 -0600
Subject: [PATCH] dinput: Begin SDL haptic implemeting Get/SetProperty

Signed-off-by: Aric Stewart <aric@codeweavers.com>
---
 dlls/dinput/joystick_sdl.c | 106 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 104 insertions(+), 2 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index e07d7a9004a..2908daeeb77 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -65,6 +65,8 @@ struct SDLDev {
     CHAR *name;
 
     BOOL has_ff;
+    int autocenter;
+    int gain;
 };
 
 struct JoystickImpl
@@ -73,6 +75,7 @@ struct JoystickImpl
     struct SDLDev              *sdldev;
 
     SDL_Joystick *device;
+    SDL_Haptic *haptic;
 };
 
 static inline JoystickImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
@@ -130,6 +133,17 @@ static void find_sdldevs(void)
 
         TRACE("Found a joystick (%i) on %p: %s\n", have_sdldevs, device, sdldev.name);
 
+        if (SDL_JoystickIsHaptic(device))
+        {
+            SDL_Haptic *haptic = SDL_HapticOpenFromJoystick(device);
+            if (haptic)
+            {
+                TRACE(" ... with force feedback\n");
+                sdldev.has_ff = TRUE;
+                SDL_HapticClose(haptic);
+            }
+        }
+
         sdldev.vendor_id = SDL_JoystickGetVendor(device);
         sdldev.product_id = SDL_JoystickGetProduct(device);
 
@@ -354,6 +368,7 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
 
     /* Open Device */
     newDevice->device = SDL_JoystickOpen(newDevice->sdldev->id);
+    newDevice->haptic = SDL_HapticOpenFromJoystick(newDevice->device);
 
     /* Count number of available axes - supported Axis & POVs */
     newDevice->generic.devcaps.dwAxes = SDL_JoystickNumAxes(newDevice->device);
@@ -401,6 +416,8 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     {
         memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[idx], df->dwObjSize);
         df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(idx) | DIDFT_ABSAXIS;
+        if (newDevice->sdldev->has_ff && i < 2)
+             df->rgodf[idx].dwFlags |= DIDOI_FFACTUATOR;
         ++idx;
     }
 
@@ -416,6 +433,10 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
         df->rgodf[idx].pguid = &GUID_Button;
         df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_PSHBUTTON;
     }
+
+    if (newDevice->sdldev->has_ff)
+        newDevice->generic.devcaps.dwFlags |= DIDC_FORCEFEEDBACK;
+
     newDevice->generic.base.data_format.wine_df = df;
 
     /* Fill the caps */
@@ -526,6 +547,8 @@ static ULONG WINAPI JoystickWImpl_Release(LPDIRECTINPUTDEVICE8W iface)
     if (This->generic.base.ref == 1 && This->device >= 0)
     {
         TRACE("Closing Joystick: %p\n",This);
+        if (This->sdldev->has_ff)
+            SDL_HapticClose(This->haptic);
         SDL_JoystickClose(This->device);
         This->device = NULL;
     }
@@ -551,7 +574,22 @@ static HRESULT WINAPI JoystickWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REF
     if (!IS_DIPROP(rguid)) return DI_OK;
 
     switch (LOWORD(rguid)) {
+        case (DWORD_PTR) DIPROP_AUTOCENTER:
+        {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
 
+            pd->dwData = This->sdldev->autocenter ? DIPROPAUTOCENTER_ON : DIPROPAUTOCENTER_OFF;
+            TRACE("autocenter(%d)\n", pd->dwData);
+            break;
+        }
+        case (DWORD_PTR) DIPROP_FFGAIN:
+        {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+            pd->dwData = This->sdldev->gain;
+            TRACE("DIPROP_FFGAIN(%d)\n", pd->dwData);
+            break;
+        }
         case (DWORD_PTR) DIPROP_VIDPID:
         {
             LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
@@ -584,6 +622,70 @@ static HRESULT WINAPI JoystickAImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface, REF
     return JoystickWImpl_GetProperty(IDirectInputDevice8W_from_impl(This), rguid, pdiph);
 }
 
+static BOOL _SetProperty(JoystickImpl *This, const GUID *prop, const DIPROPHEADER *header)
+{
+    int rc;
+
+    switch(LOWORD(prop))
+    {
+        case (DWORD_PTR)DIPROP_AUTOCENTER:
+        {
+            LPCDIPROPDWORD pd = (LPCDIPROPDWORD)header;
+
+            This->sdldev->autocenter = pd->dwData == DIPROPAUTOCENTER_ON;
+
+            rc = SDL_HapticSetAutocenter(This->haptic, This->sdldev->autocenter * 100);
+            if (rc != 0)
+                ERR("SDL_HapticSetAutocenter failed: %s\n", SDL_GetError());
+            break;
+        }
+        case (DWORD_PTR)DIPROP_FFGAIN:
+        {
+            LPCDIPROPDWORD pd = (LPCDIPROPDWORD)header;
+            int sdl_gain = MulDiv(This->sdldev->gain, 100, 10000);
+
+            TRACE("DIPROP_FFGAIN(%d)\n", pd->dwData);
+
+            This->sdldev->gain = pd->dwData;
+
+            rc = SDL_HapticSetGain(This->haptic, sdl_gain);
+            if (rc != 0)
+                ERR("SDL_HapticSetGain (%i -> %i) failed: %s\n", pd->dwData, sdl_gain, SDL_GetError());
+            break;
+        }
+        default:
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+static HRESULT WINAPI JoystickWImpl_SetProperty(IDirectInputDevice8W *iface,
+        const GUID *prop, const DIPROPHEADER *header)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("%p %s %p\n", This, debugstr_guid(prop), header);
+
+    if (_SetProperty(This, prop, header))
+        return DI_OK;
+    else
+        return JoystickWGenericImpl_SetProperty(iface, prop, header);
+}
+
+static HRESULT WINAPI JoystickAImpl_SetProperty(IDirectInputDevice8A *iface,
+        const GUID *prop, const DIPROPHEADER *header)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("%p %s %p\n", This, debugstr_guid(prop), header);
+
+    if (_SetProperty(This, prop, header))
+        return DI_OK;
+    else
+        return JoystickAGenericImpl_SetProperty(iface, prop, header);
+}
+
 /******************************************************************************
   *     GetDeviceInfo : get information about a device's identity
   */
@@ -629,7 +731,7 @@ static const IDirectInputDevice8AVtbl JoystickAvt =
     JoystickAGenericImpl_GetCapabilities,
     IDirectInputDevice2AImpl_EnumObjects,
     JoystickAImpl_GetProperty,
-    JoystickAGenericImpl_SetProperty,
+    JoystickAImpl_SetProperty,
     IDirectInputDevice2AImpl_Acquire,
     IDirectInputDevice2AImpl_Unacquire,
     JoystickAGenericImpl_GetDeviceState,
@@ -665,7 +767,7 @@ static const IDirectInputDevice8WVtbl JoystickWvt =
     JoystickWGenericImpl_GetCapabilities,
     IDirectInputDevice2WImpl_EnumObjects,
     JoystickWImpl_GetProperty,
-    JoystickWGenericImpl_SetProperty,
+    JoystickWImpl_SetProperty,
     IDirectInputDevice2WImpl_Acquire,
     IDirectInputDevice2WImpl_Unacquire,
     JoystickWGenericImpl_GetDeviceState,
From 4a00545c903e0ec97c2fd2643d00c7254a42f32c Mon Sep 17 00:00:00 2001
From: Aric Stewart <aric@codeweavers.com>
Date: Wed, 3 Jan 2018 12:50:21 -0600
Subject: [PATCH] dinput: Implement GetEffectInfo, SendForceFeedbackCommand and
 EnumCreatedEffectObjects

Signed-off-by: Aric Stewart <aric@codeweavers.com>
---
 dlls/dinput/joystick_sdl.c | 259 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 253 insertions(+), 6 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 2908daeeb77..8ef53108a9b 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -67,6 +67,7 @@ struct SDLDev {
     BOOL has_ff;
     int autocenter;
     int gain;
+    struct list effects;
 };
 
 struct JoystickImpl
@@ -362,6 +363,9 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     newDevice->generic.base.dinput = dinput;
     newDevice->sdldev              = &sdldevs[index];
     newDevice->generic.name        = (char*)newDevice->sdldev->name;
+    list_init(&newDevice->sdldev->effects);
+    newDevice->sdldev->autocenter = 1;
+    newDevice->sdldev->gain = 100;
 
     InitializeCriticalSection(&newDevice->generic.base.crit);
     newDevice->generic.base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": JoystickImpl*->base.crit");
@@ -723,6 +727,249 @@ static HRESULT WINAPI JoystickWImpl_GetDeviceInfo(LPDIRECTINPUTDEVICE8W iface,
     return DI_OK;
 }
 
+static HRESULT WINAPI JoystickWImpl_EnumEffects(LPDIRECTINPUTDEVICE8W iface,
+                                                LPDIENUMEFFECTSCALLBACKW lpCallback,
+                                                LPVOID pvRef,
+                                                DWORD dwEffType)
+{
+    DIEFFECTINFOW dei;
+    DWORD type = DIEFT_GETTYPE(dwEffType);
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+    unsigned int query;
+
+    TRACE("(this=%p,%p,%d) type=%d\n", This, pvRef, dwEffType, type);
+
+    dei.dwSize = sizeof(DIEFFECTINFOW);
+    query = SDL_HapticQuery(This->haptic);
+    TRACE("Effects 0x%x\n",query);
+
+    if ((type == DIEFT_ALL || type == DIEFT_CONSTANTFORCE)
+        && (query & SDL_HAPTIC_CONSTANT))
+    {
+        IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_ConstantForce);
+        (*lpCallback)(&dei, pvRef);
+    }
+
+    if ((type == DIEFT_ALL || type == DIEFT_RAMPFORCE) &&
+        (query & SDL_HAPTIC_RAMP))
+    {
+        IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_RampForce);
+        (*lpCallback)(&dei, pvRef);
+    }
+
+    if (type == DIEFT_ALL || type == DIEFT_PERIODIC)
+    {
+        if (query & SDL_HAPTIC_SINE)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Sine);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_TRIANGLE)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Triangle);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_SAWTOOTHUP)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothUp);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_SAWTOOTHDOWN)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothDown);
+            (*lpCallback)(&dei, pvRef);
+        }
+    }
+
+    if (type == DIEFT_ALL || type == DIEFT_CONDITION)
+    {
+        if (query & SDL_HAPTIC_SPRING)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Spring);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_DAMPER)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Damper);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_INERTIA)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Inertia);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_FRICTION)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Friction);
+            (*lpCallback)(&dei, pvRef);
+        }
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_EnumEffects(LPDIRECTINPUTDEVICE8A iface,
+                                                LPDIENUMEFFECTSCALLBACKA lpCallback,
+                                                LPVOID pvRef,
+                                                DWORD dwEffType)
+{
+    DIEFFECTINFOA dei;
+    DWORD type = DIEFT_GETTYPE(dwEffType);
+    JoystickImpl* This = impl_from_IDirectInputDevice8A(iface);
+    unsigned int query;
+
+    TRACE("(this=%p,%p,%d) type=%d\n", This, pvRef, dwEffType, type);
+
+    dei.dwSize = sizeof(DIEFFECTINFOA);
+    query = SDL_HapticQuery(This->haptic);
+    TRACE("Effects 0x%x\n",query);
+
+    if ((type == DIEFT_ALL || type == DIEFT_CONSTANTFORCE)
+        && (query & SDL_HAPTIC_CONSTANT))
+    {
+        IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_ConstantForce);
+        (*lpCallback)(&dei, pvRef);
+    }
+
+    if ((type == DIEFT_ALL || type == DIEFT_RAMPFORCE) &&
+        (query & SDL_HAPTIC_RAMP))
+    {
+        IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_RampForce);
+        (*lpCallback)(&dei, pvRef);
+    }
+
+    if (type == DIEFT_ALL || type == DIEFT_PERIODIC)
+    {
+        if (query & SDL_HAPTIC_SINE)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Sine);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_TRIANGLE)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Triangle);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_SAWTOOTHUP)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothUp);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_SAWTOOTHDOWN)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothDown);
+            (*lpCallback)(&dei, pvRef);
+        }
+    }
+
+    if (type == DIEFT_ALL || type == DIEFT_CONDITION)
+    {
+        if (query & SDL_HAPTIC_SPRING)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Spring);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_DAMPER)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Damper);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_INERTIA)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Inertia);
+            (*lpCallback)(&dei, pvRef);
+        }
+        if (query & SDL_HAPTIC_FRICTION)
+        {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Friction);
+            (*lpCallback)(&dei, pvRef);
+        }
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickWImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8W iface, DWORD dwFlags)
+{
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+    TRACE("(this=%p,%d)\n", This, dwFlags);
+
+    switch (dwFlags)
+    {
+    case DISFFC_STOPALL:
+    {
+        effect_list_item *itr;
+
+        /* Stop all effects */
+        LIST_FOR_EACH_ENTRY(itr, &This->sdldev->effects, effect_list_item, entry)
+            IDirectInputEffect_Stop(itr->ref);
+        break;
+    }
+
+    case DISFFC_RESET:
+    {
+        effect_list_item *itr;
+
+        /* Stop and unload all effects. It is not true that effects are released */
+        LIST_FOR_EACH_ENTRY(itr, &This->sdldev->effects, effect_list_item, entry)
+        {
+            IDirectInputEffect_Stop(itr->ref);
+            IDirectInputEffect_Unload(itr->ref);
+        }
+        break;
+    }
+    case DISFFC_PAUSE:
+    case DISFFC_CONTINUE:
+        FIXME("No support for Pause or Continue in sdl\n");
+        break;
+
+    case DISFFC_SETACTUATORSOFF:
+    case DISFFC_SETACTUATORSON:
+        FIXME("No direct actuator control in sdl\n");
+        break;
+
+    default:
+        WARN("Unknown Force Feedback Command %u!\n", dwFlags);
+        return DIERR_INVALIDPARAM;
+    }
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8A iface, DWORD dwFlags)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_SendForceFeedbackCommand(IDirectInputDevice8W_from_impl(This), dwFlags);
+}
+
+static HRESULT WINAPI JoystickWImpl_EnumCreatedEffectObjects(LPDIRECTINPUTDEVICE8W iface,
+                                                             LPDIENUMCREATEDEFFECTOBJECTSCALLBACK lpCallback,
+                                                             LPVOID pvRef, DWORD dwFlags)
+{
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+    effect_list_item *itr, *ptr;
+
+    TRACE("(this=%p,%p,%p,%d)\n", This, lpCallback, pvRef, dwFlags);
+
+    if (!lpCallback)
+        return DIERR_INVALIDPARAM;
+
+    if (dwFlags != 0)
+        FIXME("Flags specified, but no flags exist yet (DX9)!\n");
+
+    LIST_FOR_EACH_ENTRY_SAFE(itr, ptr, &This->sdldev->effects, effect_list_item, entry)
+        (*lpCallback)(itr->ref, pvRef);
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_EnumCreatedEffectObjects(LPDIRECTINPUTDEVICE8A iface,
+                                                             LPDIENUMCREATEDEFFECTOBJECTSCALLBACK lpCallback,
+                                                             LPVOID pvRef, DWORD dwFlags)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_EnumCreatedEffectObjects(IDirectInputDevice8W_from_impl(This), lpCallback, pvRef, dwFlags);
+}
+
 static const IDirectInputDevice8AVtbl JoystickAvt =
 {
     IDirectInputDevice2AImpl_QueryInterface,
@@ -744,11 +991,11 @@ static const IDirectInputDevice8AVtbl JoystickAvt =
     IDirectInputDevice2AImpl_RunControlPanel,
     IDirectInputDevice2AImpl_Initialize,
     IDirectInputDevice2AImpl_CreateEffect,
-    IDirectInputDevice2AImpl_EnumEffects,
+    JoystickAImpl_EnumEffects,
     IDirectInputDevice2AImpl_GetEffectInfo,
     IDirectInputDevice2AImpl_GetForceFeedbackState,
-    IDirectInputDevice2AImpl_SendForceFeedbackCommand,
-    IDirectInputDevice2AImpl_EnumCreatedEffectObjects,
+    JoystickAImpl_SendForceFeedbackCommand,
+    JoystickAImpl_EnumCreatedEffectObjects,
     IDirectInputDevice2AImpl_Escape,
     JoystickAGenericImpl_Poll,
     IDirectInputDevice2AImpl_SendDeviceData,
@@ -780,11 +1027,11 @@ static const IDirectInputDevice8WVtbl JoystickWvt =
     IDirectInputDevice2WImpl_RunControlPanel,
     IDirectInputDevice2WImpl_Initialize,
     IDirectInputDevice2WImpl_CreateEffect,
-    IDirectInputDevice2WImpl_EnumEffects,
+    JoystickWImpl_EnumEffects,
     IDirectInputDevice2WImpl_GetEffectInfo,
     IDirectInputDevice2WImpl_GetForceFeedbackState,
-    IDirectInputDevice2WImpl_SendForceFeedbackCommand,
-    IDirectInputDevice2WImpl_EnumCreatedEffectObjects,
+    JoystickWImpl_SendForceFeedbackCommand,
+    JoystickWImpl_EnumCreatedEffectObjects,
     IDirectInputDevice2WImpl_Escape,
     JoystickWGenericImpl_Poll,
     IDirectInputDevice2WImpl_SendDeviceData,
From ef779d1a21ea30a1ef7714c445b91baedd166c9b Mon Sep 17 00:00:00 2001
From: Aric Stewart <aric@codeweavers.com>
Date: Wed, 3 Jan 2018 13:26:27 -0600
Subject: [PATCH] dinput: Implement FF effects for SDL joysticks

Signed-off-by: Aric Stewart <aric@codeweavers.com>
---
 dlls/dinput/Makefile.in    |   1 +
 dlls/dinput/effect_sdl.c   | 848 +++++++++++++++++++++++++++++++++++++
 dlls/dinput/joystick_sdl.c |  93 +++-
 3 files changed, 938 insertions(+), 4 deletions(-)
 create mode 100644 dlls/dinput/effect_sdl.c

diff --git a/dlls/dinput/Makefile.in b/dlls/dinput/Makefile.in
index ee3ddc016e8..8dfebb665fb 100644
--- a/dlls/dinput/Makefile.in
+++ b/dlls/dinput/Makefile.in
@@ -11,6 +11,7 @@ C_SRCS = \
 	device.c \
 	dinput_main.c \
 	effect_linuxinput.c \
+	effect_sdl.c \
 	joystick.c \
 	joystick_linux.c \
 	joystick_linuxinput.c \
diff --git a/dlls/dinput/effect_sdl.c b/dlls/dinput/effect_sdl.c
new file mode 100644
index 00000000000..8055785cc02
--- /dev/null
+++ b/dlls/dinput/effect_sdl.c
@@ -0,0 +1,848 @@
+/*  DirectInput Joystick device from SDL
+ *
+ * Copyright 2017 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_SDL2_SDL_H
+# include <SDL2/SDL.h>
+#endif
+#include <errno.h>
+
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "wine/list.h"
+#include "windef.h"
+#include "winbase.h"
+#include "winerror.h"
+#include "winreg.h"
+#include "dinput.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+#include "joystick_private.h"
+
+#ifdef HAVE_SDL2_SDL_H
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+typedef struct _SDLInputEffectImpl {
+    IDirectInputEffect IDirectInputEffect_iface;
+    LONG ref;
+
+    SDL_Haptic *haptic;
+    GUID guid;
+
+    SDL_HapticEffect effect;
+    int effect_id;
+    BOOL first_axis_is_x;
+
+    struct list *entry;
+} SDLInputEffectImpl;
+
+static SDLInputEffectImpl *impl_from_IDirectInputEffect(IDirectInputEffect *iface)
+{
+    return CONTAINING_RECORD(iface, SDLInputEffectImpl, IDirectInputEffect_iface);
+}
+
+static const IDirectInputEffectVtbl EffectVtbl;
+
+
+static HRESULT WINAPI effect_QueryInterface(IDirectInputEffect *iface,
+        const GUID *guid, void **out)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+
+    TRACE("%p %s %p\n", This, debugstr_guid(guid), out);
+
+    if(IsEqualIID(guid, &IID_IUnknown) || IsEqualIID(guid, &IID_IDirectInputEffect)){
+        *out = iface;
+        IDirectInputEffect_AddRef(iface);
+        return DI_OK;
+    }
+
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI effect_AddRef(IDirectInputEffect *iface)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("%p, ref is now: %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI effect_Release(IDirectInputEffect *iface)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("%p, ref is now: %u\n", This, ref);
+
+    if (!ref)
+    {
+        list_remove(This->entry);
+        if (This->effect_id >= 0)
+            SDL_HapticDestroyEffect(This->haptic, This->effect_id);
+        HeapFree(GetProcessHeap(), 0, LIST_ENTRY(This->entry, effect_list_item, entry));
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI effect_Initialize(IDirectInputEffect *iface, HINSTANCE hinst,
+        DWORD version, const GUID *guid)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p 0x%x, %s\n", This, hinst, version, debugstr_guid(guid));
+    return DI_OK;
+}
+
+static HRESULT WINAPI effect_GetEffectGuid(IDirectInputEffect *iface, GUID *out)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p\n", This, out);
+    *out = This->guid;
+    return DI_OK;
+}
+
+
+#define GET_BASE_EFFECT_FIELD(target, field, value) {\
+    if (target.type == SDL_HAPTIC_SINE || \
+        target.type == SDL_HAPTIC_TRIANGLE || \
+        target.type == SDL_HAPTIC_SAWTOOTHUP || \
+        target.type == SDL_HAPTIC_SAWTOOTHDOWN) \
+        value = (target.periodic.field); \
+    else if (target.type == SDL_HAPTIC_CONSTANT) \
+        value = (target.constant.field); \
+    else if (target.type == SDL_HAPTIC_RAMP) \
+        value = (target.ramp.field); \
+    else if (target.type == SDL_HAPTIC_SPRING || \
+             target.type == SDL_HAPTIC_DAMPER || \
+             target.type == SDL_HAPTIC_INERTIA || \
+             target.type == SDL_HAPTIC_FRICTION) \
+        value = (target.condition.field); \
+    else if (target.type == SDL_HAPTIC_CUSTOM) \
+        value = (target.custom.field); \
+    }
+
+#define GET_EXTENDED_EFFECT_FIELD(target, field, value) {\
+    if (target.type == SDL_HAPTIC_SINE || \
+        target.type == SDL_HAPTIC_TRIANGLE || \
+        target.type == SDL_HAPTIC_SAWTOOTHUP || \
+        target.type == SDL_HAPTIC_SAWTOOTHDOWN) \
+        value = (target.periodic.field); \
+    else if (target.type == SDL_HAPTIC_CONSTANT) \
+        value = (target.constant.field); \
+    else if (target.type == SDL_HAPTIC_RAMP) \
+        value = (target.ramp.field); \
+    else if (target.type == SDL_HAPTIC_SPRING || \
+             target.type == SDL_HAPTIC_DAMPER || \
+             target.type == SDL_HAPTIC_INERTIA || \
+             target.type == SDL_HAPTIC_FRICTION); \
+        /* Ignored because extended fields are not preset in these effects */ \
+    else if (target.type == SDL_HAPTIC_CUSTOM) \
+        value = (target.custom.field); \
+    }
+
+#define SCALE(type, target_range, target_min, value, source_range, source_min) \
+    (type)((((target_range)*(value + source_min))/source_range)-target_min)
+
+static HRESULT WINAPI effect_GetParameters(IDirectInputEffect *iface,
+        DIEFFECT *effect, DWORD flags)
+{
+    HRESULT hr = DI_OK;
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p 0x%x\n", This, effect, flags);
+
+    if (flags & DIEP_AXES)
+    {
+        if (effect->cAxes < 2)
+            hr = DIERR_MOREDATA;
+        effect->cAxes = 2;
+        if (hr)
+            return hr;
+        else
+        {
+            effect->rgdwAxes[0] = DIJOFS_X;
+            effect->rgdwAxes[1] = DIJOFS_Y;
+        }
+    }
+
+    if (flags & DIEP_DIRECTION)
+    {
+        if (effect->cAxes < 2)
+            hr = DIERR_MOREDATA;
+        effect->cAxes = 2;
+        if (hr)
+            return hr;
+        else
+        {
+            if (effect->dwFlags & DIEFF_CARTESIAN)
+            {
+                GET_BASE_EFFECT_FIELD(This->effect, direction.dir[0], effect->rglDirection[0]);
+                GET_BASE_EFFECT_FIELD(This->effect, direction.dir[1], effect->rglDirection[1]);
+            }
+        else
+            {
+                /* Polar and spherical coordinates */
+                GET_BASE_EFFECT_FIELD(This->effect, direction.dir[0], effect->rglDirection[0]);
+            }
+        }
+    }
+
+    if (flags & DIEP_DURATION)
+    {
+        int sdl_length = 0;
+        GET_BASE_EFFECT_FIELD(This->effect, length, sdl_length);
+        if (sdl_length == SDL_HAPTIC_INFINITY)
+            effect->dwDuration = INFINITE;
+        else
+            effect->dwDuration = (DWORD)sdl_length * 1000;
+    }
+
+    if (flags & DIEP_ENVELOPE)
+    {
+        int sdl_attack_length = 0;
+        int sdl_attack_level = 0;
+        int sdl_fade_length = 0;
+        int sdl_fade_level = 0;
+
+        GET_EXTENDED_EFFECT_FIELD(This->effect, attack_length, sdl_attack_length);
+        GET_EXTENDED_EFFECT_FIELD(This->effect, attack_level, sdl_attack_level);
+        GET_EXTENDED_EFFECT_FIELD(This->effect, fade_length, sdl_fade_length);
+        GET_EXTENDED_EFFECT_FIELD(This->effect, fade_level, sdl_fade_level);
+
+        if (sdl_attack_length == 0 && sdl_attack_level == 0 && sdl_fade_length == 0 && sdl_fade_level == 0)
+        {
+            effect->lpEnvelope = NULL;
+        }
+        else if (effect->lpEnvelope == NULL)
+        {
+            return DIERR_INVALIDPARAM;
+        }
+        else
+        {
+            effect->lpEnvelope->dwAttackLevel = sdl_attack_level;
+            effect->lpEnvelope->dwAttackTime = sdl_attack_length * 1000;
+            effect->lpEnvelope->dwFadeLevel = sdl_fade_level;
+            effect->lpEnvelope->dwFadeTime = sdl_fade_length * 1000;
+        }
+    }
+
+    if (flags & DIEP_GAIN)
+        effect->dwGain = 0;
+
+    if (flags & DIEP_SAMPLEPERIOD)
+        effect->dwSamplePeriod = 0;
+
+    if (flags & DIEP_STARTDELAY && effect->dwSize > sizeof(DIEFFECT_DX5))
+    {
+        GET_BASE_EFFECT_FIELD(This->effect, delay, effect->dwStartDelay);
+        effect->dwStartDelay *= 1000;
+    }
+
+    if (flags & DIEP_TRIGGERBUTTON)
+    {
+        int trigger = 0;
+        GET_BASE_EFFECT_FIELD(This->effect, button, trigger);
+        effect->dwTriggerButton = DIJOFS_BUTTON(trigger);
+    }
+
+    if (flags & DIEP_TRIGGERREPEATINTERVAL)
+    {
+        GET_BASE_EFFECT_FIELD(This->effect, interval, effect->dwTriggerRepeatInterval);
+        effect->dwTriggerRepeatInterval *= 1000;
+    }
+
+    if (flags & DIEP_TYPESPECIFICPARAMS)
+    {
+        if (This->effect.type == SDL_HAPTIC_SINE ||
+            This->effect.type == SDL_HAPTIC_TRIANGLE ||
+            This->effect.type == SDL_HAPTIC_SAWTOOTHUP ||
+            This->effect.type == SDL_HAPTIC_SAWTOOTHDOWN)
+        {
+            DIPERIODIC *tsp = effect->lpvTypeSpecificParams;
+
+            tsp->dwMagnitude = MulDiv(This->effect.periodic.magnitude, 10000, 32767);
+            tsp->lOffset = This->effect.periodic.offset;
+            tsp->dwPhase = This->effect.periodic.phase;
+            tsp->dwPeriod = This->effect.periodic.period * 1000;
+        }
+        else if (This->effect.type == SDL_HAPTIC_CONSTANT)
+        {
+            LPDICONSTANTFORCE tsp = effect->lpvTypeSpecificParams;
+            tsp->lMagnitude = SCALE(LONG, 20000, -10000, This->effect.constant.level, 0xffff, -32767);
+        }
+        else if (This->effect.type == SDL_HAPTIC_RAMP)
+        {
+            DIRAMPFORCE *tsp = effect->lpvTypeSpecificParams;
+
+            tsp->lStart = SCALE(Sint16, 20000, -10000, This->effect.ramp.start, 0xffff, -32767);
+            tsp->lEnd = SCALE(Sint16, 20000, -10000, This->effect.ramp.end, 0xffff, -32767);
+        }
+        else if (This->effect.type == SDL_HAPTIC_SPRING ||
+                 This->effect.type == SDL_HAPTIC_DAMPER ||
+                 This->effect.type == SDL_HAPTIC_INERTIA ||
+                 This->effect.type == SDL_HAPTIC_FRICTION)
+        {
+            int i;
+            DICONDITION *tsp = effect->lpvTypeSpecificParams;
+            for (i = 0; i < 2; i++)
+            {
+                tsp[i].lOffset = SCALE(LONG, 20000, -10000, This->effect.condition.center[i], 0xffff, -32767);
+                tsp[i].lPositiveCoefficient = SCALE(LONG, 20000, -10000, This->effect.condition.right_coeff[i], 0xffff, -32767);
+                tsp[i].lNegativeCoefficient = SCALE(LONG, 10000, -20000, This->effect.condition.left_coeff[i], 0xffff, -32767);
+                tsp[i].dwPositiveSaturation = SCALE(DWORD, 10000, 0, This->effect.condition.right_sat[i], 0xffff, 0);
+                tsp[i].dwNegativeSaturation = SCALE(DWORD, 10000, 0, This->effect.condition.left_sat[i], 0xffff, 0);
+                tsp[i].lDeadBand = SCALE(LONG, 20000, -10000, This->effect.condition.deadband[i], 0xffff, -32767);
+            }
+        }
+        else if (This->effect.type == SDL_HAPTIC_CUSTOM)
+        {
+            DICUSTOMFORCE *tsp = effect->lpvTypeSpecificParams;
+
+            tsp->cChannels = This->effect.custom.channels;
+            tsp->dwSamplePeriod = This->effect.custom.period * 1000;
+            tsp->cSamples = This->effect.custom.samples;
+            tsp->rglForceData = (LONG*)This->effect.custom.data;
+        }
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI effect_Download(IDirectInputEffect *iface)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p\n", This);
+
+    if (This->effect_id < 0)
+    {
+        This->effect_id = SDL_HapticNewEffect(This->haptic, &This->effect);
+        if(This->effect_id < 0)
+        {
+            ERR("SDL_HapticNewEffect failed (Effect type %i): %s\n", This->effect.type, SDL_GetError());
+            return E_FAIL;
+        }
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI effect_Start(IDirectInputEffect *iface, DWORD iterations,
+        DWORD flags)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+
+    TRACE("%p 0x%x 0x%x\n", This, iterations, flags);
+
+    if (!(flags & DIES_NODOWNLOAD))
+    {
+        if (This->effect_id == -1)
+        {
+            HRESULT res = effect_Download(iface);
+            if (res != DI_OK)
+                return res;
+        }
+    }
+
+    if (iterations == INFINITE) iterations = SDL_HAPTIC_INFINITY;
+
+    if (SDL_HapticRunEffect(This->haptic, This->effect_id, iterations) < 0)
+    {
+        ERR("SDL_HapticRunEffect failed: %s\n", SDL_GetError());
+        return E_FAIL;
+    }
+    return DI_OK;
+}
+
+#define SET_BASE_EFFECT_FIELD(target, field, value) {\
+    if (target.type == SDL_HAPTIC_SINE || \
+        target.type == SDL_HAPTIC_TRIANGLE || \
+        target.type == SDL_HAPTIC_SAWTOOTHUP || \
+        target.type == SDL_HAPTIC_SAWTOOTHDOWN) \
+        (target.periodic.field) = value; \
+    else if (target.type == SDL_HAPTIC_CONSTANT) \
+        (target.constant.field) = value; \
+    else if (target.type == SDL_HAPTIC_RAMP) \
+        (target.ramp.field) = value; \
+    else if (target.type == SDL_HAPTIC_SPRING || \
+             target.type == SDL_HAPTIC_DAMPER || \
+             target.type == SDL_HAPTIC_INERTIA || \
+             target.type == SDL_HAPTIC_FRICTION) \
+        (target.condition.field) = value; \
+    else if (target.type == SDL_HAPTIC_CUSTOM) \
+        (target.custom.field) = value; \
+    }
+
+#define SET_EXTENDED_EFFECT_FIELD(target, field, value) {\
+    if (target.type == SDL_HAPTIC_SINE || \
+        target.type == SDL_HAPTIC_TRIANGLE || \
+        target.type == SDL_HAPTIC_SAWTOOTHUP || \
+        target.type == SDL_HAPTIC_SAWTOOTHDOWN) \
+        (target.periodic.field) = value; \
+    else if (target.type == SDL_HAPTIC_CONSTANT) \
+        (target.constant.field) = value; \
+    else if (target.type == SDL_HAPTIC_RAMP) \
+        (target.ramp.field) = value; \
+    else if (target.type == SDL_HAPTIC_SPRING || \
+             target.type == SDL_HAPTIC_DAMPER || \
+             target.type == SDL_HAPTIC_INERTIA || \
+             target.type == SDL_HAPTIC_FRICTION); \
+        /* Ignored because extended fields are not preset in these effects */ \
+    else if (target.type == SDL_HAPTIC_CUSTOM) \
+        (target.custom.field) = value; \
+    }
+
+static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
+        const DIEFFECT *effect, DWORD flags)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    HRESULT retval = DI_OK;
+
+    TRACE("%p %p 0x%x\n", This, effect, flags);
+
+    dump_DIEFFECT(effect, &This->guid, flags);
+
+    if (IsEqualGUID(&This->guid, &GUID_Sine))
+        This->effect.type = SDL_HAPTIC_SINE;
+    else if (IsEqualGUID(&This->guid, &GUID_Triangle))
+        This->effect.type = SDL_HAPTIC_TRIANGLE;
+    else if (IsEqualGUID(&This->guid, &GUID_SawtoothUp))
+        This->effect.type = SDL_HAPTIC_SAWTOOTHUP;
+    else if (IsEqualGUID(&This->guid, &GUID_SawtoothDown))
+        This->effect.type = SDL_HAPTIC_SAWTOOTHDOWN;
+    else if (IsEqualGUID(&This->guid, &GUID_ConstantForce))
+        This->effect.type = SDL_HAPTIC_CONSTANT;
+    else if (IsEqualGUID(&This->guid, &GUID_RampForce))
+        This->effect.type = SDL_HAPTIC_RAMP;
+    else if (IsEqualGUID(&This->guid, &GUID_Spring))
+        This->effect.type = SDL_HAPTIC_SPRING;
+    else if (IsEqualGUID(&This->guid, &GUID_Damper))
+        This->effect.type = SDL_HAPTIC_DAMPER;
+    else if (IsEqualGUID(&This->guid, &GUID_Inertia))
+        This->effect.type = SDL_HAPTIC_INERTIA;
+    else if (IsEqualGUID(&This->guid, &GUID_Friction))
+        This->effect.type = SDL_HAPTIC_FRICTION;
+    else if (IsEqualGUID(&This->guid, &GUID_CustomForce))
+        This->effect.type = SDL_HAPTIC_CUSTOM;
+
+    if ((flags & ~DIEP_NORESTART & ~DIEP_NODOWNLOAD & ~DIEP_START) == 0)
+    {
+        /* set everything */
+        flags = DIEP_AXES | DIEP_DIRECTION | DIEP_DURATION | DIEP_ENVELOPE |
+                DIEP_GAIN | DIEP_SAMPLEPERIOD | DIEP_STARTDELAY | DIEP_TRIGGERBUTTON |
+                DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS;
+    }
+
+    if (flags & DIEP_AXES)
+    {
+        if (effect->cAxes > 2)
+            return DIERR_INVALIDPARAM;
+        else if (effect->cAxes < 1)
+            return DIERR_INCOMPLETEEFFECT;
+        This->first_axis_is_x = effect->rgdwAxes[0] == DIJOFS_X;
+    }
+
+    if (flags & DIEP_DIRECTION)
+    {
+        if (effect->cAxes == 1)
+        {
+            if (effect->dwFlags & DIEFF_CARTESIAN)
+            {
+               SET_BASE_EFFECT_FIELD(This->effect, direction.type, SDL_HAPTIC_CARTESIAN);
+                if (flags & DIEP_AXES)
+                {
+                    SET_BASE_EFFECT_FIELD(This->effect, direction.dir[0], effect->rglDirection[0]);
+                    SET_BASE_EFFECT_FIELD(This->effect, direction.dir[1], effect->rglDirection[1]);
+                }
+            } else {
+                /* one-axis effects must use cartesian coords */
+                return DIERR_INVALIDPARAM;
+            }
+        }
+        /* two axes */
+        else
+        {
+            if (effect->dwFlags & DIEFF_CARTESIAN)
+            {
+                LONG x, y;
+
+                SET_BASE_EFFECT_FIELD(This->effect, direction.type, SDL_HAPTIC_CARTESIAN);
+
+                if (This->first_axis_is_x)
+                {
+                    x = effect->rglDirection[0];
+                    y = effect->rglDirection[1];
+                }
+                else
+                {
+                    x = effect->rglDirection[1];
+                    y = effect->rglDirection[0];
+                }
+                SET_BASE_EFFECT_FIELD(This->effect, direction.dir[0], x);
+                SET_BASE_EFFECT_FIELD(This->effect, direction.dir[1], y);
+            }
+            else
+            {
+                if (effect->dwFlags & DIEFF_POLAR)
+                {
+                    SET_BASE_EFFECT_FIELD(This->effect, direction.type, SDL_HAPTIC_POLAR);
+                }
+                if (effect->dwFlags & DIEFF_SPHERICAL)
+                {
+                    SET_BASE_EFFECT_FIELD(This->effect, direction.type, SDL_HAPTIC_SPHERICAL);
+                }
+                SET_BASE_EFFECT_FIELD(This->effect, direction.dir[0], effect->rglDirection[0]);
+            }
+        }
+    }
+
+    if (flags & DIEP_DURATION)
+    {
+        if (effect->dwDuration == INFINITE)
+        {
+            SET_BASE_EFFECT_FIELD(This->effect, length, SDL_HAPTIC_INFINITY);
+        }
+        else if(effect->dwDuration > 1000)
+        {
+            SET_BASE_EFFECT_FIELD(This->effect, length, effect->dwDuration / 1000);
+        }
+        else
+        {
+            SET_BASE_EFFECT_FIELD(This->effect, length, 1);
+        }
+    }
+
+    if (flags & DIEP_STARTDELAY && effect->dwSize > sizeof(DIEFFECT_DX5))
+    {
+        SET_BASE_EFFECT_FIELD(This->effect, delay, effect->dwStartDelay / 1000);
+    }
+
+    if (flags & DIEP_TRIGGERBUTTON)
+    {
+        SET_BASE_EFFECT_FIELD(This->effect, button, effect->dwTriggerButton);
+    }
+
+    if (flags & DIEP_TRIGGERREPEATINTERVAL)
+    {
+        SET_BASE_EFFECT_FIELD(This->effect, interval, effect->dwTriggerRepeatInterval / 1000);
+    }
+
+    if (flags & DIEP_TYPESPECIFICPARAMS)
+    {
+        if (IsEqualGUID(&This->guid, &GUID_Sine) ||
+            IsEqualGUID(&This->guid, &GUID_Triangle) ||
+            IsEqualGUID(&This->guid, &GUID_SawtoothUp) ||
+            IsEqualGUID(&This->guid, &GUID_SawtoothDown))
+        {
+            DIPERIODIC *tsp;
+            if (effect->cbTypeSpecificParams != sizeof(DIPERIODIC))
+                return DIERR_INVALIDPARAM;
+            tsp = effect->lpvTypeSpecificParams;
+
+            This->effect.periodic.magnitude = MulDiv(tsp->dwMagnitude, 32767, 10000);
+            This->effect.periodic.offset = tsp->lOffset;
+            This->effect.periodic.phase = tsp->dwPhase;
+            if (tsp->dwPeriod <= 1000)
+                This->effect.periodic.period = 1;
+            else
+                This->effect.periodic.period = tsp->dwPeriod / 1000;
+        }
+        else if (IsEqualGUID(&This->guid, &GUID_ConstantForce))
+        {
+            DICONSTANTFORCE *tsp = effect->lpvTypeSpecificParams;
+
+            if (effect->cbTypeSpecificParams != sizeof(DICONSTANTFORCE))
+                return DIERR_INVALIDPARAM;
+            tsp = effect->lpvTypeSpecificParams;
+            This->effect.constant.level = SCALE(Sint16, 0xffff, -32767, tsp->lMagnitude, 20000, -10000);
+        }
+        else if (IsEqualGUID(&This->guid, &GUID_RampForce))
+        {
+            DIRAMPFORCE *tsp = effect->lpvTypeSpecificParams;
+
+            if (effect->cbTypeSpecificParams != sizeof(DIRAMPFORCE))
+                return DIERR_INVALIDPARAM;
+            tsp = effect->lpvTypeSpecificParams;
+            This->effect.ramp.start = SCALE(Sint16, 0xffff, -32767, tsp->lStart, 20000, -10000);
+            This->effect.ramp.end = SCALE(Sint16, 0xffff, -32767, tsp->lEnd, 20000, -10000);
+        }
+        else if (IsEqualGUID(&This->guid, &GUID_Spring) ||
+            IsEqualGUID(&This->guid, &GUID_Damper) ||
+            IsEqualGUID(&This->guid, &GUID_Inertia) ||
+            IsEqualGUID(&This->guid, &GUID_Friction))
+        {
+            int sources;
+            int i,j;
+            DICONDITION *tsp = effect->lpvTypeSpecificParams;
+
+            if (effect->cbTypeSpecificParams == sizeof(DICONDITION))
+                sources = 1;
+            else if (effect->cbTypeSpecificParams == 2 * sizeof(DICONDITION))
+                sources = 2;
+            else if (effect->cbTypeSpecificParams == 3 * sizeof(DICONDITION))
+                sources = 3;
+            else
+                return DIERR_INVALIDPARAM;
+
+            for (i = j = 0; i < 3; ++i)
+            {
+                This->effect.condition.right_sat[i] = SCALE(Uint16, 0xffff, 0, tsp[j].dwPositiveSaturation, 10000, 0);
+                This->effect.condition.left_sat[i] = SCALE(Uint16, 0xffff, 0, tsp[j].dwNegativeSaturation, 10000, 0);
+                This->effect.condition.right_coeff[i] = SCALE(Sint16, 0xffff, -32767, tsp[j].lPositiveCoefficient, 20000, -10000);
+                This->effect.condition.left_coeff[i] = SCALE(Sint16, 0xffff, -32767, tsp[j].lNegativeCoefficient, 20000, -10000);
+                This->effect.condition.deadband[i] = SCALE(Uint16, 0xffff, 0, tsp[j].lDeadBand, 10000, 0);
+                This->effect.condition.center[i] = SCALE(Sint16, 0xffff, -32767, tsp[j].lOffset, 20000, -10000);
+               if (sources-1 > j)
+                j++;
+            }
+        }
+        else if (IsEqualGUID(&This->guid, &GUID_CustomForce))
+        {
+            DICUSTOMFORCE *tsp = effect->lpvTypeSpecificParams;
+
+            if (effect->cbTypeSpecificParams != sizeof(DICUSTOMFORCE))
+                return DIERR_INVALIDPARAM;
+
+            This->effect.custom.channels = tsp->cChannels;
+            This->effect.custom.period = tsp->dwSamplePeriod / 1000;
+            This->effect.custom.samples = tsp->cSamples;
+            This->effect.custom.data = (Uint16*)tsp->rglForceData;
+        }
+        else
+        {
+            FIXME("Specific effect params for type %s no implemented.\n", debugstr_guid(&This->guid));
+        }
+    }
+
+    if (flags & DIEP_ENVELOPE)
+    {
+        if (effect->lpEnvelope)
+        {
+            SET_EXTENDED_EFFECT_FIELD(This->effect, attack_length, effect->lpEnvelope->dwAttackTime / 1000);
+            SET_EXTENDED_EFFECT_FIELD(This->effect, attack_level, effect->lpEnvelope->dwAttackLevel);
+            SET_EXTENDED_EFFECT_FIELD(This->effect, fade_length, effect->lpEnvelope->dwFadeTime / 1000);
+            SET_EXTENDED_EFFECT_FIELD(This->effect, fade_level, effect->lpEnvelope->dwFadeLevel);
+        }
+        else
+        {
+            SET_EXTENDED_EFFECT_FIELD(This->effect, attack_length, 0);
+            SET_EXTENDED_EFFECT_FIELD(This->effect, attack_level, 0);
+            SET_EXTENDED_EFFECT_FIELD(This->effect, fade_length, 0);
+            SET_EXTENDED_EFFECT_FIELD(This->effect, fade_level, 0);
+        }
+    }
+
+    if (flags & DIEP_GAIN)
+        TRACE("Effect gain requested but no effect gain functionality present.\n");
+
+    if (flags & DIEP_SAMPLEPERIOD)
+        TRACE("Sample period requested but no sample period functionality present.\n");
+
+    if (This->effect_id >= 0)
+    {
+        if (SDL_HapticUpdateEffect(This->haptic, This->effect_id, &This->effect) < 0)
+        {
+            ERR("SDL_HapticUpdateEffect failed: %s\n",SDL_GetError());
+            return E_FAIL;
+        }
+
+    }
+
+    if (!(flags & DIEP_NODOWNLOAD))
+        retval = effect_Download(iface);
+    if (retval != DI_OK)
+        return DI_DOWNLOADSKIPPED;
+
+    if (flags & DIEP_START)
+        retval = effect_Start(iface, 1, 0);
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI effect_Stop(IDirectInputEffect *iface)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p\n", This);
+    if (SDL_HapticStopEffect(This->haptic, This->effect_id) < 0)
+    {
+        ERR("SDL_HapticStopEffect failed: %s\n", SDL_GetError());
+        return E_FAIL;
+    }
+    return DI_OK;
+}
+
+static HRESULT WINAPI effect_GetEffectStatus(IDirectInputEffect *iface, DWORD *flags)
+{
+    int rc;
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p %p %i\n", This, flags, This->haptic, This->effect_id);
+
+    if (!flags)
+        return E_POINTER;
+
+    if (This->effect_id == -1)
+        return DIERR_NOTDOWNLOADED;
+
+    rc = SDL_HapticGetEffectStatus(This->haptic, This->effect_id);
+    switch (rc)
+    {
+        case 0: *flags = 0; break;
+        case 1: *flags = DIEGES_PLAYING; break;
+        default:
+            ERR("SDL_HapticGetEffectStatus failed: %s\n", SDL_GetError());
+    }
+    return DI_OK;
+}
+
+static HRESULT WINAPI effect_Unload(IDirectInputEffect *iface)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p\n", This);
+    if (This->effect_id >= 0)
+        SDL_HapticDestroyEffect(This->haptic, This->effect_id);
+    This->effect_id = -1;
+    return DI_OK;
+}
+
+static HRESULT WINAPI effect_Escape(IDirectInputEffect *iface, DIEFFESCAPE *escape)
+{
+    SDLInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p\n", This, escape);
+    return E_NOTIMPL;
+}
+
+static const IDirectInputEffectVtbl EffectVtbl = {
+    effect_QueryInterface,
+    effect_AddRef,
+    effect_Release,
+    effect_Initialize,
+    effect_GetEffectGuid,
+    effect_GetParameters,
+    effect_SetParameters,
+    effect_Start,
+    effect_Stop,
+    effect_GetEffectStatus,
+    effect_Download,
+    effect_Unload,
+    effect_Escape
+};
+
+/******************************************************************************
+ *      SDLInputEffect
+ */
+
+DECLSPEC_HIDDEN HRESULT sdl_create_effect(SDL_Haptic *device, REFGUID rguid, struct list *parent_list_entry, LPDIRECTINPUTEFFECT* peff)
+{
+    SDLInputEffectImpl *effect;
+
+    effect = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SDLInputEffectImpl));
+
+    effect->IDirectInputEffect_iface.lpVtbl = &EffectVtbl;
+    effect->ref = 1;
+    effect->guid = *rguid;
+    effect->haptic = device;
+    effect->effect_id = -1;
+
+    effect->entry = parent_list_entry;
+    *peff = &effect->IDirectInputEffect_iface;
+
+    return DI_OK;
+}
+
+DECLSPEC_HIDDEN HRESULT sdl_input_get_info_A(
+        SDL_Joystick *dev,
+        REFGUID rguid,
+        LPDIEFFECTINFOA info)
+{
+    DWORD type = typeFromGUID(rguid);
+
+    TRACE("(%p, %s, %p) type=%d\n", dev, _dump_dinput_GUID(rguid), info, type);
+
+    if (!info) return E_POINTER;
+
+    if (info->dwSize != sizeof(DIEFFECTINFOA)) return DIERR_INVALIDPARAM;
+
+    info->guid = *rguid;
+
+    info->dwEffType = type;
+    /* the event device API does not support querying for all these things
+     * therefore we assume that we have support for them
+     * that's not as dangerous as it sounds, since drivers are allowed to
+     * ignore parameters they claim to support anyway */
+    info->dwEffType |= DIEFT_DEADBAND | DIEFT_FFATTACK | DIEFT_FFFADE
+                    | DIEFT_POSNEGCOEFFICIENTS | DIEFT_POSNEGSATURATION
+                    | DIEFT_SATURATION | DIEFT_STARTDELAY;
+
+    /* again, assume we have support for everything */
+    info->dwStaticParams = DIEP_ALLPARAMS;
+    info->dwDynamicParams = info->dwStaticParams;
+
+    /* yes, this is windows behavior (print the GUID_Name for name) */
+    strcpy(info->tszName, _dump_dinput_GUID(rguid));
+
+    return DI_OK;
+}
+
+DECLSPEC_HIDDEN HRESULT sdl_input_get_info_W(
+        SDL_Joystick *dev,
+        REFGUID rguid,
+        LPDIEFFECTINFOW info)
+{
+    DWORD type = typeFromGUID(rguid);
+
+    TRACE("(%p, %s, %p) type=%d\n", dev, _dump_dinput_GUID(rguid), info, type);
+
+    if (!info) return E_POINTER;
+
+    if (info->dwSize != sizeof(DIEFFECTINFOW)) return DIERR_INVALIDPARAM;
+
+    info->guid = *rguid;
+
+    info->dwEffType = type;
+    /* the event device API does not support querying for all these things
+     * therefore we assume that we have support for them
+     * that's not as dangerous as it sounds, since drivers are allowed to
+     * ignore parameters they claim to support anyway */
+    info->dwEffType |= DIEFT_DEADBAND | DIEFT_FFATTACK | DIEFT_FFFADE
+                    | DIEFT_POSNEGCOEFFICIENTS | DIEFT_POSNEGSATURATION
+                    | DIEFT_SATURATION | DIEFT_STARTDELAY;
+
+    /* again, assume we have support for everything */
+    info->dwStaticParams = DIEP_ALLPARAMS;
+    info->dwDynamicParams = info->dwStaticParams;
+
+    /* yes, this is windows behavior (print the GUID_Name for name) */
+    MultiByteToWideChar(CP_ACP, 0, _dump_dinput_GUID(rguid), -1,
+                        info->tszName, MAX_PATH);
+
+    return DI_OK;
+}
+
+#endif
diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 8ef53108a9b..956ed49a306 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -58,6 +58,12 @@ typedef struct JoystickImpl JoystickImpl;
 static const IDirectInputDevice8AVtbl JoystickAvt;
 static const IDirectInputDevice8WVtbl JoystickWvt;
 
+/* implemented in effect_sdl.c */
+HRESULT sdl_create_effect(SDL_Haptic *haptic, REFGUID rguid, struct list *parent_list_entry, LPDIRECTINPUTEFFECT* peff);
+HRESULT sdl_input_get_info_A(SDL_Joystick *dev, REFGUID rguid, LPDIEFFECTINFOA info);
+HRESULT sdl_input_get_info_W(SDL_Joystick *dev, REFGUID rguid, LPDIEFFECTINFOW info);
+
+
 struct SDLDev {
     int id;
     WORD vendor_id;
@@ -727,6 +733,67 @@ static HRESULT WINAPI JoystickWImpl_GetDeviceInfo(LPDIRECTINPUTDEVICE8W iface,
     return DI_OK;
 }
 
+static HRESULT WINAPI JoystickWImpl_CreateEffect(IDirectInputDevice8W *iface,
+        const GUID *rguid, const DIEFFECT *lpeff, IDirectInputEffect **ppdef,
+        IUnknown *pUnkOuter)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT retval = DI_OK;
+    effect_list_item* new_effect = NULL;
+
+    TRACE("%p %s %p %p %p\n", iface, debugstr_guid(rguid), lpeff, ppdef, pUnkOuter);
+    if (lpeff) dump_DIEFFECT(lpeff, rguid, 0);
+
+    if(!This->sdldev->has_ff){
+        TRACE("No force feedback support\n");
+        *ppdef = NULL;
+        return DIERR_UNSUPPORTED;
+    }
+
+    if (pUnkOuter)
+        WARN("aggregation not implemented\n");
+
+    if (!(new_effect = HeapAlloc(GetProcessHeap(), 0, sizeof(*new_effect))))
+    return DIERR_OUTOFMEMORY;
+
+    retval = sdl_create_effect(This->haptic, rguid, &new_effect->entry, &new_effect->ref);
+    if (retval != DI_OK)
+    {
+        HeapFree(GetProcessHeap(), 0, new_effect);
+        return retval;
+    }
+
+    if (lpeff != NULL)
+    {
+        retval = IDirectInputEffect_SetParameters(new_effect->ref, lpeff, 0);
+
+        if (retval != DI_OK && retval != DI_DOWNLOADSKIPPED)
+        {
+            HeapFree(GetProcessHeap(), 0, new_effect);
+            return retval;
+        }
+    }
+
+    list_add_tail(&This->sdldev->effects, &new_effect->entry);
+    *ppdef = new_effect->ref;
+
+    TRACE("allocated effect: %p\n", new_effect);
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_CreateEffect(IDirectInputDevice8A *iface,
+        const GUID *type, const DIEFFECT *params, IDirectInputEffect **out,
+        IUnknown *outer)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("%p %s %p %p %p\n", iface, debugstr_guid(type), params, out, outer);
+
+    return JoystickWImpl_CreateEffect(&This->generic.base.IDirectInputDevice8W_iface,
+            type, params, out, outer);
+}
+
 static HRESULT WINAPI JoystickWImpl_EnumEffects(LPDIRECTINPUTDEVICE8W iface,
                                                 LPDIENUMEFFECTSCALLBACKW lpCallback,
                                                 LPVOID pvRef,
@@ -889,6 +956,24 @@ static HRESULT WINAPI JoystickAImpl_EnumEffects(LPDIRECTINPUTDEVICE8A iface,
     return DI_OK;
 }
 
+static HRESULT WINAPI JoystickWImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8W iface,
+                                                  LPDIEFFECTINFOW pdei,
+                                                  REFGUID guid)
+{
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+    TRACE("(this=%p,%p,%s)\n", This, pdei, _dump_dinput_GUID(guid));
+    return sdl_input_get_info_W(This->device, guid, pdei);
+}
+
+static HRESULT WINAPI JoystickAImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8A iface,
+                          LPDIEFFECTINFOA pdei,
+                          REFGUID guid)
+{
+    JoystickImpl* This = impl_from_IDirectInputDevice8A(iface);
+    TRACE("(this=%p,%p,%s)\n", This, pdei, _dump_dinput_GUID(guid));
+    return sdl_input_get_info_A(This->device, guid, pdei);
+}
+
 static HRESULT WINAPI JoystickWImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8W iface, DWORD dwFlags)
 {
     JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
@@ -990,9 +1075,9 @@ static const IDirectInputDevice8AVtbl JoystickAvt =
     JoystickAImpl_GetDeviceInfo,
     IDirectInputDevice2AImpl_RunControlPanel,
     IDirectInputDevice2AImpl_Initialize,
-    IDirectInputDevice2AImpl_CreateEffect,
+    JoystickAImpl_CreateEffect,
     JoystickAImpl_EnumEffects,
-    IDirectInputDevice2AImpl_GetEffectInfo,
+    JoystickAImpl_GetEffectInfo,
     IDirectInputDevice2AImpl_GetForceFeedbackState,
     JoystickAImpl_SendForceFeedbackCommand,
     JoystickAImpl_EnumCreatedEffectObjects,
@@ -1026,9 +1111,9 @@ static const IDirectInputDevice8WVtbl JoystickWvt =
     JoystickWImpl_GetDeviceInfo,
     IDirectInputDevice2WImpl_RunControlPanel,
     IDirectInputDevice2WImpl_Initialize,
-    IDirectInputDevice2WImpl_CreateEffect,
+    JoystickWImpl_CreateEffect,
     JoystickWImpl_EnumEffects,
-    IDirectInputDevice2WImpl_GetEffectInfo,
+    JoystickWImpl_GetEffectInfo,
     IDirectInputDevice2WImpl_GetForceFeedbackState,
     JoystickWImpl_SendForceFeedbackCommand,
     JoystickWImpl_EnumCreatedEffectObjects,
From 5e4372c8d20b06e0a416974f8ca8dd7efd187bed Mon Sep 17 00:00:00 2001
From: Aric Stewart <aric@codeweavers.com>
Date: Mon, 8 Jan 2018 07:48:06 -0600
Subject: [PATCH] dinput: implement DISFFC_PAUSE/DISFFC_CONTINUE for SDL

Signed-off-by: Aric Stewart <aric@codeweavers.com>
---
 dlls/dinput/joystick_sdl.c | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 956ed49a306..92fe99a9f21 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -83,6 +83,7 @@ struct JoystickImpl
 
     SDL_Joystick *device;
     SDL_Haptic *haptic;
+    BOOL ff_paused;
 };
 
 static inline JoystickImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
@@ -753,6 +754,12 @@ static HRESULT WINAPI JoystickWImpl_CreateEffect(IDirectInputDevice8W *iface,
     if (pUnkOuter)
         WARN("aggregation not implemented\n");
 
+    if (This->ff_paused)
+    {
+        FIXME("Cannot add new effects to a paused SDL device\n");
+        return DIERR_GENERIC;
+    }
+
     if (!(new_effect = HeapAlloc(GetProcessHeap(), 0, sizeof(*new_effect))))
     return DIERR_OUTOFMEMORY;
 
@@ -1004,8 +1011,14 @@ static HRESULT WINAPI JoystickWImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE
         break;
     }
     case DISFFC_PAUSE:
+        This->ff_paused = TRUE;
+        if (SDL_HapticPause(This->haptic) != 0)
+            ERR("SDL_HapticPause failed: %s\n",SDL_GetError());
+        break;
     case DISFFC_CONTINUE:
-        FIXME("No support for Pause or Continue in sdl\n");
+        This->ff_paused = FALSE;
+        if (SDL_HapticUnpause(This->haptic) != 0)
+            ERR("SDL_HapticUnpause failed: %s\n",SDL_GetError());
         break;
 
     case DISFFC_SETACTUATORSOFF:
From 75c5ff61c8bbceff0af0bdfdf40cf2cf79732456 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 28 Aug 2018 10:35:08 -0500
Subject: [PATCH] dinput: Don't fail to load on old SDL

---
 dlls/dinput/joystick_sdl.c | 23 +++++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 92fe99a9f21..77e7fd83104 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -112,6 +113,9 @@ static struct SDLDev *sdldevs = NULL;
 static void find_sdldevs(void)
 {
     int i;
+    Uint16 (*pSDL_JoystickGetProduct)(SDL_Joystick * joystick) = NULL;
+    Uint16 (*pSDL_JoystickGetVendor)(SDL_Joystick * joystick) = NULL;
+    void *sdl_handle = NULL;
 
     if (InterlockedCompareExchange(&have_sdldevs, 0, -1) != -1)
         /* Someone beat us to it */
@@ -120,6 +124,16 @@ static void find_sdldevs(void)
     SDL_Init(SDL_INIT_JOYSTICK|SDL_INIT_HAPTIC);
     SDL_JoystickEventState(SDL_ENABLE);
 
+    sdl_handle = dlopen(SONAME_LIBSDL2, RTLD_NOW);
+    if (sdl_handle) {
+        pSDL_JoystickGetProduct = dlsym(sdl_handle, "SDL_JoystickGetProduct");
+        pSDL_JoystickGetVendor = dlsym(sdl_handle, "SDL_JoystickGetVendor");
+    }
+
+    if(!pSDL_JoystickGetVendor){
+        ERR("SDL installation is old! Please upgrade to >=2.0.6 to get accurate joystick information.\n");
+    }
+
     for (i = 0; i < SDL_NumJoysticks(); i++)
     {
         struct SDLDev sdldev = {0};
@@ -152,8 +166,13 @@ static void find_sdldevs(void)
             }
         }
 
-        sdldev.vendor_id = SDL_JoystickGetVendor(device);
-        sdldev.product_id = SDL_JoystickGetProduct(device);
+        if(pSDL_JoystickGetVendor){
+            sdldev.vendor_id = pSDL_JoystickGetVendor(device);
+            sdldev.product_id = pSDL_JoystickGetProduct(device);
+        }else{
+            sdldev.vendor_id = 0x01;
+            sdldev.product_id = SDL_JoystickInstanceID(device) + 1;
+        }
 
         if (!have_sdldevs)
             new_sdldevs = HeapAlloc(GetProcessHeap(), 0, sizeof(struct SDLDev));
From fc47e8c6c20a941fde487457a2dae8e9d67e97b7 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 8 May 2019 12:35:47 -0500
Subject: [PATCH] dinput: Assign joystick/gamepad for SDL devices

---
 dlls/dinput/joystick_sdl.c | 17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 77e7fd83104..e9c130efed2 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -71,7 +71,7 @@ struct SDLDev {
     WORD product_id;
     CHAR *name;
 
-    BOOL has_ff;
+    BOOL has_ff, is_joystick;
     int autocenter;
     int gain;
     struct list effects;
@@ -174,6 +174,14 @@ static void find_sdldevs(void)
             sdldev.product_id = SDL_JoystickInstanceID(device) + 1;
         }
 
+        {
+            SDL_JoystickType type = SDL_JoystickGetType(device);
+            sdldev.is_joystick =
+                type == SDL_JOYSTICK_TYPE_WHEEL ||
+                type == SDL_JOYSTICK_TYPE_FLIGHT_STICK ||
+                type == SDL_JOYSTICK_TYPE_THROTTLE;
+        }
+
         if (!have_sdldevs)
             new_sdldevs = HeapAlloc(GetProcessHeap(), 0, sizeof(struct SDLDev));
         else
@@ -204,17 +212,14 @@ static void fill_joystick_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD ver
     lpddi->guidProduct.Data1 = MAKELONG(sdldevs[id].vendor_id, sdldevs[id].product_id);
     lpddi->guidFFDriver = GUID_NULL;
 
-    if (version >= 0x0800)
-        lpddi->dwDevType = DI8DEVTYPE_JOYSTICK | (DI8DEVTYPEJOYSTICK_STANDARD << 8);
-    else
-        lpddi->dwDevType = DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8);
+    lpddi->dwDevType = get_device_type(version, sdldevs[id].is_joystick);
 
     /* Assume the joystick as HID if it is attached to USB bus and has a valid VID/PID */
     if ( sdldevs[id].vendor_id && sdldevs[id].product_id)
     {
         lpddi->dwDevType |= DIDEVTYPE_HID;
         lpddi->wUsagePage = 0x01; /* Desktop */
-        if (lpddi->dwDevType == DI8DEVTYPE_JOYSTICK || lpddi->dwDevType == DIDEVTYPE_JOYSTICK)
+        if (sdldevs[id].is_joystick)
             lpddi->wUsage = 0x04; /* Joystick */
         else
             lpddi->wUsage = 0x05; /* Game Pad */
From 1b2696cb76148cc18dce7dfc1666f791112eeea3 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 10 May 2019 08:02:01 -0500
Subject: [PATCH] dinput: For SDL, also allow enumeration of joysticks with
 DirectX 3.

---
 dlls/dinput/joystick_sdl.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index e9c130efed2..1b49663fccd 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -261,7 +261,7 @@ static HRESULT sdl_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTAN
   }
 
   if (!((dwDevType == 0) ||
-        ((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+        ((dwDevType == DIDEVTYPE_JOYSTICK) && (version >= 0x0300 && version < 0x0800)) ||
         (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
     return S_FALSE;
 
@@ -281,7 +281,7 @@ static HRESULT sdl_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTAN
   }
 
   if (!((dwDevType == 0) ||
-        ((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+        ((dwDevType == DIDEVTYPE_JOYSTICK) && (version >= 0x0300 && version < 0x0800)) ||
         (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
     return S_FALSE;
 
From f18256fc10b80cf63fafacd28d4cb1c7a26f4151 Mon Sep 17 00:00:00 2001
From: Alexey Prokhin <alexey@prokhin.ru>
Date: Wed, 15 May 2019 00:04:58 +0300
Subject: [PATCH] dinput: return fake DIPROP_GUIDANDPATH property for SDL
 devices

Treaks some games such as AC Unity, AC Rouge, Far Cry 5 into exclusively using xinput for gamepads.
---
 dlls/dinput/joystick_sdl.c | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 1b49663fccd..7f4b4e674f9 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -45,6 +45,7 @@
 #include "winbase.h"
 #include "winerror.h"
 #include "winreg.h"
+#include "devguid.h"
 #include "dinput.h"
 
 #include "dinput_private.h"
@@ -70,6 +71,7 @@ struct SDLDev {
     WORD vendor_id;
     WORD product_id;
     CHAR *name;
+    BOOL is_xbox_gamepad;
 
     BOOL has_ff, is_joystick;
     int autocenter;
@@ -180,6 +182,11 @@ static void find_sdldevs(void)
                 type == SDL_JOYSTICK_TYPE_WHEEL ||
                 type == SDL_JOYSTICK_TYPE_FLIGHT_STICK ||
                 type == SDL_JOYSTICK_TYPE_THROTTLE;
+
+            if (SDL_IsGameController(i))
+                sdldev.is_xbox_gamepad = TRUE;
+            else
+                sdldev.is_xbox_gamepad  = SDL_JoystickNumAxes(device) == 6 && SDL_JoystickNumButtons(device) >= 14;
         }
 
         if (!have_sdldevs)
@@ -644,6 +651,26 @@ static HRESULT WINAPI JoystickWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REF
             break;
         }
 
+        case (DWORD_PTR) DIPROP_GUIDANDPATH:
+        {
+            static const WCHAR formatW[] = {'\\','\\','?','\\','h','i','d','#','v','i','d','_','%','0','4','x','&',
+                                            'p','i','d','_','%','0','4','x','&','%','s','_','%','i',0};
+            static const WCHAR miW[] = {'m','i',0};
+            static const WCHAR igW[] = {'i','g',0};
+
+            LPDIPROPGUIDANDPATH pd = (LPDIPROPGUIDANDPATH)pdiph;
+
+            if (!This->sdldev->product_id || !This->sdldev->vendor_id)
+                return DIERR_UNSUPPORTED;
+
+            pd->guidClass = GUID_DEVCLASS_HIDCLASS;
+            sprintfW(pd->wszPath, formatW, This->sdldev->vendor_id, This->sdldev->product_id,
+                     This->sdldev->is_xbox_gamepad ? igW : miW, This->sdldev->id);
+
+            TRACE("DIPROP_GUIDANDPATH(%s, %s): returning fake path\n", debugstr_guid(&pd->guidClass), debugstr_w(pd->wszPath));
+            break;
+        }
+
     default:
         return JoystickWGenericImpl_GetProperty(iface, rguid, pdiph);
     }
From 94767de97cdfc31572b4357ccdcd49abf80bb919 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 16 Jul 2019 08:59:24 -0500
Subject: [PATCH] dinput: Search setupapi to find xinput devices

---
 dlls/dinput/Makefile.in    |  2 +-
 dlls/dinput/joystick.c     | 73 ++++++++++++++++++++++++++------------
 dlls/dinput/joystick_sdl.c |  5 +--
 dlls/dinput8/Makefile.in   |  2 +-
 4 files changed, 53 insertions(+), 29 deletions(-)

diff --git a/dlls/dinput/Makefile.in b/dlls/dinput/Makefile.in
index 8dfebb665fb..b2e80668d1b 100644
--- a/dlls/dinput/Makefile.in
+++ b/dlls/dinput/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = dinput.dll
 IMPORTLIB = dinput
-IMPORTS   = dinput dxguid uuid comctl32 ole32 user32 advapi32
+IMPORTS   = dinput dxguid uuid comctl32 ole32 user32 advapi32 setupapi hid
 EXTRADEFS = -DDIRECTINPUT_VERSION=0x0700
 EXTRALIBS = $(IOKIT_LIBS) $(FORCEFEEDBACK_LIBS) $(SDL2_LIBS)
 EXTRAINCL = $(SDL2_CFLAGS)
diff --git a/dlls/dinput/joystick.c b/dlls/dinput/joystick.c
index 2eab4d3a33d..1c73f6351c8 100644
--- a/dlls/dinput/joystick.c
+++ b/dlls/dinput/joystick.c
@@ -31,27 +31,11 @@
 #include "joystick_private.h"
 #include "wine/debug.h"
 #include "winreg.h"
+#include "setupapi.h"
+#include "ddk/hidsdi.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dinput);
 
-#define VID_MICROSOFT 0x045e
-
-static const WORD PID_XBOX_CONTROLLERS[] =  {
-    0x0202, /* Xbox Controller */
-    0x0285, /* Xbox Controller S */
-    0x0289, /* Xbox Controller S */
-    0x028e, /* Xbox360 Controller */
-    0x028f, /* Xbox360 Wireless Controller */
-    0x02d1, /* Xbox One Controller */
-    0x02dd, /* Xbox One Controller (Covert Forces/Firmware 2015) */
-    0x02e0, /* Xbox One X Controller */
-    0x02e3, /* Xbox One Elite Controller */
-    0x02e6, /* Wireless XBox Controller Dongle */
-    0x02ea, /* Xbox One S Controller */
-    0x02fd, /* Xbox One S Controller (Firmware 2017) */
-    0x0719, /* Xbox 360 Wireless Adapter */
-};
-
 /* Windows uses this GUID for guidProduct on non-keyboard/mouse devices.
  * Data1 contains the device VID (low word) and PID (high word).
  * Data4 ends with the ASCII bytes "PIDVID".
@@ -323,15 +307,58 @@ BOOL device_disabled_registry(const char* name)
 
 BOOL is_xinput_device(const DIDEVCAPS *devcaps, WORD vid, WORD pid)
 {
-    int i;
+    HDEVINFO device_info_set;
+    GUID hid_guid;
+    SP_DEVICE_INTERFACE_DATA interface_data;
+    SP_DEVICE_INTERFACE_DETAIL_DATA_W *data;
+    DWORD idx;
+    BOOL ret = FALSE;
+    char pathA[MAX_PATH];
+
+    HidD_GetHidGuid(&hid_guid);
+    hid_guid.Data4[7]++; /* HACK: look up the xinput-specific devices */
+
+    device_info_set = SetupDiGetClassDevsW(&hid_guid, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
 
-    if (vid == VID_MICROSOFT)
+    data = HeapAlloc(GetProcessHeap(), 0 , sizeof(*data) + MAX_PATH * sizeof(WCHAR));
+    data->cbSize = sizeof(*data);
+
+    ZeroMemory(&interface_data, sizeof(interface_data));
+    interface_data.cbSize = sizeof(interface_data);
+
+    idx = 0;
+    while (!ret && SetupDiEnumDeviceInterfaces(device_info_set, NULL, &hid_guid, idx++,
+           &interface_data))
     {
-        for (i = 0; i < ARRAY_SIZE(PID_XBOX_CONTROLLERS); i++)
-            if (pid == PID_XBOX_CONTROLLERS[i]) return TRUE;
+        const char *vid_s, *pid_s;
+        DWORD di_vid = 0, di_pid = 0;
+        static const WCHAR ig[] = {'I','G','_',0};
+
+        if (!SetupDiGetDeviceInterfaceDetailW(device_info_set,
+                &interface_data, data, sizeof(*data) + MAX_PATH * sizeof(WCHAR), NULL, NULL))
+            continue;
+
+        if (!strstrW(data->DevicePath, ig))
+            continue;
+
+        WideCharToMultiByte(CP_ACP, 0, data->DevicePath, -1,
+                pathA, sizeof(pathA), NULL, NULL);
+
+        vid_s = strstr(pathA, "VID_");
+        if (vid_s)
+            sscanf(vid_s, "VID_%4X", &di_vid);
+
+        pid_s = strstr(pathA, "PID_");
+        if (pid_s)
+            sscanf(pid_s, "PID_%4X", &di_pid);
+
+        ret = vid == di_vid && pid == di_pid;
     }
 
-    return (devcaps->dwAxes == 6 && devcaps->dwButtons >= 14);
+    HeapFree(GetProcessHeap(), 0, data);
+    SetupDiDestroyDeviceInfoList(device_info_set);
+
+    return ret;
 }
 
 /******************************************************************************
diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 7f4b4e674f9..89bf233d957 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -183,10 +183,7 @@ static void find_sdldevs(void)
                 type == SDL_JOYSTICK_TYPE_FLIGHT_STICK ||
                 type == SDL_JOYSTICK_TYPE_THROTTLE;
 
-            if (SDL_IsGameController(i))
-                sdldev.is_xbox_gamepad = TRUE;
-            else
-                sdldev.is_xbox_gamepad  = SDL_JoystickNumAxes(device) == 6 && SDL_JoystickNumButtons(device) >= 14;
+            sdldev.is_xbox_gamepad = is_xinput_device(NULL, sdldev.vendor_id, sdldev.product_id);
         }
 
         if (!have_sdldevs)
diff --git a/dlls/dinput8/Makefile.in b/dlls/dinput8/Makefile.in
index 0e6ef316a79..79f309d3e60 100644
--- a/dlls/dinput8/Makefile.in
+++ b/dlls/dinput8/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = dinput8.dll
 IMPORTLIB = dinput8
-IMPORTS   = dinput8 dxguid uuid comctl32 ole32 user32 advapi32
+IMPORTS   = dinput8 dxguid uuid comctl32 ole32 user32 advapi32 setupapi hid
 EXTRADEFS = -DDIRECTINPUT_VERSION=0x0800
 EXTRALIBS = $(IOKIT_LIBS) $(FORCEFEEDBACK_LIBS) $(SDL2_LIBS)
 EXTRAINCL = $(SDL2_CFLAGS)
From abf04290376e3b983874b8981e3a183076eccd3d Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 6 Aug 2019 08:42:14 -0500
Subject: [PATCH] dinput: Only enumerate SDL devices

---
 dlls/dinput/dinput_main.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
index e9008635064..1edf7602ea0 100644
--- a/dlls/dinput/dinput_main.c
+++ b/dlls/dinput/dinput_main.c
@@ -91,9 +91,6 @@ static const struct dinput_device *dinput_devices[] =
     &mouse_device,
     &keyboard_device,
     &joystick_sdl_device,
-    &joystick_linuxinput_device,
-    &joystick_linux_device,
-    &joystick_osx_device
 };
 
 HINSTANCE DINPUT_instance;
From d144a3d374fe5c180c7ab35f15e29934cb785d71 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 5 Aug 2019 10:55:26 -0500
Subject: [PATCH] dinput: Add a mapping function for specific device types

---
 dlls/dinput/joystick_sdl.c | 223 ++++++++++++++++++++++++++-----------
 1 file changed, 158 insertions(+), 65 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 89bf233d957..d8848b8aa4b 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -65,6 +65,17 @@ HRESULT sdl_create_effect(SDL_Haptic *haptic, REFGUID rguid, struct list *parent
 HRESULT sdl_input_get_info_A(SDL_Joystick *dev, REFGUID rguid, LPDIEFFECTINFOA info);
 HRESULT sdl_input_get_info_W(SDL_Joystick *dev, REFGUID rguid, LPDIEFFECTINFOW info);
 
+#define ITEM_TYPE_BUTTON 1
+#define ITEM_TYPE_AXIS 2
+#define ITEM_TYPE_HAT 3
+
+struct device_state_item {
+    int type;
+    int idx;
+    int val;
+};
+
+typedef BOOL (*enum_device_state_function)(JoystickImpl*, struct device_state_item *, int);
 
 struct SDLDev {
     int id;
@@ -73,6 +84,8 @@ struct SDLDev {
     CHAR *name;
     BOOL is_xbox_gamepad;
 
+    int n_buttons, n_axes, n_hats;
+
     BOOL has_ff, is_joystick;
     int autocenter;
     int gain;
@@ -87,6 +100,8 @@ struct JoystickImpl
     SDL_Joystick *device;
     SDL_Haptic *haptic;
     BOOL ff_paused;
+
+    enum_device_state_function enum_device_state;
 };
 
 static inline JoystickImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
@@ -186,6 +201,10 @@ static void find_sdldevs(void)
             sdldev.is_xbox_gamepad = is_xinput_device(NULL, sdldev.vendor_id, sdldev.product_id);
         }
 
+        sdldev.n_buttons = SDL_JoystickNumButtons(device);
+        sdldev.n_axes = SDL_JoystickNumAxes(device);
+        sdldev.n_hats = SDL_JoystickNumHats(device);
+
         if (!have_sdldevs)
             new_sdldevs = HeapAlloc(GetProcessHeap(), 0, sizeof(struct SDLDev));
         else
@@ -296,91 +315,151 @@ static HRESULT sdl_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTAN
   return S_FALSE;
 }
 
+/* straight 1:1 mapping of SDL items and dinput items */
+static BOOL enum_device_state_standard(JoystickImpl *This, struct device_state_item *st, int idx)
+{
+    DWORD n_buttons, n_axes, n_hats;
+
+    n_buttons = This->generic.devcaps.dwButtons ? This->generic.devcaps.dwButtons : This->sdldev->n_buttons;
+
+    if(idx < n_buttons)
+    {
+        st->type = ITEM_TYPE_BUTTON;
+        st->idx = idx;
+        st->val = SDL_JoystickGetButton(This->device, idx);
+        return TRUE;
+    }
+
+    idx -= n_buttons;
+
+    n_axes = This->generic.devcaps.dwAxes ? This->generic.devcaps.dwAxes : This->sdldev->n_axes;
+
+    if(idx < n_axes)
+    {
+        st->type = ITEM_TYPE_AXIS;
+        st->idx = idx;
+        st->val = SDL_JoystickGetAxis(This->device, idx);
+        return TRUE;
+    }
+
+    idx -= n_axes;
+
+    n_hats = This->generic.devcaps.dwPOVs ? This->generic.devcaps.dwPOVs : This->sdldev->n_hats;
+
+    if(idx < n_hats)
+    {
+        st->type = ITEM_TYPE_HAT;
+        st->idx = idx;
+        st->val = SDL_JoystickGetHat(This->device, idx);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
 static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
 {
     JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
-    int i;
+    int i = 0;
     int inst_id = 0;
     int newVal = 0;
+    struct device_state_item item;
 
     SDL_JoystickUpdate();
 
-    for (i = 0; i < SDL_JoystickNumButtons(This->device); i++)
+    while(This->enum_device_state(This, &item, i++))
     {
-        int val = SDL_JoystickGetButton(This->device, i);
-        int oldVal = This->generic.js.rgbButtons[i];
-        newVal = val ? 0x80 : 0x0;
-        This->generic.js.rgbButtons[i] = newVal;
-        if (oldVal != newVal)
+        switch(item.type){
+        case ITEM_TYPE_BUTTON:
         {
-            TRACE("Button: %i val %d oldVal %d newVal %d\n",  i, val, oldVal, newVal);
-            inst_id = DIDFT_MAKEINSTANCE(i) | DIDFT_PSHBUTTON;
-            queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
-        }
-    }
-    for (i = 0; i < SDL_JoystickNumAxes(This->device); i++)
-    {
-        int oldVal;
-        newVal = SDL_JoystickGetAxis(This->device, i);
-        newVal = joystick_map_axis(&This->generic.props[i], newVal);
-        switch (i)
-        {
-            case 0: oldVal = This->generic.js.lX;
-                    This->generic.js.lX  = newVal; break;
-            case 1: oldVal = This->generic.js.lY;
-                    This->generic.js.lY  = newVal; break;
-            case 2: oldVal = This->generic.js.lZ;
-                    This->generic.js.lZ  = newVal; break;
-            case 3: oldVal = This->generic.js.lRx;
-                    This->generic.js.lRx = newVal; break;
-            case 4: oldVal = This->generic.js.lRy;
-                    This->generic.js.lRy = newVal; break;
-            case 5: oldVal = This->generic.js.lRz;
-                    This->generic.js.lRz = newVal; break;
-            case 6: oldVal = This->generic.js.rglSlider[0];
-                    This->generic.js.rglSlider[0] = newVal; break;
-            case 7: oldVal = This->generic.js.rglSlider[1];
-                    This->generic.js.rglSlider[1] = newVal; break;
+            int val = item.val;
+            int oldVal = This->generic.js.rgbButtons[item.idx];
+            newVal = val ? 0x80 : 0x0;
+            This->generic.js.rgbButtons[item.idx] = newVal;
+            if (oldVal != newVal)
+            {
+                TRACE("Button: %i val %d oldVal %d newVal %d\n",  item.idx, val, oldVal, newVal);
+                inst_id = DIDFT_MAKEINSTANCE(item.idx) | DIDFT_PSHBUTTON;
+                queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
+            }
+            break;
         }
-        if (oldVal != newVal)
+
+        case ITEM_TYPE_AXIS:
         {
-            TRACE("Axis: %i oldVal %d newVal %d\n",  i, oldVal, newVal);
-            inst_id = DIDFT_MAKEINSTANCE(i) | DIDFT_ABSAXIS;
-            queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
+            int oldVal;
+            newVal = item.val;
+            newVal = joystick_map_axis(&This->generic.props[item.idx], newVal);
+            switch (item.idx)
+            {
+                case 0: oldVal = This->generic.js.lX;
+                        This->generic.js.lX  = newVal; break;
+                case 1: oldVal = This->generic.js.lY;
+                        This->generic.js.lY  = newVal; break;
+                case 2: oldVal = This->generic.js.lZ;
+                        This->generic.js.lZ  = newVal; break;
+                case 3: oldVal = This->generic.js.lRx;
+                        This->generic.js.lRx = newVal; break;
+                case 4: oldVal = This->generic.js.lRy;
+                        This->generic.js.lRy = newVal; break;
+                case 5: oldVal = This->generic.js.lRz;
+                        This->generic.js.lRz = newVal; break;
+                case 6: oldVal = This->generic.js.rglSlider[0];
+                        This->generic.js.rglSlider[0] = newVal; break;
+                case 7: oldVal = This->generic.js.rglSlider[1];
+                        This->generic.js.rglSlider[1] = newVal; break;
+            }
+            if (oldVal != newVal)
+            {
+                TRACE("Axis: %i oldVal %d newVal %d\n",  item.idx, oldVal, newVal);
+                inst_id = DIDFT_MAKEINSTANCE(item.idx) | DIDFT_ABSAXIS;
+                queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
+            }
+            break;
         }
-    }
-    for (i = 0; i < SDL_JoystickNumHats(This->device); i++)
-    {
-        int oldVal = This->generic.js.rgdwPOV[i];
-        newVal = SDL_JoystickGetHat(This->device, i);
-        switch (newVal)
+
+        case ITEM_TYPE_HAT:
         {
-            case SDL_HAT_CENTERED: newVal = -1; break;
-            case SDL_HAT_UP: newVal = 0; break;
-            case SDL_HAT_RIGHTUP:newVal = 4500; break;
-            case SDL_HAT_RIGHT: newVal = 9000; break;
-            case SDL_HAT_RIGHTDOWN: newVal = 13500; break;
-            case SDL_HAT_DOWN: newVal = 18000; break;
-            case SDL_HAT_LEFTDOWN: newVal = 22500; break;
-            case SDL_HAT_LEFT: newVal = 27000; break;
-            case SDL_HAT_LEFTUP: newVal = 31500; break;
+            int oldVal = This->generic.js.rgdwPOV[item.idx];
+            newVal = item.val;
+            switch (newVal)
+            {
+                case SDL_HAT_CENTERED: newVal = -1; break;
+                case SDL_HAT_UP: newVal = 0; break;
+                case SDL_HAT_RIGHTUP:newVal = 4500; break;
+                case SDL_HAT_RIGHT: newVal = 9000; break;
+                case SDL_HAT_RIGHTDOWN: newVal = 13500; break;
+                case SDL_HAT_DOWN: newVal = 18000; break;
+                case SDL_HAT_LEFTDOWN: newVal = 22500; break;
+                case SDL_HAT_LEFT: newVal = 27000; break;
+                case SDL_HAT_LEFTUP: newVal = 31500; break;
+            }
+            if (oldVal != newVal)
+            {
+                TRACE("Hat : %i oldVal %d newVal %d\n",  item.idx, oldVal, newVal);
+                This->generic.js.rgdwPOV[item.idx] = newVal;
+                inst_id = DIDFT_MAKEINSTANCE(item.idx) | DIDFT_POV;
+                queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
+            }
+            break;
         }
-        if (oldVal != newVal)
-        {
-            TRACE("Hat : %i oldVal %d newVal %d\n",  i, oldVal, newVal);
-            This->generic.js.rgdwPOV[i] = newVal;
-            inst_id = DIDFT_MAKEINSTANCE(i) | DIDFT_POV;
-            queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
         }
     }
 }
 
+static enum_device_state_function select_enum_function(struct SDLDev *sdldev)
+{
+    TRACE("for %04x/%04x, using no maps\n", sdldev->vendor_id, sdldev->product_id);
+    return enum_device_state_standard;
+}
+
 static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsigned short index)
 {
     JoystickImpl* newDevice;
     LPDIDATAFORMAT df = NULL;
     DIDEVICEINSTANCEW ddi;
-    int i,idx = 0;
+    int i,idx = 0, axis_count = 0, button_count = 0, hat_count = 0;
+    struct device_state_item item;
 
     newDevice = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(JoystickImpl));
     if (!newDevice) return NULL;
@@ -390,6 +469,7 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     newDevice->generic.guidProduct = DInput_PIDVID_Product_GUID;
     newDevice->generic.guidProduct.Data1 = MAKELONG(sdldevs[index].vendor_id, sdldevs[index].product_id);
     newDevice->generic.joy_polldev = poll_sdl_device_state;
+    newDevice->enum_device_state = select_enum_function(&sdldevs[index]);
 
     newDevice->generic.base.IDirectInputDevice8A_iface.lpVtbl = &JoystickAvt;
     newDevice->generic.base.IDirectInputDevice8W_iface.lpVtbl = &JoystickWvt;
@@ -409,9 +489,22 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     newDevice->device = SDL_JoystickOpen(newDevice->sdldev->id);
     newDevice->haptic = SDL_HapticOpenFromJoystick(newDevice->device);
 
-    /* Count number of available axes - supported Axis & POVs */
-    newDevice->generic.devcaps.dwAxes = SDL_JoystickNumAxes(newDevice->device);
+    i = 0;
+    while(newDevice->enum_device_state(newDevice, &item, i++)){
+        switch(item.type){
+            case ITEM_TYPE_BUTTON:
+                ++button_count;
+                break;
+            case ITEM_TYPE_AXIS:
+                ++axis_count;
+                break;
+            case ITEM_TYPE_HAT:
+                ++hat_count;
+                break;
+        }
+    }
 
+    newDevice->generic.devcaps.dwAxes = axis_count;
     if (newDevice->generic.devcaps.dwAxes > 8 )
     {
         WARN("Can't support %d axis. Clamping down to 8\n", newDevice->generic.devcaps.dwAxes);
@@ -428,14 +521,14 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
         newDevice->generic.props[i].lSaturation = 0;
     }
 
-    newDevice->generic.devcaps.dwPOVs = SDL_JoystickNumHats(newDevice->device);
+    newDevice->generic.devcaps.dwPOVs = hat_count;
     if (newDevice->generic.devcaps.dwPOVs > 4)
     {
         WARN("Can't support %d POV. Clamping down to 4\n", newDevice->generic.devcaps.dwPOVs);
         newDevice->generic.devcaps.dwPOVs = 4;
     }
 
-    newDevice->generic.devcaps.dwButtons = SDL_JoystickNumButtons(newDevice->device);
+    newDevice->generic.devcaps.dwButtons = button_count;
     if (newDevice->generic.devcaps.dwButtons > 128)
     {
         WARN("Can't support %d buttons. Clamping down to 128\n", newDevice->generic.devcaps.dwButtons);
From 4eb1d7a69dc1836b32aa67ba7cee78d9d1a80bd3 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 5 Aug 2019 11:38:25 -0500
Subject: [PATCH] dinput: Add mappings for dualshock 4 controllers

---
 dlls/dinput/joystick_sdl.c | 321 +++++++++++++++++++++++++++++++------
 1 file changed, 274 insertions(+), 47 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index d8848b8aa4b..2914a8c43d2 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -71,7 +71,7 @@ HRESULT sdl_input_get_info_W(SDL_Joystick *dev, REFGUID rguid, LPDIEFFECTINFOW i
 
 struct device_state_item {
     int type;
-    int idx;
+    int id;
     int val;
 };
 
@@ -315,6 +315,213 @@ static HRESULT sdl_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTAN
   return S_FALSE;
 }
 
+static int buttons_to_sdl_hat(int u, int r, int d, int l)
+{
+    if(u == d)
+    {
+        if(l == r)
+            return SDL_HAT_CENTERED;
+        if(l)
+            return SDL_HAT_LEFT;
+        return SDL_HAT_RIGHT;
+    }
+    if(u)
+    {
+        if(l == r)
+            return SDL_HAT_UP;
+        if(l)
+            return SDL_HAT_LEFTUP;
+        return SDL_HAT_RIGHTUP;
+    }
+    if(l == r)
+        return SDL_HAT_DOWN;
+    if(l)
+        return SDL_HAT_LEFTDOWN;
+    return SDL_HAT_RIGHTDOWN;
+}
+
+/* playstation controllers */
+#define VID_SONY 0x054c
+#define PID_SONY_DUALSHOCK_4 0x05c4
+#define PID_SONY_DUALSHOCK_4_2 0x09cc
+#define PID_SONY_DUALSHOCK_4_DONGLE 0x0ba0
+
+static BOOL enum_device_state_ds4_16button(JoystickImpl *This, struct device_state_item *st, int idx)
+{
+#define SPECIALCASE_HAT -1
+#define SPECIALCASE_L2_BUTTON -2
+#define SPECIALCASE_R2_BUTTON -3
+
+    static const struct {
+        int type;
+        int sdl_idx;
+        int dnp_id;
+    } map_ds4_16button[] = {
+        { ITEM_TYPE_AXIS, 3, 5 }, /* R2 */
+        { ITEM_TYPE_AXIS, 2, 2 }, /* L2 */
+        { ITEM_TYPE_AXIS, 1, 1 }, /* left vert */
+        { ITEM_TYPE_AXIS, 0, 0 }, /* left horiz */
+
+        { ITEM_TYPE_HAT, SPECIALCASE_HAT, 0 }, /* d-pad */
+
+        { ITEM_TYPE_BUTTON, 2, 0}, /* square */
+        { ITEM_TYPE_BUTTON, 0, 1}, /* cross */
+        { ITEM_TYPE_BUTTON, 1, 2}, /* circle */
+        { ITEM_TYPE_BUTTON, 3, 3}, /* triangle */
+
+        { ITEM_TYPE_BUTTON, 9, 4}, /* L1 */
+        { ITEM_TYPE_BUTTON, 10, 5}, /* R1 */
+        { ITEM_TYPE_BUTTON, SPECIALCASE_L2_BUTTON, 6}, /* L2 button */
+        { ITEM_TYPE_BUTTON, SPECIALCASE_R2_BUTTON, 7}, /* R2 button */
+        { ITEM_TYPE_BUTTON, 4, 8}, /* share */
+        { ITEM_TYPE_BUTTON, 6, 9}, /* options */
+
+        { ITEM_TYPE_BUTTON, 7, 10}, /* guide */
+        { ITEM_TYPE_BUTTON, 8, 11}, /* L3 */
+        { ITEM_TYPE_BUTTON, 5, 12}, /* R3 */
+
+        { ITEM_TYPE_BUTTON, 15, 13}, /* touchpad button */
+
+        { ITEM_TYPE_AXIS, 5, 4 }, /* right vert */
+        { ITEM_TYPE_AXIS, 4, 3 }, /* right horiz */
+    };
+
+    if(idx >= ARRAY_SIZE(map_ds4_16button))
+        return FALSE;
+
+    st->type = map_ds4_16button[idx].type;
+    st->id = map_ds4_16button[idx].dnp_id;
+
+    if(map_ds4_16button[idx].sdl_idx >= 0)
+    {
+        /* simple reads */
+        switch(map_ds4_16button[idx].type)
+        {
+        case ITEM_TYPE_BUTTON:
+            st->val = SDL_JoystickGetButton(This->device, map_ds4_16button[idx].sdl_idx);
+            return TRUE;
+
+        case ITEM_TYPE_AXIS:
+            st->val = SDL_JoystickGetAxis(This->device, map_ds4_16button[idx].sdl_idx);
+            return TRUE;
+
+        case ITEM_TYPE_HAT:
+            st->val = SDL_JoystickGetHat(This->device, map_ds4_16button[idx].sdl_idx);
+            return TRUE;
+        }
+    }
+
+    switch(map_ds4_16button[idx].sdl_idx){
+    case SPECIALCASE_HAT:
+    {
+        /* d-pad */
+        static const int SDL_DPAD_UP_BUTTON = 11;
+        static const int SDL_DPAD_DOWN_BUTTON = 12;
+        static const int SDL_DPAD_LEFT_BUTTON = 13;
+        static const int SDL_DPAD_RIGHT_BUTTON = 14;
+        st->val = buttons_to_sdl_hat(
+                SDL_JoystickGetButton(This->device, SDL_DPAD_UP_BUTTON),
+                SDL_JoystickGetButton(This->device, SDL_DPAD_RIGHT_BUTTON),
+                SDL_JoystickGetButton(This->device, SDL_DPAD_DOWN_BUTTON),
+                SDL_JoystickGetButton(This->device, SDL_DPAD_LEFT_BUTTON));
+        return TRUE;
+    }
+
+    case SPECIALCASE_L2_BUTTON :
+    {
+        /* L2 button */
+        /* turn button on at about 1/8 of the trigger travel */
+        static const int SDL_L2_AXIS = 4;
+        st->val = SDL_JoystickGetAxis(This->device, SDL_L2_AXIS) > 3 * SDL_JOYSTICK_AXIS_MIN / 4;
+        return TRUE;
+    }
+
+    case SPECIALCASE_R2_BUTTON:
+    {
+        /* R2 button */
+        /* turn button on at about 1/8 of the trigger travel */
+        static const int SDL_R2_AXIS = 5;
+        st->val = SDL_JoystickGetAxis(This->device, SDL_R2_AXIS) > 3 * SDL_JOYSTICK_AXIS_MIN / 4;
+        return TRUE;
+    }
+    }
+
+    ERR("???\n"); /* error in static data above */
+    return FALSE;
+
+#undef SPECIALCASE_HAT
+#undef SPECIALCASE_L2_BUTTON
+#undef SPECIALCASE_R2_BUTTON
+}
+
+static BOOL enum_device_state_ds4_13button(JoystickImpl *This, struct device_state_item *st, int idx)
+{
+    static const struct {
+        int type;
+        int sdl_idx;
+        int dnp_id;
+    } map_ds4_13button[] = {
+        { ITEM_TYPE_AXIS, 4, 5 }, /* R2 */
+        { ITEM_TYPE_AXIS, 3, 2 }, /* L2 */
+        { ITEM_TYPE_AXIS, 1, 1 }, /* left vert */
+        { ITEM_TYPE_AXIS, 0, 0 }, /* left horiz */
+
+        { ITEM_TYPE_HAT, 0, 0 }, /* d-pad */
+
+        { ITEM_TYPE_BUTTON, 3, 0}, /* square */
+        { ITEM_TYPE_BUTTON, 0, 1}, /* cross */
+        { ITEM_TYPE_BUTTON, 1, 2}, /* circle */
+        { ITEM_TYPE_BUTTON, 2, 3}, /* triangle */
+
+        { ITEM_TYPE_BUTTON, 4, 4}, /* L1 */
+        { ITEM_TYPE_BUTTON, 5, 5}, /* R1 */
+        { ITEM_TYPE_BUTTON, 6, 6}, /* L2 button */
+        { ITEM_TYPE_BUTTON, 7, 7}, /* R2 button */
+        { ITEM_TYPE_BUTTON, 8, 8}, /* share */
+        { ITEM_TYPE_BUTTON, 9, 9}, /* options */
+
+        { ITEM_TYPE_BUTTON, 11, 10}, /* guide */
+        { ITEM_TYPE_BUTTON, 12, 11}, /* L3 */
+        { ITEM_TYPE_BUTTON, 10, 12}, /* R3 */
+
+        /* ps4 controller through linux event API does not support touchpad button */
+        { ITEM_TYPE_BUTTON, -1, 13}, /* touchpad button */
+
+        { ITEM_TYPE_AXIS, 5, 4 }, /* right vert */
+        { ITEM_TYPE_AXIS, 2, 3 }, /* right horiz */
+    };
+
+    if(idx >= ARRAY_SIZE(map_ds4_13button))
+        return FALSE;
+
+    st->type = map_ds4_13button[idx].type;
+    st->id = map_ds4_13button[idx].dnp_id;
+
+    if(map_ds4_13button[idx].sdl_idx < 0)
+    {
+        st->val = 0;
+        return TRUE;
+    }
+
+    switch(map_ds4_13button[idx].type)
+    {
+    case ITEM_TYPE_BUTTON:
+        st->val = SDL_JoystickGetButton(This->device, map_ds4_13button[idx].sdl_idx);
+        return TRUE;
+
+    case ITEM_TYPE_AXIS:
+        st->val = SDL_JoystickGetAxis(This->device, map_ds4_13button[idx].sdl_idx);
+        return TRUE;
+
+    case ITEM_TYPE_HAT:
+        st->val = SDL_JoystickGetHat(This->device, map_ds4_13button[idx].sdl_idx);
+        return TRUE;
+    }
+
+    ERR("???\n"); /* error in static data above */
+    return FALSE;
+}
+
 /* straight 1:1 mapping of SDL items and dinput items */
 static BOOL enum_device_state_standard(JoystickImpl *This, struct device_state_item *st, int idx)
 {
@@ -325,7 +532,7 @@ static BOOL enum_device_state_standard(JoystickImpl *This, struct device_state_i
     if(idx < n_buttons)
     {
         st->type = ITEM_TYPE_BUTTON;
-        st->idx = idx;
+        st->id = idx;
         st->val = SDL_JoystickGetButton(This->device, idx);
         return TRUE;
     }
@@ -337,7 +544,7 @@ static BOOL enum_device_state_standard(JoystickImpl *This, struct device_state_i
     if(idx < n_axes)
     {
         st->type = ITEM_TYPE_AXIS;
-        st->idx = idx;
+        st->id = idx;
         st->val = SDL_JoystickGetAxis(This->device, idx);
         return TRUE;
     }
@@ -349,7 +556,7 @@ static BOOL enum_device_state_standard(JoystickImpl *This, struct device_state_i
     if(idx < n_hats)
     {
         st->type = ITEM_TYPE_HAT;
-        st->idx = idx;
+        st->id = idx;
         st->val = SDL_JoystickGetHat(This->device, idx);
         return TRUE;
     }
@@ -373,13 +580,13 @@ static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
         case ITEM_TYPE_BUTTON:
         {
             int val = item.val;
-            int oldVal = This->generic.js.rgbButtons[item.idx];
+            int oldVal = This->generic.js.rgbButtons[item.id];
             newVal = val ? 0x80 : 0x0;
-            This->generic.js.rgbButtons[item.idx] = newVal;
+            This->generic.js.rgbButtons[item.id] = newVal;
             if (oldVal != newVal)
             {
-                TRACE("Button: %i val %d oldVal %d newVal %d\n",  item.idx, val, oldVal, newVal);
-                inst_id = DIDFT_MAKEINSTANCE(item.idx) | DIDFT_PSHBUTTON;
+                TRACE("Button: %i val %d oldVal %d newVal %d\n",  item.id, val, oldVal, newVal);
+                inst_id = DIDFT_MAKEINSTANCE(item.id) | DIDFT_PSHBUTTON;
                 queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
             }
             break;
@@ -387,10 +594,13 @@ static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
 
         case ITEM_TYPE_AXIS:
         {
-            int oldVal;
+            int oldVal, obj;
+
+            obj = id_to_object(This->generic.base.data_format.wine_df, DIDFT_MAKEINSTANCE(item.id) | DIDFT_ABSAXIS);
             newVal = item.val;
-            newVal = joystick_map_axis(&This->generic.props[item.idx], newVal);
-            switch (item.idx)
+            newVal = joystick_map_axis(&This->generic.props[obj], newVal);
+
+            switch (item.id)
             {
                 case 0: oldVal = This->generic.js.lX;
                         This->generic.js.lX  = newVal; break;
@@ -411,8 +621,8 @@ static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
             }
             if (oldVal != newVal)
             {
-                TRACE("Axis: %i oldVal %d newVal %d\n",  item.idx, oldVal, newVal);
-                inst_id = DIDFT_MAKEINSTANCE(item.idx) | DIDFT_ABSAXIS;
+                TRACE("Axis: %i oldVal %d newVal %d\n",  item.id, oldVal, newVal);
+                inst_id = DIDFT_MAKEINSTANCE(item.id) | DIDFT_ABSAXIS;
                 queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
             }
             break;
@@ -420,7 +630,7 @@ static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
 
         case ITEM_TYPE_HAT:
         {
-            int oldVal = This->generic.js.rgdwPOV[item.idx];
+            int oldVal = This->generic.js.rgdwPOV[item.id];
             newVal = item.val;
             switch (newVal)
             {
@@ -436,9 +646,9 @@ static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
             }
             if (oldVal != newVal)
             {
-                TRACE("Hat : %i oldVal %d newVal %d\n",  item.idx, oldVal, newVal);
-                This->generic.js.rgdwPOV[item.idx] = newVal;
-                inst_id = DIDFT_MAKEINSTANCE(item.idx) | DIDFT_POV;
+                TRACE("Hat : %i oldVal %d newVal %d\n",  item.id, oldVal, newVal);
+                This->generic.js.rgdwPOV[item.id] = newVal;
+                inst_id = DIDFT_MAKEINSTANCE(item.id) | DIDFT_POV;
                 queue_event(iface, inst_id, newVal, GetCurrentTime(), This->generic.base.dinput->evsequence++);
             }
             break;
@@ -449,6 +659,23 @@ static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
 
 static enum_device_state_function select_enum_function(struct SDLDev *sdldev)
 {
+    switch(sdldev->vendor_id){
+    case VID_SONY:
+        switch(sdldev->product_id){
+        case PID_SONY_DUALSHOCK_4:
+        case PID_SONY_DUALSHOCK_4_2:
+        case PID_SONY_DUALSHOCK_4_DONGLE:
+            TRACE("for %04x/%04x, polling ds4 controller\n", sdldev->vendor_id, sdldev->product_id);
+            if(sdldev->n_buttons >= 16)
+                return enum_device_state_ds4_16button;
+
+            TRACE("SDL only reports %u buttons for this PS4 controller. Please upgrade SDL to > 2.0.10 and/or give your user hidraw access.\n",
+                    sdldev->n_buttons);
+            return enum_device_state_ds4_13button;
+        }
+        break;
+    }
+
     TRACE("for %04x/%04x, using no maps\n", sdldev->vendor_id, sdldev->product_id);
     return enum_device_state_standard;
 }
@@ -511,16 +738,6 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
         newDevice->generic.devcaps.dwAxes = 8;
     }
 
-    for (i = 0; i < newDevice->generic.devcaps.dwAxes; i++)
-    {
-        newDevice->generic.props[i].lDevMin = -32768;
-        newDevice->generic.props[i].lDevMax = 32767;
-        newDevice->generic.props[i].lMin =  0;
-        newDevice->generic.props[i].lMax =  0xffff;
-        newDevice->generic.props[i].lDeadZone = 0;
-        newDevice->generic.props[i].lSaturation = 0;
-    }
-
     newDevice->generic.devcaps.dwPOVs = hat_count;
     if (newDevice->generic.devcaps.dwPOVs > 4)
     {
@@ -544,26 +761,36 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     df->dwNumObjs = newDevice->generic.devcaps.dwAxes + newDevice->generic.devcaps.dwPOVs + newDevice->generic.devcaps.dwButtons;
     if (!(df->rgodf = HeapAlloc(GetProcessHeap(), 0, df->dwNumObjs * df->dwObjSize))) goto failed;
 
-    for (i = 0; i < newDevice->generic.devcaps.dwAxes; i++)
-    {
-        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[idx], df->dwObjSize);
-        df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(idx) | DIDFT_ABSAXIS;
-        if (newDevice->sdldev->has_ff && i < 2)
-             df->rgodf[idx].dwFlags |= DIDOI_FFACTUATOR;
-        ++idx;
-    }
-
-    for (i = 0; i < newDevice->generic.devcaps.dwPOVs; i++)
-    {
-        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[i + 8], df->dwObjSize);
-        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_POV;
-    }
-
-    for (i = 0; i < newDevice->generic.devcaps.dwButtons; i++)
-    {
-        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[i + 12], df->dwObjSize);
-        df->rgodf[idx].pguid = &GUID_Button;
-        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_PSHBUTTON;
+    i = 0;
+    while(newDevice->enum_device_state(newDevice, &item, i++)){
+        switch(item.type){
+            case ITEM_TYPE_BUTTON:
+                memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[item.id + 12], df->dwObjSize);
+                df->rgodf[idx].pguid = &GUID_Button;
+                df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(item.id) | DIDFT_PSHBUTTON;
+                ++idx;
+                break;
+            case ITEM_TYPE_AXIS:
+                memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[item.id], df->dwObjSize);
+                df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(item.id) | DIDFT_ABSAXIS;
+                if (newDevice->sdldev->has_ff && item.id < 2)
+                     df->rgodf[idx].dwFlags |= DIDOI_FFACTUATOR;
+
+                newDevice->generic.props[idx].lDevMin = -32768;
+                newDevice->generic.props[idx].lDevMax = 32767;
+                newDevice->generic.props[idx].lMin =  0;
+                newDevice->generic.props[idx].lMax =  0xffff;
+                newDevice->generic.props[idx].lDeadZone = 0;
+                newDevice->generic.props[idx].lSaturation = 0;
+
+                ++idx;
+                break;
+            case ITEM_TYPE_HAT:
+                memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[item.id + 8], df->dwObjSize);
+                df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(item.id) | DIDFT_POV;
+                ++idx;
+                break;
+        }
     }
 
     if (newDevice->sdldev->has_ff)
From 8da1756226bcaad64b83fc1313fd1890c18b1d27 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 21 Aug 2019 10:28:44 -0500
Subject: [PATCH] dinput: Implement SDL GetDeviceInfoW on top of GetDeviceInfoA

---
 dlls/dinput/joystick_sdl.c | 32 ++++++++++++++++----------------
 1 file changed, 16 insertions(+), 16 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 2914a8c43d2..145d7cad249 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -221,7 +221,7 @@ static void find_sdldevs(void)
     }
 }
 
-static void fill_joystick_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+static void fill_joystick_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
 {
     DWORD dwSize = lpddi->dwSize;
 
@@ -248,31 +248,31 @@ static void fill_joystick_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD ver
             lpddi->wUsage = 0x05; /* Game Pad */
     }
 
-    MultiByteToWideChar(CP_ACP, 0, sdldevs[id].name, -1, lpddi->tszInstanceName, MAX_PATH);
-    MultiByteToWideChar(CP_ACP, 0, sdldevs[id].name, -1, lpddi->tszProductName, MAX_PATH);
+    strcpy(lpddi->tszInstanceName, sdldevs[id].name);
+    strcpy(lpddi->tszProductName,  sdldevs[id].name);
 }
 
-static void fill_joystick_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+static void fill_joystick_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
 {
-    DIDEVICEINSTANCEW lpddiW;
+    DIDEVICEINSTANCEA lpddiA;
     DWORD dwSize = lpddi->dwSize;
 
-    lpddiW.dwSize = sizeof(lpddiW);
-    fill_joystick_dideviceinstanceW(&lpddiW, version, id);
+    lpddiA.dwSize = sizeof(lpddiA);
+    fill_joystick_dideviceinstanceA(&lpddiA, version, id);
 
     TRACE("%d %p\n", dwSize, lpddi);
     memset(lpddi, 0, dwSize);
 
-    /* Convert W->A */
+    /* Convert A->W */
     lpddi->dwSize = dwSize;
-    lpddi->guidInstance = lpddiW.guidInstance;
-    lpddi->guidProduct = lpddiW.guidProduct;
-    lpddi->dwDevType = lpddiW.dwDevType;
-    strcpy(lpddi->tszInstanceName, sdldevs[id].name);
-    strcpy(lpddi->tszProductName,  sdldevs[id].name);
-    lpddi->guidFFDriver = lpddiW.guidFFDriver;
-    lpddi->wUsagePage = lpddiW.wUsagePage;
-    lpddi->wUsage = lpddiW.wUsage;
+    lpddi->guidInstance = lpddiA.guidInstance;
+    lpddi->guidProduct = lpddiA.guidProduct;
+    lpddi->dwDevType = lpddiA.dwDevType;
+    MultiByteToWideChar(CP_ACP, 0, lpddiA.tszInstanceName, -1, lpddi->tszInstanceName, MAX_PATH);
+    MultiByteToWideChar(CP_ACP, 0, lpddiA.tszProductName, -1, lpddi->tszProductName, MAX_PATH);
+    lpddi->guidFFDriver = lpddiA.guidFFDriver;
+    lpddi->wUsagePage = lpddiA.wUsagePage;
+    lpddi->wUsage = lpddiA.wUsage;
 }
 
 static HRESULT sdl_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
From b21e0226d68d090becccc57f347f00aa043f9f55 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 21 Aug 2019 10:25:12 -0500
Subject: [PATCH] dinput: Add device info overrides for dualshock 4

---
 dlls/dinput/joystick_sdl.c | 60 +++++++++++++++++++++++++++++++++-----
 1 file changed, 52 insertions(+), 8 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 145d7cad249..debe8ee4b9f 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -56,6 +56,11 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dinput);
 
+#define VID_SONY 0x054c
+#define PID_SONY_DUALSHOCK_4 0x05c4
+#define PID_SONY_DUALSHOCK_4_2 0x09cc
+#define PID_SONY_DUALSHOCK_4_DONGLE 0x0ba0
+
 typedef struct JoystickImpl JoystickImpl;
 static const IDirectInputDevice8AVtbl JoystickAvt;
 static const IDirectInputDevice8WVtbl JoystickWvt;
@@ -221,9 +226,30 @@ static void find_sdldevs(void)
     }
 }
 
+static struct device_info_override {
+    WORD vid;
+    WORD pid;
+    const char *instance_name;
+    const char *product_name;
+    DWORD dev_type;
+    DWORD dev_type8;
+} device_info_overrides[] = {
+    { VID_SONY, PID_SONY_DUALSHOCK_4, "Wireless Controller", "Wireless Controller",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_1STPERSON | (DI8DEVTYPE1STPERSON_SIXDOF << 8) },
+
+    { VID_SONY, PID_SONY_DUALSHOCK_4_2, "Wireless Controller", "Wireless Controller",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_1STPERSON | (DI8DEVTYPE1STPERSON_SIXDOF << 8) },
+
+    { VID_SONY, PID_SONY_DUALSHOCK_4_DONGLE, "Wireless Controller", "Wireless Controller",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_1STPERSON | (DI8DEVTYPE1STPERSON_SIXDOF << 8) },
+};
+
 static void fill_joystick_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
 {
-    DWORD dwSize = lpddi->dwSize;
+    DWORD dwSize = lpddi->dwSize, i;
 
     TRACE("%d %p\n", dwSize, lpddi);
     memset(lpddi, 0, dwSize);
@@ -248,8 +274,31 @@ static void fill_joystick_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD ver
             lpddi->wUsage = 0x05; /* Game Pad */
     }
 
-    strcpy(lpddi->tszInstanceName, sdldevs[id].name);
-    strcpy(lpddi->tszProductName,  sdldevs[id].name);
+    for(i = 0; i < ARRAY_SIZE(device_info_overrides); ++i)
+    {
+        const struct device_info_override *override = &device_info_overrides[i];
+        if(sdldevs[id].vendor_id == override->vid &&
+                sdldevs[id].product_id == override->pid)
+        {
+            TRACE("found devinfo override for %04hx/%04hx\n",
+                    override->vid, override->pid);
+            if(version >= 0x800)
+                lpddi->dwDevType = override->dev_type8;
+            else
+                lpddi->dwDevType = override->dev_type;
+
+            strcpy(lpddi->tszInstanceName, override->instance_name);
+            strcpy(lpddi->tszProductName,  override->product_name);
+
+            break;
+        }
+    }
+
+    if(i >= ARRAY_SIZE(device_info_overrides))
+    {
+        strcpy(lpddi->tszInstanceName, sdldevs[id].name);
+        strcpy(lpddi->tszProductName,  sdldevs[id].name);
+    }
 }
 
 static void fill_joystick_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
@@ -341,11 +390,6 @@ static int buttons_to_sdl_hat(int u, int r, int d, int l)
 }
 
 /* playstation controllers */
-#define VID_SONY 0x054c
-#define PID_SONY_DUALSHOCK_4 0x05c4
-#define PID_SONY_DUALSHOCK_4_2 0x09cc
-#define PID_SONY_DUALSHOCK_4_DONGLE 0x0ba0
-
 static BOOL enum_device_state_ds4_16button(JoystickImpl *This, struct device_state_item *st, int idx)
 {
 #define SPECIALCASE_HAT -1
From b1acfd0573bb0500bbd74d548b6b702f461c489a Mon Sep 17 00:00:00 2001
From: Alexey Prokhin <alexey@prokhin.ru>
Date: Tue, 27 Aug 2019 20:42:07 +0300
Subject: [PATCH] dinput: Remove is_xbox_gamepad flag from SDL joysticks

---
 dlls/dinput/joystick_sdl.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index debe8ee4b9f..6696f2d1c57 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -87,7 +87,6 @@ struct SDLDev {
     WORD vendor_id;
     WORD product_id;
     CHAR *name;
-    BOOL is_xbox_gamepad;
 
     int n_buttons, n_axes, n_hats;
 
@@ -202,8 +201,6 @@ static void find_sdldevs(void)
                 type == SDL_JOYSTICK_TYPE_WHEEL ||
                 type == SDL_JOYSTICK_TYPE_FLIGHT_STICK ||
                 type == SDL_JOYSTICK_TYPE_THROTTLE;
-
-            sdldev.is_xbox_gamepad = is_xinput_device(NULL, sdldev.vendor_id, sdldev.product_id);
         }
 
         sdldev.n_buttons = SDL_JoystickNumButtons(device);
@@ -1019,14 +1016,16 @@ static HRESULT WINAPI JoystickWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REF
             static const WCHAR miW[] = {'m','i',0};
             static const WCHAR igW[] = {'i','g',0};
 
+            BOOL is_gamepad;
             LPDIPROPGUIDANDPATH pd = (LPDIPROPGUIDANDPATH)pdiph;
 
             if (!This->sdldev->product_id || !This->sdldev->vendor_id)
                 return DIERR_UNSUPPORTED;
 
+            is_gamepad = is_xinput_device(&This->generic.devcaps, This->sdldev->vendor_id, This->sdldev->product_id);
             pd->guidClass = GUID_DEVCLASS_HIDCLASS;
             sprintfW(pd->wszPath, formatW, This->sdldev->vendor_id, This->sdldev->product_id,
-                     This->sdldev->is_xbox_gamepad ? igW : miW, This->sdldev->id);
+                     is_gamepad ? igW : miW, This->sdldev->id);
 
             TRACE("DIPROP_GUIDANDPATH(%s, %s): returning fake path\n", debugstr_guid(&pd->guidClass), debugstr_w(pd->wszPath));
             break;
From e2cd02a65ed4c2474f917575d6ee175e4332acbc Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 30 Aug 2019 09:20:46 -0500
Subject: [PATCH] dinput: Don't enumerate joysticks that are blacklisted

SDL only respects these variables for game controllers. All joysticks
are allowed through. But we don't want to present these at all, so we'll
check the variables manually.
---
 dlls/dinput/joystick_sdl.c | 37 +++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 6696f2d1c57..e16803c0189 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -131,6 +131,35 @@ static const GUID DInput_Wine_SDL_Joystick_GUID = { /* 001E36B7-5DBA-4C4F-A8C9-C
 static int have_sdldevs = -1;
 static struct SDLDev *sdldevs = NULL;
 
+/* logic from SDL2's SDL_ShouldIgnoreGameController */
+static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
+{
+    char needle[16];
+    const char *blacklist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES");
+    const char *whitelist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT");
+    const char *allow_virtual = getenv("SDL_GAMECONTROLLER_ALLOW_STEAM_VIRTUAL_GAMEPAD");
+
+    if (!blacklist && !whitelist)
+        return FALSE;
+
+    if (allow_virtual && *allow_virtual != '0')
+    {
+        if(vid == 0x28DE && pid == 0x11FF)
+            return FALSE;
+    }
+
+    if (whitelist)
+    {
+        sprintf(needle, "0x%04x/0x%04x", vid, pid);
+
+        return strcasestr(whitelist, needle) == NULL;
+    }
+
+    sprintf(needle, "0x%04x/0x%04x", vid, pid);
+
+    return strcasestr(blacklist, needle) != NULL;
+}
+
 static void find_sdldevs(void)
 {
     int i;
@@ -171,6 +200,7 @@ static void find_sdldevs(void)
 
         if (device_disabled_registry(sdldev.name)) {
             SDL_JoystickClose(device);
+            HeapFree(GetProcessHeap(), 0, sdldev.name);
             continue;
         }
 
@@ -195,6 +225,13 @@ static void find_sdldevs(void)
             sdldev.product_id = SDL_JoystickInstanceID(device) + 1;
         }
 
+        if(is_in_sdl_blacklist(sdldev.vendor_id, sdldev.product_id))
+        {
+            TRACE("joystick %04x/%04x is in SDL blacklist, ignoring\n", sdldev.vendor_id, sdldev.product_id);
+            SDL_JoystickClose(device);
+            continue;
+        }
+
         {
             SDL_JoystickType type = SDL_JoystickGetType(device);
             sdldev.is_joystick =
From bafe9f5334f5035ac3a69af9eec231914f88cb5e Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 30 Aug 2019 10:58:16 -0500
Subject: [PATCH] dinput: Override Steam virtual controller name

---
 dlls/dinput/joystick_sdl.c | 53 +++++++++++++++++++++++++++++++++++++-
 1 file changed, 52 insertions(+), 1 deletion(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index e16803c0189..9836c193f7b 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -61,6 +61,19 @@ WINE_DEFAULT_DEBUG_CHANNEL(dinput);
 #define PID_SONY_DUALSHOCK_4_2 0x09cc
 #define PID_SONY_DUALSHOCK_4_DONGLE 0x0ba0
 
+#define VID_VALVE 0x28de
+#define PID_VALVE_VIRTUAL_CONTROLLER 0x11ff
+
+#define VID_MICROSOFT 0x045e
+#define PID_MICROSOFT_XBOX_360 0x028e
+#define PID_MICROSOFT_XBOX_360_WIRELESS 0x028f
+#define PID_MICROSOFT_XBOX_360_ADAPTER  0x0719
+#define PID_MICROSOFT_XBOX_ONE 0x02d1
+#define PID_MICROSOFT_XBOX_ONE_CF 0x02dd
+#define PID_MICROSOFT_XBOX_ONE_ELITE 0x02e3
+#define PID_MICROSOFT_XBOX_ONE_S 0x02ea
+#define PID_MICROSOFT_XBOX_ONE_S_2 0x02fd
+
 typedef struct JoystickImpl JoystickImpl;
 static const IDirectInputDevice8AVtbl JoystickAvt;
 static const IDirectInputDevice8WVtbl JoystickWvt;
@@ -144,7 +157,7 @@ static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
 
     if (allow_virtual && *allow_virtual != '0')
     {
-        if(vid == 0x28DE && pid == 0x11FF)
+        if(vid == VID_VALVE && pid == PID_VALVE_VIRTUAL_CONTROLLER)
             return FALSE;
     }
 
@@ -232,6 +245,12 @@ static void find_sdldevs(void)
             continue;
         }
 
+        if(sdldev.vendor_id == VID_VALVE && sdldev.product_id == PID_VALVE_VIRTUAL_CONTROLLER)
+        {
+            sdldev.vendor_id = VID_MICROSOFT;
+            sdldev.product_id = PID_MICROSOFT_XBOX_360;
+        }
+
         {
             SDL_JoystickType type = SDL_JoystickGetType(device);
             sdldev.is_joystick =
@@ -279,6 +298,38 @@ static struct device_info_override {
     { VID_SONY, PID_SONY_DUALSHOCK_4_DONGLE, "Wireless Controller", "Wireless Controller",
         DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
         DIDEVTYPE_HID | DI8DEVTYPE_1STPERSON | (DI8DEVTYPE1STPERSON_SIXDOF << 8) },
+
+    { VID_MICROSOFT, PID_MICROSOFT_XBOX_360, "Controller (XBOX 360 For Windows)", "Controller (XBOX 360 For Windows)",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_GAMEPAD | (DI8DEVTYPEGAMEPAD_STANDARD << 8) },
+
+    { VID_MICROSOFT, PID_MICROSOFT_XBOX_360_WIRELESS, "Controller (XBOX 360 For Windows)", "Controller (XBOX 360 For Windows)",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_GAMEPAD | (DI8DEVTYPEGAMEPAD_STANDARD << 8) },
+
+    { VID_MICROSOFT, PID_MICROSOFT_XBOX_360_ADAPTER, "Controller (XBOX 360 For Windows)", "Controller (XBOX 360 For Windows)",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_GAMEPAD | (DI8DEVTYPEGAMEPAD_STANDARD << 8) },
+
+    { VID_MICROSOFT, PID_MICROSOFT_XBOX_ONE, "Controller (XBOX One For Windows)", "Controller (XBOX One For Windows)",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_GAMEPAD | (DI8DEVTYPEGAMEPAD_STANDARD << 8) },
+
+    { VID_MICROSOFT, PID_MICROSOFT_XBOX_ONE_CF, "Controller (XBOX One For Windows)", "Controller (XBOX One For Windows)",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_GAMEPAD | (DI8DEVTYPEGAMEPAD_STANDARD << 8) },
+
+    { VID_MICROSOFT, PID_MICROSOFT_XBOX_ONE_ELITE, "Controller (XBOX One For Windows)", "Controller (XBOX One For Windows)",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_GAMEPAD | (DI8DEVTYPEGAMEPAD_STANDARD << 8) },
+
+    { VID_MICROSOFT, PID_MICROSOFT_XBOX_ONE_S, "Controller (XBOX One For Windows)", "Controller (XBOX One For Windows)",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_GAMEPAD | (DI8DEVTYPEGAMEPAD_STANDARD << 8) },
+
+    { VID_MICROSOFT, PID_MICROSOFT_XBOX_ONE_S_2, "Controller (XBOX One For Windows)", "Controller (XBOX One For Windows)",
+        DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8),
+        DIDEVTYPE_HID | DI8DEVTYPE_GAMEPAD | (DI8DEVTYPEGAMEPAD_STANDARD << 8) },
 };
 
 static void fill_joystick_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
From 1992076ee418e6b3428e78e725d945e1e6ac8d6a Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 3 Sep 2019 10:49:53 -0500
Subject: [PATCH] dinput: Return real rawinput path for dinput device

---
 dlls/dinput/joystick_sdl.c | 72 ++++++++++++++++++++++++++++++++------
 1 file changed, 61 insertions(+), 11 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 9836c193f7b..9cdc0f31a8a 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -24,6 +24,7 @@
 #include "config.h"
 #include "wine/port.h"
 
+#define NONAMELESSUNION
 #include <assert.h>
 #include <stdarg.h>
 #include <stdio.h>
@@ -1099,23 +1100,72 @@ static HRESULT WINAPI JoystickWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REF
 
         case (DWORD_PTR) DIPROP_GUIDANDPATH:
         {
-            static const WCHAR formatW[] = {'\\','\\','?','\\','h','i','d','#','v','i','d','_','%','0','4','x','&',
-                                            'p','i','d','_','%','0','4','x','&','%','s','_','%','i',0};
-            static const WCHAR miW[] = {'m','i',0};
-            static const WCHAR igW[] = {'i','g',0};
-
-            BOOL is_gamepad;
+            RAWINPUTDEVICELIST *list;
+            RID_DEVICE_INFO info;
+            UINT ndevs, i, ur, size;
             LPDIPROPGUIDANDPATH pd = (LPDIPROPGUIDANDPATH)pdiph;
 
+            memset(pd, 0, sizeof(*pd));
+
             if (!This->sdldev->product_id || !This->sdldev->vendor_id)
                 return DIERR_UNSUPPORTED;
 
-            is_gamepad = is_xinput_device(&This->generic.devcaps, This->sdldev->vendor_id, This->sdldev->product_id);
-            pd->guidClass = GUID_DEVCLASS_HIDCLASS;
-            sprintfW(pd->wszPath, formatW, This->sdldev->vendor_id, This->sdldev->product_id,
-                     is_gamepad ? igW : miW, This->sdldev->id);
+            ur = GetRawInputDeviceList(NULL, &ndevs, sizeof(RAWINPUTDEVICELIST));
+            if (ur == (UINT)-1)
+                return DIERR_GENERIC;
+
+            list = HeapAlloc(GetProcessHeap(), 0, ndevs * sizeof(*list));
+            if (!list)
+                return DIERR_OUTOFMEMORY;
+
+            ndevs = GetRawInputDeviceList(list, &ndevs, sizeof(RAWINPUTDEVICELIST));
+            if (ndevs == (UINT)-1)
+            {
+                HeapFree(GetProcessHeap(), 0, list);
+                return DIERR_GENERIC;
+            }
+
+            for (i = 0; i < ndevs; ++i)
+            {
+                if (list[i].dwType != RIM_TYPEHID)
+                    continue;
+
+                memset(&info, 0, sizeof(info));
+                size = info.cbSize = sizeof(info);
+
+                ur = GetRawInputDeviceInfoW(list[i].hDevice, RIDI_DEVICEINFO, &info, &size);
+                TRACE("got hid: %04x/%04x\n", info.u.hid.dwVendorId,
+                        info.u.hid.dwProductId);
+                if (ur == (UINT)-1 ||
+                        (info.u.hid.dwVendorId != This->sdldev->vendor_id ||
+                         info.u.hid.dwProductId != This->sdldev->product_id))
+                    continue;
+
+                /* found device with same vid/pid, return this path. won't work
+                 * for multiple identical controllers... */
+
+                size = ARRAY_SIZE(pd->wszPath);
+                ur = GetRawInputDeviceInfoW(list[i].hDevice, RIDI_DEVICENAME, pd->wszPath, &size);
+                if (ur == (UINT)-1)
+                {
+                    HeapFree(GetProcessHeap(), 0, list);
+                    return DIERR_GENERIC;
+                }
+
+                pd->guidClass = GUID_DEVCLASS_HIDCLASS;
+
+                TRACE("DIPROP_GUIDANDPATH(%s, %s): returning path\n", debugstr_guid(&pd->guidClass), debugstr_w(pd->wszPath));
+                break;
+            }
+
+            HeapFree(GetProcessHeap(), 0, list);
+
+            if (i >= ndevs)
+            {
+                TRACE("couldn't find matching rawinput device\n");
+                return DIERR_GENERIC;
+            }
 
-            TRACE("DIPROP_GUIDANDPATH(%s, %s): returning fake path\n", debugstr_guid(&pd->guidClass), debugstr_w(pd->wszPath));
             break;
         }
 
From 9af099835c1a7c8a9202357673d89407fd353aa4 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 5 Sep 2019 10:31:35 -0500
Subject: [PATCH] dinput: Use axis ID to look up properties, not data offset

---
 dlls/dinput/joystick.c | 36 ++++++++++++++++++------------------
 1 file changed, 18 insertions(+), 18 deletions(-)

diff --git a/dlls/dinput/joystick.c b/dlls/dinput/joystick.c
index 1c73f6351c8..9c7f2ef4193 100644
--- a/dlls/dinput/joystick.c
+++ b/dlls/dinput/joystick.c
@@ -402,15 +402,15 @@ HRESULT WINAPI JoystickWGenericImpl_SetProperty(LPDIRECTINPUTDEVICE8W iface, REF
                     remap_props.lMin = pr->lMin;
                     remap_props.lMax = pr->lMax;
 
-                    switch (This->base.data_format.wine_df->rgodf[i].dwOfs) {
-                    case DIJOFS_X        : This->js.lX  = joystick_map_axis(&remap_props, This->js.lX); break;
-                    case DIJOFS_Y        : This->js.lY  = joystick_map_axis(&remap_props, This->js.lY); break;
-                    case DIJOFS_Z        : This->js.lZ  = joystick_map_axis(&remap_props, This->js.lZ); break;
-                    case DIJOFS_RX       : This->js.lRx = joystick_map_axis(&remap_props, This->js.lRx); break;
-                    case DIJOFS_RY       : This->js.lRy = joystick_map_axis(&remap_props, This->js.lRy); break;
-                    case DIJOFS_RZ       : This->js.lRz = joystick_map_axis(&remap_props, This->js.lRz); break;
-                    case DIJOFS_SLIDER(0): This->js.rglSlider[0] = joystick_map_axis(&remap_props, This->js.rglSlider[0]); break;
-                    case DIJOFS_SLIDER(1): This->js.rglSlider[1] = joystick_map_axis(&remap_props, This->js.rglSlider[1]); break;
+                    switch (DIDFT_GETINSTANCE(This->base.data_format.wine_df->rgodf[i].dwType)) {
+                    case 0: This->js.lX  = joystick_map_axis(&remap_props, This->js.lX); break;
+                    case 1: This->js.lY  = joystick_map_axis(&remap_props, This->js.lY); break;
+                    case 2: This->js.lZ  = joystick_map_axis(&remap_props, This->js.lZ); break;
+                    case 3: This->js.lRx = joystick_map_axis(&remap_props, This->js.lRx); break;
+                    case 4: This->js.lRy = joystick_map_axis(&remap_props, This->js.lRy); break;
+                    case 5: This->js.lRz = joystick_map_axis(&remap_props, This->js.lRz); break;
+                    case 6: This->js.rglSlider[0] = joystick_map_axis(&remap_props, This->js.rglSlider[0]); break;
+                    case 7: This->js.rglSlider[1] = joystick_map_axis(&remap_props, This->js.rglSlider[1]); break;
 	            default: break;
                     }
 
@@ -432,15 +432,15 @@ HRESULT WINAPI JoystickWGenericImpl_SetProperty(LPDIRECTINPUTDEVICE8W iface, REF
                     remap_props.lMin = pr->lMin;
                     remap_props.lMax = pr->lMax;
 
-                    switch (This->base.data_format.wine_df->rgodf[obj].dwOfs) {
-                    case DIJOFS_X        : This->js.lX  = joystick_map_axis(&remap_props, This->js.lX); break;
-                    case DIJOFS_Y        : This->js.lY  = joystick_map_axis(&remap_props, This->js.lY); break;
-                    case DIJOFS_Z        : This->js.lZ  = joystick_map_axis(&remap_props, This->js.lZ); break;
-                    case DIJOFS_RX       : This->js.lRx = joystick_map_axis(&remap_props, This->js.lRx); break;
-                    case DIJOFS_RY       : This->js.lRy = joystick_map_axis(&remap_props, This->js.lRy); break;
-                    case DIJOFS_RZ       : This->js.lRz = joystick_map_axis(&remap_props, This->js.lRz); break;
-                    case DIJOFS_SLIDER(0): This->js.rglSlider[0] = joystick_map_axis(&remap_props, This->js.rglSlider[0]); break;
-                    case DIJOFS_SLIDER(1): This->js.rglSlider[1] = joystick_map_axis(&remap_props, This->js.rglSlider[1]); break;
+                    switch (DIDFT_GETINSTANCE(This->base.data_format.wine_df->rgodf[obj].dwType)) {
+                    case 0: This->js.lX  = joystick_map_axis(&remap_props, This->js.lX); break;
+                    case 1: This->js.lY  = joystick_map_axis(&remap_props, This->js.lY); break;
+                    case 2: This->js.lZ  = joystick_map_axis(&remap_props, This->js.lZ); break;
+                    case 3: This->js.lRx = joystick_map_axis(&remap_props, This->js.lRx); break;
+                    case 4: This->js.lRy = joystick_map_axis(&remap_props, This->js.lRy); break;
+                    case 5: This->js.lRz = joystick_map_axis(&remap_props, This->js.lRz); break;
+                    case 6: This->js.rglSlider[0] = joystick_map_axis(&remap_props, This->js.rglSlider[0]); break;
+                    case 7: This->js.rglSlider[1] = joystick_map_axis(&remap_props, This->js.rglSlider[1]); break;
 		    default: break;
                     }
 
From 41227ca276927402728a15df62cf1ab4c0d26d38 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 21 Aug 2019 14:12:27 -0500
Subject: [PATCH] dinput: Check for device loss in joystick Poll

---
 dlls/dinput/joystick.c            | 16 +++++++++-------
 dlls/dinput/joystick_linux.c      | 16 +++++++++-------
 dlls/dinput/joystick_linuxinput.c | 12 +++++++-----
 dlls/dinput/joystick_osx.c        | 20 +++++++++++---------
 dlls/dinput/joystick_private.h    |  2 +-
 dlls/dinput/joystick_sdl.c        |  7 ++++++-
 6 files changed, 43 insertions(+), 30 deletions(-)

diff --git a/dlls/dinput/joystick.c b/dlls/dinput/joystick.c
index 9c7f2ef4193..fc4040757f8 100644
--- a/dlls/dinput/joystick.c
+++ b/dlls/dinput/joystick.c
@@ -815,8 +815,7 @@ HRESULT WINAPI JoystickWGenericImpl_Poll(LPDIRECTINPUTDEVICE8W iface)
         return DIERR_NOTACQUIRED;
     }
 
-    This->joy_polldev(IDirectInputDevice8A_from_impl(This));
-    return DI_OK;
+    return This->joy_polldev(IDirectInputDevice8A_from_impl(This));
 }
 
 HRESULT WINAPI JoystickAGenericImpl_Poll(LPDIRECTINPUTDEVICE8A iface)
@@ -831,6 +830,7 @@ HRESULT WINAPI JoystickAGenericImpl_Poll(LPDIRECTINPUTDEVICE8A iface)
   */
 HRESULT WINAPI JoystickWGenericImpl_GetDeviceState(LPDIRECTINPUTDEVICE8W iface, DWORD len, LPVOID ptr)
 {
+    HRESULT hr;
     JoystickGenericImpl *This = impl_from_IDirectInputDevice8W(iface);
 
     TRACE("(%p,0x%08x,%p)\n", This, len, ptr);
@@ -841,12 +841,14 @@ HRESULT WINAPI JoystickWGenericImpl_GetDeviceState(LPDIRECTINPUTDEVICE8W iface,
     }
 
     /* update joystick state */
-    This->joy_polldev(IDirectInputDevice8A_from_impl(This));
-
-    /* convert and copy data to user supplied buffer */
-    fill_DataFormat(ptr, len, &This->js, &This->base.data_format);
+    hr = This->joy_polldev(IDirectInputDevice8A_from_impl(This));
+    if (SUCCEEDED(hr))
+    {
+        /* convert and copy data to user supplied buffer */
+        fill_DataFormat(ptr, len, &This->js, &This->base.data_format);
+    }
 
-    return DI_OK;
+    return hr;
 }
 
 HRESULT WINAPI JoystickAGenericImpl_GetDeviceState(LPDIRECTINPUTDEVICE8A iface, DWORD len, LPVOID ptr)
diff --git a/dlls/dinput/joystick_linux.c b/dlls/dinput/joystick_linux.c
index 2b26eb806d3..4229f3ee642 100644
--- a/dlls/dinput/joystick_linux.c
+++ b/dlls/dinput/joystick_linux.c
@@ -130,7 +130,7 @@ static const GUID DInput_Wine_Joystick_GUID = { /* 9e573ed9-7734-11d2-8d4a-23903
 static INT joystick_devices_count = -1;
 static struct JoyDev *joystick_devices;
 
-static void joy_polldev(LPDIRECTINPUTDEVICE8A iface);
+static HRESULT joy_polldev(LPDIRECTINPUTDEVICE8A iface);
 
 #define SYS_PATH_FORMAT "/sys/class/input/js%d/device/id/%s"
 static BOOL read_sys_id_variable(int index, const char *property, WORD *value)
@@ -840,7 +840,7 @@ static HRESULT WINAPI JoystickLinuxAImpl_Unacquire(LPDIRECTINPUTDEVICE8A iface)
     return JoystickLinuxWImpl_Unacquire(IDirectInputDevice8W_from_impl(This));
 }
 
-static void joy_polldev(LPDIRECTINPUTDEVICE8A iface)
+static HRESULT joy_polldev(LPDIRECTINPUTDEVICE8A iface)
 {
     struct pollfd plfd;
     struct js_event jse;
@@ -850,7 +850,7 @@ static void joy_polldev(LPDIRECTINPUTDEVICE8A iface)
 
     if (This->joyfd==-1) {
         WARN("no device\n");
-        return;
+        return DIERR_INPUTLOST;
     }
     while (1)
     {
@@ -860,16 +860,16 @@ static void joy_polldev(LPDIRECTINPUTDEVICE8A iface)
 	plfd.fd = This->joyfd;
 	plfd.events = POLLIN;
 	if (poll(&plfd,1,0) != 1)
-	    return;
+	    return DI_OK;
 	/* we have one event, so we can read */
 	if (sizeof(jse)!=read(This->joyfd,&jse,sizeof(jse))) {
-	    return;
+	    return DIERR_INPUTLOST;
 	}
         TRACE("js_event: type 0x%x, number %d, value %d\n",
               jse.type,jse.number,jse.value);
         if (jse.type & JS_EVENT_BUTTON)
         {
-            if (jse.number >= This->generic.devcaps.dwButtons) return;
+            if (jse.number >= This->generic.devcaps.dwButtons) continue;
 
             inst_id = DIDFT_MAKEINSTANCE(jse.number) | DIDFT_PSHBUTTON;
             This->generic.js.rgbButtons[jse.number] = value = jse.value ? 0x80 : 0x00;
@@ -878,7 +878,7 @@ static void joy_polldev(LPDIRECTINPUTDEVICE8A iface)
         {
             int number = This->generic.axis_map[jse.number];	/* wine format object index */
 
-            if (number < 0) return;
+            if (number < 0) continue;
             inst_id = number < 8 ?  DIDFT_MAKEINSTANCE(number) | DIDFT_ABSAXIS :
                                     DIDFT_MAKEINSTANCE(number - 8) | DIDFT_POV;
             value = joystick_map_axis(&This->generic.props[id_to_object(This->generic.base.data_format.wine_df, inst_id)], jse.value);
@@ -913,6 +913,8 @@ static void joy_polldev(LPDIRECTINPUTDEVICE8A iface)
         if (inst_id >= 0)
             queue_event(iface, inst_id, value, GetCurrentTime(), This->generic.base.dinput->evsequence++);
     }
+
+    return DI_OK;
 }
 
 static const IDirectInputDevice8AVtbl JoystickAvt =
diff --git a/dlls/dinput/joystick_linuxinput.c b/dlls/dinput/joystick_linuxinput.c
index 102de8269b9..66fc9b7f9b1 100644
--- a/dlls/dinput/joystick_linuxinput.c
+++ b/dlls/dinput/joystick_linuxinput.c
@@ -155,7 +155,7 @@ static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(JoystickImpl
 
 static void fake_current_js_state(JoystickImpl *ji);
 static void find_joydevs(void);
-static void joy_polldev(LPDIRECTINPUTDEVICE8A iface);
+static HRESULT joy_polldev(LPDIRECTINPUTDEVICE8A iface);
 
 /* This GUID is slightly different from the linux joystick one. Take note. */
 static const GUID DInput_Wine_Joystick_Base_GUID = { /* 9e573eda-7734-11d2-8d4a-23903fb6bdf7 */
@@ -809,14 +809,14 @@ static void fake_current_js_state(JoystickImpl *ji)
 #undef CENTER_AXIS
 
 /* convert wine format offset to user format object index */
-static void joy_polldev(LPDIRECTINPUTDEVICE8A iface)
+static HRESULT joy_polldev(LPDIRECTINPUTDEVICE8A iface)
 {
     struct pollfd plfd;
     struct input_event ie;
     JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
 
     if (This->joyfd==-1)
-	return;
+	return DIERR_INPUTLOST;
 
     while (1)
     {
@@ -827,11 +827,11 @@ static void joy_polldev(LPDIRECTINPUTDEVICE8A iface)
 	plfd.events = POLLIN;
 
 	if (poll(&plfd,1,0) != 1)
-	    return;
+	    return DI_OK;
 
 	/* we have one event, so we can read */
 	if (sizeof(ie)!=read(This->joyfd,&ie,sizeof(ie)))
-	    return;
+	    return DIERR_INPUTLOST;
 
 	TRACE("input_event: type %d, code %d, value %d\n",ie.type,ie.code,ie.value);
 	switch (ie.type) {
@@ -910,6 +910,8 @@ static void joy_polldev(LPDIRECTINPUTDEVICE8A iface)
             queue_event(iface, inst_id,
                         value, GetCurrentTime(), This->generic.base.dinput->evsequence++);
     }
+
+    return DI_OK;
 }
 
 /******************************************************************************
diff --git a/dlls/dinput/joystick_osx.c b/dlls/dinput/joystick_osx.c
index 4ec72465500..94eb3115d92 100644
--- a/dlls/dinput/joystick_osx.c
+++ b/dlls/dinput/joystick_osx.c
@@ -767,7 +767,7 @@ static void get_osx_device_elements_props(JoystickImpl *device)
     }
 }
 
-static void poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
+static HRESULT poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
 {
     JoystickImpl *device = impl_from_IDirectInputDevice8A(iface);
     IOHIDElementRef device_main_element;
@@ -776,13 +776,13 @@ static void poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
     TRACE("device %p device->id %i\n", device, device->id);
 
     if (!device_main_elements || device->id >= CFArrayGetCount(device_main_elements))
-        return;
+        return DIERR_INPUTLOST;
 
     device_main_element = (IOHIDElementRef) CFArrayGetValueAtIndex(device_main_elements, device->id);
     hid_device = IOHIDElementGetDevice(device_main_element);
     TRACE("main element %s hid_device %s\n", debugstr_element(device_main_element), debugstr_device(hid_device));
     if (!hid_device)
-        return;
+        return DIERR_INPUTLOST;
 
     if (device->elements)
     {
@@ -809,9 +809,9 @@ static void poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
                     {
                         valueRef = NULL;
                         if (IOHIDDeviceGetValue(hid_device, element, &valueRef) != kIOReturnSuccess)
-                            return;
+                            continue;
                         if (valueRef == NULL)
-                            return;
+                            continue;
                         val = IOHIDValueGetIntegerValue(valueRef);
                         newVal = val ? 0x80 : 0x0;
                         oldVal = device->generic.js.rgbButtons[button_idx];
@@ -835,9 +835,9 @@ static void poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
                             TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_Hatswitch\n");
                             valueRef = NULL;
                             if (IOHIDDeviceGetValue(hid_device, element, &valueRef) != kIOReturnSuccess)
-                                return;
+                                continue;
                             if (valueRef == NULL)
-                                return;
+                                continue;
                             val = IOHIDValueGetIntegerValue(valueRef);
                             oldVal = device->generic.js.rgdwPOV[pov_idx];
                             if (val >= 8)
@@ -866,9 +866,9 @@ static void poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
 
                             valueRef = NULL;
                             if (IOHIDDeviceGetValue(hid_device, element, &valueRef) != kIOReturnSuccess)
-                                return;
+                                continue;
                             if (valueRef == NULL)
-                                return;
+                                continue;
                             val = IOHIDValueGetIntegerValue(valueRef);
                             newVal = joystick_map_axis(&device->generic.props[idx], val);
                             switch (usage)
@@ -937,6 +937,8 @@ static void poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
             }
         }
     }
+
+    return DI_OK;
 }
 
 static INT find_joystick_devices(void)
diff --git a/dlls/dinput/joystick_private.h b/dlls/dinput/joystick_private.h
index b786c84decb..2af4a294303 100644
--- a/dlls/dinput/joystick_private.h
+++ b/dlls/dinput/joystick_private.h
@@ -33,7 +33,7 @@
 #define MAX_PROPS 164
 struct JoystickGenericImpl;
 
-typedef void joy_polldev_handler(LPDIRECTINPUTDEVICE8A iface);
+typedef HRESULT joy_polldev_handler(LPDIRECTINPUTDEVICE8A iface);
 
 typedef struct JoystickGenericImpl
 {
diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 9cdc0f31a8a..e84421e2e7d 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -694,7 +694,7 @@ static BOOL enum_device_state_standard(JoystickImpl *This, struct device_state_i
     return FALSE;
 }
 
-static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
+static HRESULT poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
 {
     JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
     int i = 0;
@@ -702,6 +702,9 @@ static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
     int newVal = 0;
     struct device_state_item item;
 
+    if(!SDL_JoystickGetAttached(This->device))
+        return DIERR_INPUTLOST;
+
     SDL_JoystickUpdate();
 
     while(This->enum_device_state(This, &item, i++))
@@ -785,6 +788,8 @@ static void poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
         }
         }
     }
+
+    return DI_OK;
 }
 
 static enum_device_state_function select_enum_function(struct SDLDev *sdldev)
From 0401e942ad40e30a674dc849dfc04439e570d631 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 12 Sep 2019 12:35:08 -0500
Subject: [PATCH] dinput: Keep track of joysticks even after disconnected

---
 dlls/dinput/joystick_sdl.c | 107 +++++++++++++++++++++----------------
 1 file changed, 61 insertions(+), 46 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index e84421e2e7d..e5600c39977 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -97,7 +97,9 @@ struct device_state_item {
 typedef BOOL (*enum_device_state_function)(JoystickImpl*, struct device_state_item *, int);
 
 struct SDLDev {
-    int id;
+    BOOL valid;
+
+    int instance_id;
     WORD vendor_id;
     WORD product_id;
     CHAR *name;
@@ -142,8 +144,16 @@ static const GUID DInput_Wine_SDL_Joystick_GUID = { /* 001E36B7-5DBA-4C4F-A8C9-C
   0x001E36B7, 0x5DBA, 0x4C4F, {0xA8, 0xC9, 0xCF, 0xC8, 0x68, 0x9D, 0xB4, 0x03}
 };
 
-static int have_sdldevs = -1;
-static struct SDLDev *sdldevs = NULL;
+static CRITICAL_SECTION sdldevs_lock;
+static CRITICAL_SECTION_DEBUG sdldevs_lock_debug =
+{
+    0, 0, &sdldevs_lock,
+    { &sdldevs_lock_debug.ProcessLocksList, &sdldevs_lock_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": sdldevs_lock") }
+};
+static CRITICAL_SECTION sdldevs_lock = { &sdldevs_lock_debug, -1, 0, 0, 0, 0 };
+
+static struct SDLDev sdldevs[64];
 
 /* logic from SDL2's SDL_ShouldIgnoreGameController */
 static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
@@ -180,6 +190,7 @@ static void find_sdldevs(void)
     Uint16 (*pSDL_JoystickGetProduct)(SDL_Joystick * joystick) = NULL;
     Uint16 (*pSDL_JoystickGetVendor)(SDL_Joystick * joystick) = NULL;
     void *sdl_handle = NULL;
+    static int have_sdldevs = -1;
 
     if (InterlockedCompareExchange(&have_sdldevs, 0, -1) != -1)
         /* Someone beat us to it */
@@ -200,25 +211,24 @@ static void find_sdldevs(void)
 
     for (i = 0; i < SDL_NumJoysticks(); i++)
     {
-        struct SDLDev sdldev = {0};
-        struct SDLDev *new_sdldevs;
+        struct SDLDev *sdldev = &sdldevs[have_sdldevs];
         SDL_Joystick *device;
         const CHAR* name;
 
-        sdldev.id = i;
         device = SDL_JoystickOpen(i);
+        sdldev->instance_id = SDL_JoystickInstanceID(device);
 
         name = SDL_JoystickName(device);
-        sdldev.name = HeapAlloc(GetProcessHeap(), 0, strlen(name) + 1);
-        strcpy(sdldev.name, name);
+        sdldev->name = HeapAlloc(GetProcessHeap(), 0, strlen(name) + 1);
+        strcpy(sdldev->name, name);
 
-        if (device_disabled_registry(sdldev.name)) {
+        if (device_disabled_registry(sdldev->name)) {
             SDL_JoystickClose(device);
-            HeapFree(GetProcessHeap(), 0, sdldev.name);
+            HeapFree(GetProcessHeap(), 0, sdldev->name);
             continue;
         }
 
-        TRACE("Found a joystick (%i) on %p: %s\n", have_sdldevs, device, sdldev.name);
+        TRACE("Found a joystick (%i) on %p: %s\n", have_sdldevs, device, sdldev->name);
 
         if (SDL_JoystickIsHaptic(device))
         {
@@ -226,56 +236,48 @@ static void find_sdldevs(void)
             if (haptic)
             {
                 TRACE(" ... with force feedback\n");
-                sdldev.has_ff = TRUE;
+                sdldev->has_ff = TRUE;
                 SDL_HapticClose(haptic);
             }
         }
 
         if(pSDL_JoystickGetVendor){
-            sdldev.vendor_id = pSDL_JoystickGetVendor(device);
-            sdldev.product_id = pSDL_JoystickGetProduct(device);
+            sdldev->vendor_id = pSDL_JoystickGetVendor(device);
+            sdldev->product_id = pSDL_JoystickGetProduct(device);
         }else{
-            sdldev.vendor_id = 0x01;
-            sdldev.product_id = SDL_JoystickInstanceID(device) + 1;
+            sdldev->vendor_id = 0x01;
+            sdldev->product_id = SDL_JoystickInstanceID(device) + 1;
         }
 
-        if(is_in_sdl_blacklist(sdldev.vendor_id, sdldev.product_id))
+        if(is_in_sdl_blacklist(sdldev->vendor_id, sdldev->product_id))
         {
-            TRACE("joystick %04x/%04x is in SDL blacklist, ignoring\n", sdldev.vendor_id, sdldev.product_id);
+            TRACE("joystick %04x/%04x is in SDL blacklist, ignoring\n", sdldev->vendor_id, sdldev->product_id);
             SDL_JoystickClose(device);
             continue;
         }
 
-        if(sdldev.vendor_id == VID_VALVE && sdldev.product_id == PID_VALVE_VIRTUAL_CONTROLLER)
+        if(sdldev->vendor_id == VID_VALVE && sdldev->product_id == PID_VALVE_VIRTUAL_CONTROLLER)
         {
-            sdldev.vendor_id = VID_MICROSOFT;
-            sdldev.product_id = PID_MICROSOFT_XBOX_360;
+            sdldev->vendor_id = VID_MICROSOFT;
+            sdldev->product_id = PID_MICROSOFT_XBOX_360;
         }
 
         {
             SDL_JoystickType type = SDL_JoystickGetType(device);
-            sdldev.is_joystick =
+            sdldev->is_joystick =
                 type == SDL_JOYSTICK_TYPE_WHEEL ||
                 type == SDL_JOYSTICK_TYPE_FLIGHT_STICK ||
                 type == SDL_JOYSTICK_TYPE_THROTTLE;
         }
 
-        sdldev.n_buttons = SDL_JoystickNumButtons(device);
-        sdldev.n_axes = SDL_JoystickNumAxes(device);
-        sdldev.n_hats = SDL_JoystickNumHats(device);
+        sdldev->n_buttons = SDL_JoystickNumButtons(device);
+        sdldev->n_axes = SDL_JoystickNumAxes(device);
+        sdldev->n_hats = SDL_JoystickNumHats(device);
 
-        if (!have_sdldevs)
-            new_sdldevs = HeapAlloc(GetProcessHeap(), 0, sizeof(struct SDLDev));
-        else
-            new_sdldevs = HeapReAlloc(GetProcessHeap(), 0, sdldevs, (1 + have_sdldevs) * sizeof(struct SDLDev));
+        sdldev->valid = TRUE;
 
         SDL_JoystickClose(device);
-        if (!new_sdldevs)
-        {
-            continue;
-        }
-        sdldevs = new_sdldevs;
-        sdldevs[have_sdldevs] = sdldev;
+
         have_sdldevs++;
     }
 }
@@ -414,9 +416,8 @@ static HRESULT sdl_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTAN
 {
   find_sdldevs();
 
-  if (id >= have_sdldevs) {
-    return E_FAIL;
-  }
+    if (id >= ARRAY_SIZE(sdldevs) || !sdldevs[id].valid)
+        return E_FAIL;
 
   if (!((dwDevType == 0) ||
         ((dwDevType == DIDEVTYPE_JOYSTICK) && (version >= 0x0300 && version < 0x0800)) ||
@@ -432,11 +433,13 @@ static HRESULT sdl_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTAN
 
 static HRESULT sdl_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
 {
-  find_sdldevs();
+    find_sdldevs();
 
-  if (id >= have_sdldevs) {
-    return E_FAIL;
-  }
+    if (id >= ARRAY_SIZE(sdldevs) || !sdldevs[id].valid)
+        return E_FAIL;
+
+  if (!sdldevs[id].valid)
+      return E_FAIL;
 
   if (!((dwDevType == 0) ||
         ((dwDevType == DIDEVTYPE_JOYSTICK) && (version >= 0x0300 && version < 0x0800)) ||
@@ -822,6 +825,17 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     DIDEVICEINSTANCEW ddi;
     int i,idx = 0, axis_count = 0, button_count = 0, hat_count = 0;
     struct device_state_item item;
+    SDL_Joystick *sdl_js;
+
+    sdl_js = SDL_JoystickFromInstanceID(sdldevs[index].instance_id);
+    if (!sdl_js)
+        return NULL;
+
+    if (!SDL_JoystickGetAttached(sdl_js))
+    {
+        SDL_JoystickClose(sdl_js);
+        return NULL;
+    }
 
     newDevice = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(JoystickImpl));
     if (!newDevice) return NULL;
@@ -848,7 +862,7 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     newDevice->generic.base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": JoystickImpl*->base.crit");
 
     /* Open Device */
-    newDevice->device = SDL_JoystickOpen(newDevice->sdldev->id);
+    newDevice->device = sdl_js;
     newDevice->haptic = SDL_HapticOpenFromJoystick(newDevice->device);
 
     i = 0;
@@ -984,8 +998,7 @@ static HRESULT sdl_create_device(IDirectInputImpl *dinput, REFGUID rguid, REFIID
     find_sdldevs();
     *pdev = NULL;
 
-    if ((index = get_joystick_index(rguid)) < 0xffff &&
-        have_sdldevs && index < have_sdldevs)
+    if ((index = get_joystick_index(rguid)) < 0xffff && sdldevs[index].valid)
     {
         JoystickImpl *This;
 
@@ -1012,6 +1025,8 @@ static HRESULT sdl_create_device(IDirectInputImpl *dinput, REFGUID rguid, REFIID
         }
 
         This = alloc_device(rguid, dinput, index);
+        if (!This)
+            return DIERR_INPUTLOST;
         TRACE("Created a Joystick device (%p)\n", This);
 
         if (!This) return DIERR_OUTOFMEMORY;
@@ -1098,7 +1113,7 @@ static HRESULT WINAPI JoystickWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REF
         {
             LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
 
-            pd->dwData = This->sdldev->id;
+            pd->dwData = This->sdldev - sdldevs;
             TRACE("DIPROP_JOYSTICKID(%d)\n", pd->dwData);
             break;
         }
From ccc96e8e78d7e2d6d91a15bfa100ac8feda6771d Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 12 Sep 2019 14:21:08 -0500
Subject: [PATCH] dinput: Poll for new SDL devices when requested

---
 dlls/dinput/joystick_sdl.c | 136 ++++++++++++++++++++++++-------------
 1 file changed, 90 insertions(+), 46 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index e5600c39977..95dba8cac83 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -109,6 +109,9 @@ struct SDLDev {
     BOOL has_ff, is_joystick;
     int autocenter;
     int gain;
+
+    SDL_Joystick *sdl_js;
+
     struct list effects;
 };
 
@@ -184,20 +187,12 @@ static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
     return strcasestr(blacklist, needle) != NULL;
 }
 
-static void find_sdldevs(void)
+static Uint16 (*pSDL_JoystickGetProduct)(SDL_Joystick *);
+static Uint16 (*pSDL_JoystickGetVendor)(SDL_Joystick *);
+
+static BOOL WINAPI sdldrv_init(INIT_ONCE *once, void *param, void **context)
 {
-    int i;
-    Uint16 (*pSDL_JoystickGetProduct)(SDL_Joystick * joystick) = NULL;
-    Uint16 (*pSDL_JoystickGetVendor)(SDL_Joystick * joystick) = NULL;
     void *sdl_handle = NULL;
-    static int have_sdldevs = -1;
-
-    if (InterlockedCompareExchange(&have_sdldevs, 0, -1) != -1)
-        /* Someone beat us to it */
-        return;
-
-    SDL_Init(SDL_INIT_JOYSTICK|SDL_INIT_HAPTIC);
-    SDL_JoystickEventState(SDL_ENABLE);
 
     sdl_handle = dlopen(SONAME_LIBSDL2, RTLD_NOW);
     if (sdl_handle) {
@@ -209,12 +204,59 @@ static void find_sdldevs(void)
         ERR("SDL installation is old! Please upgrade to >=2.0.6 to get accurate joystick information.\n");
     }
 
+    SDL_Init(SDL_INIT_JOYSTICK|SDL_INIT_HAPTIC);
+    SDL_JoystickEventState(SDL_ENABLE);
+
+    return TRUE;
+}
+
+static void find_sdldevs(void)
+{
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+    static ULONGLONG last_check = 0;
+    ULONGLONG now;
+    int i;
+
+    InitOnceExecuteOnce(&init_once, sdldrv_init, NULL, NULL);
+
+    SDL_PumpEvents();
+
+    now = GetTickCount64();
+
+    if(last_check > 0 && last_check + 1000 > now)
+        return;
+
+    last_check = now;
+
+    EnterCriticalSection(&sdldevs_lock);
+
     for (i = 0; i < SDL_NumJoysticks(); i++)
     {
-        struct SDLDev *sdldev = &sdldevs[have_sdldevs];
+        struct SDLDev *sdldev = &sdldevs[0];
         SDL_Joystick *device;
         const CHAR* name;
 
+        while(sdldev < &sdldevs[ARRAY_SIZE(sdldevs)] &&
+                sdldev->valid)
+        {
+            if(sdldev->instance_id == SDL_JoystickGetDeviceInstanceID(i))
+                break;
+            sdldev++;
+        }
+
+        if(sdldev >= &sdldevs[ARRAY_SIZE(sdldevs)])
+        {
+            ERR("ran out of joystick slots!!\n");
+            LeaveCriticalSection(&sdldevs_lock);
+            return;
+        }
+
+        if(sdldev->valid)
+        {
+            /* this joystic is already discovered */
+            continue;
+        }
+
         device = SDL_JoystickOpen(i);
         sdldev->instance_id = SDL_JoystickInstanceID(device);
 
@@ -228,7 +270,7 @@ static void find_sdldevs(void)
             continue;
         }
 
-        TRACE("Found a joystick (%i) on %p: %s\n", have_sdldevs, device, sdldev->name);
+        TRACE("Found a joystick on %p: %s\n", device, sdldev->name);
 
         if (SDL_JoystickIsHaptic(device))
         {
@@ -253,6 +295,7 @@ static void find_sdldevs(void)
         {
             TRACE("joystick %04x/%04x is in SDL blacklist, ignoring\n", sdldev->vendor_id, sdldev->product_id);
             SDL_JoystickClose(device);
+            HeapFree(GetProcessHeap(), 0, sdldev->name);
             continue;
         }
 
@@ -274,12 +317,13 @@ static void find_sdldevs(void)
         sdldev->n_axes = SDL_JoystickNumAxes(device);
         sdldev->n_hats = SDL_JoystickNumHats(device);
 
-        sdldev->valid = TRUE;
-
-        SDL_JoystickClose(device);
+        sdldev->sdl_js = device;
 
-        have_sdldevs++;
+        /* must be last member to be set */
+        sdldev->valid = TRUE;
     }
+
+    LeaveCriticalSection(&sdldevs_lock);
 }
 
 static struct device_info_override {
@@ -414,21 +458,27 @@ static void fill_joystick_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD ver
 
 static HRESULT sdl_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
 {
-  find_sdldevs();
+    find_sdldevs();
 
     if (id >= ARRAY_SIZE(sdldevs) || !sdldevs[id].valid)
         return E_FAIL;
 
-  if (!((dwDevType == 0) ||
-        ((dwDevType == DIDEVTYPE_JOYSTICK) && (version >= 0x0300 && version < 0x0800)) ||
-        (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
-    return S_FALSE;
+    if (!((dwDevType == 0) ||
+          ((dwDevType == DIDEVTYPE_JOYSTICK) && (version >= 0x0300 && version < 0x0800)) ||
+          (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
+        return S_FALSE;
+
+    if ((dwFlags & DIEDFL_FORCEFEEDBACK) && !sdldevs[id].has_ff)
+        return S_FALSE;
+
+    if (dwFlags & DIEDFL_ATTACHEDONLY)
+    {
+        if (!SDL_JoystickGetAttached(sdldevs[id].sdl_js))
+            return S_FALSE;
+    }
 
-  if (!(dwFlags & DIEDFL_FORCEFEEDBACK) || sdldevs[id].has_ff) {
     fill_joystick_dideviceinstanceA(lpddi, version, id);
     return S_OK;
-  }
-  return S_FALSE;
 }
 
 static HRESULT sdl_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
@@ -438,19 +488,22 @@ static HRESULT sdl_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTAN
     if (id >= ARRAY_SIZE(sdldevs) || !sdldevs[id].valid)
         return E_FAIL;
 
-  if (!sdldevs[id].valid)
-      return E_FAIL;
+    if (!((dwDevType == 0) ||
+          ((dwDevType == DIDEVTYPE_JOYSTICK) && (version >= 0x0300 && version < 0x0800)) ||
+          (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
+        return S_FALSE;
+
+    if ((dwFlags & DIEDFL_FORCEFEEDBACK) && !sdldevs[id].has_ff)
+        return S_FALSE;
 
-  if (!((dwDevType == 0) ||
-        ((dwDevType == DIDEVTYPE_JOYSTICK) && (version >= 0x0300 && version < 0x0800)) ||
-        (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
-    return S_FALSE;
+    if (dwFlags & DIEDFL_ATTACHEDONLY)
+    {
+        if (!SDL_JoystickGetAttached(sdldevs[id].sdl_js))
+            return S_FALSE;
+    }
 
-  if (!(dwFlags & DIEDFL_FORCEFEEDBACK) || sdldevs[id].has_ff) {
     fill_joystick_dideviceinstanceW(lpddi, version, id);
     return S_OK;
-  }
-  return S_FALSE;
 }
 
 static int buttons_to_sdl_hat(int u, int r, int d, int l)
@@ -825,18 +878,10 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     DIDEVICEINSTANCEW ddi;
     int i,idx = 0, axis_count = 0, button_count = 0, hat_count = 0;
     struct device_state_item item;
-    SDL_Joystick *sdl_js;
 
-    sdl_js = SDL_JoystickFromInstanceID(sdldevs[index].instance_id);
-    if (!sdl_js)
+    if (!SDL_JoystickGetAttached(sdldevs[index].sdl_js))
         return NULL;
 
-    if (!SDL_JoystickGetAttached(sdl_js))
-    {
-        SDL_JoystickClose(sdl_js);
-        return NULL;
-    }
-
     newDevice = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(JoystickImpl));
     if (!newDevice) return NULL;
 
@@ -862,7 +907,7 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     newDevice->generic.base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": JoystickImpl*->base.crit");
 
     /* Open Device */
-    newDevice->device = sdl_js;
+    newDevice->device = sdldevs[index].sdl_js;
     newDevice->haptic = SDL_HapticOpenFromJoystick(newDevice->device);
 
     i = 0;
@@ -1058,7 +1103,6 @@ static ULONG WINAPI JoystickWImpl_Release(LPDIRECTINPUTDEVICE8W iface)
         TRACE("Closing Joystick: %p\n",This);
         if (This->sdldev->has_ff)
             SDL_HapticClose(This->haptic);
-        SDL_JoystickClose(This->device);
         This->device = NULL;
     }
     return IDirectInputDevice2WImpl_Release(iface);
From 4bdefa955ecd100ef8a1c5afb1eb109955b5de70 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 16 Sep 2019 12:31:37 -0500
Subject: [PATCH] dinput: Access SDL_Joystick member once per operation

In case it changes out from under us.
---
 dlls/dinput/joystick_sdl.c | 103 +++++++++++++++++--------------------
 1 file changed, 48 insertions(+), 55 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 95dba8cac83..a32e745dc37 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -94,7 +94,7 @@ struct device_state_item {
     int val;
 };
 
-typedef BOOL (*enum_device_state_function)(JoystickImpl*, struct device_state_item *, int);
+typedef BOOL (*enum_device_state_function)(SDL_Joystick *, JoystickImpl *, struct device_state_item *, int);
 
 struct SDLDev {
     BOOL valid;
@@ -106,11 +106,12 @@ struct SDLDev {
 
     int n_buttons, n_axes, n_hats;
 
-    BOOL has_ff, is_joystick;
+    BOOL is_joystick;
     int autocenter;
     int gain;
 
     SDL_Joystick *sdl_js;
+    SDL_Haptic *sdl_haptic;
 
     struct list effects;
 };
@@ -120,8 +121,6 @@ struct JoystickImpl
     struct JoystickGenericImpl generic;
     struct SDLDev              *sdldev;
 
-    SDL_Joystick *device;
-    SDL_Haptic *haptic;
     BOOL ff_paused;
 
     enum_device_state_function enum_device_state;
@@ -234,6 +233,7 @@ static void find_sdldevs(void)
     {
         struct SDLDev *sdldev = &sdldevs[0];
         SDL_Joystick *device;
+        SDL_Haptic *haptic = NULL;
         const CHAR* name;
 
         while(sdldev < &sdldevs[ARRAY_SIZE(sdldevs)] &&
@@ -274,12 +274,10 @@ static void find_sdldevs(void)
 
         if (SDL_JoystickIsHaptic(device))
         {
-            SDL_Haptic *haptic = SDL_HapticOpenFromJoystick(device);
+            haptic = SDL_HapticOpenFromJoystick(device);
             if (haptic)
             {
                 TRACE(" ... with force feedback\n");
-                sdldev->has_ff = TRUE;
-                SDL_HapticClose(haptic);
             }
         }
 
@@ -318,6 +316,7 @@ static void find_sdldevs(void)
         sdldev->n_hats = SDL_JoystickNumHats(device);
 
         sdldev->sdl_js = device;
+        sdldev->sdl_haptic = haptic;
 
         /* must be last member to be set */
         sdldev->valid = TRUE;
@@ -468,7 +467,7 @@ static HRESULT sdl_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTAN
           (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
         return S_FALSE;
 
-    if ((dwFlags & DIEDFL_FORCEFEEDBACK) && !sdldevs[id].has_ff)
+    if ((dwFlags & DIEDFL_FORCEFEEDBACK) && !sdldevs[id].sdl_haptic)
         return S_FALSE;
 
     if (dwFlags & DIEDFL_ATTACHEDONLY)
@@ -493,7 +492,7 @@ static HRESULT sdl_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTAN
           (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
         return S_FALSE;
 
-    if ((dwFlags & DIEDFL_FORCEFEEDBACK) && !sdldevs[id].has_ff)
+    if ((dwFlags & DIEDFL_FORCEFEEDBACK) && !sdldevs[id].sdl_haptic)
         return S_FALSE;
 
     if (dwFlags & DIEDFL_ATTACHEDONLY)
@@ -532,7 +531,7 @@ static int buttons_to_sdl_hat(int u, int r, int d, int l)
 }
 
 /* playstation controllers */
-static BOOL enum_device_state_ds4_16button(JoystickImpl *This, struct device_state_item *st, int idx)
+static BOOL enum_device_state_ds4_16button(SDL_Joystick *js, JoystickImpl *This, struct device_state_item *st, int idx)
 {
 #define SPECIALCASE_HAT -1
 #define SPECIALCASE_L2_BUTTON -2
@@ -584,15 +583,15 @@ static BOOL enum_device_state_ds4_16button(JoystickImpl *This, struct device_sta
         switch(map_ds4_16button[idx].type)
         {
         case ITEM_TYPE_BUTTON:
-            st->val = SDL_JoystickGetButton(This->device, map_ds4_16button[idx].sdl_idx);
+            st->val = SDL_JoystickGetButton(js, map_ds4_16button[idx].sdl_idx);
             return TRUE;
 
         case ITEM_TYPE_AXIS:
-            st->val = SDL_JoystickGetAxis(This->device, map_ds4_16button[idx].sdl_idx);
+            st->val = SDL_JoystickGetAxis(js, map_ds4_16button[idx].sdl_idx);
             return TRUE;
 
         case ITEM_TYPE_HAT:
-            st->val = SDL_JoystickGetHat(This->device, map_ds4_16button[idx].sdl_idx);
+            st->val = SDL_JoystickGetHat(js, map_ds4_16button[idx].sdl_idx);
             return TRUE;
         }
     }
@@ -606,10 +605,10 @@ static BOOL enum_device_state_ds4_16button(JoystickImpl *This, struct device_sta
         static const int SDL_DPAD_LEFT_BUTTON = 13;
         static const int SDL_DPAD_RIGHT_BUTTON = 14;
         st->val = buttons_to_sdl_hat(
-                SDL_JoystickGetButton(This->device, SDL_DPAD_UP_BUTTON),
-                SDL_JoystickGetButton(This->device, SDL_DPAD_RIGHT_BUTTON),
-                SDL_JoystickGetButton(This->device, SDL_DPAD_DOWN_BUTTON),
-                SDL_JoystickGetButton(This->device, SDL_DPAD_LEFT_BUTTON));
+                SDL_JoystickGetButton(js, SDL_DPAD_UP_BUTTON),
+                SDL_JoystickGetButton(js, SDL_DPAD_RIGHT_BUTTON),
+                SDL_JoystickGetButton(js, SDL_DPAD_DOWN_BUTTON),
+                SDL_JoystickGetButton(js, SDL_DPAD_LEFT_BUTTON));
         return TRUE;
     }
 
@@ -618,7 +617,7 @@ static BOOL enum_device_state_ds4_16button(JoystickImpl *This, struct device_sta
         /* L2 button */
         /* turn button on at about 1/8 of the trigger travel */
         static const int SDL_L2_AXIS = 4;
-        st->val = SDL_JoystickGetAxis(This->device, SDL_L2_AXIS) > 3 * SDL_JOYSTICK_AXIS_MIN / 4;
+        st->val = SDL_JoystickGetAxis(js, SDL_L2_AXIS) > 3 * SDL_JOYSTICK_AXIS_MIN / 4;
         return TRUE;
     }
 
@@ -627,7 +626,7 @@ static BOOL enum_device_state_ds4_16button(JoystickImpl *This, struct device_sta
         /* R2 button */
         /* turn button on at about 1/8 of the trigger travel */
         static const int SDL_R2_AXIS = 5;
-        st->val = SDL_JoystickGetAxis(This->device, SDL_R2_AXIS) > 3 * SDL_JOYSTICK_AXIS_MIN / 4;
+        st->val = SDL_JoystickGetAxis(js, SDL_R2_AXIS) > 3 * SDL_JOYSTICK_AXIS_MIN / 4;
         return TRUE;
     }
     }
@@ -640,7 +639,7 @@ static BOOL enum_device_state_ds4_16button(JoystickImpl *This, struct device_sta
 #undef SPECIALCASE_R2_BUTTON
 }
 
-static BOOL enum_device_state_ds4_13button(JoystickImpl *This, struct device_state_item *st, int idx)
+static BOOL enum_device_state_ds4_13button(SDL_Joystick *js, JoystickImpl *This, struct device_state_item *st, int idx)
 {
     static const struct {
         int type;
@@ -692,15 +691,15 @@ static BOOL enum_device_state_ds4_13button(JoystickImpl *This, struct device_sta
     switch(map_ds4_13button[idx].type)
     {
     case ITEM_TYPE_BUTTON:
-        st->val = SDL_JoystickGetButton(This->device, map_ds4_13button[idx].sdl_idx);
+        st->val = SDL_JoystickGetButton(js, map_ds4_13button[idx].sdl_idx);
         return TRUE;
 
     case ITEM_TYPE_AXIS:
-        st->val = SDL_JoystickGetAxis(This->device, map_ds4_13button[idx].sdl_idx);
+        st->val = SDL_JoystickGetAxis(js, map_ds4_13button[idx].sdl_idx);
         return TRUE;
 
     case ITEM_TYPE_HAT:
-        st->val = SDL_JoystickGetHat(This->device, map_ds4_13button[idx].sdl_idx);
+        st->val = SDL_JoystickGetHat(js, map_ds4_13button[idx].sdl_idx);
         return TRUE;
     }
 
@@ -709,7 +708,7 @@ static BOOL enum_device_state_ds4_13button(JoystickImpl *This, struct device_sta
 }
 
 /* straight 1:1 mapping of SDL items and dinput items */
-static BOOL enum_device_state_standard(JoystickImpl *This, struct device_state_item *st, int idx)
+static BOOL enum_device_state_standard(SDL_Joystick *js, JoystickImpl *This, struct device_state_item *st, int idx)
 {
     DWORD n_buttons, n_axes, n_hats;
 
@@ -719,7 +718,7 @@ static BOOL enum_device_state_standard(JoystickImpl *This, struct device_state_i
     {
         st->type = ITEM_TYPE_BUTTON;
         st->id = idx;
-        st->val = SDL_JoystickGetButton(This->device, idx);
+        st->val = SDL_JoystickGetButton(js, idx);
         return TRUE;
     }
 
@@ -731,7 +730,7 @@ static BOOL enum_device_state_standard(JoystickImpl *This, struct device_state_i
     {
         st->type = ITEM_TYPE_AXIS;
         st->id = idx;
-        st->val = SDL_JoystickGetAxis(This->device, idx);
+        st->val = SDL_JoystickGetAxis(js, idx);
         return TRUE;
     }
 
@@ -743,7 +742,7 @@ static BOOL enum_device_state_standard(JoystickImpl *This, struct device_state_i
     {
         st->type = ITEM_TYPE_HAT;
         st->id = idx;
-        st->val = SDL_JoystickGetHat(This->device, idx);
+        st->val = SDL_JoystickGetHat(js, idx);
         return TRUE;
     }
 
@@ -757,13 +756,14 @@ static HRESULT poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
     int inst_id = 0;
     int newVal = 0;
     struct device_state_item item;
+    SDL_Joystick *js = This->sdldev->sdl_js;
 
-    if(!SDL_JoystickGetAttached(This->device))
+    if(!SDL_JoystickGetAttached(js))
         return DIERR_INPUTLOST;
 
     SDL_JoystickUpdate();
 
-    while(This->enum_device_state(This, &item, i++))
+    while(This->enum_device_state(js, This, &item, i++))
     {
         switch(item.type){
         case ITEM_TYPE_BUTTON:
@@ -878,8 +878,11 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     DIDEVICEINSTANCEW ddi;
     int i,idx = 0, axis_count = 0, button_count = 0, hat_count = 0;
     struct device_state_item item;
+    SDL_Joystick *js;
 
-    if (!SDL_JoystickGetAttached(sdldevs[index].sdl_js))
+    js = sdldevs[index].sdl_js;
+
+    if (!SDL_JoystickGetAttached(js))
         return NULL;
 
     newDevice = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(JoystickImpl));
@@ -907,11 +910,9 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     newDevice->generic.base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": JoystickImpl*->base.crit");
 
     /* Open Device */
-    newDevice->device = sdldevs[index].sdl_js;
-    newDevice->haptic = SDL_HapticOpenFromJoystick(newDevice->device);
 
     i = 0;
-    while(newDevice->enum_device_state(newDevice, &item, i++)){
+    while(newDevice->enum_device_state(js, newDevice, &item, i++)){
         switch(item.type){
             case ITEM_TYPE_BUTTON:
                 ++button_count;
@@ -956,7 +957,7 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     if (!(df->rgodf = HeapAlloc(GetProcessHeap(), 0, df->dwNumObjs * df->dwObjSize))) goto failed;
 
     i = 0;
-    while(newDevice->enum_device_state(newDevice, &item, i++)){
+    while(newDevice->enum_device_state(js, newDevice, &item, i++)){
         switch(item.type){
             case ITEM_TYPE_BUTTON:
                 memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[item.id + 12], df->dwObjSize);
@@ -967,7 +968,7 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
             case ITEM_TYPE_AXIS:
                 memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[item.id], df->dwObjSize);
                 df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(item.id) | DIDFT_ABSAXIS;
-                if (newDevice->sdldev->has_ff && item.id < 2)
+                if (newDevice->sdldev->sdl_haptic && item.id < 2)
                      df->rgodf[idx].dwFlags |= DIDOI_FFACTUATOR;
 
                 newDevice->generic.props[idx].lDevMin = -32768;
@@ -987,7 +988,7 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
         }
     }
 
-    if (newDevice->sdldev->has_ff)
+    if (newDevice->sdldev->sdl_haptic)
         newDevice->generic.devcaps.dwFlags |= DIDC_FORCEFEEDBACK;
 
     newDevice->generic.base.data_format.wine_df = df;
@@ -1000,7 +1001,7 @@ static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsig
     fill_joystick_dideviceinstanceW(&ddi, newDevice->generic.base.dinput->dwVersion, index);
     newDevice->generic.devcaps.dwDevType = ddi.dwDevType;
 
-    if (newDevice->sdldev->has_ff)
+    if (newDevice->sdldev->sdl_haptic)
         newDevice->generic.devcaps.dwFlags |= DIDC_FORCEFEEDBACK;
 
     IDirectInput_AddRef(&newDevice->generic.base.dinput->IDirectInput7A_iface);
@@ -1096,15 +1097,7 @@ const struct dinput_device joystick_sdl_device = {
 
 static ULONG WINAPI JoystickWImpl_Release(LPDIRECTINPUTDEVICE8W iface)
 {
-    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
     TRACE("(this=%p)\n", iface);
-    if (This->generic.base.ref == 1 && This->device >= 0)
-    {
-        TRACE("Closing Joystick: %p\n",This);
-        if (This->sdldev->has_ff)
-            SDL_HapticClose(This->haptic);
-        This->device = NULL;
-    }
     return IDirectInputDevice2WImpl_Release(iface);
 }
 
@@ -1258,7 +1251,7 @@ static BOOL _SetProperty(JoystickImpl *This, const GUID *prop, const DIPROPHEADE
 
             This->sdldev->autocenter = pd->dwData == DIPROPAUTOCENTER_ON;
 
-            rc = SDL_HapticSetAutocenter(This->haptic, This->sdldev->autocenter * 100);
+            rc = SDL_HapticSetAutocenter(This->sdldev->sdl_haptic, This->sdldev->autocenter * 100);
             if (rc != 0)
                 ERR("SDL_HapticSetAutocenter failed: %s\n", SDL_GetError());
             break;
@@ -1272,7 +1265,7 @@ static BOOL _SetProperty(JoystickImpl *This, const GUID *prop, const DIPROPHEADE
 
             This->sdldev->gain = pd->dwData;
 
-            rc = SDL_HapticSetGain(This->haptic, sdl_gain);
+            rc = SDL_HapticSetGain(This->sdldev->sdl_haptic, sdl_gain);
             if (rc != 0)
                 ERR("SDL_HapticSetGain (%i -> %i) failed: %s\n", pd->dwData, sdl_gain, SDL_GetError());
             break;
@@ -1358,7 +1351,7 @@ static HRESULT WINAPI JoystickWImpl_CreateEffect(IDirectInputDevice8W *iface,
     TRACE("%p %s %p %p %p\n", iface, debugstr_guid(rguid), lpeff, ppdef, pUnkOuter);
     if (lpeff) dump_DIEFFECT(lpeff, rguid, 0);
 
-    if(!This->sdldev->has_ff){
+    if(!This->sdldev->sdl_haptic){
         TRACE("No force feedback support\n");
         *ppdef = NULL;
         return DIERR_UNSUPPORTED;
@@ -1376,7 +1369,7 @@ static HRESULT WINAPI JoystickWImpl_CreateEffect(IDirectInputDevice8W *iface,
     if (!(new_effect = HeapAlloc(GetProcessHeap(), 0, sizeof(*new_effect))))
     return DIERR_OUTOFMEMORY;
 
-    retval = sdl_create_effect(This->haptic, rguid, &new_effect->entry, &new_effect->ref);
+    retval = sdl_create_effect(This->sdldev->sdl_haptic, rguid, &new_effect->entry, &new_effect->ref);
     if (retval != DI_OK)
     {
         HeapFree(GetProcessHeap(), 0, new_effect);
@@ -1427,7 +1420,7 @@ static HRESULT WINAPI JoystickWImpl_EnumEffects(LPDIRECTINPUTDEVICE8W iface,
     TRACE("(this=%p,%p,%d) type=%d\n", This, pvRef, dwEffType, type);
 
     dei.dwSize = sizeof(DIEFFECTINFOW);
-    query = SDL_HapticQuery(This->haptic);
+    query = SDL_HapticQuery(This->sdldev->sdl_haptic);
     TRACE("Effects 0x%x\n",query);
 
     if ((type == DIEFT_ALL || type == DIEFT_CONSTANTFORCE)
@@ -1508,7 +1501,7 @@ static HRESULT WINAPI JoystickAImpl_EnumEffects(LPDIRECTINPUTDEVICE8A iface,
     TRACE("(this=%p,%p,%d) type=%d\n", This, pvRef, dwEffType, type);
 
     dei.dwSize = sizeof(DIEFFECTINFOA);
-    query = SDL_HapticQuery(This->haptic);
+    query = SDL_HapticQuery(This->sdldev->sdl_haptic);
     TRACE("Effects 0x%x\n",query);
 
     if ((type == DIEFT_ALL || type == DIEFT_CONSTANTFORCE)
@@ -1582,7 +1575,7 @@ static HRESULT WINAPI JoystickWImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8W iface,
 {
     JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
     TRACE("(this=%p,%p,%s)\n", This, pdei, _dump_dinput_GUID(guid));
-    return sdl_input_get_info_W(This->device, guid, pdei);
+    return sdl_input_get_info_W(This->sdldev->sdl_js, guid, pdei);
 }
 
 static HRESULT WINAPI JoystickAImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8A iface,
@@ -1591,7 +1584,7 @@ static HRESULT WINAPI JoystickAImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8A iface,
 {
     JoystickImpl* This = impl_from_IDirectInputDevice8A(iface);
     TRACE("(this=%p,%p,%s)\n", This, pdei, _dump_dinput_GUID(guid));
-    return sdl_input_get_info_A(This->device, guid, pdei);
+    return sdl_input_get_info_A(This->sdldev->sdl_js, guid, pdei);
 }
 
 static HRESULT WINAPI JoystickWImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8W iface, DWORD dwFlags)
@@ -1625,12 +1618,12 @@ static HRESULT WINAPI JoystickWImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE
     }
     case DISFFC_PAUSE:
         This->ff_paused = TRUE;
-        if (SDL_HapticPause(This->haptic) != 0)
+        if (SDL_HapticPause(This->sdldev->sdl_haptic) != 0)
             ERR("SDL_HapticPause failed: %s\n",SDL_GetError());
         break;
     case DISFFC_CONTINUE:
         This->ff_paused = FALSE;
-        if (SDL_HapticUnpause(This->haptic) != 0)
+        if (SDL_HapticUnpause(This->sdldev->sdl_haptic) != 0)
             ERR("SDL_HapticUnpause failed: %s\n",SDL_GetError());
         break;
 
From 26e821314c2e1e1e03a4db74294df09b15428b62 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 16 Sep 2019 13:49:06 -0500
Subject: [PATCH] dinput: Check for new devices on every access

---
 dlls/dinput/joystick_sdl.c | 36 +++++++++++++++++++++++++++++++++---
 1 file changed, 33 insertions(+), 3 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index a32e745dc37..c3b0a1b9e84 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -102,6 +102,7 @@ struct SDLDev {
     int instance_id;
     WORD vendor_id;
     WORD product_id;
+    SDL_JoystickGUID sdl_guid;
     CHAR *name;
 
     int n_buttons, n_axes, n_hats;
@@ -239,8 +240,15 @@ static void find_sdldevs(void)
         while(sdldev < &sdldevs[ARRAY_SIZE(sdldevs)] &&
                 sdldev->valid)
         {
+            SDL_JoystickGUID sdl_guid;
             if(sdldev->instance_id == SDL_JoystickGetDeviceInstanceID(i))
                 break;
+            sdl_guid = SDL_JoystickGetDeviceGUID(i);
+            if(!memcmp(&sdldev->sdl_guid, &sdl_guid, sizeof(SDL_JoystickGUID))){
+                if(!SDL_JoystickGetAttached(sdldev->sdl_js))
+                    /* same GUID but detached; reconnected, so assign to this slot */
+                    break;
+            }
             sdldev++;
         }
 
@@ -253,12 +261,26 @@ static void find_sdldevs(void)
 
         if(sdldev->valid)
         {
-            /* this joystic is already discovered */
+            if(SDL_JoystickGetAttached(sdldev->sdl_js))
+            {
+                /* this joystic is already discovered */
+                continue;
+            }
+
+            /* reconnected, update sdldev */
+            TRACE("reconnected \"%s\"\n", sdldev->name);
+            device = SDL_JoystickOpen(i);
+            sdldev->instance_id = SDL_JoystickInstanceID(device);
+            if (SDL_JoystickIsHaptic(device))
+                sdldev->sdl_haptic = SDL_HapticOpenFromJoystick(device);
+
+            InterlockedExchangePointer((void**)&sdldev->sdl_js, device);
             continue;
         }
 
         device = SDL_JoystickOpen(i);
         sdldev->instance_id = SDL_JoystickInstanceID(device);
+        sdldev->sdl_guid = SDL_JoystickGetGUID(device);
 
         name = SDL_JoystickName(device);
         sdldev->name = HeapAlloc(GetProcessHeap(), 0, strlen(name) + 1);
@@ -758,10 +780,16 @@ static HRESULT poll_sdl_device_state(LPDIRECTINPUTDEVICE8A iface)
     struct device_state_item item;
     SDL_Joystick *js = This->sdldev->sdl_js;
 
+    SDL_JoystickUpdate();
+
     if(!SDL_JoystickGetAttached(js))
-        return DIERR_INPUTLOST;
+    {
+        find_sdldevs();
 
-    SDL_JoystickUpdate();
+        js = This->sdldev->sdl_js;
+        if(!SDL_JoystickGetAttached(js))
+            return DIERR_INPUTLOST;
+    }
 
     while(This->enum_device_state(js, This, &item, i++))
     {
@@ -1575,6 +1603,7 @@ static HRESULT WINAPI JoystickWImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8W iface,
 {
     JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
     TRACE("(this=%p,%p,%s)\n", This, pdei, _dump_dinput_GUID(guid));
+    find_sdldevs();
     return sdl_input_get_info_W(This->sdldev->sdl_js, guid, pdei);
 }
 
@@ -1584,6 +1613,7 @@ static HRESULT WINAPI JoystickAImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8A iface,
 {
     JoystickImpl* This = impl_from_IDirectInputDevice8A(iface);
     TRACE("(this=%p,%p,%s)\n", This, pdei, _dump_dinput_GUID(guid));
+    find_sdldevs();
     return sdl_input_get_info_A(This->sdldev->sdl_js, guid, pdei);
 }
 
From 93d7111b680f9a2f0f7791d479692f7f1a31707a Mon Sep 17 00:00:00 2001
From: Bernat Arlandis <berarma@hotmail.com>
Date: Tue, 3 Dec 2019 00:16:43 +0100
Subject: [PATCH] dinput: Scale periodic effect offset correctly

---
 dlls/dinput/effect_sdl.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/dinput/effect_sdl.c b/dlls/dinput/effect_sdl.c
index 8055785cc02..8343247fa9a 100644
--- a/dlls/dinput/effect_sdl.c
+++ b/dlls/dinput/effect_sdl.c
@@ -289,7 +289,7 @@ static HRESULT WINAPI effect_GetParameters(IDirectInputEffect *iface,
             DIPERIODIC *tsp = effect->lpvTypeSpecificParams;
 
             tsp->dwMagnitude = MulDiv(This->effect.periodic.magnitude, 10000, 32767);
-            tsp->lOffset = This->effect.periodic.offset;
+            tsp->lOffset = SCALE(LONG, 20000, -10000, This->effect.periodic.offset, 0xffff, -32767);
             tsp->dwPhase = This->effect.periodic.phase;
             tsp->dwPeriod = This->effect.periodic.period * 1000;
         }
@@ -567,7 +567,7 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
             tsp = effect->lpvTypeSpecificParams;
 
             This->effect.periodic.magnitude = MulDiv(tsp->dwMagnitude, 32767, 10000);
-            This->effect.periodic.offset = tsp->lOffset;
+            This->effect.periodic.offset = SCALE(Sint16, 0xffff, -32767, tsp->lOffset, 20000, -10000);
             This->effect.periodic.phase = tsp->dwPhase;
             if (tsp->dwPeriod <= 1000)
                 This->effect.periodic.period = 1;
From 1cc970e338441749b97430236ff50c79c33f74b2 Mon Sep 17 00:00:00 2001
From: Bernat Arlandis <berarma@hotmail.com>
Date: Tue, 3 Dec 2019 00:16:43 +0100
Subject: [PATCH] dinput: Log effect directions, and use effective flags

---
 dlls/dinput/effect_sdl.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/dinput/effect_sdl.c b/dlls/dinput/effect_sdl.c
index 8343247fa9a..fbed8520941 100644
--- a/dlls/dinput/effect_sdl.c
+++ b/dlls/dinput/effect_sdl.c
@@ -427,8 +427,6 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
 
     TRACE("%p %p 0x%x\n", This, effect, flags);
 
-    dump_DIEFFECT(effect, &This->guid, flags);
-
     if (IsEqualGUID(&This->guid, &GUID_Sine))
         This->effect.type = SDL_HAPTIC_SINE;
     else if (IsEqualGUID(&This->guid, &GUID_Triangle))
@@ -469,6 +467,8 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
         This->first_axis_is_x = effect->rgdwAxes[0] == DIJOFS_X;
     }
 
+    dump_DIEFFECT(effect, &This->guid, flags);
+
     if (flags & DIEP_DIRECTION)
     {
         if (effect->cAxes == 1)
From 0b6612d0002c5835ec03a43792e279983cee56e1 Mon Sep 17 00:00:00 2001
From: Bernat Arlandis <berarma@hotmail.com>
Date: Tue, 3 Dec 2019 00:16:43 +0100
Subject: [PATCH] dinput: Don't set unused effect direction value

---
 dlls/dinput/effect_sdl.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/dlls/dinput/effect_sdl.c b/dlls/dinput/effect_sdl.c
index fbed8520941..345bf091280 100644
--- a/dlls/dinput/effect_sdl.c
+++ b/dlls/dinput/effect_sdl.c
@@ -479,7 +479,6 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
                 if (flags & DIEP_AXES)
                 {
                     SET_BASE_EFFECT_FIELD(This->effect, direction.dir[0], effect->rglDirection[0]);
-                    SET_BASE_EFFECT_FIELD(This->effect, direction.dir[1], effect->rglDirection[1]);
                 }
             } else {
                 /* one-axis effects must use cartesian coords */
From cea464743091a87acd6df91f01aa2c9721f549e3 Mon Sep 17 00:00:00 2001
From: Bernat Arlandis <berarma@hotmail.com>
Date: Tue, 3 Dec 2019 00:16:43 +0100
Subject: [PATCH] dinput: Set SDL gain correctly

---
 dlls/dinput/joystick_sdl.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index c3b0a1b9e84..fd2a1cda735 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -1287,12 +1287,14 @@ static BOOL _SetProperty(JoystickImpl *This, const GUID *prop, const DIPROPHEADE
         case (DWORD_PTR)DIPROP_FFGAIN:
         {
             LPCDIPROPDWORD pd = (LPCDIPROPDWORD)header;
-            int sdl_gain = MulDiv(This->sdldev->gain, 100, 10000);
+            int sdl_gain;
 
             TRACE("DIPROP_FFGAIN(%d)\n", pd->dwData);
 
             This->sdldev->gain = pd->dwData;
 
+            sdl_gain = MulDiv(This->sdldev->gain, 100, 10000);
+
             rc = SDL_HapticSetGain(This->sdldev->sdl_haptic, sdl_gain);
             if (rc != 0)
                 ERR("SDL_HapticSetGain (%i -> %i) failed: %s\n", pd->dwData, sdl_gain, SDL_GetError());
From 9220386d5e7a27e82f98ed93841e0a47a2ffbc5d Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 3 Dec 2019 14:44:57 -0600
Subject: [PATCH] dinput: Fix converting effect values to and from SDL

With assistance from Bernat Arlandis.
---
 dlls/dinput/effect_sdl.c | 61 ++++++++++++++++++++++++----------------
 1 file changed, 37 insertions(+), 24 deletions(-)

diff --git a/dlls/dinput/effect_sdl.c b/dlls/dinput/effect_sdl.c
index 345bf091280..36e9075dcdb 100644
--- a/dlls/dinput/effect_sdl.c
+++ b/dlls/dinput/effect_sdl.c
@@ -169,8 +169,21 @@ static HRESULT WINAPI effect_GetEffectGuid(IDirectInputEffect *iface, GUID *out)
         value = (target.custom.field); \
     }
 
-#define SCALE(type, target_range, target_min, value, source_range, source_min) \
-    (type)((((target_range)*(value + source_min))/source_range)-target_min)
+/* map [-32768, 0, 32767] -> [-10000, 0, 10000] */
+#define CENTERED_SDL_TO_DI(val) \
+    ((20000 * (val - 0x8000)) / 0xffff + 10000)
+
+/* map [-10000, 0, 10000] -> [-32768, 0, 32767] */
+#define CENTERED_DI_TO_SDL(val) \
+    ((0xffff * (val - 10000)) / 20000 + 0x7fff)
+
+/* map [0, sdl_max] -> [0, 10000] */
+#define ZEROED_SDL_TO_DI(val, sdl_max) \
+    ((10000 * val) / sdl_max)
+
+/* map [0, 10000] -> [0, sdl_max] */
+#define ZEROED_DI_TO_SDL(val, sdl_max) \
+    ((sdl_max * val) / 10000)
 
 static HRESULT WINAPI effect_GetParameters(IDirectInputEffect *iface,
         DIEFFECT *effect, DWORD flags)
@@ -288,22 +301,22 @@ static HRESULT WINAPI effect_GetParameters(IDirectInputEffect *iface,
         {
             DIPERIODIC *tsp = effect->lpvTypeSpecificParams;
 
-            tsp->dwMagnitude = MulDiv(This->effect.periodic.magnitude, 10000, 32767);
-            tsp->lOffset = SCALE(LONG, 20000, -10000, This->effect.periodic.offset, 0xffff, -32767);
+            tsp->dwMagnitude = ZEROED_SDL_TO_DI(This->effect.periodic.magnitude, SDL_MAX_SINT16);
+            tsp->lOffset = CENTERED_SDL_TO_DI(This->effect.periodic.offset);
             tsp->dwPhase = This->effect.periodic.phase;
             tsp->dwPeriod = This->effect.periodic.period * 1000;
         }
         else if (This->effect.type == SDL_HAPTIC_CONSTANT)
         {
             LPDICONSTANTFORCE tsp = effect->lpvTypeSpecificParams;
-            tsp->lMagnitude = SCALE(LONG, 20000, -10000, This->effect.constant.level, 0xffff, -32767);
+            tsp->lMagnitude = CENTERED_SDL_TO_DI(This->effect.constant.level);
         }
         else if (This->effect.type == SDL_HAPTIC_RAMP)
         {
             DIRAMPFORCE *tsp = effect->lpvTypeSpecificParams;
 
-            tsp->lStart = SCALE(Sint16, 20000, -10000, This->effect.ramp.start, 0xffff, -32767);
-            tsp->lEnd = SCALE(Sint16, 20000, -10000, This->effect.ramp.end, 0xffff, -32767);
+            tsp->lStart = CENTERED_SDL_TO_DI(This->effect.ramp.start);
+            tsp->lEnd = CENTERED_SDL_TO_DI(This->effect.ramp.end);
         }
         else if (This->effect.type == SDL_HAPTIC_SPRING ||
                  This->effect.type == SDL_HAPTIC_DAMPER ||
@@ -314,12 +327,12 @@ static HRESULT WINAPI effect_GetParameters(IDirectInputEffect *iface,
             DICONDITION *tsp = effect->lpvTypeSpecificParams;
             for (i = 0; i < 2; i++)
             {
-                tsp[i].lOffset = SCALE(LONG, 20000, -10000, This->effect.condition.center[i], 0xffff, -32767);
-                tsp[i].lPositiveCoefficient = SCALE(LONG, 20000, -10000, This->effect.condition.right_coeff[i], 0xffff, -32767);
-                tsp[i].lNegativeCoefficient = SCALE(LONG, 10000, -20000, This->effect.condition.left_coeff[i], 0xffff, -32767);
-                tsp[i].dwPositiveSaturation = SCALE(DWORD, 10000, 0, This->effect.condition.right_sat[i], 0xffff, 0);
-                tsp[i].dwNegativeSaturation = SCALE(DWORD, 10000, 0, This->effect.condition.left_sat[i], 0xffff, 0);
-                tsp[i].lDeadBand = SCALE(LONG, 20000, -10000, This->effect.condition.deadband[i], 0xffff, -32767);
+                tsp[i].lOffset = CENTERED_SDL_TO_DI(This->effect.condition.center[i]);
+                tsp[i].lPositiveCoefficient = CENTERED_SDL_TO_DI(This->effect.condition.right_coeff[i]);
+                tsp[i].lNegativeCoefficient = CENTERED_SDL_TO_DI(This->effect.condition.left_coeff[i]);
+                tsp[i].dwPositiveSaturation = ZEROED_SDL_TO_DI(This->effect.condition.right_sat[i], SDL_MAX_UINT16);
+                tsp[i].dwNegativeSaturation = ZEROED_SDL_TO_DI(This->effect.condition.left_sat[i], SDL_MAX_UINT16);
+                tsp[i].lDeadBand = This->effect.condition.deadband[i] * 10000 / SDL_MAX_UINT16;
             }
         }
         else if (This->effect.type == SDL_HAPTIC_CUSTOM)
@@ -565,8 +578,8 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
                 return DIERR_INVALIDPARAM;
             tsp = effect->lpvTypeSpecificParams;
 
-            This->effect.periodic.magnitude = MulDiv(tsp->dwMagnitude, 32767, 10000);
-            This->effect.periodic.offset = SCALE(Sint16, 0xffff, -32767, tsp->lOffset, 20000, -10000);
+            This->effect.periodic.magnitude = ZEROED_DI_TO_SDL(tsp->dwMagnitude, SDL_MAX_SINT16);
+            This->effect.periodic.offset = CENTERED_DI_TO_SDL(tsp->lOffset);
             This->effect.periodic.phase = tsp->dwPhase;
             if (tsp->dwPeriod <= 1000)
                 This->effect.periodic.period = 1;
@@ -580,7 +593,7 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
             if (effect->cbTypeSpecificParams != sizeof(DICONSTANTFORCE))
                 return DIERR_INVALIDPARAM;
             tsp = effect->lpvTypeSpecificParams;
-            This->effect.constant.level = SCALE(Sint16, 0xffff, -32767, tsp->lMagnitude, 20000, -10000);
+            This->effect.constant.level = CENTERED_DI_TO_SDL(tsp->lMagnitude);
         }
         else if (IsEqualGUID(&This->guid, &GUID_RampForce))
         {
@@ -589,8 +602,8 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
             if (effect->cbTypeSpecificParams != sizeof(DIRAMPFORCE))
                 return DIERR_INVALIDPARAM;
             tsp = effect->lpvTypeSpecificParams;
-            This->effect.ramp.start = SCALE(Sint16, 0xffff, -32767, tsp->lStart, 20000, -10000);
-            This->effect.ramp.end = SCALE(Sint16, 0xffff, -32767, tsp->lEnd, 20000, -10000);
+            This->effect.ramp.start = CENTERED_DI_TO_SDL(tsp->lStart);
+            This->effect.ramp.end = CENTERED_DI_TO_SDL(tsp->lEnd);
         }
         else if (IsEqualGUID(&This->guid, &GUID_Spring) ||
             IsEqualGUID(&This->guid, &GUID_Damper) ||
@@ -612,12 +625,12 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
 
             for (i = j = 0; i < 3; ++i)
             {
-                This->effect.condition.right_sat[i] = SCALE(Uint16, 0xffff, 0, tsp[j].dwPositiveSaturation, 10000, 0);
-                This->effect.condition.left_sat[i] = SCALE(Uint16, 0xffff, 0, tsp[j].dwNegativeSaturation, 10000, 0);
-                This->effect.condition.right_coeff[i] = SCALE(Sint16, 0xffff, -32767, tsp[j].lPositiveCoefficient, 20000, -10000);
-                This->effect.condition.left_coeff[i] = SCALE(Sint16, 0xffff, -32767, tsp[j].lNegativeCoefficient, 20000, -10000);
-                This->effect.condition.deadband[i] = SCALE(Uint16, 0xffff, 0, tsp[j].lDeadBand, 10000, 0);
-                This->effect.condition.center[i] = SCALE(Sint16, 0xffff, -32767, tsp[j].lOffset, 20000, -10000);
+                This->effect.condition.right_sat[i] = ZEROED_DI_TO_SDL(tsp[j].dwPositiveSaturation, SDL_MAX_UINT16);
+                This->effect.condition.left_sat[i] = ZEROED_DI_TO_SDL(tsp[j].dwNegativeSaturation, SDL_MAX_UINT16);
+                This->effect.condition.right_coeff[i] = CENTERED_DI_TO_SDL(tsp[j].lPositiveCoefficient);
+                This->effect.condition.left_coeff[i] = CENTERED_DI_TO_SDL(tsp[j].lNegativeCoefficient);
+                This->effect.condition.deadband[i] = tsp[j].lDeadBand * SDL_MAX_UINT16 / 10000;
+                This->effect.condition.center[i] = CENTERED_DI_TO_SDL(tsp[j].lOffset);
                if (sources-1 > j)
                 j++;
             }
From 5013b524c03151342329082943832afd7835cb35 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 3 Dec 2019 13:38:28 -0600
Subject: [PATCH] dinput: Add mapping for xbox controllers

---
 dlls/dinput/joystick_sdl.c | 92 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 92 insertions(+)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index fd2a1cda735..158669881fc 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -729,6 +729,83 @@ static BOOL enum_device_state_ds4_13button(SDL_Joystick *js, JoystickImpl *This,
     return FALSE;
 }
 
+static BOOL enum_device_state_ms_xb360(SDL_Joystick *js, JoystickImpl *This, struct device_state_item *st, int idx)
+{
+#define SPECIALCASE_TRIGGERS -1
+
+    static const struct {
+        int type;
+        int sdl_idx;
+        int dnp_id;
+    } map_ms_xb360[] = {
+        { ITEM_TYPE_AXIS, 1, 1 }, /* left vert */
+        { ITEM_TYPE_AXIS, 0, 0 }, /* left horiz */
+        { ITEM_TYPE_AXIS, 4, 4 }, /* right vert */
+        { ITEM_TYPE_AXIS, 3, 3 }, /* right horiz */
+        { ITEM_TYPE_AXIS, SPECIALCASE_TRIGGERS, 2 }, /* combined triggers */
+
+        { ITEM_TYPE_BUTTON, 0, 0}, /* A */
+        { ITEM_TYPE_BUTTON, 1, 1}, /* B */
+        { ITEM_TYPE_BUTTON, 2, 2}, /* X */
+        { ITEM_TYPE_BUTTON, 3, 3}, /* Y */
+        { ITEM_TYPE_BUTTON, 4, 4}, /* LB */
+        { ITEM_TYPE_BUTTON, 5, 5}, /* RB */
+        { ITEM_TYPE_BUTTON, 6, 6}, /* Back */
+        { ITEM_TYPE_BUTTON, 7, 7}, /* Start */
+        /* guide button (#8) is not reported by dinput */
+        { ITEM_TYPE_BUTTON, 9, 8}, /* LS */
+        { ITEM_TYPE_BUTTON, 10, 9}, /* RS */
+
+        { ITEM_TYPE_HAT, 0, 0 }, /* d-pad */
+    };
+
+    if(idx >= ARRAY_SIZE(map_ms_xb360))
+        return FALSE;
+
+    st->type = map_ms_xb360[idx].type;
+    st->id = map_ms_xb360[idx].dnp_id;
+
+    if(map_ms_xb360[idx].sdl_idx >= 0)
+    {
+        /* simple reads */
+        switch(map_ms_xb360[idx].type)
+        {
+        case ITEM_TYPE_BUTTON:
+            st->val = SDL_JoystickGetButton(js, map_ms_xb360[idx].sdl_idx);
+            return TRUE;
+
+        case ITEM_TYPE_AXIS:
+            st->val = SDL_JoystickGetAxis(js, map_ms_xb360[idx].sdl_idx);
+            return TRUE;
+
+        case ITEM_TYPE_HAT:
+            st->val = SDL_JoystickGetHat(js, map_ms_xb360[idx].sdl_idx);
+            return TRUE;
+        }
+    }
+
+    switch(map_ms_xb360[idx].sdl_idx){
+    case SPECIALCASE_TRIGGERS:
+    {
+        /* combined triggers axis */
+        static const int SDL_LTRIGGER = 2;
+        static const int SDL_RTRIGGER = 5;
+
+        int ltrigger = SDL_JoystickGetAxis(js, SDL_LTRIGGER);
+        int rtrigger = SDL_JoystickGetAxis(js, SDL_RTRIGGER);
+
+        /* yes, they are combined into one value and cannot be detangled */
+        st->val = (ltrigger - rtrigger) / 2;
+        return TRUE;
+    }
+    }
+
+    ERR("???\n"); /* error in static data above */
+    return FALSE;
+
+#undef SPECIALCASE_TRIGGERS
+}
+
 /* straight 1:1 mapping of SDL items and dinput items */
 static BOOL enum_device_state_standard(SDL_Joystick *js, JoystickImpl *This, struct device_state_item *st, int idx)
 {
@@ -893,6 +970,21 @@ static enum_device_state_function select_enum_function(struct SDLDev *sdldev)
             return enum_device_state_ds4_13button;
         }
         break;
+
+    case VID_MICROSOFT:
+        switch(sdldev->product_id){
+        case PID_MICROSOFT_XBOX_360:
+        case PID_MICROSOFT_XBOX_360_WIRELESS:
+        case PID_MICROSOFT_XBOX_360_ADAPTER:
+        case PID_MICROSOFT_XBOX_ONE:
+        case PID_MICROSOFT_XBOX_ONE_CF:
+        case PID_MICROSOFT_XBOX_ONE_ELITE:
+        case PID_MICROSOFT_XBOX_ONE_S:
+        case PID_MICROSOFT_XBOX_ONE_S_2:
+            TRACE("for %04x/%04x, polling xbox 360/one controller\n", sdldev->vendor_id, sdldev->product_id);
+            return enum_device_state_ms_xb360;
+        }
+        break;
     }
 
     TRACE("for %04x/%04x, using no maps\n", sdldev->vendor_id, sdldev->product_id);
From 95b5a4fc849d06352f7e4cfaa5ecfd9de5895a47 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 28 Aug 2018 10:35:19 -0500
Subject: [PATCH] winebus: Show an ERR on old SDL

---
 dlls/winebus.sys/bus_sdl.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index 95d5b9f9d0d..64407acc9e5 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -1161,6 +1161,9 @@ NTSTATUS sdl_driver_init(void)
         pSDL_JoystickGetProduct = dlsym(sdl_handle, "SDL_JoystickGetProduct");
         pSDL_JoystickGetProductVersion = dlsym(sdl_handle, "SDL_JoystickGetProductVersion");
         pSDL_JoystickGetVendor = dlsym(sdl_handle, "SDL_JoystickGetVendor");
+        if(!pSDL_JoystickGetVendor){
+            ERR("SDL installation is old! Please upgrade to >=2.0.6 to get accurate joystick information.\n");
+        }
     }
 
     map_controllers = check_bus_option(&controller_mode, 1);
From 402fd2744267638d6bf89974b2a8c49cf87268a3 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 2 May 2019 10:17:49 -0500
Subject: [PATCH] winebus.sys: Don't report the guide button

This breaks our xinput.
---
 dlls/winebus.sys/bus_sdl.c | 9 ++++++---
 dlls/xinput1_3/hid.c       | 5 ++---
 2 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index 64407acc9e5..0e052b6f8a6 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -151,17 +151,17 @@ static const BYTE REPORT_AXIS_TAIL[] = {
 };
 #define IDX_ABS_AXIS_COUNT 23
 
-#define CONTROLLER_NUM_BUTTONS 11
+#define CONTROLLER_NUM_BUTTONS 10
 
 static const BYTE CONTROLLER_BUTTONS[] = {
     0x05, 0x09, /* USAGE_PAGE (Button) */
     0x19, 0x01, /* USAGE_MINIMUM (Button 1) */
-    0x29, CONTROLLER_NUM_BUTTONS, /* USAGE_MAXIMUM (Button 11) */
+    0x29, CONTROLLER_NUM_BUTTONS, /* USAGE_MAXIMUM (Button 10) */
     0x15, 0x00, /* LOGICAL_MINIMUM (0) */
     0x25, 0x01, /* LOGICAL_MAXIMUM (1) */
     0x35, 0x00, /* LOGICAL_MINIMUM (0) */
     0x45, 0x01, /* LOGICAL_MAXIMUM (1) */
-    0x95, CONTROLLER_NUM_BUTTONS, /* REPORT_COUNT (11) */
+    0x95, CONTROLLER_NUM_BUTTONS, /* REPORT_COUNT (10) */
     0x75, 0x01, /* REPORT_SIZE (1) */
     0x81, 0x02, /* INPUT (Data,Var,Abs) */
 };
@@ -837,7 +837,10 @@ static BOOL set_mapped_report_from_event(SDL_Event *event)
                 case SDL_CONTROLLER_BUTTON_START: usage = 7; break;
                 case SDL_CONTROLLER_BUTTON_LEFTSTICK: usage = 8; break;
                 case SDL_CONTROLLER_BUTTON_RIGHTSTICK: usage = 9; break;
+
+                /* native HID does not report the guide button
                 case SDL_CONTROLLER_BUTTON_GUIDE: usage = 10; break;
+                */
 
                 case SDL_CONTROLLER_BUTTON_DPAD_UP:
                 case SDL_CONTROLLER_BUTTON_DPAD_DOWN:
diff --git a/dlls/xinput1_3/hid.c b/dlls/xinput1_3/hid.c
index bb719ed56cc..28cbf0c4d7d 100644
--- a/dlls/xinput1_3/hid.c
+++ b/dlls/xinput1_3/hid.c
@@ -110,7 +110,7 @@ static BOOL VerifyGamepad(PHIDP_PREPARSED_DATA ppd, XINPUT_CAPABILITIES *xinput_
             button_count = max(button_count, button_caps[i].NotRange.Usage);
     }
     HeapFree(GetProcessHeap(), 0, button_caps);
-    if (button_count < 11)
+    if (button_count < 10)
         WARN("Too few buttons, continuing anyway\n");
     xinput_caps->Gamepad.wButtons = 0xffff;
 
@@ -342,7 +342,7 @@ void HID_update_state(xinput_controller *device, XINPUT_STATE *state)
     CHAR *report = private->reports[(private->current_report)%2];
     CHAR *target_report = private->reports[(private->current_report+1)%2];
 
-    USAGE buttons[11];
+    USAGE buttons[10];
     ULONG button_length, hat_value;
     LONG value;
 
@@ -384,7 +384,6 @@ void HID_update_state(xinput_controller *device, XINPUT_STATE *state)
                 case 8: device->state.Gamepad.wButtons |= XINPUT_GAMEPAD_START; break;
                 case 9: device->state.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_THUMB; break;
                 case 10: device->state.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_THUMB; break;
-                case 11: device->state.Gamepad.wButtons |= XINPUT_GAMEPAD_GUIDE; break;
             }
         }
 
From c8f67246ba4d2a4cb427a5b2d1e6f54ebdde0aff Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 30 Apr 2019 11:18:45 -0500
Subject: [PATCH] winebus.sys: Report triggers as a single axis

This breaks our xinput (triggers can't be de-mangled).
---
 dlls/winebus.sys/bus_sdl.c | 71 +++++++++++++++++++++++++++-----------
 dlls/xinput1_3/hid.c       | 23 ++++++------
 2 files changed, 61 insertions(+), 33 deletions(-)

diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index 0e052b6f8a6..85ed84290d7 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -184,17 +184,17 @@ static const BYTE CONTROLLER_AXIS [] = {
 static const BYTE CONTROLLER_TRIGGERS [] = {
     0x05, 0x01,         /* USAGE_PAGE (Generic Desktop) */
     0x09, 0x32,         /* USAGE (Z) */
-    0x09, 0x35,         /* USAGE (RZ) */
-    0x16, 0x00, 0x00,   /* LOGICAL_MINIMUM (0) */
-    0x26, 0xff, 0x7f,   /* LOGICAL_MAXIMUM (32767) */
-    0x36, 0x00, 0x00,   /* PHYSICAL_MINIMUM (0) */
-    0x46, 0xff, 0x7f,   /* PHYSICAL_MAXIMUM (32767) */
+    0x17, 0x00, 0x00, 0x00, 0x00,   /* LOGICAL_MINIMUM (0) */
+    0x27, 0xff, 0xff, 0x00, 0x00,   /* LOGICAL_MAXIMUM (65535) */
+    0x37, 0x00, 0x00, 0x00, 0x00,   /* PHYSICAL_MINIMUM (0) */
+    0x47, 0xff, 0xff, 0x00, 0x00,   /* PHYSICAL_MAXIMUM (65535) */
     0x75, 0x10,         /* REPORT_SIZE (16) */
-    0x95, 0x02,         /* REPORT_COUNT (2) */
+    0x95, 0x01,         /* REPORT_COUNT (1) */
     0x81, 0x02,         /* INPUT (Data,Var,Abs) */
 };
 
-#define CONTROLLER_NUM_AXES 6
+#define CONTROLLER_NUM_AXES 5
+#define COMBINED_TRIGGER_INDEX 4
 
 #define CONTROLLER_NUM_HATSWITCHES 1
 
@@ -264,14 +264,23 @@ static void set_button_value(struct platform_private *ext, int index, int value)
     }
 }
 
-static void set_axis_value(struct platform_private *ext, int index, short value, BOOL controller)
+static unsigned short map_axis_to_hid(short v)
 {
-    WORD *report = (WORD *)(ext->report_buffer + ext->axis_start);
+    return ((int)v) + 32768;
+}
 
-    if (controller && (index == SDL_CONTROLLER_AXIS_TRIGGERLEFT || index == SDL_CONTROLLER_AXIS_TRIGGERRIGHT))
-        report[index] = LE_WORD(value);
-    else
-        report[index] = LE_WORD(value) + 32768;
+static short compose_trigger_value(SDL_GameController *joystick)
+{
+    /* yes, they are combined into one value and cannot be detangled */
+    return 0x8000
+        + pSDL_GameControllerGetAxis(joystick, SDL_CONTROLLER_AXIS_TRIGGERLEFT)
+        - pSDL_GameControllerGetAxis(joystick, SDL_CONTROLLER_AXIS_TRIGGERRIGHT);
+}
+
+static void set_axis_value(struct platform_private *ext, int index, short value)
+{
+    WORD *report = (WORD *)(ext->report_buffer + ext->axis_start);
+    report[index] = LE_WORD(value);
 }
 
 static void set_ball_value(struct platform_private *ext, int index, int value1, int value2)
@@ -499,7 +508,7 @@ static BOOL build_report_descriptor(struct platform_private *ext)
 
     /* Initialize axis in the report */
     for (i = 0; i < axis_count; i++)
-        set_axis_value(ext, i, pSDL_JoystickGetAxis(ext->sdl_joystick, i), FALSE);
+        set_axis_value(ext, i, map_axis_to_hid(pSDL_JoystickGetAxis(ext->sdl_joystick, i)));
     for (i = 0; i < hat_count; i++)
         set_hat_value(ext, i, pSDL_JoystickGetHat(ext->sdl_joystick, i));
 
@@ -536,7 +545,7 @@ static SHORT compose_dpad_value(SDL_GameController *joystick)
 static BOOL build_mapped_report_descriptor(struct platform_private *ext)
 {
     BYTE *report_ptr;
-    INT i, descript_size;
+    INT descript_size;
 
     static const int BUTTON_BIT_COUNT = CONTROLLER_NUM_BUTTONS + CONTROLLER_NUM_HATSWITCHES * 4;
 
@@ -596,8 +605,19 @@ static BOOL build_mapped_report_descriptor(struct platform_private *ext)
     }
 
     /* Initialize axis in the report */
-    for (i = SDL_CONTROLLER_AXIS_LEFTX; i < SDL_CONTROLLER_AXIS_MAX; i++)
-        set_axis_value(ext, i, pSDL_GameControllerGetAxis(ext->sdl_controller, i), TRUE);
+    set_axis_value(ext, SDL_CONTROLLER_AXIS_LEFTX,
+            map_axis_to_hid(pSDL_GameControllerGetAxis(ext->sdl_controller, SDL_CONTROLLER_AXIS_LEFTX)));
+
+    set_axis_value(ext, SDL_CONTROLLER_AXIS_LEFTY,
+            map_axis_to_hid(pSDL_GameControllerGetAxis(ext->sdl_controller, SDL_CONTROLLER_AXIS_LEFTY)));
+
+    set_axis_value(ext, SDL_CONTROLLER_AXIS_RIGHTX,
+            map_axis_to_hid(pSDL_GameControllerGetAxis(ext->sdl_controller, SDL_CONTROLLER_AXIS_RIGHTX)));
+
+    set_axis_value(ext, SDL_CONTROLLER_AXIS_RIGHTY,
+            map_axis_to_hid(pSDL_GameControllerGetAxis(ext->sdl_controller, SDL_CONTROLLER_AXIS_RIGHTY)));
+
+    set_axis_value(ext, COMBINED_TRIGGER_INDEX, compose_trigger_value(ext->sdl_controller));
 
     set_hat_value(ext, 0, compose_dpad_value(ext->sdl_controller));
 
@@ -776,7 +796,7 @@ static BOOL set_report_from_event(SDL_Event *event)
 
             if (ie->axis < 6)
             {
-                set_axis_value(private, ie->axis, ie->value, FALSE);
+                set_axis_value(private, ie->axis, map_axis_to_hid(ie->value));
                 process_hid_report(device, private->report_buffer, private->buffer_length);
             }
             break;
@@ -864,8 +884,19 @@ static BOOL set_mapped_report_from_event(SDL_Event *event)
         case SDL_CONTROLLERAXISMOTION:
         {
             SDL_ControllerAxisEvent *ie = &event->caxis;
-
-            set_axis_value(private, ie->axis, ie->value, TRUE);
+            switch (ie->axis)
+            {
+                case SDL_CONTROLLER_AXIS_LEFTX:
+                case SDL_CONTROLLER_AXIS_LEFTY:
+                case SDL_CONTROLLER_AXIS_RIGHTX:
+                case SDL_CONTROLLER_AXIS_RIGHTY:
+                    set_axis_value(private, ie->axis, map_axis_to_hid(ie->value));
+                    break;
+                case SDL_CONTROLLER_AXIS_TRIGGERLEFT:
+                case SDL_CONTROLLER_AXIS_TRIGGERRIGHT:
+                    set_axis_value(private, COMBINED_TRIGGER_INDEX, compose_trigger_value(private->sdl_controller));
+                    break;
+            }
             process_hid_report(device, private->report_buffer, private->buffer_length);
             break;
         }
diff --git a/dlls/xinput1_3/hid.c b/dlls/xinput1_3/hid.c
index 28cbf0c4d7d..f5a5a91b2ba 100644
--- a/dlls/xinput1_3/hid.c
+++ b/dlls/xinput1_3/hid.c
@@ -64,7 +64,7 @@ struct hid_platform_private {
     BYTE current_report;
     CHAR *reports[2];
 
-    struct axis_info lx, ly, ltrigger, rx, ry, rtrigger;
+    struct axis_info lx, ly, triggers, rx, ry;
 };
 
 static DWORD last_check = 0;
@@ -77,10 +77,9 @@ static void MarkUsage(struct hid_platform_private *private, WORD usage, LONG min
     {
         case HID_USAGE_GENERIC_X: private->lx = info; break;
         case HID_USAGE_GENERIC_Y: private->ly = info; break;
-        case HID_USAGE_GENERIC_Z: private->ltrigger = info; break;
+        case HID_USAGE_GENERIC_Z: private->triggers = info; break;
         case HID_USAGE_GENERIC_RX: private->rx = info; break;
         case HID_USAGE_GENERIC_RY: private->ry = info; break;
-        case HID_USAGE_GENERIC_RZ: private->rtrigger = info; break;
     }
 }
 
@@ -132,14 +131,13 @@ static BOOL VerifyGamepad(PHIDP_PREPARSED_DATA ppd, XINPUT_CAPABILITIES *xinput_
     }
     HeapFree(GetProcessHeap(), 0, value_caps);
 
-    if (private->ltrigger.bits)
+    if (private->triggers.bits)
+    {
         xinput_caps->Gamepad.bLeftTrigger = (1u << (sizeof(xinput_caps->Gamepad.bLeftTrigger) + 1)) - 1;
-    else
-        WARN("Missing axis LeftTrigger\n");
-    if (private->rtrigger.bits)
         xinput_caps->Gamepad.bRightTrigger = (1u << (sizeof(xinput_caps->Gamepad.bRightTrigger) + 1)) - 1;
+    }
     else
-        WARN("Missing axis RightTrigger\n");
+        WARN("Missing Trigger axes\n");
     if (private->lx.bits)
         xinput_caps->Gamepad.sThumbLX = (1u << (sizeof(xinput_caps->Gamepad.sThumbLX) + 1)) - 1;
     else
@@ -439,13 +437,12 @@ void HID_update_state(xinput_controller *device, XINPUT_STATE *state)
                                         private->ppd, target_report, private->report_length) == HIDP_STATUS_SUCCESS)
             device->state.Gamepad.sThumbRY = -scale_short(value, &private->ry) - 1;
 
-        if(HidP_GetScaledUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_RZ, &value,
-                                        private->ppd, target_report, private->report_length) == HIDP_STATUS_SUCCESS)
-            device->state.Gamepad.bRightTrigger = scale_byte(value, &private->rtrigger);
-
         if(HidP_GetScaledUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_Z, &value,
                                         private->ppd, target_report, private->report_length) == HIDP_STATUS_SUCCESS)
-            device->state.Gamepad.bLeftTrigger = scale_byte(value, &private->ltrigger);
+        {
+            device->state.Gamepad.bLeftTrigger = scale_byte(value, &private->triggers);
+            device->state.Gamepad.bRightTrigger = scale_byte(value, &private->triggers);
+        }
     }
 
     memcpy(state, &device->state, sizeof(*state));
From fcf7d2f75148dc5f25499747afcea86fa15a4da0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 30 Apr 2019 11:20:26 -0500
Subject: [PATCH] winebus.sys: Report axes in correct order

---
 dlls/winebus.sys/bus_sdl.c | 21 ++++++++++++++-------
 1 file changed, 14 insertions(+), 7 deletions(-)

diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index 85ed84290d7..af52ad0b89f 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -140,6 +140,13 @@ static inline struct platform_private *impl_from_DEVICE_OBJECT(DEVICE_OBJECT *de
     return (struct platform_private *)get_platform_private(device);
 }
 
+static const int controller_axis_map[SDL_CONTROLLER_AXIS_MAX] = {
+    /* SDL_CONTROLLER_AXIS_LEFTX -> */ 1,
+    /* SDL_CONTROLLER_AXIS_LEFTY -> */ 0,
+    /* SDL_CONTROLLER_AXIS_RIGHTX -> */ 3,
+    /* SDL_CONTROLLER_AXIS_RIGHTY -> */ 2,
+};
+
 static const BYTE REPORT_AXIS_TAIL[] = {
     0x17, 0x00, 0x00, 0x00, 0x00,   /* LOGICAL_MINIMUM (0) */
     0x27, 0xff, 0xff, 0x00, 0x00,   /* LOGICAL_MAXIMUM (65535) */
@@ -168,10 +175,10 @@ static const BYTE CONTROLLER_BUTTONS[] = {
 
 static const BYTE CONTROLLER_AXIS [] = {
     0x05, 0x01,         /* USAGE_PAGE (Generic Desktop) */
-    0x09, 0x30,         /* USAGE (X) */
     0x09, 0x31,         /* USAGE (Y) */
-    0x09, 0x33,         /* USAGE (RX) */
+    0x09, 0x30,         /* USAGE (X) */
     0x09, 0x34,         /* USAGE (RY) */
+    0x09, 0x33,         /* USAGE (RX) */
     0x17, 0x00, 0x00, 0x00, 0x00,   /* LOGICAL_MINIMUM (0) */
     0x27, 0xff, 0xff, 0x00, 0x00,   /* LOGICAL_MAXIMUM (65535) */
     0x37, 0x00, 0x00, 0x00, 0x00,   /* PHYSICAL_MINIMUM (0) */
@@ -605,16 +612,16 @@ static BOOL build_mapped_report_descriptor(struct platform_private *ext)
     }
 
     /* Initialize axis in the report */
-    set_axis_value(ext, SDL_CONTROLLER_AXIS_LEFTX,
+    set_axis_value(ext, controller_axis_map[SDL_CONTROLLER_AXIS_LEFTX],
             map_axis_to_hid(pSDL_GameControllerGetAxis(ext->sdl_controller, SDL_CONTROLLER_AXIS_LEFTX)));
 
-    set_axis_value(ext, SDL_CONTROLLER_AXIS_LEFTY,
+    set_axis_value(ext, controller_axis_map[SDL_CONTROLLER_AXIS_LEFTY],
             map_axis_to_hid(pSDL_GameControllerGetAxis(ext->sdl_controller, SDL_CONTROLLER_AXIS_LEFTY)));
 
-    set_axis_value(ext, SDL_CONTROLLER_AXIS_RIGHTX,
+    set_axis_value(ext, controller_axis_map[SDL_CONTROLLER_AXIS_RIGHTX],
             map_axis_to_hid(pSDL_GameControllerGetAxis(ext->sdl_controller, SDL_CONTROLLER_AXIS_RIGHTX)));
 
-    set_axis_value(ext, SDL_CONTROLLER_AXIS_RIGHTY,
+    set_axis_value(ext, controller_axis_map[SDL_CONTROLLER_AXIS_RIGHTY],
             map_axis_to_hid(pSDL_GameControllerGetAxis(ext->sdl_controller, SDL_CONTROLLER_AXIS_RIGHTY)));
 
     set_axis_value(ext, COMBINED_TRIGGER_INDEX, compose_trigger_value(ext->sdl_controller));
@@ -890,7 +897,7 @@ static BOOL set_mapped_report_from_event(SDL_Event *event)
                 case SDL_CONTROLLER_AXIS_LEFTY:
                 case SDL_CONTROLLER_AXIS_RIGHTX:
                 case SDL_CONTROLLER_AXIS_RIGHTY:
-                    set_axis_value(private, ie->axis, map_axis_to_hid(ie->value));
+                    set_axis_value(private, controller_axis_map[ie->axis], map_axis_to_hid(ie->value));
                     break;
                 case SDL_CONTROLLER_AXIS_TRIGGERLEFT:
                 case SDL_CONTROLLER_AXIS_TRIGGERRIGHT:
From 797edf73aacf7d6d90dc8d3bad2d05f7e11e4e95 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 2 May 2019 08:16:37 -0500
Subject: [PATCH] HACK: create a duplicate xinput-only device for each SDL
 controller

---
 dlls/hidclass.sys/device.c   |  4 ++-
 dlls/hidclass.sys/hid.h      |  2 +-
 dlls/hidclass.sys/pnp.c      |  2 +-
 dlls/winebus.sys/bus.h       |  2 +-
 dlls/winebus.sys/bus_iohid.c |  2 +-
 dlls/winebus.sys/bus_sdl.c   | 51 +++++++++++++++++++++++++++++-------
 dlls/winebus.sys/bus_udev.c  |  4 +--
 dlls/winebus.sys/main.c      |  8 +++---
 dlls/xinput1_3/hid.c         |  1 +
 9 files changed, 56 insertions(+), 20 deletions(-)

diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
index 369d847e3c1..f95245e0b95 100644
--- a/dlls/hidclass.sys/device.c
+++ b/dlls/hidclass.sys/device.c
@@ -76,7 +76,7 @@ NTSTATUS HID_CreateDevice(DEVICE_OBJECT *native_device, HID_MINIDRIVER_REGISTRAT
     return STATUS_SUCCESS;
 }
 
-NTSTATUS HID_LinkDevice(DEVICE_OBJECT *device)
+NTSTATUS HID_LinkDevice(DEVICE_OBJECT *device, BOOL xinput_hack)
 {
     static const WCHAR backslashW[] = {'\\',0};
     WCHAR device_instance_id[MAX_DEVICE_ID_LEN];
@@ -88,6 +88,8 @@ NTSTATUS HID_LinkDevice(DEVICE_OBJECT *device)
     BASE_DEVICE_EXTENSION *ext;
 
     HidD_GetHidGuid(&hidGuid);
+    if(xinput_hack)
+        hidGuid.Data4[7]++; /* HACK: use different GUID so only xinput will find this device */
     ext = device->DeviceExtension;
 
     RtlInitUnicodeString( &nameW, ext->device_name);
diff --git a/dlls/hidclass.sys/hid.h b/dlls/hidclass.sys/hid.h
index f12e04d7898..459dca3b26f 100644
--- a/dlls/hidclass.sys/hid.h
+++ b/dlls/hidclass.sys/hid.h
@@ -97,7 +97,7 @@ minidriver* find_minidriver(DRIVER_OBJECT* driver) DECLSPEC_HIDDEN;
 
 /* Internal device functions */
 NTSTATUS HID_CreateDevice(DEVICE_OBJECT *native_device, HID_MINIDRIVER_REGISTRATION *driver, DEVICE_OBJECT **device) DECLSPEC_HIDDEN;
-NTSTATUS HID_LinkDevice(DEVICE_OBJECT *device) DECLSPEC_HIDDEN;
+NTSTATUS HID_LinkDevice(DEVICE_OBJECT *device, BOOL xinput_hack) DECLSPEC_HIDDEN;
 void HID_DeleteDevice(DEVICE_OBJECT *device) DECLSPEC_HIDDEN;
 void HID_StartDeviceThread(DEVICE_OBJECT *device) DECLSPEC_HIDDEN;
 
diff --git a/dlls/hidclass.sys/pnp.c b/dlls/hidclass.sys/pnp.c
index b84a358dba4..e97ce8e1fda 100644
--- a/dlls/hidclass.sys/pnp.c
+++ b/dlls/hidclass.sys/pnp.c
@@ -197,7 +197,7 @@ NTSTATUS WINAPI PNP_AddDevice(DRIVER_OBJECT *driver, DEVICE_OBJECT *PDO)
     lstrcatW(ext->device_id, separator_W);
     lstrcatW(ext->device_id, wcschr(device_id, '\\') + 1);
 
-    HID_LinkDevice(device);
+    HID_LinkDevice(device, attr.Reserved[0]/*xinput_hack*/);
 
     ext->poll_interval = DEFAULT_POLL_INTERVAL;
 
diff --git a/dlls/winebus.sys/bus.h b/dlls/winebus.sys/bus.h
index 22a4b46a516..8aa5535aa1d 100644
--- a/dlls/winebus.sys/bus.h
+++ b/dlls/winebus.sys/bus.h
@@ -43,7 +43,7 @@ void *get_platform_private(DEVICE_OBJECT *device) DECLSPEC_HIDDEN;
 /* HID Plug and Play Bus */
 DEVICE_OBJECT *bus_create_hid_device(const WCHAR *busidW, WORD vid, WORD pid,
                                      WORD input, DWORD version, DWORD uid, const WCHAR *serialW, BOOL is_gamepad,
-                                     const platform_vtbl *vtbl, DWORD platform_data_size) DECLSPEC_HIDDEN;
+                                     const platform_vtbl *vtbl, DWORD platform_data_size, BOOL xinput_hack) DECLSPEC_HIDDEN;
 DEVICE_OBJECT *bus_find_hid_device(const platform_vtbl *vtbl, void *platform_dev) DECLSPEC_HIDDEN;
 void bus_unlink_hid_device(DEVICE_OBJECT *device) DECLSPEC_HIDDEN;
 void bus_remove_hid_device(DEVICE_OBJECT *device) DECLSPEC_HIDDEN;
diff --git a/dlls/winebus.sys/bus_iohid.c b/dlls/winebus.sys/bus_iohid.c
index df578b4b9d6..c6b2c541095 100644
--- a/dlls/winebus.sys/bus_iohid.c
+++ b/dlls/winebus.sys/bus_iohid.c
@@ -346,7 +346,7 @@ static void handle_DeviceMatchingCallback(void *context, IOReturn result, void *
 
     device = bus_create_hid_device(busidW, vid, pid, input,
             version, uid, str ? serial_string : NULL, is_gamepad,
-            &iohid_vtbl, sizeof(struct platform_private));
+            &iohid_vtbl, sizeof(struct platform_private), FALSE);
     if (!device)
         ERR("Failed to create device\n");
     else
diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index af52ad0b89f..e91bad7b6ee 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -69,6 +69,8 @@ static void *sdl_handle = NULL;
 static HANDLE deviceloop_handle;
 static UINT quit_event = -1;
 
+#define XINPUT_HACK_ID_BIT 0x80000000
+
 #ifdef SONAME_LIBSDL2
 #define MAKE_FUNCPTR(f) static typeof(f) * p##f = NULL
 MAKE_FUNCPTR(SDL_GetError);
@@ -133,6 +135,8 @@ struct platform_private
 
     SDL_Haptic *sdl_haptic;
     int haptic_effect_id;
+
+    BOOL xinput_hack;
 };
 
 static inline struct platform_private *impl_from_DEVICE_OBJECT(DEVICE_OBJECT *device)
@@ -549,7 +553,7 @@ static SHORT compose_dpad_value(SDL_GameController *joystick)
     return SDL_HAT_CENTERED;
 }
 
-static BOOL build_mapped_report_descriptor(struct platform_private *ext)
+static BOOL build_mapped_report_descriptor(struct platform_private *ext, BOOL xinput_hack)
 {
     BYTE *report_ptr;
     INT descript_size;
@@ -775,7 +779,6 @@ static BOOL set_report_from_event(SDL_Event *event)
     device = bus_enumerate_hid_devices(&sdl_vtbl, compare_joystick_id, ULongToPtr(id));
     if (!device)
     {
-        ERR("Failed to find device at index %i\n",id);
         return FALSE;
     }
     private = impl_from_DEVICE_OBJECT(device);
@@ -839,7 +842,6 @@ static BOOL set_mapped_report_from_event(SDL_Event *event)
     device = bus_enumerate_hid_devices(&sdl_vtbl, compare_joystick_id, ULongToPtr(id));
     if (!device)
     {
-        ERR("Failed to find device at index %i\n",id);
         return FALSE;
     }
     private = impl_from_DEVICE_OBJECT(device);
@@ -941,7 +943,7 @@ static void try_remove_device(SDL_JoystickID id)
         pSDL_HapticClose(sdl_haptic);
 }
 
-static void try_add_device(unsigned int index)
+static void try_add_device(unsigned int index, BOOL xinput_hack)
 {
     DWORD vid = 0, pid = 0, version = 0;
     DEVICE_OBJECT *device = NULL;
@@ -964,7 +966,16 @@ static void try_add_device(unsigned int index)
     if (map_controllers && pSDL_IsGameController(index))
         controller = pSDL_GameControllerOpen(index);
 
+    if (xinput_hack && (!map_controllers || !controller))
+    {
+        /* xinput hack only applies to mapped controllers */
+        pSDL_JoystickClose(joystick);
+        return;
+    }
+
     id = pSDL_JoystickInstanceID(joystick);
+    if(xinput_hack)
+        id |= XINPUT_HACK_ID_BIT;
 
     if (pSDL_JoystickGetProductVersion != NULL) {
         vid = pSDL_JoystickGetVendor(joystick);
@@ -984,15 +995,15 @@ static void try_add_device(unsigned int index)
 
     if (controller)
     {
-        TRACE("Found sdl game controller %i (vid %04x, pid %04x, version %u, serial %s)\n",
-              id, vid, pid, version, debugstr_w(serial));
+        TRACE("Found sdl game controller 0x%x (vid %04x, pid %04x, version %u, serial %s, xinput_hack: %u)\n",
+              id, vid, pid, version, debugstr_w(serial), xinput_hack);
         is_xbox_gamepad = TRUE;
     }
     else
     {
         int button_count, axis_count;
 
-        TRACE("Found sdl device %i (vid %04x, pid %04x, version %u, serial %s)\n",
+        TRACE("Found sdl device 0x%x (vid %04x, pid %04x, version %u, serial %s)\n",
               id, vid, pid, version, debugstr_w(serial));
 
         axis_count = pSDL_JoystickNumAxes(joystick);
@@ -1003,7 +1014,7 @@ static void try_add_device(unsigned int index)
         input = 0;
 
     device = bus_create_hid_device(sdl_busidW, vid, pid, input, version, index,
-            serial, is_xbox_gamepad, &sdl_vtbl, sizeof(struct platform_private));
+            serial, is_xbox_gamepad, &sdl_vtbl, sizeof(struct platform_private), xinput_hack);
 
     if (device)
     {
@@ -1013,7 +1024,7 @@ static void try_add_device(unsigned int index)
         private->sdl_controller = controller;
         private->id = id;
         if (controller)
-            rc = build_mapped_report_descriptor(private);
+            rc = build_mapped_report_descriptor(private, xinput_hack);
         else
             rc = build_report_descriptor(private);
         if (!rc)
@@ -1037,13 +1048,33 @@ static void process_device_event(SDL_Event *event)
     TRACE_(hid_report)("Received action %x\n", event->type);
 
     if (event->type == SDL_JOYDEVICEADDED)
-        try_add_device(((SDL_JoyDeviceEvent*)event)->which);
+    {
+        try_add_device(((SDL_JoyDeviceEvent*)event)->which, TRUE);
+        try_add_device(((SDL_JoyDeviceEvent*)event)->which, FALSE);
+    }
     else if (event->type == SDL_JOYDEVICEREMOVED)
+    {
         try_remove_device(((SDL_JoyDeviceEvent*)event)->which);
+        try_remove_device(((SDL_JoyDeviceEvent*)event)->which | XINPUT_HACK_ID_BIT);
+    }
     else if (event->type >= SDL_JOYAXISMOTION && event->type <= SDL_JOYBUTTONUP)
+    {
+        SDL_Event xinput_hack_event = *event;
+
         set_report_from_event(event);
+
+        ((SDL_JoyAxisEvent*)&xinput_hack_event)->which |= XINPUT_HACK_ID_BIT;
+        set_report_from_event(&xinput_hack_event);
+    }
     else if (event->type >= SDL_CONTROLLERAXISMOTION && event->type <= SDL_CONTROLLERBUTTONUP)
+    {
+        SDL_Event xinput_hack_event = *event;
+
         set_mapped_report_from_event(event);
+
+        ((SDL_JoyAxisEvent*)&xinput_hack_event)->which |= XINPUT_HACK_ID_BIT;
+        set_mapped_report_from_event(&xinput_hack_event);
+    }
 }
 
 static DWORD CALLBACK deviceloop_thread(void *args)
diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 1473579c72c..defe3ea7a65 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1237,13 +1237,13 @@ static void try_add_device(struct udev_device *dev)
     if (strcmp(subsystem, "hidraw") == 0)
     {
         device = bus_create_hid_device(hidraw_busidW, vid, pid, input, version, 0, serial, is_gamepad,
-                                       &hidraw_vtbl, sizeof(struct platform_private));
+                                       &hidraw_vtbl, sizeof(struct platform_private), FALSE);
     }
 #ifdef HAS_PROPER_INPUT_HEADER
     else if (strcmp(subsystem, "input") == 0)
     {
         device = bus_create_hid_device(lnxev_busidW, vid, pid, input, version, 0, serial, is_gamepad,
-                                       &lnxev_vtbl, sizeof(struct wine_input_private));
+                                       &lnxev_vtbl, sizeof(struct wine_input_private), FALSE);
     }
 #endif
 
diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index 2388033ceda..6c6aa6b7330 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -116,7 +116,7 @@ struct device_extension
 
     WORD vid, pid, input;
     DWORD uid, version, index;
-    BOOL is_gamepad;
+    BOOL is_gamepad, xinput_hack;
     WCHAR *serial;
     const WCHAR *busid;  /* Expected to be a static constant */
 
@@ -233,7 +233,7 @@ static WCHAR *get_compatible_ids(DEVICE_OBJECT *device)
 
 DEVICE_OBJECT *bus_create_hid_device(const WCHAR *busidW, WORD vid, WORD pid,
                                      WORD input, DWORD version, DWORD uid, const WCHAR *serialW, BOOL is_gamepad,
-                                     const platform_vtbl *vtbl, DWORD platform_data_size)
+                                     const platform_vtbl *vtbl, DWORD platform_data_size, BOOL xinput_hack)
 {
     static const WCHAR device_name_fmtW[] = {'\\','D','e','v','i','c','e','\\','%','s','#','%','p',0};
     struct device_extension *ext;
@@ -274,6 +274,7 @@ DEVICE_OBJECT *bus_create_hid_device(const WCHAR *busidW, WORD vid, WORD pid,
     ext->version            = version;
     ext->index              = get_device_index(vid, pid, input);
     ext->is_gamepad         = is_gamepad;
+    ext->xinput_hack = xinput_hack;
     ext->serial             = strdupW(serialW);
     ext->busid              = busidW;
     ext->vtbl               = vtbl;
@@ -537,7 +538,7 @@ static void mouse_device_create(void)
 {
     static const WCHAR busidW[] = {'W','I','N','E','M','O','U','S','E',0};
 
-    mouse_obj = bus_create_hid_device(busidW, 0, 0, -1, 0, 0, busidW, FALSE, &mouse_vtbl, 0);
+    mouse_obj = bus_create_hid_device(busidW, 0, 0, -1, 0, 0, busidW, FALSE, &mouse_vtbl, 0, FALSE);
     IoInvalidateDeviceRelations(bus_pdo, BusRelations);
 }
 
@@ -718,6 +719,7 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
             attr->VendorID = ext->vid;
             attr->ProductID = ext->pid;
             attr->VersionNumber = ext->version;
+            attr->Reserved[0] = ext->xinput_hack;
 
             irp->IoStatus.u.Status = status = STATUS_SUCCESS;
             irp->IoStatus.Information = sizeof(*attr);
diff --git a/dlls/xinput1_3/hid.c b/dlls/xinput1_3/hid.c
index f5a5a91b2ba..1f3a9985fcf 100644
--- a/dlls/xinput1_3/hid.c
+++ b/dlls/xinput1_3/hid.c
@@ -228,6 +228,7 @@ void HID_find_gamepads(xinput_controller *devices)
     last_check = idx;
 
     HidD_GetHidGuid(&hid_guid);
+    hid_guid.Data4[7]++; /* HACK: look up the xinput-specific devices */
 
     device_info_set = SetupDiGetClassDevsW(&hid_guid, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
 
From 45c34c0cf2fa334712be59cead1dc59bac763924 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 2 May 2019 08:50:13 -0500
Subject: [PATCH] HACK: treat xinput-only controllers specially

---
 dlls/winebus.sys/bus_sdl.c | 77 +++++++++++++++++++++++++++++++-------
 dlls/xinput1_3/hid.c       | 14 +++++--
 2 files changed, 73 insertions(+), 18 deletions(-)

diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index e91bad7b6ee..9489619a8a5 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -163,6 +163,7 @@ static const BYTE REPORT_AXIS_TAIL[] = {
 #define IDX_ABS_AXIS_COUNT 23
 
 #define CONTROLLER_NUM_BUTTONS 10
+#define CONTROLLER_NUM_BUTTONS_XINPUT_HACK 11
 
 static const BYTE CONTROLLER_BUTTONS[] = {
     0x05, 0x09, /* USAGE_PAGE (Button) */
@@ -177,6 +178,19 @@ static const BYTE CONTROLLER_BUTTONS[] = {
     0x81, 0x02, /* INPUT (Data,Var,Abs) */
 };
 
+static const BYTE CONTROLLER_BUTTONS_XINPUT_HACK[] = {
+    0x05, 0x09, /* USAGE_PAGE (Button) */
+    0x19, 0x01, /* USAGE_MINIMUM (Button 1) */
+    0x29, CONTROLLER_NUM_BUTTONS_XINPUT_HACK, /* USAGE_MAXIMUM (Button 11) */
+    0x15, 0x00, /* LOGICAL_MINIMUM (0) */
+    0x25, 0x01, /* LOGICAL_MAXIMUM (1) */
+    0x35, 0x00, /* LOGICAL_MINIMUM (0) */
+    0x45, 0x01, /* LOGICAL_MAXIMUM (1) */
+    0x95, CONTROLLER_NUM_BUTTONS_XINPUT_HACK, /* REPORT_COUNT (11) */
+    0x75, 0x01, /* REPORT_SIZE (1) */
+    0x81, 0x02, /* INPUT (Data,Var,Abs) */
+};
+
 static const BYTE CONTROLLER_AXIS [] = {
     0x05, 0x01,         /* USAGE_PAGE (Generic Desktop) */
     0x09, 0x31,         /* USAGE (Y) */
@@ -280,12 +294,24 @@ static unsigned short map_axis_to_hid(short v)
     return ((int)v) + 32768;
 }
 
-static short compose_trigger_value(SDL_GameController *joystick)
+static unsigned char map_trigger_to_byte(short v)
+{
+    return ((int)v) * 255 / 32767;
+}
+
+static short compose_trigger_value(struct platform_private *private)
 {
+    if(private->xinput_hack)
+    {
+        /* The range for triggers is [0,32767], so we have to map it to a byte. */
+        return map_trigger_to_byte(pSDL_GameControllerGetAxis(private->sdl_controller, SDL_CONTROLLER_AXIS_TRIGGERLEFT)) << 8 |
+                map_trigger_to_byte(pSDL_GameControllerGetAxis(private->sdl_controller, SDL_CONTROLLER_AXIS_TRIGGERRIGHT));
+    }
+
     /* yes, they are combined into one value and cannot be detangled */
     return 0x8000
-        + pSDL_GameControllerGetAxis(joystick, SDL_CONTROLLER_AXIS_TRIGGERLEFT)
-        - pSDL_GameControllerGetAxis(joystick, SDL_CONTROLLER_AXIS_TRIGGERRIGHT);
+        + pSDL_GameControllerGetAxis(private->sdl_controller, SDL_CONTROLLER_AXIS_TRIGGERLEFT)
+        - pSDL_GameControllerGetAxis(private->sdl_controller, SDL_CONTROLLER_AXIS_TRIGGERRIGHT);
 }
 
 static void set_axis_value(struct platform_private *ext, int index, short value)
@@ -558,7 +584,7 @@ static BOOL build_mapped_report_descriptor(struct platform_private *ext, BOOL xi
     BYTE *report_ptr;
     INT descript_size;
 
-    static const int BUTTON_BIT_COUNT = CONTROLLER_NUM_BUTTONS + CONTROLLER_NUM_HATSWITCHES * 4;
+    int BUTTON_BIT_COUNT;
 
     descript_size = sizeof(REPORT_HEADER) + sizeof(REPORT_TAIL);
     descript_size += sizeof(CONTROLLER_AXIS);
@@ -566,13 +592,25 @@ static BOOL build_mapped_report_descriptor(struct platform_private *ext, BOOL xi
     descript_size += sizeof(CONTROLLER_BUTTONS);
     descript_size += sizeof(REPORT_HATSWITCH);
     descript_size += sizeof(REPORT_PADDING);
-    if (BUTTON_BIT_COUNT % 8 != 0)
-        descript_size += sizeof(REPORT_PADDING);
     descript_size += test_haptic(ext);
 
     ext->axis_start = 0;
     ext->button_start = CONTROLLER_NUM_AXES * sizeof(WORD);
-    ext->hat_bit_offs = CONTROLLER_NUM_BUTTONS;
+
+    if(ext->xinput_hack)
+    {
+        ext->hat_bit_offs = CONTROLLER_NUM_BUTTONS_XINPUT_HACK;
+        BUTTON_BIT_COUNT = CONTROLLER_NUM_BUTTONS_XINPUT_HACK + CONTROLLER_NUM_HATSWITCHES * 4;
+    }
+    else
+    {
+        ext->hat_bit_offs = CONTROLLER_NUM_BUTTONS;
+        BUTTON_BIT_COUNT = CONTROLLER_NUM_BUTTONS + CONTROLLER_NUM_HATSWITCHES * 4;
+    }
+
+
+    if (BUTTON_BIT_COUNT % 8 != 0)
+        descript_size += sizeof(REPORT_PADDING);
 
     ext->buffer_length = (BUTTON_BIT_COUNT + 7) / 8
         + CONTROLLER_NUM_AXES * sizeof(WORD)
@@ -597,8 +635,16 @@ static BOOL build_mapped_report_descriptor(struct platform_private *ext, BOOL xi
     report_ptr += sizeof(CONTROLLER_AXIS);
     memcpy(report_ptr, CONTROLLER_TRIGGERS, sizeof(CONTROLLER_TRIGGERS));
     report_ptr += sizeof(CONTROLLER_TRIGGERS);
-    memcpy(report_ptr, CONTROLLER_BUTTONS, sizeof(CONTROLLER_BUTTONS));
-    report_ptr += sizeof(CONTROLLER_BUTTONS);
+    if(ext->xinput_hack)
+    {
+        memcpy(report_ptr, CONTROLLER_BUTTONS_XINPUT_HACK, sizeof(CONTROLLER_BUTTONS_XINPUT_HACK));
+        report_ptr += sizeof(CONTROLLER_BUTTONS_XINPUT_HACK);
+    }
+    else
+    {
+        memcpy(report_ptr, CONTROLLER_BUTTONS, sizeof(CONTROLLER_BUTTONS));
+        report_ptr += sizeof(CONTROLLER_BUTTONS);
+    }
     report_ptr = add_hatswitch(report_ptr, 1);
     if (BUTTON_BIT_COUNT % 8 != 0)
         report_ptr = add_padding_block(report_ptr, 8 - (BUTTON_BIT_COUNT % 8));/* unused bits between hatswitch and following constant */
@@ -628,7 +674,7 @@ static BOOL build_mapped_report_descriptor(struct platform_private *ext, BOOL xi
     set_axis_value(ext, controller_axis_map[SDL_CONTROLLER_AXIS_RIGHTY],
             map_axis_to_hid(pSDL_GameControllerGetAxis(ext->sdl_controller, SDL_CONTROLLER_AXIS_RIGHTY)));
 
-    set_axis_value(ext, COMBINED_TRIGGER_INDEX, compose_trigger_value(ext->sdl_controller));
+    set_axis_value(ext, COMBINED_TRIGGER_INDEX, compose_trigger_value(ext));
 
     set_hat_value(ext, 0, compose_dpad_value(ext->sdl_controller));
 
@@ -867,9 +913,11 @@ static BOOL set_mapped_report_from_event(SDL_Event *event)
                 case SDL_CONTROLLER_BUTTON_LEFTSTICK: usage = 8; break;
                 case SDL_CONTROLLER_BUTTON_RIGHTSTICK: usage = 9; break;
 
-                /* native HID does not report the guide button
-                case SDL_CONTROLLER_BUTTON_GUIDE: usage = 10; break;
-                */
+                case SDL_CONTROLLER_BUTTON_GUIDE:
+                    /* native HID does not report the guide button */
+                    if(private->xinput_hack)
+                        usage = 10;
+                    break;
 
                 case SDL_CONTROLLER_BUTTON_DPAD_UP:
                 case SDL_CONTROLLER_BUTTON_DPAD_DOWN:
@@ -903,7 +951,7 @@ static BOOL set_mapped_report_from_event(SDL_Event *event)
                     break;
                 case SDL_CONTROLLER_AXIS_TRIGGERLEFT:
                 case SDL_CONTROLLER_AXIS_TRIGGERRIGHT:
-                    set_axis_value(private, COMBINED_TRIGGER_INDEX, compose_trigger_value(private->sdl_controller));
+                    set_axis_value(private, COMBINED_TRIGGER_INDEX, compose_trigger_value(private));
                     break;
             }
             process_hid_report(device, private->report_buffer, private->buffer_length);
@@ -1023,6 +1071,7 @@ static void try_add_device(unsigned int index, BOOL xinput_hack)
         private->sdl_joystick = joystick;
         private->sdl_controller = controller;
         private->id = id;
+        private->xinput_hack = xinput_hack;
         if (controller)
             rc = build_mapped_report_descriptor(private, xinput_hack);
         else
diff --git a/dlls/xinput1_3/hid.c b/dlls/xinput1_3/hid.c
index 1f3a9985fcf..179b6c94e73 100644
--- a/dlls/xinput1_3/hid.c
+++ b/dlls/xinput1_3/hid.c
@@ -109,7 +109,7 @@ static BOOL VerifyGamepad(PHIDP_PREPARSED_DATA ppd, XINPUT_CAPABILITIES *xinput_
             button_count = max(button_count, button_caps[i].NotRange.Usage);
     }
     HeapFree(GetProcessHeap(), 0, button_caps);
-    if (button_count < 10)
+    if (button_count < 11)
         WARN("Too few buttons, continuing anyway\n");
     xinput_caps->Gamepad.wButtons = 0xffff;
 
@@ -341,7 +341,7 @@ void HID_update_state(xinput_controller *device, XINPUT_STATE *state)
     CHAR *report = private->reports[(private->current_report)%2];
     CHAR *target_report = private->reports[(private->current_report+1)%2];
 
-    USAGE buttons[10];
+    USAGE buttons[11];
     ULONG button_length, hat_value;
     LONG value;
 
@@ -383,6 +383,7 @@ void HID_update_state(xinput_controller *device, XINPUT_STATE *state)
                 case 8: device->state.Gamepad.wButtons |= XINPUT_GAMEPAD_START; break;
                 case 9: device->state.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_THUMB; break;
                 case 10: device->state.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_THUMB; break;
+                case 11: device->state.Gamepad.wButtons |= XINPUT_GAMEPAD_GUIDE; break;
             }
         }
 
@@ -441,8 +442,13 @@ void HID_update_state(xinput_controller *device, XINPUT_STATE *state)
         if(HidP_GetScaledUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_Z, &value,
                                         private->ppd, target_report, private->report_length) == HIDP_STATUS_SUCCESS)
         {
-            device->state.Gamepad.bLeftTrigger = scale_byte(value, &private->triggers);
-            device->state.Gamepad.bRightTrigger = scale_byte(value, &private->triggers);
+            /* Wine-specific hack: Windows HID mangles trigger values irretrievably, so
+             * we instead encode them in a different format in winebus. We use that
+             * format here. We should be using WineBus to talk directly to the
+             * controller's USB device so they can be correctly mangled in HID. */
+            HidP_GetScaledUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_Z, &value, private->ppd, target_report, private->report_length);
+            device->state.Gamepad.bLeftTrigger = (value >> 8) & 0xFF;//scale_byte(value, &private->ltrigger);
+            device->state.Gamepad.bRightTrigger = value & 0xFF;//scale_byte(value, &private->rtrigger);
         }
     }
 
From 4883de1b56f89b425984cb40d5c6bd5d4b00d024 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 6 Aug 2019 13:27:25 -0500
Subject: [PATCH] winebus.sys: Disable linuxevent API

We either go through SDL or hidraw directly.
---
 dlls/winebus.sys/bus_udev.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index defe3ea7a65..c35e60068e0 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -47,7 +47,7 @@
 # include <linux/input.h>
 # undef SW_MAX
 # if defined(EVIOCGBIT) && defined(EV_ABS) && defined(BTN_PINKIE)
-#  define HAS_PROPER_INPUT_HEADER
+//#  define HAS_PROPER_INPUT_HEADER
 # endif
 # ifndef SYN_DROPPED
 #  define SYN_DROPPED 3
From 1bd45fe397615ce03b71858287feedd388c04402 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 19 Aug 2019 14:01:55 -0500
Subject: [PATCH] winebus.sys: Try to open devices with hidraw first

---
 dlls/winebus.sys/bus.h      |  2 ++
 dlls/winebus.sys/bus_sdl.c  | 31 +++++++++++++++++++------------
 dlls/winebus.sys/bus_udev.c | 22 ++++++++++++++++++++++
 dlls/winebus.sys/main.c     |  5 +++--
 4 files changed, 46 insertions(+), 14 deletions(-)

diff --git a/dlls/winebus.sys/bus.h b/dlls/winebus.sys/bus.h
index 8aa5535aa1d..8fc90cad5ee 100644
--- a/dlls/winebus.sys/bus.h
+++ b/dlls/winebus.sys/bus.h
@@ -54,5 +54,7 @@ DEVICE_OBJECT* bus_enumerate_hid_devices(const platform_vtbl *vtbl, enum_func fu
 DWORD check_bus_option(const UNICODE_STRING *option, DWORD default_value) DECLSPEC_HIDDEN;
 BOOL is_xbox_gamepad(WORD vid, WORD pid) DECLSPEC_HIDDEN;
 
+BOOL is_already_opened_by_hidraw(DWORD vid, DWORD pid) DECLSPEC_HIDDEN;
+
 extern HANDLE driver_key DECLSPEC_HIDDEN;
 extern DEVICE_OBJECT *bus_pdo DECLSPEC_HIDDEN;
diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index 9489619a8a5..6173e161a6e 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -1011,6 +1011,25 @@ static void try_add_device(unsigned int index, BOOL xinput_hack)
         return;
     }
 
+    if (pSDL_JoystickGetProductVersion != NULL) {
+        vid = pSDL_JoystickGetVendor(joystick);
+        pid = pSDL_JoystickGetProduct(joystick);
+        version = pSDL_JoystickGetProductVersion(joystick);
+    }
+    else
+    {
+        vid = 0x01;
+        pid = pSDL_JoystickInstanceID(joystick) + 1;
+        version = 0;
+    }
+
+    if(is_already_opened_by_hidraw(vid, pid))
+    {
+        /* we use SDL only for controllers which hidraw couldn't open */
+        TRACE("device %04x/%04x already opened by hidraw, skipping\n", vid, pid);
+        return;
+    }
+
     if (map_controllers && pSDL_IsGameController(index))
         controller = pSDL_GameControllerOpen(index);
 
@@ -1025,18 +1044,6 @@ static void try_add_device(unsigned int index, BOOL xinput_hack)
     if(xinput_hack)
         id |= XINPUT_HACK_ID_BIT;
 
-    if (pSDL_JoystickGetProductVersion != NULL) {
-        vid = pSDL_JoystickGetVendor(joystick);
-        pid = pSDL_JoystickGetProduct(joystick);
-        version = pSDL_JoystickGetProductVersion(joystick);
-    }
-    else
-    {
-        vid = 0x01;
-        pid = pSDL_JoystickInstanceID(joystick) + 1;
-        version = 0;
-    }
-
     guid = pSDL_JoystickGetGUID(joystick);
     pSDL_JoystickGetGUIDString(guid, guid_str, sizeof(guid_str));
     MultiByteToWideChar(CP_ACP, 0, guid_str, -1, serial, sizeof(guid_str));
diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index c35e60068e0..b5043b86c5c 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -98,6 +98,10 @@ static int deviceloop_control[2];
 static const WCHAR hidraw_busidW[] = {'H','I','D','R','A','W',0};
 static const WCHAR lnxev_busidW[] = {'L','N','X','E','V',0};
 
+struct vidpid {
+    WORD vid, pid;
+};
+
 struct platform_private
 {
     struct udev_device *udev_device;
@@ -105,6 +109,8 @@ struct platform_private
 
     HANDLE report_thread;
     int control_pipe[2];
+
+    struct vidpid vidpid;
 };
 
 static inline struct platform_private *impl_from_DEVICE_OBJECT(DEVICE_OBJECT *device)
@@ -1135,6 +1141,20 @@ static DWORD a_to_bcd(const char *s)
     return r;
 }
 
+static int check_for_vidpid(DEVICE_OBJECT *device, void* context)
+{
+    struct vidpid *vidpid = context;
+    struct platform_private *dev = impl_from_DEVICE_OBJECT(device);
+    return !(dev->vidpid.vid == vidpid->vid &&
+        dev->vidpid.pid == vidpid->pid);
+}
+
+BOOL is_already_opened_by_hidraw(DWORD vid, DWORD pid)
+{
+    struct vidpid vidpid = {vid, pid};
+    return bus_enumerate_hid_devices(&hidraw_vtbl, check_for_vidpid, &vidpid) != NULL;
+}
+
 static void try_add_device(struct udev_device *dev)
 {
     DWORD vid = 0, pid = 0, version = 0;
@@ -1252,6 +1272,8 @@ static void try_add_device(struct udev_device *dev)
         struct platform_private *private = impl_from_DEVICE_OBJECT(device);
         private->udev_device = udev_device_ref(dev);
         private->device_fd = fd;
+        private->vidpid.vid = vid;
+        private->vidpid.pid = pid;
 #ifdef HAS_PROPER_INPUT_HEADER
         if (strcmp(subsystem, "input") == 0)
             if (!build_report_descriptor((struct wine_input_private*)private, dev))
diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index 6c6aa6b7330..a861a29f5d6 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -557,6 +557,9 @@ static NTSTATUS fdo_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
     case IRP_MN_START_DEVICE:
         mouse_device_create();
 
+        udev_driver_init();
+        iohid_driver_init();
+
         if (check_bus_option(&SDL_enabled, 1))
         {
             if (sdl_driver_init() == STATUS_SUCCESS)
@@ -565,8 +568,6 @@ static NTSTATUS fdo_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
                 break;
             }
         }
-        udev_driver_init();
-        iohid_driver_init();
         irp->IoStatus.u.Status = STATUS_SUCCESS;
         break;
     case IRP_MN_SURPRISE_REMOVAL:
From d355b1e6339954e1412b428d7336881e790c8f15 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 6 Aug 2019 13:37:38 -0500
Subject: [PATCH] winebus.sys: Don't use hidraw for xbox controllers

Xbox controllers don't present real HID devices.
---
 dlls/winebus.sys/bus_udev.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index b5043b86c5c..e8afa393cb0 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1237,7 +1237,11 @@ static void try_add_device(struct udev_device *dev)
 #endif
 
     if (is_xbox_gamepad(vid, pid))
-        is_gamepad = TRUE;
+    {
+        /* SDL handles xbox (and steam) controllers */
+        close(fd);
+        return;
+    }
 #ifdef HAS_PROPER_INPUT_HEADER
     else
     {
From de2873bfba28d8aba1ffb88183d4a4a3d2c4c0a7 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 14 Aug 2019 08:47:53 -0500
Subject: [PATCH] winebus: Don't report hidraw devices which are being used as
 virtual controllers

---
 dlls/winebus.sys/bus_udev.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index e8afa393cb0..82414c12461 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -18,6 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#define _GNU_SOURCE
 #include "config.h"
 #include <errno.h>
 #include <fcntl.h>
@@ -1155,6 +1156,19 @@ BOOL is_already_opened_by_hidraw(DWORD vid, DWORD pid)
     return bus_enumerate_hid_devices(&hidraw_vtbl, check_for_vidpid, &vidpid) != NULL;
 }
 
+static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
+{
+    char needle[16];
+    const char *blacklist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES");
+
+    if (!blacklist)
+        return FALSE;
+
+    sprintf(needle, "0x%04x/0x%04x", vid, pid);
+
+    return strcasestr(blacklist, needle) != NULL;
+}
+
 static void try_add_device(struct udev_device *dev)
 {
     DWORD vid = 0, pid = 0, version = 0;
@@ -1236,6 +1250,13 @@ static void try_add_device(struct udev_device *dev)
         WARN("Could not get device to query VID, PID, Version and Serial\n");
 #endif
 
+    if (is_in_sdl_blacklist(vid, pid))
+    {
+        /* this device is being used as a virtual Steam controller */
+        close(fd);
+        return;
+    }
+
     if (is_xbox_gamepad(vid, pid))
     {
         /* SDL handles xbox (and steam) controllers */
From 2001e220b875f81dc2d65440d06c17f8a83c0d51 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 14 Aug 2019 09:15:21 -0500
Subject: [PATCH] winebus.sys: Don't use hidraw for Steam controllers

---
 dlls/winebus.sys/bus.h      |  1 +
 dlls/winebus.sys/bus_udev.c |  4 +++-
 dlls/winebus.sys/main.c     | 24 ++++++++++++++++++++++++
 3 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/dlls/winebus.sys/bus.h b/dlls/winebus.sys/bus.h
index 8fc90cad5ee..69bd7ce66d7 100644
--- a/dlls/winebus.sys/bus.h
+++ b/dlls/winebus.sys/bus.h
@@ -53,6 +53,7 @@ DEVICE_OBJECT* bus_enumerate_hid_devices(const platform_vtbl *vtbl, enum_func fu
 /* General Bus Functions */
 DWORD check_bus_option(const UNICODE_STRING *option, DWORD default_value) DECLSPEC_HIDDEN;
 BOOL is_xbox_gamepad(WORD vid, WORD pid) DECLSPEC_HIDDEN;
+BOOL is_steam_controller(WORD vid, WORD pid) DECLSPEC_HIDDEN;
 
 BOOL is_already_opened_by_hidraw(DWORD vid, DWORD pid) DECLSPEC_HIDDEN;
 
diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 82414c12461..be457600d43 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1250,9 +1250,10 @@ static void try_add_device(struct udev_device *dev)
         WARN("Could not get device to query VID, PID, Version and Serial\n");
 #endif
 
-    if (is_in_sdl_blacklist(vid, pid))
+    if (is_steam_controller(vid, pid) || is_in_sdl_blacklist(vid, pid))
     {
         /* this device is being used as a virtual Steam controller */
+        TRACE("hidraw %s: ignoring device %04x/%04x with virtual Steam controller\n", debugstr_a(devnode), vid, pid);
         close(fd);
         return;
     }
@@ -1260,6 +1261,7 @@ static void try_add_device(struct udev_device *dev)
     if (is_xbox_gamepad(vid, pid))
     {
         /* SDL handles xbox (and steam) controllers */
+        TRACE("hidraw %s: ignoring xinput device %04x/%04x\n", debugstr_a(devnode), vid, pid);
         close(fd);
         return;
     }
diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index a861a29f5d6..7c5dbfd9eb2 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -94,6 +94,18 @@ static const struct product_desc XBOX_CONTROLLERS[] = {
     {VID_MICROSOFT, 0x0719, NULL, xbox360_product_string, NULL}, /* Xbox 360 Wireless Adapter */
 };
 
+#define VID_VALVE 0x28de
+
+static const struct product_desc STEAM_CONTROLLERS[] = {
+    {VID_VALVE, 0x1101, NULL, NULL, NULL}, /* Valve Legacy Steam Controller */
+    {VID_VALVE, 0x1102, NULL, NULL, NULL}, /* Valve wired Steam Controller */
+    {VID_VALVE, 0x1105, NULL, NULL, NULL}, /* Valve Bluetooth Steam Controller */
+    {VID_VALVE, 0x1106, NULL, NULL, NULL}, /* Valve Bluetooth Steam Controller */
+    {VID_VALVE, 0x1142, NULL, NULL, NULL}, /* Valve wireless Steam Controller */
+    {VID_VALVE, 0x1201, NULL, NULL, NULL}, /* Valve wired Steam Controller */
+    {VID_VALVE, 0x1202, NULL, NULL, NULL}, /* Valve Bluetooth Steam Controller */
+};
+
 static DRIVER_OBJECT *driver_obj;
 
 static DEVICE_OBJECT *mouse_obj;
@@ -967,6 +979,18 @@ static NTSTATUS WINAPI driver_add_device(DRIVER_OBJECT *driver, DEVICE_OBJECT *p
     return STATUS_SUCCESS;
 }
 
+BOOL is_steam_controller(WORD vid, WORD pid)
+{
+    if (vid == VID_VALVE)
+    {
+        int i;
+        for (i = 0; i < ARRAY_SIZE(STEAM_CONTROLLERS); i++)
+            if (pid == STEAM_CONTROLLERS[i].pid) return TRUE;
+    }
+
+    return FALSE;
+}
+
 static void WINAPI driver_unload(DRIVER_OBJECT *driver)
 {
     NtClose(driver_key);
From 9c53961497ee08097a93ba86425aa8fee9553914 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 22 Aug 2019 09:59:27 -0500
Subject: [PATCH] winebus.drv: Also respect the SDL device whitelist

---
 dlls/winebus.sys/bus_udev.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index be457600d43..adccaf95242 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1160,6 +1160,14 @@ static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
 {
     char needle[16];
     const char *blacklist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES");
+    const char *whitelist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT");
+
+    if (whitelist)
+    {
+        sprintf(needle, "0x%04x/0x%04x", vid, pid);
+
+        return strcasestr(whitelist, needle) == NULL;
+    }
 
     if (!blacklist)
         return FALSE;
From 32012692e146f39075bd25fcd548481bffdbbb1b Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 29 Aug 2019 15:04:36 -0500
Subject: [PATCH] winebus.sys: Ignore blacklisted SDL joysticks, too

SDL only respects these variables for game controllers. All joysticks
are allowed through. But we don't want to present these at all, so we'll
check the variables manually.
---
 dlls/winebus.sys/bus_sdl.c | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index 6173e161a6e..3ee7d467121 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -991,6 +991,35 @@ static void try_remove_device(SDL_JoystickID id)
         pSDL_HapticClose(sdl_haptic);
 }
 
+/* logic from SDL2's SDL_ShouldIgnoreGameController */
+static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
+{
+    char needle[16];
+    const char *blacklist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES");
+    const char *whitelist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT");
+    const char *allow_virtual = getenv("SDL_GAMECONTROLLER_ALLOW_STEAM_VIRTUAL_GAMEPAD");
+
+    if (!blacklist && !whitelist)
+        return FALSE;
+
+    if (allow_virtual && *allow_virtual != '0')
+    {
+        if(vid == 0x28DE && pid == 0x11FF)
+            return FALSE;
+    }
+
+    if (whitelist)
+    {
+        sprintf(needle, "0x%04x/0x%04x", vid, pid);
+
+        return strcasestr(whitelist, needle) == NULL;
+    }
+
+    sprintf(needle, "0x%04x/0x%04x", vid, pid);
+
+    return strcasestr(blacklist, needle) != NULL;
+}
+
 static void try_add_device(unsigned int index, BOOL xinput_hack)
 {
     DWORD vid = 0, pid = 0, version = 0;
@@ -1030,6 +1059,12 @@ static void try_add_device(unsigned int index, BOOL xinput_hack)
         return;
     }
 
+    if(is_in_sdl_blacklist(vid, pid))
+    {
+        TRACE("device %04x/%04x is in blacklist, ignoring\n", vid, pid);
+        return;
+    }
+
     if (map_controllers && pSDL_IsGameController(index))
         controller = pSDL_GameControllerOpen(index);
 
From 8a26358e858272608e05cd9296d4a15e79487372 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 30 Aug 2019 10:20:16 -0500
Subject: [PATCH] winebus.sys: Override Steam virtual controller vid/pid with
 Xbox

Matches Windows Steam client behavior.
---
 dlls/winebus.sys/bus_sdl.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index 3ee7d467121..e586b154e29 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -1088,6 +1088,13 @@ static void try_add_device(unsigned int index, BOOL xinput_hack)
         TRACE("Found sdl game controller 0x%x (vid %04x, pid %04x, version %u, serial %s, xinput_hack: %u)\n",
               id, vid, pid, version, debugstr_w(serial), xinput_hack);
         is_xbox_gamepad = TRUE;
+
+        if(vid == 0x28DE && pid == 0x11FF)
+        {
+            TRACE("Steam virtual controller, pretending it's an Xbox 360 controller\n");
+            vid = 0x045e;
+            pid = 0x028e;
+        }
     }
     else
     {
From 7113709b48f0ec7ea50390fc8cc74a4c31abaf22 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 29 Aug 2019 11:20:23 -0500
Subject: [PATCH] winebus: Extract bluetooth info from uevent

udev doesn't report this info.
---
 dlls/winebus.sys/bus_udev.c | 167 ++++++++++++++++++++++--------------
 1 file changed, 101 insertions(+), 66 deletions(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index adccaf95242..7c30710db9c 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -112,6 +112,8 @@ struct platform_private
     int control_pipe[2];
 
     struct vidpid vidpid;
+
+    DWORD bus_type;
 };
 
 static inline struct platform_private *impl_from_DEVICE_OBJECT(DEVICE_OBJECT *device)
@@ -654,6 +656,68 @@ static WCHAR *get_sysattr_string(struct udev_device *dev, const char *sysattr)
     return strdupAtoW(attr);
 }
 
+static void parse_uevent_info(const char *uevent, DWORD *bus_type, DWORD *vendor_id,
+                             DWORD *product_id, WORD *input, WCHAR **serial_number, WCHAR **product)
+{
+    char *tmp;
+    char *saveptr = NULL;
+    char *line;
+    char *key;
+    char *value;
+
+    tmp = heap_alloc(strlen(uevent) + 1);
+    strcpy(tmp, uevent);
+    line = strtok_r(tmp, "\n", &saveptr);
+    while (line != NULL)
+    {
+        /* line: "KEY=value" */
+        key = line;
+        value = strchr(line, '=');
+        if (!value)
+        {
+            goto next_line;
+        }
+        *value = '\0';
+        value++;
+
+        if (strcmp(key, "HID_ID") == 0)
+        {
+            /**
+             *        type vendor   product
+             * HID_ID=0003:000005AC:00008242
+             **/
+            sscanf(value, "%x:%x:%x", bus_type, vendor_id, product_id);
+        }
+        else if (strcmp(key, "HID_UNIQ") == 0)
+        {
+            /* The caller has to free the serial number */
+            if (*value)
+            {
+                *serial_number = strdupAtoW(value);
+            }
+        }
+        else if (product && strcmp(key, "HID_NAME") == 0)
+        {
+            /* The caller has to free the product name */
+            if (*value)
+            {
+                *product = strdupAtoW(value);
+            }
+        }
+        else if (strcmp(key, "HID_PHYS") == 0)
+        {
+            const char *input_no = strstr(value, "input");
+            if (input_no)
+                *input = atoi(input_no+5 );
+        }
+
+next_line:
+        line = strtok_r(NULL, "\n", &saveptr);
+    }
+
+    heap_free(tmp);
+}
+
 static int compare_platform_device(DEVICE_OBJECT *device, void *platform_dev)
 {
     struct udev_device *dev1 = impl_from_DEVICE_OBJECT(device)->udev_device;
@@ -695,12 +759,43 @@ static NTSTATUS hidraw_get_reportdescriptor(DEVICE_OBJECT *device, BYTE *buffer,
 
 static NTSTATUS hidraw_get_string(DEVICE_OBJECT *device, DWORD index, WCHAR *buffer, DWORD length)
 {
-    struct udev_device *usbdev;
+    struct udev_device *usbdev, *hiddev;
     struct platform_private *private = impl_from_DEVICE_OBJECT(device);
     WCHAR *str = NULL;
 
+    hiddev = udev_device_get_parent_with_subsystem_devtype(private->udev_device, "hid", NULL);
     usbdev = udev_device_get_parent_with_subsystem_devtype(private->udev_device, "usb", "usb_device");
-    if (usbdev)
+
+    if (private->bus_type == BUS_BLUETOOTH && hiddev)
+    {
+        DWORD bus_type, vid, pid;
+        WORD input;
+        WCHAR *serial = NULL, *product = NULL;
+
+        /* udev doesn't report this info, so we have to extract it from uevent property */
+
+        parse_uevent_info(udev_device_get_sysattr_value(hiddev, "uevent"),
+                &bus_type, &vid, &pid, &input, &serial, &product);
+
+        switch (index)
+        {
+            case HID_STRING_ID_IPRODUCT:
+                str = product;
+                HeapFree(GetProcessHeap(), 0, serial);
+                break;
+            case HID_STRING_ID_IMANUFACTURER:
+                /* TODO */
+                break;
+            case HID_STRING_ID_ISERIALNUMBER:
+                str = serial;
+                HeapFree(GetProcessHeap(), 0, product);
+                break;
+            default:
+                ERR("Unhandled string index %08x\n", index);
+                return STATUS_NOT_IMPLEMENTED;
+        }
+    }
+    else if (usbdev)
     {
         switch (index)
         {
@@ -1067,68 +1162,6 @@ static int check_same_device(DEVICE_OBJECT *device, void* context)
     return !compare_platform_device(device, context);
 }
 
-static int parse_uevent_info(const char *uevent, DWORD *vendor_id,
-                             DWORD *product_id, WORD *input, WCHAR **serial_number)
-{
-    DWORD bus_type;
-    char *tmp;
-    char *saveptr = NULL;
-    char *line;
-    char *key;
-    char *value;
-
-    int found_id = 0;
-    int found_serial = 0;
-
-    tmp = heap_alloc(strlen(uevent) + 1);
-    strcpy(tmp, uevent);
-    line = strtok_r(tmp, "\n", &saveptr);
-    while (line != NULL)
-    {
-        /* line: "KEY=value" */
-        key = line;
-        value = strchr(line, '=');
-        if (!value)
-        {
-            goto next_line;
-        }
-        *value = '\0';
-        value++;
-
-        if (strcmp(key, "HID_ID") == 0)
-        {
-            /**
-             *        type vendor   product
-             * HID_ID=0003:000005AC:00008242
-             **/
-            int ret = sscanf(value, "%x:%x:%x", &bus_type, vendor_id, product_id);
-            if (ret == 3)
-                found_id = 1;
-        }
-        else if (strcmp(key, "HID_UNIQ") == 0)
-        {
-            /* The caller has to free the serial number */
-            if (*value)
-            {
-                *serial_number = strdupAtoW(value);
-                found_serial = 1;
-            }
-        }
-        else if (strcmp(key, "HID_PHYS") == 0)
-        {
-            const char *input_no = strstr(value, "input");
-            if (input_no)
-                *input = atoi(input_no+5 );
-        }
-
-next_line:
-        line = strtok_r(NULL, "\n", &saveptr);
-    }
-
-    heap_free(tmp);
-    return (found_id && found_serial);
-}
-
 static DWORD a_to_bcd(const char *s)
 {
     DWORD r = 0;
@@ -1179,7 +1212,7 @@ static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
 
 static void try_add_device(struct udev_device *dev)
 {
-    DWORD vid = 0, pid = 0, version = 0;
+    DWORD vid = 0, pid = 0, version = 0, bus_type = 0;
     struct udev_device *hiddev = NULL, *walk_device;
     DEVICE_OBJECT *device = NULL;
     const char *subsystem;
@@ -1222,7 +1255,7 @@ static void try_add_device(struct udev_device *dev)
         }
 #endif
         parse_uevent_info(udev_device_get_sysattr_value(hiddev, "uevent"),
-                          &vid, &pid, &input, &serial);
+                          &bus_type, &vid, &pid, &input, &serial, NULL);
         if (serial == NULL)
             serial = strdupAtoW(base_serial);
 
@@ -1252,6 +1285,7 @@ static void try_add_device(struct udev_device *dev)
         vid = device_id.vendor;
         pid = device_id.product;
         version = device_id.version;
+        bus_type = device_id.bustype;
     }
 #else
     else
@@ -1309,6 +1343,7 @@ static void try_add_device(struct udev_device *dev)
         private->device_fd = fd;
         private->vidpid.vid = vid;
         private->vidpid.pid = pid;
+        private->bus_type = bus_type;
 #ifdef HAS_PROPER_INPUT_HEADER
         if (strcmp(subsystem, "input") == 0)
             if (!build_report_descriptor((struct wine_input_private*)private, dev))
From ae2844b8794b2fdc454fe8388aad0fe09fc30a9b Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 30 Aug 2019 12:12:26 -0500
Subject: [PATCH] winebus.sys: Bluetooth doesn't report USB device version

---
 dlls/winebus.sys/bus_udev.c | 19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 7c30710db9c..280ffc9323f 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1259,15 +1259,18 @@ static void try_add_device(struct udev_device *dev)
         if (serial == NULL)
             serial = strdupAtoW(base_serial);
 
-        walk_device = dev;
-        while (walk_device && !bcdDevice)
+        if(bus_type != BUS_BLUETOOTH)
         {
-            bcdDevice = udev_device_get_sysattr_value(walk_device, "bcdDevice");
-            walk_device = udev_device_get_parent(walk_device);
-        }
-        if (bcdDevice)
-        {
-            version = a_to_bcd(bcdDevice);
+            walk_device = dev;
+            while (walk_device && !bcdDevice)
+            {
+                bcdDevice = udev_device_get_sysattr_value(walk_device, "bcdDevice");
+                walk_device = udev_device_get_parent(walk_device);
+            }
+            if (bcdDevice)
+            {
+                version = a_to_bcd(bcdDevice);
+            }
         }
     }
 #ifdef HAS_PROPER_INPUT_HEADER
From 35b2676915829a6e267fa99010bf389fc52f63dc Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 6 Dec 2019 11:00:49 -0600
Subject: [PATCH] winebus.sys: Process quirky DS4 bluetooth reports

---
 dlls/winebus.sys/bus_udev.c | 49 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 48 insertions(+), 1 deletion(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 280ffc9323f..6bff5dbcc7a 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -103,6 +103,9 @@ struct vidpid {
     WORD vid, pid;
 };
 
+/* the kernel is a great place to learn about these DS4 quirks */
+#define QUIRK_DS4_BT 0x1
+
 struct platform_private
 {
     struct udev_device *udev_device;
@@ -113,6 +116,8 @@ struct platform_private
 
     struct vidpid vidpid;
 
+    DWORD quirks;
+
     DWORD bus_type;
 };
 
@@ -885,7 +890,20 @@ static DWORD CALLBACK device_report_thread(void *args)
         else if (size == 0)
             TRACE_(hid_report)("Failed to read report\n");
         else
-            process_hid_report(device, report_buffer, size);
+        {
+            if(private->quirks & QUIRK_DS4_BT)
+            {
+                /* Following the kernel example, report 17 is the only type we care about for
+                 * DS4 over bluetooth. but it has two extra header bytes, so skip those. */
+                if(report_buffer[0] == 0x11)
+                {
+                    /* update report number to match windows */
+                    report_buffer[2] = 1;
+                    process_hid_report(device, report_buffer + 2, size - 2);
+                }
+            }else
+                process_hid_report(device, report_buffer, size);
+        }
     }
     return 0;
 }
@@ -1210,6 +1228,34 @@ static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
     return strcasestr(blacklist, needle) != NULL;
 }
 
+static void set_quirks(struct platform_private *private)
+{
+#define VID_SONY 0x054c
+#define PID_SONY_DUALSHOCK_4 0x05c4
+#define PID_SONY_DUALSHOCK_4_2 0x09cc
+#define PID_SONY_DUALSHOCK_4_DONGLE 0x0ba0
+
+    private->quirks = 0;
+
+    switch(private->vidpid.vid)
+    {
+    case VID_SONY:
+        switch(private->vidpid.pid)
+        {
+        case PID_SONY_DUALSHOCK_4:
+        case PID_SONY_DUALSHOCK_4_2:
+        case PID_SONY_DUALSHOCK_4_DONGLE:
+            if(private->bus_type == BUS_BLUETOOTH)
+                private->quirks |= QUIRK_DS4_BT;
+            break;
+        }
+        break;
+    }
+
+    TRACE("for %04x/%04x, quirks set to: 0x%x\n", private->vidpid.vid,
+            private->vidpid.pid, private->quirks);
+}
+
 static void try_add_device(struct udev_device *dev)
 {
     DWORD vid = 0, pid = 0, version = 0, bus_type = 0;
@@ -1347,6 +1393,7 @@ static void try_add_device(struct udev_device *dev)
         private->vidpid.vid = vid;
         private->vidpid.pid = pid;
         private->bus_type = bus_type;
+        set_quirks(private);
 #ifdef HAS_PROPER_INPUT_HEADER
         if (strcmp(subsystem, "input") == 0)
             if (!build_report_descriptor((struct wine_input_private*)private, dev))
From e822607e345ab99ac8142784948f4c3ba4fd8b8b Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 31 Mar 2020 08:25:38 -0500
Subject: [PATCH] winebus, dinput: Ignore some joysticks that SDL reports

SDL has a blacklist, but it isn't complete. Ignore some more devices
while we fix upstream.
---
 dlls/dinput/joystick_sdl.c  | 24 ++++++++++++++++++++++++
 dlls/winebus.sys/bus_sdl.c  | 24 +++++++++++++++++++++++-
 include/wine/js_blacklist.h |  3 +++
 3 files changed, 50 insertions(+), 1 deletion(-)
 create mode 100644 include/wine/js_blacklist.h

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 158669881fc..ccb4a17f9ad 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -53,6 +53,8 @@
 #include "device_private.h"
 #include "joystick_private.h"
 
+#include "wine/js_blacklist.h" /* for wine_js_blacklist */
+
 #ifdef HAVE_SDL2_SDL_H
 
 WINE_DEFAULT_DEBUG_CHANNEL(dinput);
@@ -187,6 +189,20 @@ static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
     return strcasestr(blacklist, needle) != NULL;
 }
 
+static BOOL is_in_wine_blacklist(const DWORD vid, const DWORD pid)
+{
+    int i;
+    for(i = 0; i < ARRAY_SIZE(wine_js_blacklist); ++i)
+    {
+        if(vid == wine_js_blacklist[i].vid &&
+                (wine_js_blacklist[i].pid == 0 ||
+                 wine_js_blacklist[i].pid == pid))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
 static Uint16 (*pSDL_JoystickGetProduct)(SDL_Joystick *);
 static Uint16 (*pSDL_JoystickGetVendor)(SDL_Joystick *);
 
@@ -319,6 +335,14 @@ static void find_sdldevs(void)
             continue;
         }
 
+        if(is_in_wine_blacklist(sdldev->vendor_id, sdldev->product_id))
+        {
+            TRACE("joystick %04x/%04x is in Wine blacklist, ignoring\n", sdldev->vendor_id, sdldev->product_id);
+            SDL_JoystickClose(device);
+            HeapFree(GetProcessHeap(), 0, sdldev->name);
+            continue;
+        }
+
         if(sdldev->vendor_id == VID_VALVE && sdldev->product_id == PID_VALVE_VIRTUAL_CONTROLLER)
         {
             sdldev->vendor_id = VID_MICROSOFT;
diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index e586b154e29..8c16e6c24f8 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -47,6 +47,8 @@
 #include "hidusage.h"
 #include "controller.h"
 
+#include "wine/js_blacklist.h" /* for wine_js_blacklist */
+
 #ifdef WORDS_BIGENDIAN
 # define LE_WORD(x) RtlUshortByteSwap(x)
 #else
@@ -1020,6 +1022,20 @@ static BOOL is_in_sdl_blacklist(DWORD vid, DWORD pid)
     return strcasestr(blacklist, needle) != NULL;
 }
 
+static BOOL is_in_wine_blacklist(const DWORD vid, const DWORD pid)
+{
+    int i;
+    for(i = 0; i < ARRAY_SIZE(wine_js_blacklist); ++i)
+    {
+        if(vid == wine_js_blacklist[i].vid &&
+                (wine_js_blacklist[i].pid == 0 ||
+                 wine_js_blacklist[i].pid == pid))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
 static void try_add_device(unsigned int index, BOOL xinput_hack)
 {
     DWORD vid = 0, pid = 0, version = 0;
@@ -1061,7 +1077,13 @@ static void try_add_device(unsigned int index, BOOL xinput_hack)
 
     if(is_in_sdl_blacklist(vid, pid))
     {
-        TRACE("device %04x/%04x is in blacklist, ignoring\n", vid, pid);
+        TRACE("device %04x/%04x is in SDL blacklist, ignoring\n", vid, pid);
+        return;
+    }
+
+    if(is_in_wine_blacklist(vid, pid))
+    {
+        TRACE("device %04x/%04x is in Wine blacklist, ignoring\n", vid, pid);
         return;
     }
 
diff --git a/include/wine/js_blacklist.h b/include/wine/js_blacklist.h
new file mode 100644
index 00000000000..b8f2ec7dd28
--- /dev/null
+++ b/include/wine/js_blacklist.h
@@ -0,0 +1,3 @@
+static const struct { short vid; short pid; } wine_js_blacklist[] = {
+    {0x056a, 0x0000}, /* all Wacom devices */
+};

From 317847d588829fea98950067570151ab4ce4a777 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 29 Sep 2020 20:18:56 +0200
Subject: [PATCH] user32: Gracefully ignore invalid rawinput HID devices.

---
 dlls/hidclass.sys/device.c |  7 ++-----
 dlls/hidclass.sys/pnp.c    | 14 +++++++++-----
 dlls/user32/rawinput.c     |  7 ++++---
 3 files changed, 15 insertions(+), 13 deletions(-)

diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
index f95245e0b95..37448b315d1 100644
--- a/dlls/hidclass.sys/device.c
+++ b/dlls/hidclass.sys/device.c
@@ -127,7 +127,7 @@ NTSTATUS HID_LinkDevice(DEVICE_OBJECT *device, BOOL xinput_hack)
         return status;
     }
 
-    ext->link_handle = INVALID_HANDLE_VALUE;
+    ext->link_handle = 0;
 
     /* FIXME: This should probably be done in mouhid.sys. */
     if (ext->preparseData->caps.UsagePage == HID_USAGE_PAGE_GENERIC
@@ -253,13 +253,10 @@ static void HID_Device_sendRawInput(DEVICE_OBJECT *device, HID_XFER_PACKET *pack
 {
     BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
 
-    if (ext->link_handle == INVALID_HANDLE_VALUE)
-        return;
-
     SERVER_START_REQ(send_hardware_message)
     {
         req->win                  = 0;
-        req->flags                = SEND_HWMSG_RAWINPUT;
+        req->flags                = 0;
         req->input.type           = HW_INPUT_HID;
         req->input.hid.device     = wine_server_obj_handle(ext->link_handle);
         req->input.hid.usage_page = ext->preparseData->caps.UsagePage;
diff --git a/dlls/hidclass.sys/pnp.c b/dlls/hidclass.sys/pnp.c
index e97ce8e1fda..abb517e10d5 100644
--- a/dlls/hidclass.sys/pnp.c
+++ b/dlls/hidclass.sys/pnp.c
@@ -300,6 +300,7 @@ NTSTATUS WINAPI HID_PNP_Dispatch(DEVICE_OBJECT *device, IRP *irp)
         {
             BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
             OBJECT_ATTRIBUTES attr;
+            HANDLE tmp;
 
             rc = minidriver->PNPDispatch(device, irp);
 
@@ -313,13 +314,16 @@ NTSTATUS WINAPI HID_PNP_Dispatch(DEVICE_OBJECT *device, IRP *irp)
             attr.ObjectName = &ext->link_name;
             attr.SecurityDescriptor = NULL;
             attr.SecurityQualityOfService = NULL;
-            NtOpenSymbolicLinkObject(&ext->link_handle, SYMBOLIC_LINK_QUERY, &attr);
-            ext->link_handle = ConvertToGlobalHandle(ext->link_handle);
 
-            if (ext->link_handle == INVALID_HANDLE_VALUE)
-                ERR("Failed to open link %s, error %u.\n", debugstr_w(ext->link_name.Buffer), GetLastError());
-            else
+            if (!NtOpenSymbolicLinkObject(&tmp, SYMBOLIC_LINK_QUERY, &attr) &&
+                (ext->link_handle = ConvertToGlobalHandle(tmp)) != INVALID_HANDLE_VALUE)
                 TRACE("Opened link handle: %p for %s\n", ext->link_handle, debugstr_w(ext->link_name.Buffer));
+            else
+            {
+                ERR("Failed to open link %s, error %u.\n", debugstr_w(ext->link_name.Buffer), GetLastError());
+                ext->link_handle = 0;
+            }
+            NtClose(tmp);
 
             return rc;
         }
diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index 6eaf50cf353..9ea5ea393e8 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -64,8 +64,6 @@ static CRITICAL_SECTION_DEBUG rawinput_devices_cs_debug =
 };
 static CRITICAL_SECTION rawinput_devices_cs = { &rawinput_devices_cs_debug, -1, 0, 0, 0, 0 };
 
-extern DWORD WINAPI GetFinalPathNameByHandleW(HANDLE file, LPWSTR path, DWORD charcount, DWORD flags);
-
 static BOOL array_reserve(void **elements, unsigned int *capacity, unsigned int count, unsigned int size)
 {
     unsigned int new_capacity, max_capacity;
@@ -147,7 +145,7 @@ static struct device *add_device(HDEVINFO set, SP_DEVICE_INTERFACE_DATA *iface)
     device->path = path;
     device->file = file;
     device->info.cbSize = sizeof(RID_DEVICE_INFO);
-    device->handle = INVALID_HANDLE_VALUE;
+    device->handle = 0;
 
     return device;
 }
@@ -160,6 +158,9 @@ static HANDLE rawinput_handle_from_device_handle(HANDLE device, BOOL rescan)
     ULONG dummy;
     unsigned int i;
 
+    if (!device) return NULL;
+
+    /* check already known devices to avoid comparing paths again */
     for (i = 0; i < rawinput_devices_count; ++i)
     {
         if (rawinput_devices[i].handle == device)
From 76eae961027989e6641e81b3d6621c119090976a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 19 Mar 2020 14:54:52 +0100
Subject: [PATCH] dinput: Ignore force feedback on gamepads.

DmC Devil May Cry crashes if gamepads report ffb support.
---
 dlls/dinput/joystick_sdl.c | 26 +++++++++++++-------------
 1 file changed, 13 insertions(+), 13 deletions(-)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index ccb4a17f9ad..9f5a1efad3e 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -287,7 +287,7 @@ static void find_sdldevs(void)
             TRACE("reconnected \"%s\"\n", sdldev->name);
             device = SDL_JoystickOpen(i);
             sdldev->instance_id = SDL_JoystickInstanceID(device);
-            if (SDL_JoystickIsHaptic(device))
+            if (sdldev->is_joystick && SDL_JoystickIsHaptic(device))
                 sdldev->sdl_haptic = SDL_HapticOpenFromJoystick(device);
 
             InterlockedExchangePointer((void**)&sdldev->sdl_js, device);
@@ -310,13 +310,21 @@ static void find_sdldevs(void)
 
         TRACE("Found a joystick on %p: %s\n", device, sdldev->name);
 
+        {
+            SDL_JoystickType type = SDL_JoystickGetType(device);
+            sdldev->is_joystick =
+                type == SDL_JOYSTICK_TYPE_UNKNOWN ||
+                type == SDL_JOYSTICK_TYPE_WHEEL ||
+                type == SDL_JOYSTICK_TYPE_FLIGHT_STICK ||
+                type == SDL_JOYSTICK_TYPE_THROTTLE;
+        }
+
         if (SDL_JoystickIsHaptic(device))
         {
-            haptic = SDL_HapticOpenFromJoystick(device);
-            if (haptic)
-            {
+            if (!sdldev->is_joystick)
+                WARN("Ignoring force feedback support for \"%s\"\n", sdldev->name);
+            else if ((haptic = SDL_HapticOpenFromJoystick(device)))
                 TRACE(" ... with force feedback\n");
-            }
         }
 
         if(pSDL_JoystickGetVendor){
@@ -349,14 +357,6 @@ static void find_sdldevs(void)
             sdldev->product_id = PID_MICROSOFT_XBOX_360;
         }
 
-        {
-            SDL_JoystickType type = SDL_JoystickGetType(device);
-            sdldev->is_joystick =
-                type == SDL_JOYSTICK_TYPE_WHEEL ||
-                type == SDL_JOYSTICK_TYPE_FLIGHT_STICK ||
-                type == SDL_JOYSTICK_TYPE_THROTTLE;
-        }
-
         sdldev->n_buttons = SDL_JoystickNumButtons(device);
         sdldev->n_axes = SDL_JoystickNumAxes(device);
         sdldev->n_hats = SDL_JoystickNumHats(device);
From f6eb7f1a393769162793d9b5a44b69affda0236c Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Thu, 23 Apr 2020 17:12:48 -0700
Subject: [PATCH] dinput/sdl: Fix IDirectInputEffect::SetParameters() behavior
 with NULL effect parameters.

Equivalent of upstream f66517b5a27057243912f3a7c4a41a291ab2bfb8 for
effect_sdl.
---
 dlls/dinput/effect_sdl.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/dinput/effect_sdl.c b/dlls/dinput/effect_sdl.c
index 36e9075dcdb..b77c8eae9f7 100644
--- a/dlls/dinput/effect_sdl.c
+++ b/dlls/dinput/effect_sdl.c
@@ -473,6 +473,9 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
 
     if (flags & DIEP_AXES)
     {
+        if (!effect->rgdwAxes)
+            return DIERR_INVALIDPARAM;
+
         if (effect->cAxes > 2)
             return DIERR_INVALIDPARAM;
         else if (effect->cAxes < 1)
@@ -484,6 +487,9 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
 
     if (flags & DIEP_DIRECTION)
     {
+        if (!effect->rglDirection)
+            return DIERR_INVALIDPARAM;
+
         if (effect->cAxes == 1)
         {
             if (effect->dwFlags & DIEFF_CARTESIAN)
@@ -568,6 +574,9 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
 
     if (flags & DIEP_TYPESPECIFICPARAMS)
     {
+        if (!effect->lpvTypeSpecificParams)
+            return DIERR_INVALIDPARAM;
+
         if (IsEqualGUID(&This->guid, &GUID_Sine) ||
             IsEqualGUID(&This->guid, &GUID_Triangle) ||
             IsEqualGUID(&This->guid, &GUID_SawtoothUp) ||
From 588c5797c4f111b45715b1ec9d9813fe76b7788b Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Thu, 23 Apr 2020 17:22:03 -0700
Subject: [PATCH] dinput/sdl: Fix IDirectInputEffect::SetParameters() when
 called with flags=0.

Equivalent of upstream 1832dc3df32f0133e695457401f6961d8d40532d for
effect/joystick_sdl.
---
 dlls/dinput/effect_sdl.c   | 13 ++++---------
 dlls/dinput/joystick_sdl.c |  5 ++++-
 2 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/dlls/dinput/effect_sdl.c b/dlls/dinput/effect_sdl.c
index b77c8eae9f7..d8289923616 100644
--- a/dlls/dinput/effect_sdl.c
+++ b/dlls/dinput/effect_sdl.c
@@ -463,13 +463,10 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
     else if (IsEqualGUID(&This->guid, &GUID_CustomForce))
         This->effect.type = SDL_HAPTIC_CUSTOM;
 
-    if ((flags & ~DIEP_NORESTART & ~DIEP_NODOWNLOAD & ~DIEP_START) == 0)
-    {
-        /* set everything */
-        flags = DIEP_AXES | DIEP_DIRECTION | DIEP_DURATION | DIEP_ENVELOPE |
-                DIEP_GAIN | DIEP_SAMPLEPERIOD | DIEP_STARTDELAY | DIEP_TRIGGERBUTTON |
-                DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS;
-    }
+    dump_DIEFFECT(effect, &This->guid, flags);
+
+    if (!flags)
+        return DI_NOEFFECT;
 
     if (flags & DIEP_AXES)
     {
@@ -483,8 +480,6 @@ static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
         This->first_axis_is_x = effect->rgdwAxes[0] == DIJOFS_X;
     }
 
-    dump_DIEFFECT(effect, &This->guid, flags);
-
     if (flags & DIEP_DIRECTION)
     {
         if (!effect->rglDirection)
diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index 9f5a1efad3e..b5486a3357f 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -1524,7 +1524,10 @@ static HRESULT WINAPI JoystickWImpl_CreateEffect(IDirectInputDevice8W *iface,
 
     if (lpeff != NULL)
     {
-        retval = IDirectInputEffect_SetParameters(new_effect->ref, lpeff, 0);
+        retval = IDirectInputEffect_SetParameters(new_effect->ref, lpeff,
+            DIEP_AXES | DIEP_DIRECTION | DIEP_DURATION | DIEP_ENVELOPE |
+            DIEP_GAIN | DIEP_SAMPLEPERIOD | DIEP_STARTDELAY | DIEP_TRIGGERBUTTON |
+            DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS);
 
         if (retval != DI_OK && retval != DI_DOWNLOADSKIPPED)
         {
From 246a62499dac5a8b5d057c6d9cfeda400210f44a Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 27 Apr 2020 10:35:45 -0700
Subject: [PATCH] dinput: Set dwDevType specifically for steering wheels.

Fixes wheel detection for WRC 7
---
 dlls/dinput/joystick_sdl.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/dinput/joystick_sdl.c b/dlls/dinput/joystick_sdl.c
index b5486a3357f..e6266084906 100644
--- a/dlls/dinput/joystick_sdl.c
+++ b/dlls/dinput/joystick_sdl.c
@@ -109,6 +109,7 @@ struct SDLDev {
 
     int n_buttons, n_axes, n_hats;
 
+    SDL_JoystickType type;
     BOOL is_joystick;
     int autocenter;
     int gain;
@@ -312,6 +313,7 @@ static void find_sdldevs(void)
 
         {
             SDL_JoystickType type = SDL_JoystickGetType(device);
+            sdldev->type = type;
             sdldev->is_joystick =
                 type == SDL_JOYSTICK_TYPE_UNKNOWN ||
                 type == SDL_JOYSTICK_TYPE_WHEEL ||
@@ -440,6 +442,13 @@ static void fill_joystick_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD ver
 
     lpddi->dwDevType = get_device_type(version, sdldevs[id].is_joystick);
 
+    /* DirectInput 8 has more-specific device types which some games look for */
+    if (version >= 0x800)
+    {
+        if (sdldevs[id].type == SDL_JOYSTICK_TYPE_WHEEL)
+            lpddi->dwDevType = DI8DEVTYPE_DRIVING | (DI8DEVTYPEDRIVING_DUALPEDALS << 8);
+    }
+
     /* Assume the joystick as HID if it is attached to USB bus and has a valid VID/PID */
     if ( sdldevs[id].vendor_id && sdldevs[id].product_id)
     {
 
From fde64743462076fc772aaa3334633185f0ab76b1 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 21 Jan 2020 10:22:19 -0600
Subject: [PATCH] user32: Rescan for devices if we can't find it

---
 dlls/user32/rawinput.c     | 18 ++++++++++++------
 dlls/user32/user_private.h |  2 --
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index 4914c67c98b..2b9ac104b0c 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -152,7 +152,8 @@ static struct device *add_device(HDEVINFO set, SP_DEVICE_INTERFACE_DATA *iface)
     return device;
 }
 
-HANDLE rawinput_handle_from_device_handle(HANDLE device)
+static void find_devices(BOOL force);
+static HANDLE rawinput_handle_from_device_handle(HANDLE device, BOOL rescan)
 {
     WCHAR buffer[sizeof(OBJECT_NAME_INFORMATION) + MAX_PATH + 1];
     OBJECT_NAME_INFORMATION *info = (OBJECT_NAME_INFORMATION*)&buffer;
@@ -181,10 +182,15 @@ HANDLE rawinput_handle_from_device_handle(HANDLE device)
         }
     }
 
-    return NULL;
+    if (!rescan)
+        return NULL;
+
+    find_devices(TRUE);
+
+    return rawinput_handle_from_device_handle(device, FALSE);
 }
 
-static void find_devices(void)
+static void find_devices(BOOL force)
 {
     static ULONGLONG last_check;
 
@@ -196,7 +202,7 @@ static void find_devices(void)
     HDEVINFO set;
     DWORD idx;
 
-    if (GetTickCount64() - last_check < 2000)
+    if (!force && GetTickCount64() - last_check < 2000)
         return;
     last_check = GetTickCount64();
 
@@ -372,7 +378,7 @@ BOOL rawinput_from_hardware_message(RAWINPUT *rawinput, const struct hardware_ms
         }
 
         rawinput->header.dwSize  = FIELD_OFFSET(RAWINPUT, data.hid.bRawData) + msg_data->rawinput.hid.length;
-        rawinput->header.hDevice = rawinput_handle_from_device_handle(wine_server_ptr_handle(msg_data->rawinput.hid.device));
+        rawinput->header.hDevice = rawinput_handle_from_device_handle(wine_server_ptr_handle(msg_data->rawinput.hid.device), TRUE);
         rawinput->header.wParam  = 0;
 
         rawinput->data.hid.dwSizeHid = msg_data->rawinput.hid.length;
@@ -410,7 +416,7 @@ UINT WINAPI GetRawInputDeviceList(RAWINPUTDEVICELIST *devices, UINT *device_coun
         return ~0U;
     }
 
-    find_devices();
+    find_devices(FALSE);
 
     if (!devices)
     {
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 013fa66f833..6bc357476fe 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -387,6 +387,4 @@ static inline WCHAR *heap_strdupW(const WCHAR *src)
     return dst;
 }
 
-extern HANDLE rawinput_handle_from_device_handle(HANDLE device);
-
 #endif /* __WINE_USER_PRIVATE_H */
From bee73b0b4a534b087c3985d288e1140864ba6a75 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 2 Dec 2019 13:30:19 -0600
Subject: [PATCH] user32: Also look up xinput-only HID devices

---
 dlls/user32/rawinput.c | 65 ++++++++++++++++++++++++++++--------------
 1 file changed, 43 insertions(+), 22 deletions(-)

diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index 2b9ac104b0c..6eaf50cf353 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -190,37 +190,18 @@ static HANDLE rawinput_handle_from_device_handle(HANDLE device, BOOL rescan)
     return rawinput_handle_from_device_handle(device, FALSE);
 }
 
-static void find_devices(BOOL force)
+static void find_rawinput_devices_by_guid(const GUID *guid)
 {
-    static ULONGLONG last_check;
-
     SP_DEVICE_INTERFACE_DATA iface = { sizeof(iface) };
     struct device *device;
     HIDD_ATTRIBUTES attr;
     HIDP_CAPS caps;
-    GUID hid_guid;
     HDEVINFO set;
     DWORD idx;
 
-    if (!force && GetTickCount64() - last_check < 2000)
-        return;
-    last_check = GetTickCount64();
-
-    HidD_GetHidGuid(&hid_guid);
-
-    EnterCriticalSection(&rawinput_devices_cs);
-
-    /* destroy previous list */
-    for (idx = 0; idx < rawinput_devices_count; ++idx)
-    {
-        CloseHandle(rawinput_devices[idx].file);
-        heap_free(rawinput_devices[idx].path);
-    }
-    rawinput_devices_count = 0;
-
-    set = SetupDiGetClassDevsW(&hid_guid, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
+    set = SetupDiGetClassDevsW(guid, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
 
-    for (idx = 0; SetupDiEnumDeviceInterfaces(set, NULL, &hid_guid, idx, &iface); ++idx)
+    for (idx = 0; SetupDiEnumDeviceInterfaces(set, NULL, guid, idx, &iface); ++idx)
     {
         if (!(device = add_device(set, &iface)))
             continue;
@@ -245,6 +226,46 @@ static void find_devices(BOOL force)
     }
 
     SetupDiDestroyDeviceInfoList(set);
+}
+
+static void find_devices(BOOL force)
+{
+    static ULONGLONG last_check;
+
+    SP_DEVICE_INTERFACE_DATA iface = { sizeof(iface) };
+    struct device *device;
+    HDEVINFO set;
+    DWORD idx;
+    GUID hid_guid;
+
+    if (!force && GetTickCount64() - last_check < 2000)
+        return;
+
+    HidD_GetHidGuid(&hid_guid);
+
+    EnterCriticalSection(&rawinput_devices_cs);
+
+    if (!force && GetTickCount64() - last_check < 2000)
+    {
+        LeaveCriticalSection(&rawinput_devices_cs);
+        return;
+    }
+
+    last_check = GetTickCount64();
+
+    /* destroy previous list */
+    for (idx = 0; idx < rawinput_devices_count; ++idx)
+    {
+        CloseHandle(rawinput_devices[idx].file);
+        heap_free(rawinput_devices[idx].path);
+    }
+    rawinput_devices_count = 0;
+
+    find_rawinput_devices_by_guid(&hid_guid);
+
+    /* HACK: also look up the xinput-specific devices */
+    hid_guid.Data4[7]++;
+    find_rawinput_devices_by_guid(&hid_guid);
 
     set = SetupDiGetClassDevsW(&GUID_DEVINTERFACE_MOUSE, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
 
