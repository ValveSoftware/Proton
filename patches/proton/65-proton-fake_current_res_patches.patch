From c6d0490250dbc6783618326429b0e4e819bc3cc2 Mon Sep 17 00:00:00 2001
From: Dragomir Ivanov <drago.ivanov@gmail.com>
Date: Sun, 30 Jan 2022 23:47:56 +0200
Subject: [PATCH] fshack: Add faking current resolution ability

---
 dlls/winex11.drv/fs.c | 55 +++++++++++++++++++++++++++++++++++++++----
 1 file changed, 50 insertions(+), 5 deletions(-)

diff --git a/dlls/winex11.drv/fs.c b/dlls/winex11.drv/fs.c
index 9b781a729e5..0c8db02f06c 100644
--- a/dlls/winex11.drv/fs.c
+++ b/dlls/winex11.drv/fs.c
@@ -95,6 +95,8 @@ static struct fs_monitor_size fs_monitor_sizes[] =
     {1280, 1024}, /*  5:4 */
 };
 
+static struct fs_monitor_size fake_current_resolution;
+
 /* A fake monitor for the fullscreen hack */
 struct fs_monitor
 {
@@ -249,13 +251,30 @@ static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
     return TRUE;
 }
 
+BOOL fs_hack_is_fake_current_res(struct fs_monitor_size* fixed_size)
+{
+    fixed_size->width = 0;
+    fixed_size->height = 0;
+    const char *e = getenv("WINE_FULLSCREEN_FSR_CUSTOM_MODE");
+    if (e) 
+    {
+        const int n = sscanf(e,"%dx%d",&(fixed_size->width),&(fixed_size->height));
+        if (n==2) 
+        {
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
 /* Add a fake monitor to fs_monitors list.
  * Call this function with fs_section entered */
 static BOOL fs_add_monitor(const WCHAR *device_name)
 {
     struct fs_monitor *fs_monitor;
-    DEVMODEW real_mode;
+    DEVMODEW real_mode, user_mode;
     ULONG_PTR real_id;
+    double scale;
 
     if (!real_settings_handler.get_id(device_name, &real_id))
         return FALSE;
@@ -266,11 +285,33 @@ static BOOL fs_add_monitor(const WCHAR *device_name)
     if (!(fs_monitor = malloc(sizeof(*fs_monitor))))
         return FALSE;
 
-    fs_monitor->user_mode = real_mode;
+    user_mode = real_mode;
+
+    if (fs_hack_is_fake_current_res(&fake_current_resolution)) {
+        user_mode.dmPelsWidth = fake_current_resolution.width;
+        user_mode.dmPelsHeight = fake_current_resolution.height;
+        TRACE("is_fake_current_res: %dx%d", fake_current_resolution.width, fake_current_resolution.height);
+    }
+
+    fs_monitor->user_mode = user_mode;
     fs_monitor->real_mode = real_mode;
-    fs_monitor->user_to_real_scale = 1.0;
-    fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x;
-    fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y;
+    /* If real mode is narrower than fake mode, scale to fit width */
+    if ((double)real_mode.dmPelsWidth / (double)real_mode.dmPelsHeight
+             < (double)user_mode.dmPelsWidth / (double)user_mode.dmPelsHeight)
+    {
+        scale = (double)real_mode.dmPelsWidth / (double)user_mode.dmPelsWidth;
+        fs_monitor->user_to_real_scale = scale;
+        fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x;
+        fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y + (real_mode.dmPelsHeight - user_mode.dmPelsHeight * scale) / 2;
+    }
+    /* Else scale to fit height */
+    else
+    {
+        scale = (double)real_mode.dmPelsHeight / (double)user_mode.dmPelsHeight;
+        fs_monitor->user_to_real_scale = scale;
+        fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x + (real_mode.dmPelsWidth - user_mode.dmPelsWidth * scale) / 2;
+        fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y;
+    }
     lstrcpyW(fs_monitor->user_mode.dmDeviceName, device_name);
     if (!fs_monitor_add_modes(fs_monitor))
     {
@@ -373,6 +414,10 @@ static BOOL fs_get_current_mode(ULONG_PTR id, DEVMODEW *mode)
     if (fs_monitor)
     {
         *mode = fs_monitor->user_mode;
+        if (fake_current_resolution.width != 0 && fake_current_resolution.height != 0) {
+            mode->dmPelsWidth=fake_current_resolution.width;
+            mode->dmPelsHeight=fake_current_resolution.height;
+        }
         LeaveCriticalSection(&fs_section);
         return TRUE;
     }
diff --git a/dlls/winex11.drv/fs.c b/dlls/winex11.drv/fs.c
index 79f1e030baa..89614b2c8eb 100644
--- a/dlls/winex11.drv/fs.c
+++ b/dlls/winex11.drv/fs.c
@@ -211,6 +211,11 @@ static struct fs_monitor_size fsr4k_performance[] =
     {1920, 1080},  /* 16:9 - 'FSR 2160p Performance' */
 };
 
+static struct fs_monitor_size fsr_fake_res[] =
+{
+    {1920, 1080},  /* Custom resolution, replaced by WINE_FULLSCREEN_FSR_CUSTOM_MODE */
+};
+
 static struct fs_monitor_size fake_current_resolution;
 
 /* A fake monitor for the fullscreen hack */
@@ -310,8 +315,12 @@ static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
     
     if (fsr_flag = getenv("WINE_FULLSCREEN_FSR")) 
     {
-        if (fsr_mode = getenv("WINE_FULLSCREEN_FSR_MODE"))
+        if (fs_hack_is_fake_current_res(&fake_current_resolution))
         {
+            /* Custom Resolution */
+            memcpy(fs_monitor_sizes+sizeof(fsr_fake_res),fsr_fake_res,sizeof(fsr_fake_res));
+        } 
+        else if (fsr_mode = getenv("WINE_FULLSCREEN_FSR_MODE")) {
             if (!strcmp(fsr_mode, "ultra")) {
                 if (current_mode.dmPelsWidth >= 1129 && current_mode.dmPelsWidth <= 1920) {
                     /* 1080p FSR resolutions */
@@ -370,7 +379,8 @@ static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
                 }
             }
         /* If no mode specified, default to balanced */
-        } else {
+        } 
+        else {
             if (current_mode.dmPelsWidth >= 1129 && current_mode.dmPelsWidth <= 1920) {
                 /* 1080p FSR resolutions */
                 memcpy(fs_monitor_sizes+sizeof(fsr1080_balanced),fsr1080_balanced,sizeof(fsr1080_balanced));
@@ -457,6 +467,7 @@ BOOL fs_hack_is_fake_current_res(struct fs_monitor_size* fixed_size)
         const int n = sscanf(e,"%dx%d",&(fixed_size->width),&(fixed_size->height));
         if (n==2) 
         {
+            memcpy(fsr_fake_res+sizeof(fixed_size),fixed_size,sizeof(fixed_size));
             return TRUE;
         }
     }
-- 
2.30.2

