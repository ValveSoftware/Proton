From cf3783be65fe36469de4a73d1db5b5db383e9f65 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 6 Nov 2020 12:20:16 -0600
Subject: [PATCH] Revert "winex11.drv: Interpret mouse 6/7 as horiz scroll."

This reverts commit 893080e4df5a45929320ebb88b8668eea316476c.

We have a trade-off here between supporting horizontal scroll, or
mapping those actions to the XBUTTON{1,2} messages. Some users were
using those buttons in their games, which broke with this change. It
seems more likely that the extra button mapping will be useful than
horizontal scrolling, so let's revert this commit.
---
 dlls/winex11.drv/mouse.c | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 51a6828f10c..7029983b92d 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -75,8 +75,8 @@ static const UINT button_down_flags[NB_BUTTONS] =
     MOUSEEVENTF_RIGHTDOWN,
     MOUSEEVENTF_WHEEL,
     MOUSEEVENTF_WHEEL,
-    MOUSEEVENTF_HWHEEL,
-    MOUSEEVENTF_HWHEEL,
+    MOUSEEVENTF_XDOWN,  /* FIXME: horizontal wheel */
+    MOUSEEVENTF_XDOWN,
     MOUSEEVENTF_XDOWN,
     MOUSEEVENTF_XDOWN
 };
@@ -88,8 +88,8 @@ static const UINT button_up_flags[NB_BUTTONS] =
     MOUSEEVENTF_RIGHTUP,
     0,
     0,
-    0,
-    0,
+    MOUSEEVENTF_XUP,
+    MOUSEEVENTF_XUP,
     MOUSEEVENTF_XUP,
     MOUSEEVENTF_XUP
 };
@@ -101,8 +101,8 @@ static const UINT button_down_data[NB_BUTTONS] =
     0,
     WHEEL_DELTA,
     -WHEEL_DELTA,
-    -WHEEL_DELTA,
-    WHEEL_DELTA,
+    XBUTTON1,
+    XBUTTON2,
     XBUTTON1,
     XBUTTON2
 };
@@ -114,8 +114,8 @@ static const UINT button_up_data[NB_BUTTONS] =
     0,
     0,
     0,
-    0,
-    0,
+    XBUTTON1,
+    XBUTTON2,
     XBUTTON1,
     XBUTTON2
 };
From cf051b76ba4972b7383f074fa1d127c5c3c03946 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 17 Jan 2020 12:45:32 +0100
Subject: [PATCH] winex11.drv: Rename EVENT_x11_time_to_win32_time to
 x11drv_time_to_ticks.

---
 dlls/winex11.drv/event.c    |  8 ++++----
 dlls/winex11.drv/keyboard.c |  2 +-
 dlls/winex11.drv/mouse.c    | 10 +++++-----
 dlls/winex11.drv/wintab.c   |  6 +++---
 dlls/winex11.drv/x11drv.h   |  2 +-
 5 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 170111e9c28..24b0a3da2f2 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -503,12 +503,12 @@ DWORD CDECL X11DRV_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handl
 }

 /***********************************************************************
- *           EVENT_x11_time_to_win32_time
+ *           x11drv_time_to_ticks
  *
  * Make our timer and the X timer line up as best we can
  *  Pass 0 to retrieve the current adjustment value (times -1)
  */
-DWORD EVENT_x11_time_to_win32_time(Time time)
+DWORD x11drv_time_to_ticks( Time time )
 {
   static DWORD adjust = 0;
   DWORD now = GetTickCount();
@@ -569,10 +569,10 @@ static void set_input_focus( struct x11drv_win_data *data )

     if (!data->whole_window) return;

-    if (EVENT_x11_time_to_win32_time(0))
+    if (x11drv_time_to_ticks(0))
         /* ICCCM says don't use CurrentTime, so try to use last message time if possible */
         /* FIXME: this is not entirely correct */
-        timestamp = GetMessageTime() - EVENT_x11_time_to_win32_time(0);
+        timestamp = GetMessageTime() - x11drv_time_to_ticks(0);
     else
         timestamp = CurrentTime;

diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index c6eab6f5cfa..e70e1254c9e 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -1330,7 +1330,7 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
     DWORD dwFlags;
     int ascii_chars;
     XIC xic = X11DRV_get_ic( hwnd );
-    DWORD event_time = EVENT_x11_time_to_win32_time(event->time);
+    DWORD event_time = x11drv_time_to_ticks( event->time );
     Status status = 0;

     TRACE_(key)("type %d, window %lx, state 0x%04x, keycode %u\n",
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 7029983b92d..b053aba973c 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1704,7 +1704,7 @@ BOOL X11DRV_ButtonPress( HWND hwnd, XEvent *xev )
     input.u.mi.dy          = event->y;
     input.u.mi.mouseData   = button_down_data[buttonNum];
     input.u.mi.dwFlags     = button_down_flags[buttonNum] | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
-    input.u.mi.time        = EVENT_x11_time_to_win32_time( event->time );
+    input.u.mi.time        = x11drv_time_to_ticks( event->time );
     input.u.mi.dwExtraInfo = 0;

     update_user_time( event->time );
@@ -1731,7 +1731,7 @@ BOOL X11DRV_ButtonRelease( HWND hwnd, XEvent *xev )
     input.u.mi.dy          = event->y;
     input.u.mi.mouseData   = button_up_data[buttonNum];
     input.u.mi.dwFlags     = button_up_flags[buttonNum] | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
-    input.u.mi.time        = EVENT_x11_time_to_win32_time( event->time );
+    input.u.mi.time        = x11drv_time_to_ticks( event->time );
     input.u.mi.dwExtraInfo = 0;

     map_event_coords( hwnd, event->window, event->root, event->x_root, event->y_root, &input );
@@ -1755,7 +1755,7 @@ BOOL X11DRV_MotionNotify( HWND hwnd, XEvent *xev )
     input.u.mi.dy          = event->y;
     input.u.mi.mouseData   = 0;
     input.u.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
-    input.u.mi.time        = EVENT_x11_time_to_win32_time( event->time );
+    input.u.mi.time        = x11drv_time_to_ticks( event->time );
     input.u.mi.dwExtraInfo = 0;

     if (!hwnd && is_old_motion_event( event->serial ))
@@ -1787,7 +1787,7 @@ BOOL X11DRV_EnterNotify( HWND hwnd, XEvent *xev )
     input.u.mi.dy          = event->y;
     input.u.mi.mouseData   = 0;
     input.u.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
-    input.u.mi.time        = EVENT_x11_time_to_win32_time( event->time );
+    input.u.mi.time        = x11drv_time_to_ticks( event->time );
     input.u.mi.dwExtraInfo = 0;

     if (is_old_motion_event( event->serial ))
@@ -1907,7 +1907,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
     input.type = INPUT_MOUSE;
     input.u.mi.mouseData   = 0;
     input.u.mi.dwFlags     = MOUSEEVENTF_MOVE;
-    input.u.mi.time        = EVENT_x11_time_to_win32_time( event->time );
+    input.u.mi.time        = x11drv_time_to_ticks( event->time );
     input.u.mi.dwExtraInfo = 0;
     input.u.mi.dx          = 0;
     input.u.mi.dy          = 0;
diff --git a/dlls/winex11.drv/wintab.c b/dlls/winex11.drv/wintab.c
index 331601c3325..692d0872286 100644
--- a/dlls/winex11.drv/wintab.c
+++ b/dlls/winex11.drv/wintab.c
@@ -893,7 +893,7 @@ static BOOL motion_event( HWND hwnd, XEvent *event )

     /* Set cursor to inverted if cursor is the eraser */
     gMsgPacket.pkStatus = (cursor->TYPE  == CSR_TYPE_ERASER ? TPS_INVERT:0);
-    gMsgPacket.pkTime = EVENT_x11_time_to_win32_time(motion->time);
+    gMsgPacket.pkTime = x11drv_time_to_ticks(motion->time);
     gMsgPacket.pkSerialNumber = gSerial++;
     gMsgPacket.pkCursor = curnum;
     gMsgPacket.pkX = motion->axis_data[0];
@@ -926,7 +926,7 @@ static BOOL button_event( HWND hwnd, XEvent *event )
     /* Set cursor to inverted if cursor is the eraser */
     gMsgPacket.pkStatus = (cursor->TYPE == CSR_TYPE_ERASER ? TPS_INVERT:0);
     set_button_state(curnum, button->deviceid);
-    gMsgPacket.pkTime = EVENT_x11_time_to_win32_time(button->time);
+    gMsgPacket.pkTime = x11drv_time_to_ticks(button->time);
     gMsgPacket.pkSerialNumber = gSerial++;
     gMsgPacket.pkCursor = curnum;
     if (button->axes_count > 0) {
@@ -976,7 +976,7 @@ static BOOL proximity_event( HWND hwnd, XEvent *event )
     /* Set cursor to inverted if cursor is the eraser */
     gMsgPacket.pkStatus = (cursor->TYPE == CSR_TYPE_ERASER ? TPS_INVERT:0);
     gMsgPacket.pkStatus |= (event->type==proximity_out_type)?TPS_PROXIMITY:0;
-    gMsgPacket.pkTime = EVENT_x11_time_to_win32_time(proximity->time);
+    gMsgPacket.pkTime = x11drv_time_to_ticks(proximity->time);
     gMsgPacket.pkSerialNumber = gSerial++;
     gMsgPacket.pkCursor = curnum;
     gMsgPacket.pkX = proximity->axis_data[0];
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 8dc74aa2e39..0f09c1891f6 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -569,7 +569,7 @@ extern int xinput2_opcode DECLSPEC_HIDDEN;
 extern Bool (*pXGetEventData)( Display *display, XEvent /*XGenericEventCookie*/ *event ) DECLSPEC_HIDDEN;
 extern void (*pXFreeEventData)( Display *display, XEvent /*XGenericEventCookie*/ *event ) DECLSPEC_HIDDEN;

-extern DWORD EVENT_x11_time_to_win32_time(Time time) DECLSPEC_HIDDEN;
+extern DWORD x11drv_time_to_ticks(Time time) DECLSPEC_HIDDEN;

 /* X11 driver private messages, must be in the range 0x80001000..0x80001fff */
 enum x11drv_window_messages
From ad9001792de0e8227aa7aa218bc42a29864ebd39 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 4 Jan 2022 00:11:25 +0100
Subject: [PATCH] dinput/tests: Add some RegisterDeviceNotificationA and
 hotplug tests.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

CW-Bug-Id: #19841
CW-Bug-Id: #19843
CW-Bug-Id: #19844

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
(cherry picked from commit 22f9f5caead14be79751879ec117d9a2760eb4d2)
---
 dlls/dinput/tests/dinput_test.h |   1 +
 dlls/dinput/tests/hid.c         |  86 ++++++++++
 dlls/dinput/tests/joystick8.c   | 282 ++++++++++++++++++++++++++++++++
 3 files changed, 369 insertions(+)

diff --git a/dlls/dinput/tests/dinput_test.h b/dlls/dinput/tests/dinput_test.h
index 0a4c9ba5fa4..97eed949a36 100644
--- a/dlls/dinput/tests/dinput_test.h
+++ b/dlls/dinput/tests/dinput_test.h
@@ -66,6 +66,7 @@ BOOL dinput_test_init_( const char *file, int line );
 void dinput_test_exit(void);

 HRESULT dinput_test_create_device( DWORD version, DIDEVICEINSTANCEW *devinst, IDirectInputDevice8W **device );
+DWORD WINAPI dinput_test_device_thread( void *stop_event );

 #define check_member_( file, line, val, exp, fmt, member )                                         \
     ok_(file, line)( (val).member == (exp).member, "got " #member " " fmt "\n", (val).member )
diff --git a/dlls/dinput/tests/hid.c b/dlls/dinput/tests/hid.c
index a0fd2f6c660..534269d1dfe 100644
--- a/dlls/dinput/tests/hid.c
+++ b/dlls/dinput/tests/hid.c
@@ -3478,6 +3478,92 @@ HRESULT dinput_test_create_device( DWORD version, DIDEVICEINSTANCEW *devinst, ID
     return DI_OK;
 }

+DWORD WINAPI dinput_test_device_thread( void *stop_event )
+{
+#include "psh_hid_macros.h"
+    static const unsigned char gamepad_desc[] =
+    {
+        USAGE_PAGE(1, HID_USAGE_PAGE_GENERIC),
+        USAGE(1, HID_USAGE_GENERIC_GAMEPAD),
+        COLLECTION(1, Application),
+            USAGE(1, HID_USAGE_GENERIC_GAMEPAD),
+            COLLECTION(1, Physical),
+                USAGE(1, HID_USAGE_GENERIC_X),
+                USAGE(1, HID_USAGE_GENERIC_Y),
+                LOGICAL_MINIMUM(1, 0),
+                LOGICAL_MAXIMUM(1, 127),
+                PHYSICAL_MINIMUM(1, 0),
+                PHYSICAL_MAXIMUM(1, 127),
+                REPORT_SIZE(1, 8),
+                REPORT_COUNT(1, 2),
+                INPUT(1, Data|Var|Abs),
+
+                USAGE_PAGE(1, HID_USAGE_PAGE_BUTTON),
+                USAGE_MINIMUM(1, 1),
+                USAGE_MAXIMUM(1, 6),
+                LOGICAL_MINIMUM(1, 0),
+                LOGICAL_MAXIMUM(1, 1),
+                PHYSICAL_MINIMUM(1, 0),
+                PHYSICAL_MAXIMUM(1, 1),
+                REPORT_SIZE(1, 1),
+                REPORT_COUNT(1, 8),
+                INPUT(1, Data|Var|Abs),
+            END_COLLECTION,
+        END_COLLECTION,
+    };
+#include "pop_hid_macros.h"
+    static const HID_DEVICE_ATTRIBUTES attributes =
+    {
+        .Size = sizeof(HID_DEVICE_ATTRIBUTES),
+        .VendorID = LOWORD( EXPECT_VIDPID ),
+        .ProductID = HIWORD( EXPECT_VIDPID ),
+        .VersionNumber = 0x0100,
+    };
+    static const HIDP_CAPS caps =
+    {
+        .InputReportByteLength = 3,
+    };
+
+    WCHAR cwd[MAX_PATH], tempdir[MAX_PATH];
+    DWORD report_id = 1, polled = 0;
+    char context[64];
+    LSTATUS status;
+    HKEY hkey;
+
+    GetCurrentDirectoryW( ARRAY_SIZE(cwd), cwd );
+    GetTempPathW( ARRAY_SIZE(tempdir), tempdir );
+    SetCurrentDirectoryW( tempdir );
+
+    status = RegCreateKeyExW( HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services\\winetest",
+                              0, NULL, REG_OPTION_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL );
+    ok( !status, "RegCreateKeyExW returned %#x\n", status );
+    status = RegSetValueExW( hkey, L"ReportID", 0, REG_DWORD, (void *)&report_id, sizeof(report_id) );
+    ok( !status, "RegSetValueExW returned %#x\n", status );
+    status = RegSetValueExW( hkey, L"PolledMode", 0, REG_DWORD, (void *)&polled, sizeof(polled) );
+    ok( !status, "RegSetValueExW returned %#x\n", status );
+    status = RegSetValueExW( hkey, L"Descriptor", 0, REG_BINARY, (void *)gamepad_desc, sizeof(gamepad_desc) );
+    ok( !status, "RegSetValueExW returned %#x\n", status );
+    status = RegSetValueExW( hkey, L"Attributes", 0, REG_BINARY, (void *)&attributes, sizeof(attributes) );
+    ok( !status, "RegSetValueExW returned %#x\n", status );
+    status = RegSetValueExW( hkey, L"Caps", 0, REG_BINARY, (void *)&caps, sizeof(caps) );
+    ok( !status, "RegSetValueExW returned %#x\n", status );
+    status = RegSetValueExW( hkey, L"Expect", 0, REG_BINARY, (void *)NULL, 0 );
+    ok( !status, "RegSetValueExW returned %#x\n", status );
+    status = RegSetValueExW( hkey, L"Input", 0, REG_BINARY, NULL, 0 );
+    ok( !status, "RegSetValueExW returned %#x\n", status );
+    fill_context( __LINE__, context, ARRAY_SIZE(context) );
+    status = RegSetValueExW( hkey, L"Context", 0, REG_BINARY, (void *)context, sizeof(context) );
+    ok( !status, "RegSetValueExW returned %#x\n", status );
+
+    pnp_driver_start( L"driver_hid.dll" );
+    WaitForSingleObject( stop_event, INFINITE );
+    pnp_driver_stop();
+
+    SetCurrentDirectoryW( cwd );
+
+    return 0;
+}
+
 START_TEST( hid )
 {
     if (!dinput_test_init()) return;
diff --git a/dlls/dinput/tests/joystick8.c b/dlls/dinput/tests/joystick8.c
index d06b56cbf8c..0943d44fd58 100644
--- a/dlls/dinput/tests/joystick8.c
+++ b/dlls/dinput/tests/joystick8.c
@@ -30,6 +30,7 @@
 #include "dinput.h"
 #include "dinputd.h"
 #include "devguid.h"
+#include "dbt.h"
 #include "mmsystem.h"

 #include "wine/hid.h"
@@ -2741,6 +2742,285 @@ static BOOL test_winmm_joystick(void)
     return device != NULL;
 }

+static int device_change_count;
+static int device_change_expect;
+static HWND device_change_hwnd;
+static BOOL device_change_all;
+
+static BOOL all_upper( const WCHAR *str, const WCHAR *end )
+{
+    while (str++ != end) if (towupper( str[-1] ) != str[-1]) return FALSE;
+    return TRUE;
+}
+
+static BOOL all_lower( const WCHAR *str, const WCHAR *end )
+{
+    while (str++ != end) if (towlower( str[-1] ) != str[-1]) return FALSE;
+    return TRUE;
+}
+
+static LRESULT CALLBACK devnotify_wndproc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
+{
+    if (msg == WM_DEVICECHANGE)
+    {
+        DEV_BROADCAST_HDR *header = (DEV_BROADCAST_HDR *)lparam;
+        DEV_BROADCAST_DEVICEINTERFACE_W *iface = (DEV_BROADCAST_DEVICEINTERFACE_W *)lparam;
+        const WCHAR *upper_end, *name_end, *expect_prefix;
+        GUID expect_guid;
+
+        if (device_change_all && (device_change_count == 0 || device_change_count == 3))
+        {
+            expect_guid = control_class;
+            expect_prefix = L"\\\\?\\ROOT#";
+        }
+        else
+        {
+            expect_guid = GUID_DEVINTERFACE_HID;
+            expect_prefix = L"\\\\?\\HID#";
+        }
+
+        ok( hwnd == device_change_hwnd, "got hwnd %p\n", hwnd );
+        ok( header->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE, "got dbch_devicetype %u\n",
+            header->dbch_devicetype );
+
+        winetest_push_context( "%u", device_change_count );
+
+        todo_wine_if( IsEqualGUID( &iface->dbcc_classguid, &control_class ) && !device_change_all )
+        ok( IsEqualGUID( &iface->dbcc_classguid, &expect_guid ), "got dbch_classguid %s\n",
+            debugstr_guid( &iface->dbcc_classguid ) );
+        ok( iface->dbcc_size >= offsetof( DEV_BROADCAST_DEVICEINTERFACE_W, dbcc_name[wcslen( iface->dbcc_name ) + 1] ),
+            "got dbcc_size %u\n", iface->dbcc_size );
+        todo_wine
+        ok( !wcsncmp( iface->dbcc_name, expect_prefix, wcslen( expect_prefix ) ),
+            "got dbcc_name %s\n", debugstr_w(iface->dbcc_name) );
+
+        upper_end = wcschr( iface->dbcc_name + wcslen( expect_prefix ), '#' );
+        name_end = iface->dbcc_name + wcslen( iface->dbcc_name ) + 1;
+        ok( !!upper_end, "got dbcc_name %s\n", debugstr_w(iface->dbcc_name) );
+        todo_wine
+        ok( all_upper( iface->dbcc_name, upper_end ), "got dbcc_name %s\n", debugstr_w(iface->dbcc_name) );
+        ok( all_lower( upper_end, name_end ), "got dbcc_name %s\n", debugstr_w(iface->dbcc_name) );
+
+        if (device_change_count++ >= device_change_expect / 2)
+            ok( wparam == DBT_DEVICEREMOVECOMPLETE, "got wparam %#x\n", (DWORD)wparam );
+        else
+            ok( wparam == DBT_DEVICEARRIVAL, "got wparam %#x\n", (DWORD)wparam );
+
+        winetest_pop_context();
+    }
+
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+static void test_RegisterDeviceNotification(void)
+{
+    DEV_BROADCAST_DEVICEINTERFACE_A iface_filter_a =
+    {
+        .dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE_A),
+        .dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE,
+        .dbcc_classguid = GUID_DEVINTERFACE_HID,
+    };
+    WNDCLASSEXW class =
+    {
+        .cbSize = sizeof(WNDCLASSEXW),
+        .hInstance = GetModuleHandleW( NULL ),
+        .lpszClassName = L"devnotify",
+        .lpfnWndProc = devnotify_wndproc,
+    };
+    char buffer[1024] = {0};
+    DEV_BROADCAST_HDR *header = (DEV_BROADCAST_HDR *)buffer;
+    HANDLE hwnd, thread, stop_event;
+    HDEVNOTIFY devnotify;
+    MSG msg;
+
+    RegisterClassExW( &class );
+
+    hwnd = CreateWindowW( class.lpszClassName, NULL, 0, 0, 0, 0, 0, HWND_MESSAGE, NULL, NULL, NULL );
+    ok( !!hwnd, "CreateWindowW failed, error %u\n", GetLastError() );
+
+    SetLastError( 0xdeadbeef );
+    devnotify = RegisterDeviceNotificationA( NULL, NULL, 0 );
+    todo_wine
+    ok( !devnotify, "RegisterDeviceNotificationA succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %u\n", GetLastError() );
+    if (devnotify) UnregisterDeviceNotification( devnotify );
+
+    SetLastError( 0xdeadbeef );
+    devnotify = RegisterDeviceNotificationA( (HWND)0xdeadbeef, NULL, 0 );
+    todo_wine
+    ok( !devnotify, "RegisterDeviceNotificationA succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %u\n", GetLastError() );
+    if (devnotify) UnregisterDeviceNotification( devnotify );
+
+    SetLastError( 0xdeadbeef );
+    devnotify = RegisterDeviceNotificationA( hwnd, NULL, 2 );
+    todo_wine
+    ok( !devnotify, "RegisterDeviceNotificationA succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %u\n", GetLastError() );
+    if (devnotify) UnregisterDeviceNotification( devnotify );
+
+    SetLastError( 0xdeadbeef );
+    memset( header, 0, sizeof(DEV_BROADCAST_OEM) );
+    header->dbch_size = sizeof(DEV_BROADCAST_OEM);
+    header->dbch_devicetype = DBT_DEVTYP_OEM;
+    devnotify = RegisterDeviceNotificationA( hwnd, header, 0 );
+    todo_wine
+    ok( !devnotify, "RegisterDeviceNotificationA succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_DATA || GetLastError() == ERROR_SERVICE_SPECIFIC_ERROR,
+        "got error %u\n", GetLastError() );
+    if (devnotify) UnregisterDeviceNotification( devnotify );
+
+    SetLastError( 0xdeadbeef );
+    memset( header, 0, sizeof(DEV_BROADCAST_DEVNODE) );
+    header->dbch_size = sizeof(DEV_BROADCAST_DEVNODE);
+    header->dbch_devicetype = DBT_DEVTYP_DEVNODE;
+    devnotify = RegisterDeviceNotificationA( hwnd, header, 0 );
+    todo_wine
+    ok( !devnotify, "RegisterDeviceNotificationA succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_DATA || GetLastError() == ERROR_SERVICE_SPECIFIC_ERROR,
+        "got error %u\n", GetLastError() );
+    if (devnotify) UnregisterDeviceNotification( devnotify );
+
+    SetLastError( 0xdeadbeef );
+    memset( header, 0, sizeof(DEV_BROADCAST_VOLUME) );
+    header->dbch_size = sizeof(DEV_BROADCAST_VOLUME);
+    header->dbch_devicetype = DBT_DEVTYP_VOLUME;
+    devnotify = RegisterDeviceNotificationA( hwnd, header, 0 );
+    todo_wine
+    ok( !devnotify, "RegisterDeviceNotificationA succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_DATA || GetLastError() == ERROR_SERVICE_SPECIFIC_ERROR,
+        "got error %u\n", GetLastError() );
+    if (devnotify) UnregisterDeviceNotification( devnotify );
+
+    SetLastError( 0xdeadbeef );
+    memset( header, 0, sizeof(DEV_BROADCAST_PORT_A) );
+    header->dbch_size = sizeof(DEV_BROADCAST_PORT_A);
+    header->dbch_devicetype = DBT_DEVTYP_PORT;
+    devnotify = RegisterDeviceNotificationA( hwnd, header, 0 );
+    todo_wine
+    ok( !devnotify, "RegisterDeviceNotificationA succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_DATA || GetLastError() == ERROR_SERVICE_SPECIFIC_ERROR,
+        "got error %u\n", GetLastError() );
+    if (devnotify) UnregisterDeviceNotification( devnotify );
+
+    SetLastError( 0xdeadbeef );
+    memset( header, 0, sizeof(DEV_BROADCAST_NET) );
+    header->dbch_size = sizeof(DEV_BROADCAST_NET);
+    header->dbch_devicetype = DBT_DEVTYP_NET;
+    devnotify = RegisterDeviceNotificationA( hwnd, header, 0 );
+    todo_wine
+    ok( !devnotify, "RegisterDeviceNotificationA succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_DATA || GetLastError() == ERROR_SERVICE_SPECIFIC_ERROR,
+        "got error %u\n", GetLastError() );
+    if (devnotify) UnregisterDeviceNotification( devnotify );
+
+    devnotify = RegisterDeviceNotificationA( hwnd, &iface_filter_a, DEVICE_NOTIFY_WINDOW_HANDLE );
+    ok( !!devnotify, "RegisterDeviceNotificationA failed, error %u\n", GetLastError() );
+    while (PeekMessageW( &msg, hwnd, 0, 0, PM_REMOVE )) DispatchMessageW( &msg );
+
+    device_change_count = 0;
+    if (!strcmp( winetest_platform, "wine" )) device_change_expect = 4;
+    else device_change_expect = 2;
+    device_change_hwnd = hwnd;
+    device_change_all = FALSE;
+    stop_event = CreateEventW( NULL, FALSE, FALSE, NULL );
+    ok( !!stop_event, "CreateEventW failed, error %u\n", GetLastError() );
+    thread = CreateThread( NULL, 0, dinput_test_device_thread, stop_event, 0, NULL );
+    ok( !!thread, "CreateThread failed, error %u\n", GetLastError() );
+
+    while (device_change_count < device_change_expect)
+    {
+        while (PeekMessageW( &msg, hwnd, 0, 0, PM_REMOVE ))
+        {
+            TranslateMessage( &msg );
+            ok( msg.message != WM_DEVICECHANGE, "got WM_DEVICECHANGE\n" );
+            DispatchMessageW( &msg );
+        }
+        if (device_change_count == device_change_expect / 2) SetEvent( stop_event );
+    }
+
+    WaitForSingleObject( thread, INFINITE );
+    CloseHandle( thread );
+    CloseHandle( stop_event );
+
+    UnregisterDeviceNotification( devnotify );
+
+    memcpy( buffer, &iface_filter_a, sizeof(iface_filter_a) );
+    strcpy( ((DEV_BROADCAST_DEVICEINTERFACE_A *)buffer)->dbcc_name, "device name" );
+    ((DEV_BROADCAST_DEVICEINTERFACE_A *)buffer)->dbcc_size += strlen( "device name" ) + 1;
+    devnotify = RegisterDeviceNotificationA( hwnd, buffer, DEVICE_NOTIFY_WINDOW_HANDLE );
+    ok( !!devnotify, "RegisterDeviceNotificationA failed, error %u\n", GetLastError() );
+    while (PeekMessageW( &msg, hwnd, 0, 0, PM_REMOVE )) DispatchMessageW( &msg );
+
+    device_change_count = 0;
+    if (!strcmp( winetest_platform, "wine" )) device_change_expect = 4;
+    else device_change_expect = 2;
+    device_change_hwnd = hwnd;
+    device_change_all = FALSE;
+    stop_event = CreateEventW( NULL, FALSE, FALSE, NULL );
+    ok( !!stop_event, "CreateEventW failed, error %u\n", GetLastError() );
+    thread = CreateThread( NULL, 0, dinput_test_device_thread, stop_event, 0, NULL );
+    ok( !!thread, "CreateThread failed, error %u\n", GetLastError() );
+
+    while (device_change_count < device_change_expect)
+    {
+        while (PeekMessageW( &msg, hwnd, 0, 0, PM_REMOVE ))
+        {
+            TranslateMessage( &msg );
+            ok( msg.message != WM_DEVICECHANGE, "got WM_DEVICECHANGE\n" );
+            DispatchMessageW( &msg );
+        }
+        if (device_change_count == device_change_expect / 2) SetEvent( stop_event );
+    }
+
+    WaitForSingleObject( thread, INFINITE );
+    CloseHandle( thread );
+    CloseHandle( stop_event );
+
+    UnregisterDeviceNotification( devnotify );
+
+    devnotify = RegisterDeviceNotificationA( hwnd, &iface_filter_a, DEVICE_NOTIFY_ALL_INTERFACE_CLASSES );
+    ok( !!devnotify, "RegisterDeviceNotificationA failed, error %u\n", GetLastError() );
+    while (PeekMessageW( &msg, hwnd, 0, 0, PM_REMOVE )) DispatchMessageW( &msg );
+
+    device_change_count = 0;
+    device_change_expect = 4;
+    device_change_hwnd = hwnd;
+    device_change_all = TRUE;
+    stop_event = CreateEventW( NULL, FALSE, FALSE, NULL );
+    ok( !!stop_event, "CreateEventW failed, error %u\n", GetLastError() );
+    thread = CreateThread( NULL, 0, dinput_test_device_thread, stop_event, 0, NULL );
+    ok( !!thread, "CreateThread failed, error %u\n", GetLastError() );
+
+    while (device_change_count < device_change_expect)
+    {
+        while (PeekMessageW( &msg, hwnd, 0, 0, PM_REMOVE ))
+        {
+            TranslateMessage( &msg );
+            ok( msg.message != WM_DEVICECHANGE, "got WM_DEVICECHANGE\n" );
+            DispatchMessageW( &msg );
+        }
+        if (device_change_count == device_change_expect / 2) SetEvent( stop_event );
+    }
+
+    WaitForSingleObject( thread, INFINITE );
+    CloseHandle( thread );
+    CloseHandle( stop_event );
+
+    UnregisterDeviceNotification( devnotify );
+
+    DestroyWindow( hwnd );
+    UnregisterClassW( class.lpszClassName, class.hInstance );
+}
+
 START_TEST( joystick8 )
 {
     if (!dinput_test_init()) return;
@@ -2758,6 +3038,8 @@ START_TEST( joystick8 )
         test_simple_joystick( 0x500 );
         test_simple_joystick( 0x700 );
         test_simple_joystick( 0x800 );
+
+        test_RegisterDeviceNotification();
     }
     CoUninitialize();

From 2f1fb676d8bc1ab64c1702988d44e8cf6ddaa2b0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 24 Dec 2021 12:23:43 +0100
Subject: [PATCH] user32: Remove FIXME from RegisterDeviceNotificationA.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

There's no conversion to do, the device name in the filter is ignored.

CW-Bug-Id: #19841
CW-Bug-Id: #19843
CW-Bug-Id: #19844
Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
(cherry picked from commit 30af95f45da07dbdc20f6c1684140803354b23db)
---
 dlls/user32/input.c | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index a9624153bed..a1b140215c3 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -1196,13 +1196,9 @@ extern BOOL WINAPI I_ScUnregisterDeviceNotification( HDEVNOTIFY handle );
  *
  * See RegisterDeviceNotificationW.
  */
-HDEVNOTIFY WINAPI RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID pNotificationFilter, DWORD dwFlags)
+HDEVNOTIFY WINAPI RegisterDeviceNotificationA( HANDLE handle, void *filter, DWORD flags )
 {
-    TRACE("(hwnd=%p, filter=%p,flags=0x%08x)\n",
-        hRecipient,pNotificationFilter,dwFlags);
-    if (pNotificationFilter)
-        FIXME("The notification filter will requires an A->W when filter support is implemented\n");
-    return RegisterDeviceNotificationW(hRecipient, pNotificationFilter, dwFlags);
+    return RegisterDeviceNotificationW( handle, filter, flags );
 }

 /***********************************************************************
From d609fdac26246e98d8476c7852820df532014eeb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 5 Jan 2022 15:19:33 +0100
Subject: [PATCH] user32: Guard rawinput_devices against concurrent accesses.

CW-Bug-Id: #19841
CW-Bug-Id: #19843
CW-Bug-Id: #19844
---
 dlls/user32/rawinput.c | 41 +++++++++++++++++++++++++++++++++--------
 1 file changed, 33 insertions(+), 8 deletions(-)

diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index a774f12231b..96233329e04 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -279,11 +279,25 @@ BOOL rawinput_device_get_usages(HANDLE handle, USAGE *usage_page, USAGE *usage)

     *usage_page = *usage = 0;

-    if (!(device = find_device_from_handle(handle))) return FALSE;
-    if (device->info.dwType != RIM_TYPEHID) return FALSE;
+    EnterCriticalSection(&rawinput_devices_cs);
+
+    if (!(device = find_device_from_handle(handle)))
+    {
+        WARN("could not find device for handle %p\n", handle);
+        LeaveCriticalSection(&rawinput_devices_cs);
+        return FALSE;
+    }
+    if (device->info.dwType != RIM_TYPEHID)
+    {
+        WARN("found non-hid device for handle %p\n", handle);
+        LeaveCriticalSection(&rawinput_devices_cs);
+        return FALSE;
+    }

     *usage_page = device->info.hid.usUsagePage;
     *usage = device->info.hid.usUsage;
+
+    LeaveCriticalSection(&rawinput_devices_cs);
     return TRUE;
 }

@@ -423,7 +437,7 @@ BOOL rawinput_from_hardware_message(RAWINPUT *rawinput, const struct hardware_ms
 UINT WINAPI GetRawInputDeviceList(RAWINPUTDEVICELIST *devices, UINT *device_count, UINT size)
 {
     static UINT last_check;
-    UINT i, ticks = GetTickCount();
+    UINT i, count, ticks = GetTickCount();

     TRACE("devices %p, device_count %p, size %u.\n", devices, device_count, size);

@@ -439,32 +453,36 @@ UINT WINAPI GetRawInputDeviceList(RAWINPUTDEVICELIST *devices, UINT *device_coun
         return ~0U;
     }

+    EnterCriticalSection(&rawinput_devices_cs);
     if (ticks - last_check > 2000)
     {
         last_check = ticks;
         rawinput_update_device_list();
     }

+    count = rawinput_devices_count;
+    LeaveCriticalSection(&rawinput_devices_cs);
+
     if (!devices)
     {
-        *device_count = rawinput_devices_count;
+        *device_count = count;
         return 0;
     }

-    if (*device_count < rawinput_devices_count)
+    if (*device_count < count)
     {
         SetLastError(ERROR_INSUFFICIENT_BUFFER);
-        *device_count = rawinput_devices_count;
+        *device_count = count;
         return ~0U;
     }

-    for (i = 0; i < rawinput_devices_count; ++i)
+    for (i = 0; i < count; ++i)
     {
         devices[i].hDevice = rawinput_devices[i].handle;
         devices[i].dwType = rawinput_devices[i].info.dwType;
     }

-    return rawinput_devices_count;
+    return count;
 }

 /***********************************************************************
@@ -741,8 +759,12 @@ UINT WINAPI GetRawInputDeviceInfoW(HANDLE handle, UINT command, void *data, UINT
         SetLastError(ERROR_NOACCESS);
         return ~0U;
     }
+
+    EnterCriticalSection(&rawinput_devices_cs);
+
     if (!(device = find_device_from_handle(handle)))
     {
+        LeaveCriticalSection(&rawinput_devices_cs);
         SetLastError(ERROR_INVALID_HANDLE);
         return ~0U;
     }
@@ -774,10 +796,13 @@ UINT WINAPI GetRawInputDeviceInfoW(HANDLE handle, UINT command, void *data, UINT

     default:
         FIXME("command %#x not supported\n", command);
+        LeaveCriticalSection(&rawinput_devices_cs);
         SetLastError(ERROR_INVALID_PARAMETER);
         return ~0U;
     }

+    LeaveCriticalSection(&rawinput_devices_cs);
+
     if (!data)
         return 0;

From a5f9baa9c61d71b09824f2a41e8d56c542241005 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 5 Jan 2022 16:14:02 +0100
Subject: [PATCH] user32: Add or remove rawinput devices individually on
 WM_DEVICECHANGE.

CW-Bug-Id: #19841
CW-Bug-Id: #19843
CW-Bug-Id: #19844
---
 dlls/user32/input.c        |  4 ++++
 dlls/user32/rawinput.c     | 42 +++++++++++++++++++++++++++++++++++++-
 dlls/user32/user_private.h |  2 ++
 3 files changed, 47 insertions(+), 1 deletion(-)

diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index a1b140215c3..c6b49d2a928 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -1166,6 +1166,10 @@ BOOL WINAPI EnableMouseInPointer(BOOL enable)

 static DWORD CALLBACK devnotify_window_callback(HANDLE handle, DWORD flags, DEV_BROADCAST_HDR *header)
 {
+    DEV_BROADCAST_DEVICEINTERFACE_W *iface = (DEV_BROADCAST_DEVICEINTERFACE_W *)header;
+    if (flags == DBT_DEVICEARRIVAL) rawinput_add_device(iface->dbcc_name);
+    if (flags == DBT_DEVICEREMOVECOMPLETE) rawinput_remove_device(iface->dbcc_name);
+
     SendMessageTimeoutW(handle, WM_DEVICECHANGE, flags, (LPARAM)header, SMTO_ABORTIFHUNG, 2000, NULL);
     return 0;
 }
diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index 96233329e04..05bc3709bd2 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -172,6 +172,46 @@ static struct device *add_device(HDEVINFO set, SP_DEVICE_INTERFACE_DATA *iface)
     return device;
 }

+void rawinput_add_device(const WCHAR *device_path)
+{
+    ULONG i;
+
+    EnterCriticalSection(&rawinput_devices_cs);
+
+    for (i = 0; i < rawinput_devices_count; ++i)
+        if (!wcsicmp(rawinput_devices[i].detail->DevicePath, device_path))
+            break;
+
+    /* not there yet, force refresh the list, we cannot just add the device
+       here because it may not have its rawinput handle property assigned yet */
+    if (i == rawinput_devices_count) rawinput_devices_count = 0;
+
+    LeaveCriticalSection(&rawinput_devices_cs);
+}
+
+void rawinput_remove_device(const WCHAR *device_path)
+{
+    UINT i;
+
+    EnterCriticalSection(&rawinput_devices_cs);
+
+    for (i = 0; i < rawinput_devices_count; ++i)
+        if (!wcsicmp(rawinput_devices[i].detail->DevicePath, device_path))
+            break;
+
+    if (i < rawinput_devices_count)
+    {
+        HidD_FreePreparsedData(rawinput_devices[i].data);
+        CloseHandle(rawinput_devices[i].file);
+        free(rawinput_devices[i].detail);
+
+        rawinput_devices_count--;
+        memmove(rawinput_devices + i, rawinput_devices + i + 1, rawinput_devices_count - i);
+    }
+
+    LeaveCriticalSection(&rawinput_devices_cs);
+}
+
 void rawinput_update_device_list(void)
 {
     SP_DEVICE_INTERFACE_DATA iface = { sizeof(iface) };
@@ -454,7 +494,7 @@ UINT WINAPI GetRawInputDeviceList(RAWINPUTDEVICELIST *devices, UINT *device_coun
     }

     EnterCriticalSection(&rawinput_devices_cs);
-    if (ticks - last_check > 2000)
+    if (ticks - last_check > 2000 || !rawinput_devices_count)
     {
         last_check = ticks;
         rawinput_update_device_list();
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index e9dc214442b..c2c546a5865 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -154,6 +154,8 @@ extern BOOL rawinput_from_hardware_message(RAWINPUT *rawinput, const struct hard
 extern BOOL rawinput_device_get_usages(HANDLE handle, USAGE *usage_page, USAGE *usage);
 extern struct rawinput_thread_data *rawinput_thread_data(void);
 extern void rawinput_update_device_list(void);
+extern void rawinput_add_device(const WCHAR *device_path);
+extern void rawinput_remove_device(const WCHAR *device_path);

 extern void create_offscreen_window_surface( const RECT *visible_rect, struct window_surface **surface ) DECLSPEC_HIDDEN;

From 5975d0b5d870cfe1bf6c6fdce063a04957ed89a0 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Thu, 27 Jan 2022 19:17:58 +0200
Subject: [PATCH] hidclass.sys: Add input.inf that matches all HID devices.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This makes it so that all the devices on the HID bus now have Class,
ClassGUID, Driver and DriverDesc register properties populated.

Without having at least Driver and Class set SDL2 refuses to use HID
devices directly.

Signed-off-by: Arkadiusz Hiler <ahiler@codeweavers.com>
Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
(cherry picked from commit 2f2aba45dd5f6e5bc1317afc7bc2e00ef78fff40)
---
 dlls/hidclass.sys/Makefile.in |  2 ++
 dlls/hidclass.sys/hidclass.rc | 20 ++++++++++++++++++++
 dlls/hidclass.sys/input.inf   | 13 +++++++++++++
 loader/wine.inf.in            |  1 +
 4 files changed, 36 insertions(+)
 create mode 100644 dlls/hidclass.sys/hidclass.rc
 create mode 100644 dlls/hidclass.sys/input.inf

diff --git a/dlls/hidclass.sys/Makefile.in b/dlls/hidclass.sys/Makefile.in
index 25a0396dabe..788828ad66a 100644
--- a/dlls/hidclass.sys/Makefile.in
+++ b/dlls/hidclass.sys/Makefile.in
@@ -5,3 +5,5 @@ IMPORTS   = hal ntoskrnl user32 hidparse
 C_SRCS = \
 	device.c \
 	pnp.c
+
+RC_SRCS = hidclass.rc
diff --git a/dlls/hidclass.sys/hidclass.rc b/dlls/hidclass.sys/hidclass.rc
new file mode 100644
index 00000000000..409bdc16b45
--- /dev/null
+++ b/dlls/hidclass.sys/hidclass.rc
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2022 Arkadiusz Hiler
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* @makedep: input.inf */
+1 WINE_DATA_FILE input.inf
diff --git a/dlls/hidclass.sys/input.inf b/dlls/hidclass.sys/input.inf
new file mode 100644
index 00000000000..d9222b13672
--- /dev/null
+++ b/dlls/hidclass.sys/input.inf
@@ -0,0 +1,13 @@
+[Version]
+Signature="$CHICAGO$"
+ClassGuid={745a17a0-74d3-11d0-b6fe-00a0c90f57da}
+Class=HIDClass
+
+[Manufacturer]
+Wine=mfg_section
+
+[mfg_section]
+Wine HID device=device_section,HID\
+
+[device_section.Services]
+AddService = ,0x2
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 677ae91a406..a3bf302ec6c 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -5760,6 +5760,7 @@ protocol,"@%11%\ws2_32.dll,-3"
 services,"@%11%\ws2_32.dll,-4"

 [InfFiles]
+input.inf,"@%12%\hidclass.sys,-1"
 winebus.inf,"@%12%\winebus.sys,-1"
 winehid.inf,"@%12%\winehid.sys,-1"
 wineusb.inf,"@%12%\wineusb.sys,-1"
From 9788768b62ddacb10fe00af888e54a79ad69e445 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Wed, 19 Jan 2022 15:04:20 +0200
Subject: [PATCH] dinput/tests: Add static asserts for arrays that have to
 match in size.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Arkadiusz Hiler <ahiler@codeweavers.com>
Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
(cherry picked from commit 2420f7e188e04cb428211aabef8ec2f327b0416f)
---
 dlls/dinput/tests/joystick8.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/dinput/tests/joystick8.c b/dlls/dinput/tests/joystick8.c
index 525f14f0bba..927d65abf4f 100644
--- a/dlls/dinput/tests/joystick8.c
+++ b/dlls/dinput/tests/joystick8.c
@@ -2313,6 +2313,9 @@ static BOOL test_device_types( DWORD version )
         },
     };

+    C_ASSERT(ARRAY_SIZE(expect_caps) == ARRAY_SIZE(device_desc));
+    C_ASSERT(ARRAY_SIZE(expect_devinst) == ARRAY_SIZE(device_desc));
+
     DIDEVICEINSTANCEW devinst = {.dwSize = sizeof(DIDEVICEINSTANCEW)};
     DIDEVCAPS caps = {.dwSize = sizeof(DIDEVCAPS)};
     WCHAR cwd[MAX_PATH], tempdir[MAX_PATH];
From 2caa21b9221ed6406992f3f62b9c7c330b098f4f Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Wed, 19 Jan 2022 15:04:21 +0200
Subject: [PATCH] include: Add HID_USAGE_SIMULATION_CLUTCH.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Arkadiusz Hiler <ahiler@codeweavers.com>
Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
(cherry picked from commit 87331939a2c7b5f4a164e77c2f2d3e6c13d3c5a9)
---
 include/hidusage.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/include/hidusage.h b/include/hidusage.h
index da7274b5945..3e2ee77f8c8 100644
--- a/include/hidusage.h
+++ b/include/hidusage.h
@@ -207,6 +207,7 @@ typedef USHORT USAGE, *PUSAGE;
 #define HID_USAGE_SIMULATION_THROTTLE     ((USAGE) 0xBB)
 #define HID_USAGE_SIMULATION_ACCELERATOR  ((USAGE) 0xC4)
 #define HID_USAGE_SIMULATION_BRAKE        ((USAGE) 0xC5)
+#define HID_USAGE_SIMULATION_CLUTCH       ((USAGE) 0xC6)
 #define HID_USAGE_SIMULATION_STEERING     ((USAGE) 0xC8)

 #define HID_USAGE_TELEPHONY_PHONE                ((USAGE) 0x01)
From f1c5ef63f605a7ae7c729d01ef971459e9a2b6a8 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Wed, 5 Jan 2022 21:34:42 +0200
Subject: [PATCH] winebus.sys: Add Logitech G920 mapping to the SDL backend.

The HID input report format is different between Linux
(hid_logitech_hidpp) and Windows when it comes to axis HID usages.

To correct that we can use the device through SDL and craft our own
HID mapping.
---
 dlls/winebus.sys/bus_sdl.c | 59 +++++++++++++++++++++++++++-----------
 include/wine/hid.h         |  5 ++++
 2 files changed, 47 insertions(+), 17 deletions(-)

diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index 8cb1fea24e0..26191ccb3a5 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -227,22 +227,44 @@ static BOOL descriptor_add_haptic(struct sdl_device *impl)
     return TRUE;
 }

-static NTSTATUS build_joystick_report_descriptor(struct unix_device *iface)
+static const USAGE_AND_PAGE g920_absolute_usages[] =
+{
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_X},  /* wheel */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_Y},  /* accelerator */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_Z},  /* brake */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_RZ}, /* clutch */
+};
+
+static const USAGE_AND_PAGE generic_absolute_usages[] =
 {
-    static const USAGE_AND_PAGE absolute_usages[] =
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_X},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_Y},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_Z},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_RX},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_RY},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_RZ},
+    {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_THROTTLE},
+    {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_RUDDER},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_WHEEL},
+    {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_ACCELERATOR},
+    {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_BRAKE},
+};
+
+static int get_absolute_usages(struct sdl_device *impl, const USAGE_AND_PAGE **absolute_usages)
+{
+    if (is_logitech_g920(pSDL_JoystickGetVendor(impl->sdl_joystick), pSDL_JoystickGetProduct(impl->sdl_joystick)))
     {
-        {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_X},
-        {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_Y},
-        {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_Z},
-        {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_RX},
-        {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_RY},
-        {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_RZ},
-        {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_THROTTLE},
-        {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_RUDDER},
-        {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_WHEEL},
-        {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_ACCELERATOR},
-        {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_BRAKE},
-    };
+        *absolute_usages = g920_absolute_usages;
+        return ARRAY_SIZE(g920_absolute_usages);
+    }
+
+    *absolute_usages = generic_absolute_usages;
+    return ARRAY_SIZE(generic_absolute_usages);
+}
+
+static NTSTATUS build_joystick_report_descriptor(struct unix_device *iface)
+{
+    const USAGE_AND_PAGE *absolute_usages = NULL;
     static const USAGE_AND_PAGE relative_usages[] =
     {
         {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_X},
@@ -257,12 +279,15 @@ static NTSTATUS build_joystick_report_descriptor(struct unix_device *iface)
     };
     struct sdl_device *impl = impl_from_unix_device(iface);
     int i, button_count, axis_count, ball_count, hat_count;
+    size_t absolute_usages_count;
+
+    absolute_usages_count = get_absolute_usages(impl, &absolute_usages);

     axis_count = pSDL_JoystickNumAxes(impl->sdl_joystick);
-    if (axis_count > ARRAY_SIZE(absolute_usages))
+    if (axis_count > absolute_usages_count)
     {
-        FIXME("More than %zu absolute axes found, ignoring.\n", ARRAY_SIZE(absolute_usages));
-        axis_count = ARRAY_SIZE(absolute_usages);
+        FIXME("More than %zu absolute axes found, ignoring.\n", absolute_usages_count);
+        axis_count = absolute_usages_count;
     }

     ball_count = pSDL_JoystickNumBalls(impl->sdl_joystick);
diff --git a/include/wine/hid.h b/include/wine/hid.h
index 236888cbdc7..9a641cf00f7 100644
--- a/include/wine/hid.h
+++ b/include/wine/hid.h
@@ -227,4 +227,9 @@ struct hid_preparsed_data
 #define PID_USAGE_CREATE_NEW_EFFECT_REPORT         ((USAGE) 0xab)
 #define PID_USAGE_RAM_POOL_AVAILABLE               ((USAGE) 0xac)

+static inline BOOL is_logitech_g920(WORD vid, WORD pid)
+{
+    return vid == 0x046D && pid == 0xC262;
+}
+
 #endif /* __WINE_PARSE_H */
From 7c76a48943171f0def105a022860a0e198298534 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Mon, 24 Jan 2022 15:18:26 +0200
Subject: [PATCH] HACK: winebus.sys: Defer Logitech G920 to the SDL backend.

---
 dlls/winebus.sys/bus_udev.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index b40c9f3f605..47597bc0c4c 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1670,6 +1670,12 @@ static void udev_add_device(struct udev_device *dev, int fd)
         memcpy(desc.serialnumber, zeros, sizeof(zeros));
     }

+    if (is_logitech_g920(desc.vid, desc.pid))
+    {
+        TRACE("hidraw %s: deferring %s to a different backend\n", debugstr_a(devnode), debugstr_device_desc(&desc));
+        close(fd);
+        return;
+    }
     if (is_sdl_blacklisted(desc.vid, desc.pid))
     {
         /* this device is blacklisted */
From 8221592419d1e82f843c85422d069be9f0c37da7 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Tue, 18 Jan 2022 14:29:59 +0200
Subject: [PATCH] dinput: Make it possible to add hacks that override names and
 GUID of axes.

---
 dlls/dinput/joystick_hid.c | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/dlls/dinput/joystick_hid.c b/dlls/dinput/joystick_hid.c
index fe59b69a93c..f8a392eb4f9 100644
--- a/dlls/dinput/joystick_hid.c
+++ b/dlls/dinput/joystick_hid.c
@@ -532,6 +532,8 @@ static BOOL enum_objects( struct hid_joystick *impl, const DIPROPHEADER *filter,
     struct hid_collection_node *node, *node_end;
     WORD version = impl->base.dinput->dwVersion;
     BOOL ret, seen_axis[6] = {0};
+    const GUID *hack_guid;
+    const WCHAR *hack_name;
     const WCHAR *tmp;

     button_ofs += impl->caps.NumberInputValueCaps * sizeof(LONG);
@@ -551,6 +553,8 @@ static BOOL enum_objects( struct hid_joystick *impl, const DIPROPHEADER *filter,
             value_ofs += (caps->usage_max - caps->usage_min + 1) * sizeof(LONG);
         else for (j = caps->usage_min; j <= caps->usage_max; ++j)
         {
+            hack_name = NULL;
+            hack_guid = NULL;
             instance.dwOfs = value_ofs;
             switch (MAKELONG(j, caps->usage_page))
             {
@@ -597,12 +601,16 @@ static BOOL enum_objects( struct hid_joystick *impl, const DIPROPHEADER *filter,
             }
             instance.wUsagePage = caps->usage_page;
             instance.wUsage = j;
-            instance.guidType = *object_usage_to_guid( instance.wUsagePage, instance.wUsage );
+            if (hack_guid)
+                instance.guidType = *hack_guid;
+            else
+                instance.guidType = *object_usage_to_guid( instance.wUsagePage, instance.wUsage );
             instance.wReportId = caps->report_id;
             instance.wCollectionNumber = caps->link_collection;
             instance.dwDimension = caps->units;
             instance.wExponent = caps->units_exp;
-            if ((tmp = object_usage_to_string( &instance ))) lstrcpynW( instance.tszName, tmp, MAX_PATH );
+            if (hack_name) lstrcpynW( instance.tszName, hack_name, MAX_PATH );
+            else if ((tmp = object_usage_to_string( &instance ))) lstrcpynW( instance.tszName, tmp, MAX_PATH );
             else swprintf( instance.tszName, MAX_PATH, L"Unknown %u", DIDFT_GETINSTANCE( instance.dwType ) );
             check_pid_effect_axis_caps( impl, &instance );
             ret = enum_object( impl, filter, flags, callback, caps, &instance, data );
From 7de2bfee4e5bb8a315ccdb348f0cf6c63f361455 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Tue, 18 Jan 2022 14:30:46 +0200
Subject: [PATCH] dinput: Add mapping for Logitech G920.

The wheel has a custom mapping and type override on Windows that do not
correspond what dinput would create by itself basing on HID descriptors.
---
 dlls/dinput/joystick_hid.c | 39 +++++++++++++++++++++++++++++++++++++-
 1 file changed, 38 insertions(+), 1 deletion(-)

diff --git a/dlls/dinput/joystick_hid.c b/dlls/dinput/joystick_hid.c
index f8a392eb4f9..1cac074facc 100644
--- a/dlls/dinput/joystick_hid.c
+++ b/dlls/dinput/joystick_hid.c
@@ -46,6 +46,9 @@
 #include "wine/debug.h"
 #include "wine/hid.h"

+#define VID_LOGITECH 0x046D
+#define PID_LOGITECH_G920 0xC262
+
 WINE_DEFAULT_DEBUG_CHANNEL(dinput);

 DEFINE_GUID( GUID_DEVINTERFACE_WINEXINPUT,0x6c53d5fd,0x6480,0x440f,0xb6,0x18,0x47,0x67,0x50,0xc5,0xe1,0xa6 );
@@ -564,7 +567,38 @@ static BOOL enum_objects( struct hid_joystick *impl, const DIPROPHEADER *filter,
             case MAKELONG(HID_USAGE_GENERIC_RX, HID_USAGE_PAGE_GENERIC):
             case MAKELONG(HID_USAGE_GENERIC_RY, HID_USAGE_PAGE_GENERIC):
             case MAKELONG(HID_USAGE_GENERIC_RZ, HID_USAGE_PAGE_GENERIC):
-                set_axis_type( &instance, seen_axis, j - HID_USAGE_GENERIC_X, &axis );
+                if (impl->attrs.VendorID == VID_LOGITECH && impl->attrs.ProductID == PID_LOGITECH_G920)
+                {
+                    if (j == HID_USAGE_GENERIC_X)
+                    {
+                        set_axis_type( &instance, seen_axis, 0, &axis );
+                        hack_guid = &GUID_XAxis;
+                        hack_name = L"Wheel axis";
+                    }
+                    else if (j == HID_USAGE_GENERIC_Y)
+                    {
+                        set_axis_type( &instance, seen_axis, 2, &axis );
+                        hack_guid = &GUID_YAxis;
+                        hack_name = L"Accelerator";
+                    }
+                    else if (j == HID_USAGE_GENERIC_Z)
+                    {
+                        set_axis_type( &instance, seen_axis, 5, &axis );
+                        hack_guid = &GUID_RzAxis;
+                        hack_name = L"Brake";
+                    }
+                    else if (j == HID_USAGE_GENERIC_RZ)
+                    {
+                        instance.dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 6 + axis++ );
+                        hack_guid = &GUID_Slider;
+                        hack_name = L"Clutch";
+                    }
+                    else WARN("unknown axis usage page %x usage %x for Logitech G920\n", caps->usage_page, j);
+                }
+                else
+                {
+                    set_axis_type( &instance, seen_axis, j - HID_USAGE_GENERIC_X, &axis );
+                }
                 instance.dwFlags = DIDOI_ASPECTPOSITION;
                 break;
             case MAKELONG(HID_USAGE_SIMULATION_STEERING, HID_USAGE_PAGE_SIMULATION):
@@ -1550,6 +1584,9 @@ static BOOL hid_joystick_device_try_open( UINT32 handle, const WCHAR *path, HAND
             type |= (DI8DEVTYPEDRIVING_LIMITED << 8);
     }

+    if (attrs->VendorID == VID_LOGITECH && attrs->ProductID == PID_LOGITECH_G920)
+        type = DI8DEVTYPE_DRIVING | (DI8DEVTYPEDRIVING_DUALPEDALS << 8) | DIDEVTYPE_HID;
+
     instance->dwDevType = device_type_for_version( type, version );

     *device = device_file;
