From 40f9cbafbf1d7d5cfecf6d765e440ff03ce2376d Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 6 Jan 2022 14:00:35 +0300
Subject: [PATCH] winhttp: HACK: Reuse threadpool for Monster Hunter Rise.

CW-Bug-Id: #19484
---
 dlls/winhttp/main.c            |  6 ++++
 dlls/winhttp/request.c         | 64 +++++++++++++++++++++++++++++++---
 dlls/winhttp/winhttp_private.h |  1 +
 3 files changed, 67 insertions(+), 4 deletions(-)

diff --git a/dlls/winhttp/main.c b/dlls/winhttp/main.c
index 3b570fee6d5..c8de51fa85b 100644
--- a/dlls/winhttp/main.c
+++ b/dlls/winhttp/main.c
@@ -42,9 +42,15 @@ BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpv)
     switch(fdwReason)
     {
     case DLL_PROCESS_ATTACH:
+    {
+        char str[64];
+
         winhttp_instance = hInstDLL;
         DisableThreadLibraryCalls(hInstDLL);
+        if ((reuse_threadpool = GetEnvironmentVariableA( "SteamGameId", str, sizeof(str)) && !strcmp(str, "1446780" )))
+            ERR( "HACK: setting reuse_threadpool.\n" );
         break;
+    }
     case DLL_PROCESS_DETACH:
         if (lpv) break;
         netconn_unload();
diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index a2a5774d74d..ee6e2eca847 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -43,6 +43,24 @@ WINE_DEFAULT_DEBUG_CHANNEL(winhttp);

 #define DEFAULT_KEEP_ALIVE_TIMEOUT 30000

+BOOL reuse_threadpool;
+
+static struct
+{
+    TP_POOL *pool;
+    LONG ref;
+}
+thread_pool_cache;
+
+static CRITICAL_SECTION thread_pool_cache_cs;
+static CRITICAL_SECTION_DEBUG thread_pool_cache_debug =
+{
+    0, 0, &thread_pool_cache_cs,
+    { &thread_pool_cache_debug.ProcessLocksList, &thread_pool_cache_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": thread_pool_cache_cs") }
+};
+static CRITICAL_SECTION thread_pool_cache_cs = { &thread_pool_cache_debug, -1, 0, 0, 0, 0 };
+
 static const WCHAR *attribute_table[] =
 {
     L"Mime-Version",                /* WINHTTP_QUERY_MIME_VERSION               = 0  */
@@ -122,13 +140,37 @@ static const WCHAR *attribute_table[] =
     NULL                            /* WINHTTP_QUERY_PASSPORT_CONFIG            = 78 */
 };

+static TP_POOL *create_thread_pool(void)
+{
+    TP_POOL *pool;
+
+    if (!(pool = CreateThreadpool( NULL ))) return NULL;
+    SetThreadpoolThreadMinimum( pool, 1 );
+    SetThreadpoolThreadMaximum( pool, 1 );
+
+    return pool;
+}
+
 static DWORD start_queue( struct queue *queue )
 {
     if (queue->pool) return ERROR_SUCCESS;

-    if (!(queue->pool = CreateThreadpool( NULL ))) return GetLastError();
-    SetThreadpoolThreadMinimum( queue->pool, 1 );
-    SetThreadpoolThreadMaximum( queue->pool, 1 );
+    if (reuse_threadpool)
+    {
+        EnterCriticalSection( &thread_pool_cache_cs );
+        if (!thread_pool_cache.pool)
+        {
+            assert( !thread_pool_cache.ref );
+            thread_pool_cache.pool = create_thread_pool();
+        }
+        ++thread_pool_cache.ref;
+        queue->pool = thread_pool_cache.pool;
+        LeaveCriticalSection( &thread_pool_cache_cs );
+    }
+    else
+    {
+        if (!(queue->pool = create_thread_pool())) return GetLastError();
+    }

     memset( &queue->env, 0, sizeof(queue->env) );
     queue->env.Version = 1;
@@ -141,7 +183,21 @@ static DWORD start_queue( struct queue *queue )
 void stop_queue( struct queue *queue )
 {
     if (!queue->pool) return;
-    CloseThreadpool( queue->pool );
+    if (reuse_threadpool)
+    {
+        EnterCriticalSection( &thread_pool_cache_cs );
+        assert(thread_pool_cache.ref);
+        if (!--thread_pool_cache.ref)
+        {
+            CloseThreadpool( thread_pool_cache.pool );
+            thread_pool_cache.pool = NULL;
+        }
+        LeaveCriticalSection( &thread_pool_cache_cs );
+    }
+    else
+    {
+        CloseThreadpool( queue->pool );
+    }
     queue->pool = NULL;
     TRACE("stopped %p\n", queue);
 }
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 53c1f2e0122..93dffe8df32 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -403,5 +403,6 @@ static inline char *strdupWA_sized( const WCHAR *src, DWORD size )
 }

 extern HINSTANCE winhttp_instance DECLSPEC_HIDDEN;
+extern BOOL reuse_threadpool DECLSPEC_HIDDEN;

 #endif /* _WINE_WINHTTP_PRIVATE_H_ */
From 0262122fc328410e6b0b410837c35881b3aa85af Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 19 Apr 2021 15:29:39 +0300
Subject: [PATCH] winevulkan: Don't hardcode performance frequency.

For Forza Horizon 4.
---
 dlls/winevulkan/loader.c    | 33 +++++++++++++++++++++++++++++++++
 dlls/winevulkan/make_vulkan |  2 +-
 2 files changed, 34 insertions(+), 1 deletion(-)

diff --git a/dlls/winevulkan/loader.c b/dlls/winevulkan/loader.c
index d3ac9f57763..fcb79983114 100644
--- a/dlls/winevulkan/loader.c
+++ b/dlls/winevulkan/loader.c
@@ -442,6 +442,39 @@ void WINAPI vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice phys_dev,
     }
 }

+VkResult WINAPI vkGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation)
+{
+    struct vkGetCalibratedTimestampsEXT_params params;
+    static LARGE_INTEGER freq;
+    VkResult res;
+    uint32_t i;
+
+    if (!freq.QuadPart)
+    {
+        LARGE_INTEGER temp;
+
+        QueryPerformanceFrequency(&temp);
+        InterlockedCompareExchange64(&freq.QuadPart, temp.QuadPart, 0);
+    }
+
+    params.device = device;
+    params.timestampCount = timestampCount;
+    params.pTimestampInfos = pTimestampInfos;
+    params.pTimestamps = pTimestamps;
+    params.pMaxDeviation = pMaxDeviation;
+    res = vk_unix_call(unix_vkGetCalibratedTimestampsEXT, &params);
+    if (res != VK_SUCCESS)
+        return res;
+
+    for (i = 0; i < timestampCount; i++)
+    {
+        if (pTimestampInfos[i].timeDomain != VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT) continue;
+        pTimestamps[i] *= freq.QuadPart / 10000000;
+    }
+
+    return VK_SUCCESS;
+}
+
 static BOOL WINAPI call_vulkan_debug_report_callback( struct wine_vk_debug_report_params *params, ULONG size )
 {
     return params->user_callback(params->flags, params->object_type, params->object_handle, params->location,
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 516c817715f..a0287c1ff09 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -254,7 +254,7 @@ FUNCTION_OVERRIDES = {

     # VK_EXT_calibrated_timestamps
     "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
-    "vkGetCalibratedTimestampsEXT" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkGetCalibratedTimestampsEXT" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},

     # VK_EXT_debug_utils
     "vkCreateDebugUtilsMessengerEXT" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
From 045a694d11b3acca3ef566f8ccba41b8376a9ce7 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 29 Oct 2019 09:16:37 -0500
Subject: [PATCH] setupapi: Support DICGF_PRESENT when looking for devices

---
 dlls/setupapi/devinst.c | 83 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 81 insertions(+), 2 deletions(-)

diff --git a/dlls/setupapi/devinst.c b/dlls/setupapi/devinst.c
index ecc0b58ca5c..aea0e605f1d 100644
--- a/dlls/setupapi/devinst.c
+++ b/dlls/setupapi/devinst.c
@@ -103,6 +103,7 @@ static const WCHAR Linked[] = {'L','i','n','k','e','d',0};
 static const WCHAR dotInterfaces[] = {'.','I','n','t','e','r','f','a','c','e','s',0};
 static const WCHAR AddInterface[] = {'A','d','d','I','n','t','e','r','f','a','c','e',0};
 static const WCHAR backslashW[] = {'\\',0};
+static const WCHAR hashW[] = {'#',0};
 static const WCHAR emptyW[] = {0};

 #define SERVICE_CONTROL_REENUMERATE_ROOT_DEVICES 128
@@ -318,7 +319,6 @@ static WCHAR *get_iface_key_path(struct device_iface *iface)

 static WCHAR *get_refstr_key_path(struct device_iface *iface)
 {
-    static const WCHAR hashW[] = {'#',0};
     static const WCHAR slashW[] = {'\\',0};
     WCHAR *path, *ptr;
     size_t len = lstrlenW(DeviceClasses) + 1 + 38 + 1 + lstrlenW(iface->symlink) + 1 + 1;
@@ -2423,6 +2423,80 @@ static void SETUPDI_EnumerateInterfaces(HDEVINFO DeviceInfoSet,
     }
 }

+
+/* iterate over all interfaces supported by this device instance. if any of
+ * them are "linked", return TRUE */
+static BOOL is_device_instance_linked(HKEY interfacesKey, const WCHAR *deviceInstance)
+{
+    LONG l;
+    DWORD class_idx = 0, device_idx, len, type;
+    HKEY class_key, device_key, link_key;
+    WCHAR class_keyname[40], device_keyname[MAX_DEVICE_ID_LEN];
+    WCHAR interface_devinstance[MAX_DEVICE_ID_LEN];
+
+    while (1)
+    {
+        len = ARRAY_SIZE(class_keyname);
+        l = RegEnumKeyExW(interfacesKey, class_idx++, class_keyname, &len, NULL, NULL, NULL, NULL);
+        if (l)
+            break;
+
+        l = RegOpenKeyExW(interfacesKey, class_keyname, 0, KEY_READ, &class_key);
+        if (l)
+            continue;
+
+        device_idx = 0;
+        while (1)
+        {
+            len = ARRAY_SIZE(device_keyname);
+            l = RegEnumKeyExW(class_key, device_idx++, device_keyname, &len, NULL, NULL, NULL, NULL);
+            if (l)
+                break;
+
+            l = RegOpenKeyExW(class_key, device_keyname, 0, KEY_READ, &device_key);
+            if (l)
+                continue;
+
+            len = ARRAY_SIZE(interface_devinstance);
+            l = RegQueryValueExW(device_key, DeviceInstance, NULL, &type, (BYTE *)interface_devinstance, &len);
+            if (l || type != REG_SZ)
+            {
+                RegCloseKey(device_key);
+                continue;
+            }
+
+            if (lstrcmpiW(interface_devinstance, deviceInstance))
+            {
+                /* not our device instance */
+                RegCloseKey(device_key);
+                continue;
+            }
+
+            l = RegOpenKeyExW(device_key, hashW, 0, KEY_READ, &link_key);
+            if (l)
+            {
+                RegCloseKey(device_key);
+                continue;
+            }
+
+            if (is_linked(link_key))
+            {
+                RegCloseKey(link_key);
+                RegCloseKey(device_key);
+                RegCloseKey(class_key);
+                return TRUE;
+            }
+
+            RegCloseKey(link_key);
+            RegCloseKey(device_key);
+        }
+
+        RegCloseKey(class_key);
+    }
+
+    return FALSE;
+}
+
 static void SETUPDI_EnumerateMatchingDeviceInstances(struct DeviceInfoSet *set,
         LPCWSTR enumerator, LPCWSTR deviceName, HKEY deviceKey,
         const GUID *class, DWORD flags)
@@ -2431,6 +2505,7 @@ static void SETUPDI_EnumerateMatchingDeviceInstances(struct DeviceInfoSet *set,
     DWORD i, len;
     WCHAR deviceInstance[MAX_PATH];
     LONG l = ERROR_SUCCESS;
+    HKEY interfacesKey = SetupDiOpenClassRegKeyExW(NULL, KEY_READ, DIOCR_INTERFACE, NULL, NULL);

     TRACE("%s %s\n", debugstr_w(enumerator), debugstr_w(deviceName));

@@ -2467,7 +2542,9 @@ static void SETUPDI_EnumerateMatchingDeviceInstances(struct DeviceInfoSet *set,
                              {'%','s','\\','%','s','\\','%','s',0};

                             if (swprintf(id, ARRAY_SIZE(id), fmt, enumerator,
-                                    deviceName, deviceInstance) != -1)
+                                        deviceName, deviceInstance) != -1 &&
+                                    (!(flags & DIGCF_PRESENT) ||
+                                     is_device_instance_linked(interfacesKey, id)))
                             {
                                 create_device(set, &deviceClass, id, FALSE);
                             }
@@ -2480,6 +2557,8 @@ static void SETUPDI_EnumerateMatchingDeviceInstances(struct DeviceInfoSet *set,
             l = ERROR_SUCCESS;
         }
     }
+
+    RegCloseKey(interfacesKey);
 }

 static void SETUPDI_EnumerateMatchingDevices(HDEVINFO DeviceInfoSet,
From 16b32c4ff36fa8d8801fe0e1afb26be70ecc9b1c Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 18 Jun 2018 07:56:35 -0500
Subject: [PATCH] ntdll: Notice THREADNAME_INFO exceptions and set thread name
 on Linux

Patch by Zeb.
---
 dlls/ntdll/unix/thread.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 86811594d81..039bfeb0a86 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -57,6 +57,9 @@
 #ifdef HAVE_LIBPROCSTAT_H
 #include <libprocstat.h>
 #endif
+#ifdef HAVE_PRCTL
+#include <sys/prctl.h>
+#endif

 #define NONAMELESSUNION
 #define NONAMELESSSTRUCT
@@ -1440,6 +1443,16 @@ void wait_suspend( CONTEXT *context )
 }


+/* "How to: Set a Thread Name in Native Code"
+ * https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx */
+typedef struct tagTHREADNAME_INFO
+{
+   DWORD   dwType;     /* Must be 0x1000 */
+   LPCSTR  szName;     /* Pointer to name - limited to 9 bytes (8 characters + terminator) */
+   DWORD   dwThreadID; /* Thread ID (-1 = caller thread) */
+   DWORD   dwFlags;    /* Reserved for future use.  Must be zero. */
+} THREADNAME_INFO;
+
 /**********************************************************************
  *           send_debug_event
  *
@@ -1461,6 +1474,21 @@ NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_c
     for (i = 0; i < min( rec->NumberParameters, EXCEPTION_MAXIMUM_PARAMETERS ); i++)
         params[i] = rec->ExceptionInformation[i];

+    if (rec->ExceptionCode == 0x406d1388)
+    {
+        const THREADNAME_INFO *threadname = (const THREADNAME_INFO *)rec->ExceptionInformation;
+
+        if (threadname->dwThreadID == -1)
+        {
+#ifdef HAVE_PRCTL
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+            prctl( PR_SET_NAME, threadname->szName );
+#endif
+        }
+    }
+
     SERVER_START_REQ( queue_exception_event )
     {
         req->first   = first_chance;
From 0e5c03061868da894886f5dc940e1c24a9209fba Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 2 Nov 2020 13:21:49 +0100
Subject: [PATCH] wine/server: Add traces for client requests.

---
 include/wine/server.h | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/include/wine/server.h b/include/wine/server.h
index 57bcdbbb00d..5b533b48714 100644
--- a/include/wine/server.h
+++ b/include/wine/server.h
@@ -26,6 +26,7 @@
 #include <winbase.h>
 #include <winternl.h>
 #include <wine/server_protocol.h>
+#include <wine/debug.h>

 /* client communication functions */

@@ -123,6 +124,8 @@ static inline void *wine_server_get_ptr( client_ptr_t ptr )

 #define SERVER_START_REQ(type) \
     do { \
+        WINE_DECLARE_DEBUG_CHANNEL(client); \
+        static const char *const __req_name = #type; \
         struct __server_request_info __req; \
         struct type##_request * const req = &__req.u.req.type##_request; \
         const struct type##_reply * const reply = &__req.u.reply.type##_reply; \
@@ -130,10 +133,12 @@ static inline void *wine_server_get_ptr( client_ptr_t ptr )
         __req.u.req.request_header.req = REQ_##type; \
         __req.data_count = 0; \
         (void)reply; \
+        TRACE_(client)("%s start\n", __req_name); \
         do

 #define SERVER_END_REQ \
         while(0); \
+        TRACE_(client)("%s end\n", __req_name); \
     } while(0)


From c9dd827b315ba9394020ec65c161096ce3e968e8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 2 Nov 2020 13:32:07 +0100
Subject: [PATCH] ntdll: Add +microsecs channel for precise timestamps.

---
 dlls/ntdll/thread.c     | 10 +++++++++-
 dlls/ntdll/unix/debug.c | 10 +++++++++-
 dlls/winecrt0/debug.c   | 12 +++++++++++-
 3 files changed, 29 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index fc9055ca09f..5fc956b1dc4 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -36,6 +36,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(thread);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
 WINE_DECLARE_DEBUG_CHANNEL(pid);
 WINE_DECLARE_DEBUG_CHANNEL(timestamp);
+WINE_DECLARE_DEBUG_CHANNEL(microsecs);

 struct _KUSER_SHARED_DATA *user_shared_data = (void *)0x7ffe0000;

@@ -143,7 +144,14 @@ int __cdecl __wine_dbg_header( enum __wine_debug_class cls, struct __wine_debug_
     /* only print header if we are at the beginning of the line */
     if (info->out_pos) return 0;

-    if (TRACE_ON(timestamp))
+    if (TRACE_ON(microsecs))
+    {
+        LARGE_INTEGER counter, frequency, microsecs;
+        NtQueryPerformanceCounter(&counter, &frequency);
+        microsecs.QuadPart = counter.QuadPart * 1000000 / frequency.QuadPart;
+        pos += sprintf( pos, "%3u.%06u:", (unsigned int)(microsecs.QuadPart / 1000000), (unsigned int)(microsecs.QuadPart % 1000000) );
+    }
+    else if (TRACE_ON(timestamp))
     {
         ULONG ticks = NtGetTickCount();
         pos += sprintf( pos, "%3u.%03u:", ticks / 1000, ticks % 1000 );
diff --git a/dlls/ntdll/unix/debug.c b/dlls/ntdll/unix/debug.c
index 250c2d19c8e..66bdb3ca2e3 100644
--- a/dlls/ntdll/unix/debug.c
+++ b/dlls/ntdll/unix/debug.c
@@ -44,6 +44,7 @@

 WINE_DECLARE_DEBUG_CHANNEL(pid);
 WINE_DECLARE_DEBUG_CHANNEL(timestamp);
+WINE_DECLARE_DEBUG_CHANNEL(microsecs);
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);

 struct debug_info
@@ -297,7 +298,14 @@ int __cdecl __wine_dbg_header( enum __wine_debug_class cls, struct __wine_debug_

     if (init_done)
     {
-        if (TRACE_ON(timestamp))
+        if (TRACE_ON(microsecs))
+        {
+            LARGE_INTEGER counter, frequency, microsecs;
+            NtQueryPerformanceCounter(&counter, &frequency);
+            microsecs.QuadPart = counter.QuadPart * 1000000 / frequency.QuadPart;
+            pos += sprintf( pos, "%3u.%06u:", (unsigned int)(microsecs.QuadPart / 1000000), (unsigned int)(microsecs.QuadPart % 1000000) );
+        }
+        else if (TRACE_ON(timestamp))
         {
             ULONG ticks = NtGetTickCount();
             pos += sprintf( pos, "%3u.%03u:", ticks / 1000, ticks % 1000 );
diff --git a/dlls/winecrt0/debug.c b/dlls/winecrt0/debug.c
index 14f3d2d3773..0ac5caa4b9c 100644
--- a/dlls/winecrt0/debug.c
+++ b/dlls/winecrt0/debug.c
@@ -30,6 +30,7 @@

 WINE_DECLARE_DEBUG_CHANNEL(pid);
 WINE_DECLARE_DEBUG_CHANNEL(timestamp);
+WINE_DECLARE_DEBUG_CHANNEL(microsecs);

 static const char * (__cdecl *p__wine_dbg_strdup)( const char *str );
 static int (__cdecl *p__wine_dbg_output)( const char *str );
@@ -189,7 +190,16 @@ static int __cdecl fallback__wine_dbg_header( enum __wine_debug_class cls,
     /* skip header if partial line and no other thread came in between */
     if (partial_line_tid == GetCurrentThreadId()) return 0;

-    if (TRACE_ON(timestamp))
+    if (TRACE_ON(microsecs))
+    {
+        static LARGE_INTEGER frequency;
+        LARGE_INTEGER counter, microsecs;
+        if (!frequency.QuadPart) QueryPerformanceFrequency(&frequency);
+        QueryPerformanceCounter(&counter);
+        microsecs.QuadPart = counter.QuadPart * 1000000 / frequency.QuadPart;
+        pos += sprintf( pos, "%3u.%06u:", (unsigned int)(microsecs.QuadPart / 1000000), (unsigned int)(microsecs.QuadPart % 1000000) );
+    }
+    else if (TRACE_ON(timestamp))
     {
         ULONG ticks = GetTickCount();
         pos += sprintf( pos, "%3u.%03u:", ticks / 1000, ticks % 1000 );
From eac035c702984574a3d8920acb102a0be71b72a4 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 11 Sep 2020 17:55:59 +1000
Subject: [PATCH] include: Remove interfaces already define in msxml6.idl

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/msxml3/factory.c         |   1 +
 dlls/msxml3/tests/saxreader.c |   1 +
 dlls/msxml3/tests/schema.c    |   5 ++
 dlls/msxml3/uuid.c            |  11 ++++
 include/msxml2.idl            | 109 ----------------------------------
 include/msxml6.idl            |  24 ++++----
 6 files changed, 30 insertions(+), 121 deletions(-)

diff --git a/dlls/msxml3/factory.c b/dlls/msxml3/factory.c
index b8c8281063a..34aa3bc4e23 100644
--- a/dlls/msxml3/factory.c
+++ b/dlls/msxml3/factory.c
@@ -31,6 +31,7 @@
 #include "ole2.h"
 #include "msxml.h"
 #include "msxml2.h"
+#include "msxml6.h"
 #include "xmlparser.h"

 /* undef the #define in msxml2 so that we can access the v.2 version
diff --git a/dlls/msxml3/tests/saxreader.c b/dlls/msxml3/tests/saxreader.c
index 20c5e07443b..d998a0805d7 100644
--- a/dlls/msxml3/tests/saxreader.c
+++ b/dlls/msxml3/tests/saxreader.c
@@ -29,6 +29,7 @@
 #include "windows.h"
 #include "ole2.h"
 #include "msxml2.h"
+#include "msxml6.h"
 #include "msxml2did.h"
 #include "ocidl.h"
 #include "dispex.h"
diff --git a/dlls/msxml3/tests/schema.c b/dlls/msxml3/tests/schema.c
index 4cdfedf9c29..219d7144ddb 100644
--- a/dlls/msxml3/tests/schema.c
+++ b/dlls/msxml3/tests/schema.c
@@ -32,6 +32,11 @@
 #include "dispex.h"
 #include "cguid.h"

+DEFINE_GUID(CLSID_MXXMLWriter60, 0x88d96a0f, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_SAXAttributes60, 0x88d96a0e, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_SAXXMLReader60, 0x88d96a0c, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_XMLSchemaCache60, 0x88d96a07, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+
 #include "wine/test.h"

 #define EXPECT_HR(hr,hr_exp) \
diff --git a/dlls/msxml3/uuid.c b/dlls/msxml3/uuid.c
index 4abbe5e4763..333d4f3d3c7 100644
--- a/dlls/msxml3/uuid.c
+++ b/dlls/msxml3/uuid.c
@@ -41,6 +41,17 @@
 #include "initguid.h"
 #include "msxml2.h"

+/* Cannot include msxml6 here since we will get a duplicate LIBID_MSXML2 error.  */
+DEFINE_GUID(CLSID_FreeThreadedDOMDocument60, 0x88d96a06, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_MXNamespaceManager60, 0x88d96a11, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_MXXMLWriter60, 0x88d96a0f, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_SAXAttributes60, 0x88d96a0e, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_SAXXMLReader60, 0x88d96a0c, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_ServerXMLHTTP60, 0x88d96a0b, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_XMLHTTP60, 0x88d96a0a, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_XMLSchemaCache60, 0x88d96a07, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_XSLTemplate60, 0x88d96a08, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+
 /*
  * Note that because of a #define in msxml2.h, we end up initializing
  * CLSID_DOMDocument2 to be the v.3 version independent DOMDocument
diff --git a/include/msxml2.idl b/include/msxml2.idl
index 916e0e8ab3d..1d1ba7a5248 100644
--- a/include/msxml2.idl
+++ b/include/msxml2.idl
@@ -1612,15 +1612,6 @@ coclass FreeThreadedDOMDocument40
     [default, source] dispinterface XMLDOMDocumentEvents;
 }

-[
-    uuid(88d96a06-f192-11d4-a65f-0040963251e5),
-]
-coclass FreeThreadedDOMDocument60
-{
-    [default] interface IXMLDOMDocument3;
-    [default, source] dispinterface XMLDOMDocumentEvents;
-}
-
 [
     helpstring("Free threaded XML DOM Document"),
     progid("Msxml2.FreeThreadedDOMDocument"),
@@ -1662,14 +1653,6 @@ coclass XMLHTTP40
     [default] interface IXMLHTTPRequest;
 }

-[
-    uuid(88d96a0a-f192-11d4-a65f-0040963251e5)
-]
-coclass XMLHTTP60
-{
-    [default] interface IXMLHTTPRequest;
-}
-
 [
     helpstring("XML HTTP"),
     progid("Msxml2.XMLHTTP"),
@@ -1702,14 +1685,6 @@ coclass ServerXMLHTTP40
     [default] interface IServerXMLHTTPRequest2;
 }

-[
-    uuid(88d96a0b-f192-11d4-a65f-0040963251e5)
-]
-coclass ServerXMLHTTP60
-{
-    [default] interface IServerXMLHTTPRequest2;
-}
-
 [
     helpstring("Server XML HTTP"),
     progid("Msxml2.ServerXMLHTTP"),
@@ -1750,14 +1725,6 @@ coclass XMLSchemaCache40
     [default] interface IXMLDOMSchemaCollection2;
 }

-[
-    uuid(88d96a07-f192-11d4-a65f-0040963251e5)
-]
-coclass XMLSchemaCache60
-{
-    [default] interface IXMLDOMSchemaCollection2;
-}
-
 [
     helpstring("XML Schema Cache"),
     progid("Msxml2.XMLSchemaCache"),
@@ -1798,14 +1765,6 @@ coclass XSLTemplate40
     [default] interface IXSLTemplate;
 }

-[
-    uuid(88d96a08-f192-11d4-a65f-0040963251e5)
-]
-coclass XSLTemplate60
-{
-    [default] interface IXSLTemplate;
-}
-
 [
     helpstring("XSL Template"),
     progid("Msxml2.XSLTemplate"),
@@ -3297,15 +3256,6 @@ coclass SAXXMLReader40
     interface ISAXXMLReader;
 }

-[
-    uuid(88d96a0c-f192-11d4-a65f-0040963251e5)
-]
-coclass SAXXMLReader60
-{
-    [default] interface IVBSAXXMLReader;
-    interface ISAXXMLReader;
-}
-
 [
     helpstring("SAX XML Reader"),
     progid("Msxml2.SAXXMLReader"),
@@ -3380,26 +3330,6 @@ coclass MXHTMLWriter40
     interface IVBSAXLexicalHandler;
 }

-[
-    uuid(88d96a10-f192-11d4-a65f-0040963251e5)
-]
-coclass MXHTMLWriter60
-{
-    [default] interface IMXWriter;
-
-    interface ISAXContentHandler;
-    interface ISAXDeclHandler;
-    interface ISAXDTDHandler;
-    interface ISAXErrorHandler;
-    interface ISAXLexicalHandler;
-
-    interface IVBSAXContentHandler;
-    interface IVBSAXDeclHandler;
-    interface IVBSAXDTDHandler;
-    interface IVBSAXErrorHandler;
-    interface IVBSAXLexicalHandler;
-}
-
 [
     helpstring("MXXMLWriter 3.0"),
     progid("Msxml2.MXXMLWriter.3.0"),
@@ -3444,26 +3374,6 @@ coclass MXXMLWriter40
     interface IVBSAXLexicalHandler;
 }

-[
-    uuid(88d96a0f-f192-11d4-a65f-0040963251e5)
-]
-coclass MXXMLWriter60
-{
-    [default] interface IMXWriter;
-
-    interface ISAXContentHandler;
-    interface ISAXDeclHandler;
-    interface ISAXDTDHandler;
-    interface ISAXErrorHandler;
-    interface ISAXLexicalHandler;
-
-    interface IVBSAXContentHandler;
-    interface IVBSAXDeclHandler;
-    interface IVBSAXDTDHandler;
-    interface IVBSAXErrorHandler;
-    interface IVBSAXLexicalHandler;
-}
-
 [
     helpstring("MXXMLWriter"),
     progid("Msxml2.MXXMLWriter"),
@@ -3506,15 +3416,6 @@ coclass MXNamespaceManager40
     interface IMXNamespaceManager;
 }

-[
-    uuid(88d96a11-f192-11d4-a65f-0040963251e5)
-]
-coclass MXNamespaceManager60
-{
-    [default] interface IVBMXNamespaceManager;
-    interface IMXNamespaceManager;
-}
-
 [
     helpstring("SAXAttributes 3.0"),
     progid("Msxml2.SAXAttributes.3.0"),
@@ -3539,16 +3440,6 @@ coclass SAXAttributes40
     interface ISAXAttributes;
 }

-[
-    uuid(88d96a0e-f192-11d4-a65f-0040963251e5)
-]
-coclass SAXAttributes60
-{
-    [default] interface IMXAttributes;
-    interface IVBSAXAttributes;
-    interface ISAXAttributes;
-}
-
 [
     helpstring("SAXAttributes"),
     progid("Msxml2.SAXAttributes"),
diff --git a/include/msxml6.idl b/include/msxml6.idl
index 4948de39f1f..e6a0a5feda5 100644
--- a/include/msxml6.idl
+++ b/include/msxml6.idl
@@ -3048,18 +3048,6 @@ coclass DOMDocument60
     [default, source] dispinterface XMLDOMDocumentEvents;
 }

-[
-    helpstring("Free threaded XML DOM Document 6.0"),
-    progid("Msxml2.FreeThreadedDOMDocument.6.0"),
-    threading(both),
-    uuid(88d96a06-f192-11d4-a65f-0040963251e5),
-]
-coclass FreeThreadedDOMDocument60
-{
-    [default] interface IXMLDOMDocument3;
-    [default, source] dispinterface XMLDOMDocumentEvents;
-}
-
 [
     helpstring("SAX XML Reader 6.0"),
     progid("Msxml2.SAXXMLReader.6.0"),
@@ -3165,6 +3153,18 @@ coclass XSLTemplate60
     [default] interface IXSLTemplate;
 }

+[
+    helpstring("Free threaded XML DOM Document 6.0"),
+    progid("Msxml2.FreeThreadedDOMDocument.6.0"),
+    threading(both),
+    uuid(88d96a06-f192-11d4-a65f-0040963251e5),
+]
+coclass FreeThreadedDOMDocument60
+{
+    [default] interface IXMLDOMDocument3;
+    [default, source] dispinterface XMLDOMDocumentEvents;
+}
+
 [
     helpstring("XML HTTP 6.0"),
     progid("Msxml2.XMLHTTP.6.0"),
From 847b319c121eb100b163bc314e905a3570656739 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 8 Sep 2020 18:43:52 +0200
Subject: [PATCH] msxml3: Implement FreeThreadedXMLHTTP60.

Update from Gijs Vermeulen <gijsvrm@gmail.com>
---
 dlls/msxml3/Makefile.in     |   2 +-
 dlls/msxml3/factory.c       |   5 +
 dlls/msxml3/httprequest.c   | 496 +++++++++++++++++++++++++++++++++++-
 dlls/msxml3/msxml_private.h |   1 +
 dlls/msxml3/tests/httpreq.c | 395 +++++++++++++++++++++++++++-
 dlls/msxml3/tests/schema.c  |   6 +
 dlls/msxml3/uuid.c          |   5 +
 7 files changed, 905 insertions(+), 5 deletions(-)

diff --git a/dlls/msxml3/Makefile.in b/dlls/msxml3/Makefile.in
index 2bf789732da..e2d737599b1 100644
--- a/dlls/msxml3/Makefile.in
+++ b/dlls/msxml3/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = msxml3.dll
-IMPORTS   = $(XSLT_PE_LIBS) $(XML2_PE_LIBS) uuid urlmon shlwapi oleaut32 ole32 user32 advapi32
+IMPORTS   = $(XSLT_PE_LIBS) $(XML2_PE_LIBS) uuid urlmon shlwapi oleaut32 ole32 user32 advapi32 rtworkq
 EXTRAINCL = $(XSLT_PE_CFLAGS) $(XML2_PE_CFLAGS)

 C_SRCS = \
diff --git a/dlls/msxml3/factory.c b/dlls/msxml3/factory.c
index 34aa3bc4e23..651a6b8e9df 100644
--- a/dlls/msxml3/factory.c
+++ b/dlls/msxml3/factory.c
@@ -277,6 +277,7 @@ static HRESULT DOMClassFactory_Create(const GUID *clsid, REFIID riid, void **ppv

 static ClassFactory xmldoccf = { { &ClassFactoryVtbl }, XMLDocument_create };
 static ClassFactory httpreqcf = { { &ClassFactoryVtbl }, XMLHTTPRequest_create };
+static ClassFactory httpreqcf2 = { { &ClassFactoryVtbl }, XMLHTTPRequest2_create };
 static ClassFactory serverhttp = { { &ClassFactoryVtbl }, ServerXMLHTTP_create };
 static ClassFactory xsltemplatecf = { { &ClassFactoryVtbl }, XSLTemplate_create };
 static ClassFactory mxnsmanagercf = { {&ClassFactoryVtbl }, MXNamespaceManager_create };
@@ -338,6 +339,10 @@ HRESULT WINAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, void **ppv )
     {
         cf = &httpreqcf.IClassFactory_iface;
     }
+    else if( IsEqualCLSID( rclsid, &CLSID_FreeThreadedXMLHTTP60 ))
+    {
+        cf = &httpreqcf2.IClassFactory_iface;
+    }
     else if( IsEqualCLSID( rclsid, &CLSID_ServerXMLHTTP ) ||
              IsEqualCLSID( rclsid, &CLSID_ServerXMLHTTP30 ) ||
              IsEqualCLSID( rclsid, &CLSID_ServerXMLHTTP40 ) ||
diff --git a/dlls/msxml3/httprequest.c b/dlls/msxml3/httprequest.c
index 934d580064f..65232bbc8af 100644
--- a/dlls/msxml3/httprequest.c
+++ b/dlls/msxml3/httprequest.c
@@ -38,10 +38,12 @@
 #include "shlwapi.h"

 #include "msxml_dispex.h"
+#include "initguid.h"
+#include "rtworkq.h"

 #include "wine/debug.h"

-WINE_DEFAULT_DEBUG_CHANNEL(msxml);
+WINE_DEFAULT_DEBUG_CHANNEL(xmlhttp);

 static const WCHAR colspaceW[] = {':',' ',0};
 static const WCHAR crlfW[] = {'\r','\n',0};
@@ -2074,6 +2076,468 @@ static const struct IServerXMLHTTPRequestVtbl ServerXMLHTTPRequestVtbl =
     ServerXMLHTTPRequest_setOption
 };

+static DWORD xhr2_work_queue;
+
+struct xml_http_request_2
+{
+    httprequest req;
+    IXMLHTTPRequest3 IXMLHTTPRequest3_iface;
+    IRtwqAsyncCallback IRtwqAsyncCallback_iface;
+    IDispatch IDispatch_iface;
+
+    IXMLHTTPRequest2Callback *callback;
+    IXMLHTTPRequest3Callback *callback3;
+    ISequentialStream *response_body;
+    ISequentialStream *request_body;
+    ULONGLONG request_body_size;
+};
+
+static inline struct xml_http_request_2 *impl_from_IXMLHTTPRequest3(IXMLHTTPRequest3 *iface)
+{
+    return CONTAINING_RECORD(iface, struct xml_http_request_2, IXMLHTTPRequest3_iface);
+}
+
+static inline struct xml_http_request_2 *xml_http_request_2_from_IRtwqAsyncCallback(IRtwqAsyncCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct xml_http_request_2, IRtwqAsyncCallback_iface);
+}
+
+static inline struct xml_http_request_2 *xml_http_request_2_from_IDispatch(IDispatch *iface)
+{
+    return CONTAINING_RECORD(iface, struct xml_http_request_2, IDispatch_iface);
+}
+
+static HRESULT WINAPI xml_http_request_2_QueryInterface(IXMLHTTPRequest3 *iface, REFIID riid, void **obj)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IXMLHTTPRequest3) || IsEqualGUID(riid, &IID_IXMLHTTPRequest2)
+        || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IUnknown_AddRef((IUnknown*)*obj);
+        return S_OK;
+    }
+
+    FIXME("Unsupported interface %s\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI xml_http_request_2_AddRef(IXMLHTTPRequest3 *iface)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    ULONG ref = InterlockedIncrement(&This->req.ref);
+    TRACE("(%p)->(%u)\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI xml_http_request_2_Release(IXMLHTTPRequest3 *iface)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    ULONG ref = InterlockedDecrement(&This->req.ref);
+
+    TRACE("(%p)->(%u)\n", This, ref);
+
+    if (ref == 0)
+    {
+        /* do not call httprequest_put_onreadystatechange to avoid ref cycle */
+        This->req.sink = NULL;
+        if (This->response_body) ISequentialStream_Release(This->response_body);
+        if (This->request_body) ISequentialStream_Release(This->request_body);
+        if (This->callback3) IXMLHTTPRequest3Callback_Release(This->callback3);
+        if (This->callback) IXMLHTTPRequest2Callback_Release(This->callback);
+        heap_free(This);
+        RtwqShutdown();
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI xml_http_request_2_Open(IXMLHTTPRequest3 *iface, const WCHAR *method,
+                                              const WCHAR *url, IXMLHTTPRequest2Callback *callback,
+                                              const WCHAR *username, const WCHAR *password,
+                                              const WCHAR *proxy_username, const WCHAR *proxy_password)
+{
+    static const WCHAR accept_encoding[] = {'A','c','c','e','p','t','-','E','n','c','o','d','i','n','g',0};
+    static const WCHAR empty = 0;
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    VARIANT async_v, username_v, password_v;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s %s %p %s %s %s %s)\n", This, debugstr_w(method), debugstr_w(url), callback,
+          debugstr_w(username), debugstr_w(password), debugstr_w(proxy_username), debugstr_w(proxy_password));
+
+    if (This->callback) IXMLHTTPRequest2Callback_Release(This->callback);
+    if (This->callback3) IXMLHTTPRequest3Callback_Release(This->callback3);
+    IXMLHTTPRequest2Callback_AddRef(callback);
+    This->callback = callback;
+    if (FAILED(IXMLHTTPRequest2Callback_QueryInterface(callback, &IID_IXMLHTTPRequest3Callback, (void **)&This->callback3)))
+        This->callback3 = NULL;
+
+    if (proxy_username || proxy_password) FIXME("proxy credentials not implemented\n");
+
+    VariantInit(&async_v);
+    V_VT(&async_v) = VT_BOOL;
+    V_BOOL(&async_v) = FALSE; /* FIXME: TRUE needs a RTWQ_WINDOW_WORKQUEUE */
+
+    VariantInit(&username_v);
+    V_VT(&username_v) = VT_BSTR;
+    if (username) V_BSTR(&username_v) = SysAllocString(username);
+    else V_BSTR(&username_v) = SysAllocString(&empty);
+
+    VariantInit(&password_v);
+    V_VT(&password_v) = VT_BSTR;
+    if (password) V_BSTR(&password_v) = SysAllocString(password);
+    else V_BSTR(&password_v) = SysAllocString(&empty);
+
+    if (FAILED(hr = httprequest_open(&This->req, (BSTR)method, (BSTR)url, async_v, username_v, password_v)))
+        return hr;
+    return httprequest_setRequestHeader(&This->req, (BSTR)accept_encoding, (BSTR)&empty);
+}
+
+static HRESULT WINAPI xml_http_request_2_Send(IXMLHTTPRequest3 *iface, ISequentialStream *body, ULONGLONG body_size)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    IRtwqAsyncResult *result;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p %s)\n", This, body, wine_dbgstr_longlong( body_size ));
+
+    if (body_size)
+    {
+        ISequentialStream_AddRef(body);
+        This->request_body = body;
+        This->request_body_size = body_size;
+    }
+
+    if (FAILED(hr = RtwqCreateAsyncResult(NULL, &This->IRtwqAsyncCallback_iface, NULL, &result)))
+        return hr;
+    // IRtwqAsyncCallback_Invoke(&This->IRtwqAsyncCallback_iface, result);
+    hr = RtwqPutWorkItem(xhr2_work_queue, 0, result);
+    if (result) IRtwqAsyncResult_Release(result);
+
+    return hr;
+}
+
+static HRESULT WINAPI xml_http_request_2_Abort(IXMLHTTPRequest3 *iface)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    TRACE("(%p) stub!\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_SetCookie(IXMLHTTPRequest3 *iface, const XHR_COOKIE *cookie, DWORD *state)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%p %p) stub!\n", This, cookie, state);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_SetCustomResponseStream(IXMLHTTPRequest3 *iface, ISequentialStream *stream)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%p) stub!\n", This, stream);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_SetProperty(IXMLHTTPRequest3 *iface, XHR_PROPERTY property, ULONGLONG value)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%#x %s) stub!\n", This, property, wine_dbgstr_longlong( value ));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_SetRequestHeader(IXMLHTTPRequest3 *iface,
+                                                          const WCHAR *header, const WCHAR *value)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    TRACE("(%p)->(%s %s)\n", This, debugstr_w(header), debugstr_w(value));
+    return httprequest_setRequestHeader(&This->req, (BSTR)header, (BSTR)value);
+}
+
+static HRESULT WINAPI xml_http_request_2_GetAllResponseHeaders(IXMLHTTPRequest3 *iface, WCHAR **headers)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%p) stub!\n", This, headers);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_GetCookie(IXMLHTTPRequest3 *iface, const WCHAR *url,
+                                                   const WCHAR *name, DWORD flags,
+                                                   ULONG *cookies_count, XHR_COOKIE **cookies)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%s %s %d %p %p) stub!\n", This, debugstr_w(url), debugstr_w(name), flags, cookies_count, cookies);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_GetResponseHeader(IXMLHTTPRequest3 *iface,
+                                                           const WCHAR *header, WCHAR **value)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_w(header), value);
+
+    if (FAILED(hr = httprequest_getResponseHeader(&This->req, (BSTR)header, value)))
+        return hr;
+
+#define E_FILE_NOT_FOUND                                   _HRESULT_TYPEDEF_(0x80070002)
+
+    if (hr == S_FALSE)
+    {
+        *value = NULL;
+        return E_FILE_NOT_FOUND;
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI xml_http_request_3_SetClientCertificate(IXMLHTTPRequest3 *iface, DWORD count, const BYTE *hashes, const WCHAR *pin)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%d %p %s) stub!\n", This, count, hashes, debugstr_w(pin));
+    return E_NOTIMPL;
+}
+
+static const struct IXMLHTTPRequest3Vtbl XMLHTTPRequest3Vtbl = {
+    /* IUnknown methods */
+    xml_http_request_2_QueryInterface,
+    xml_http_request_2_AddRef,
+    xml_http_request_2_Release,
+    /* IXMLHTTPRequest2 methods */
+    xml_http_request_2_Open,
+    xml_http_request_2_Send,
+    xml_http_request_2_Abort,
+    xml_http_request_2_SetCookie,
+    xml_http_request_2_SetCustomResponseStream,
+    xml_http_request_2_SetProperty,
+    xml_http_request_2_SetRequestHeader,
+    xml_http_request_2_GetAllResponseHeaders,
+    xml_http_request_2_GetCookie,
+    xml_http_request_2_GetResponseHeader,
+    /* IXMLHTTPRequest3 methods */
+    xml_http_request_3_SetClientCertificate,
+};
+
+static HRESULT WINAPI xml_http_request_2_IRtwqAsyncCallback_QueryInterface(IRtwqAsyncCallback *iface, REFIID riid, void **obj)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IRtwqAsyncCallback(iface);
+    TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IRtwqAsyncCallback) || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        IRtwqAsyncCallback_AddRef(iface);
+        *obj = iface;
+        return S_OK;
+    }
+
+    FIXME("Unsupported interface %s\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI xml_http_request_2_IRtwqAsyncCallback_AddRef(IRtwqAsyncCallback *iface)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IRtwqAsyncCallback(iface);
+    TRACE("(%p)\n", This);
+    return xml_http_request_2_AddRef(&This->IXMLHTTPRequest3_iface);
+}
+
+static ULONG WINAPI xml_http_request_2_IRtwqAsyncCallback_Release(IRtwqAsyncCallback *iface)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IRtwqAsyncCallback(iface);
+    TRACE("(%p)\n", This);
+    return xml_http_request_2_Release(&This->IXMLHTTPRequest3_iface);
+}
+
+static HRESULT WINAPI xml_http_request_2_IRtwqAsyncCallback_GetParameters(IRtwqAsyncCallback *iface,
+        DWORD *flags, DWORD *queue)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IRtwqAsyncCallback(iface);
+
+    TRACE("(%p)->(%p %p)\n", This, flags, queue);
+
+    *flags = 0;
+    *queue = xhr2_work_queue;
+    return S_OK;
+}
+
+static HRESULT WINAPI xml_http_request_2_IRtwqAsyncCallback_Invoke(IRtwqAsyncCallback *iface,
+        IRtwqAsyncResult *result)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IRtwqAsyncCallback(iface);
+    VARIANT body_v;
+    HRESULT hr;
+    ULONG read;
+
+    TRACE("(%p)->(%p)\n", This, result);
+
+    VariantInit(&body_v);
+
+    if (This->request_body)
+    {
+        V_VT(&body_v) = VT_BSTR;
+        V_BSTR(&body_v) = CoTaskMemAlloc(This->request_body_size);
+
+        if (FAILED(hr = ISequentialStream_Read(This->request_body, V_BSTR(&body_v), This->request_body_size, &read)) ||
+            read < This->request_body_size)
+        {
+            ERR("Failed to allocate request body memory, hr %#x\n", hr);
+            CoTaskMemFree(V_BSTR(&body_v));
+            goto done;
+        }
+
+        ISequentialStream_Release(This->request_body);
+        This->request_body = NULL;
+    }
+
+    hr = httprequest_send(&This->req, body_v);
+
+done:
+    return IRtwqAsyncResult_SetStatus(result, hr);
+}
+
+static const struct IRtwqAsyncCallbackVtbl xml_http_request_2_IRtwqAsyncCallbackVtbl = {
+    /* IUnknown methods */
+    xml_http_request_2_IRtwqAsyncCallback_QueryInterface,
+    xml_http_request_2_IRtwqAsyncCallback_AddRef,
+    xml_http_request_2_IRtwqAsyncCallback_Release,
+    /* IRtwqAsyncCallback methods */
+    xml_http_request_2_IRtwqAsyncCallback_GetParameters,
+    xml_http_request_2_IRtwqAsyncCallback_Invoke,
+};
+
+static HRESULT WINAPI xml_http_request_2_IDispatch_QueryInterface(IDispatch *iface, REFIID riid, void **obj)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IDispatch) || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        IDispatch_AddRef(iface);
+        *obj = iface;
+        return S_OK;
+    }
+
+    FIXME("Unsupported interface %s\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI xml_http_request_2_IDispatch_AddRef(IDispatch *iface)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    TRACE("(%p)\n", This);
+    return xml_http_request_2_AddRef(&This->IXMLHTTPRequest3_iface);
+}
+
+static ULONG WINAPI xml_http_request_2_IDispatch_Release(IDispatch *iface)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    TRACE("(%p)\n", This);
+    return xml_http_request_2_Release(&This->IXMLHTTPRequest3_iface);
+}
+
+static HRESULT WINAPI xml_http_request_2_IDispatch_GetTypeInfoCount(IDispatch *iface, UINT *value)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    FIXME("(%p)->(%p) stub!\n", This, value);
+    *value = 0;
+    return S_OK;
+}
+
+static HRESULT WINAPI xml_http_request_2_IDispatch_GetTypeInfo(IDispatch *iface, UINT index,
+                                                               LCID lcid, ITypeInfo **value)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    FIXME("(%p)->(%d %u %p) stub!\n", This, index, lcid, value);
+    *value = NULL;
+    return S_OK;
+}
+
+static HRESULT WINAPI xml_http_request_2_IDispatch_GetIDsOfNames(IDispatch *iface, REFIID riid,
+                                                                 OLECHAR **names, UINT names_count,
+                                                                 LCID lcid, DISPID *disp_ids)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    FIXME("(%p)->(%s %p %d %u %p) stub!\n", This, debugstr_guid(riid), names, names_count, lcid, disp_ids);
+    return S_OK;
+}
+
+static HRESULT WINAPI xml_http_request_2_IDispatch_Invoke(IDispatch *iface, DISPID id, REFIID riid,
+                                                          LCID lcid, WORD flags, DISPPARAMS *params,
+                                                          VARIANT *result, EXCEPINFO *exception, UINT *arg_err)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    IXMLHTTPRequest2 *xhr2_iface = (IXMLHTTPRequest2*)&This->IXMLHTTPRequest3_iface;
+    HRESULT hr;
+    LONG status;
+    BSTR status_str = NULL;
+
+    TRACE("(%p)->(%d %s %u %d %p %p %p %p) stub!\n", This, id, debugstr_guid(riid), lcid, flags,
+          params, result, exception, arg_err);
+
+    if (This->req.state == READYSTATE_COMPLETE)
+    {
+        VARIANT body_v;
+        VariantInit(&body_v);
+
+        IXMLHTTPRequest2Callback_AddRef(This->callback);
+        if (This->callback3)
+        {
+            IXMLHTTPRequest3Callback_AddRef(This->callback3);
+            IXMLHTTPRequest3Callback_OnServerCertificateReceived(This->callback3, (IXMLHTTPRequest3 *)xhr2_iface, 0, 1, NULL);
+            IXMLHTTPRequest3Callback_Release(This->callback3);
+        }
+
+        if (FAILED(hr = httprequest_get_status(&This->req, &status)) ||
+            FAILED(hr = httprequest_get_statusText(&This->req, &status_str)))
+        {
+            WARN("failed to get response status, error %#x\n", hr);
+            IXMLHTTPRequest2Callback_OnError(This->callback, xhr2_iface, hr);
+            IXMLHTTPRequest2Callback_Release(This->callback);
+            return S_OK;
+        }
+
+        IXMLHTTPRequest2Callback_OnHeadersAvailable(This->callback, xhr2_iface, status, status_str);
+        SysFreeString(status_str);
+
+        if (This->response_body) ISequentialStream_Release(This->response_body);
+        This->response_body = NULL;
+
+        if (FAILED(hr = httprequest_get_responseStream(&This->req, &body_v)) ||
+            FAILED(hr = IUnknown_QueryInterface(V_UNKNOWN(&body_v), &IID_ISequentialStream, (void **)&This->response_body)))
+        {
+            WARN("failed to get response stream, error %#x\n", hr);
+            IXMLHTTPRequest2Callback_OnError(This->callback, xhr2_iface, hr);
+            IXMLHTTPRequest2Callback_Release(This->callback);
+            return S_OK;
+        }
+
+        IXMLHTTPRequest2Callback_OnDataAvailable(This->callback, xhr2_iface, This->response_body);
+        IXMLHTTPRequest2Callback_OnResponseReceived(This->callback, xhr2_iface, This->response_body);
+        IXMLHTTPRequest2Callback_Release(This->callback);
+    }
+
+    return S_OK;
+}
+
+static const struct IDispatchVtbl xml_http_request_2_IDispatchVtbl = {
+    /* IUnknown methods */
+    xml_http_request_2_IDispatch_QueryInterface,
+    xml_http_request_2_IDispatch_AddRef,
+    xml_http_request_2_IDispatch_Release,
+    /* IDispatch methods */
+    xml_http_request_2_IDispatch_GetTypeInfoCount,
+    xml_http_request_2_IDispatch_GetTypeInfo,
+    xml_http_request_2_IDispatch_GetIDsOfNames,
+    xml_http_request_2_IDispatch_Invoke,
+};
+
 static void init_httprequest(httprequest *req)
 {
     req->IXMLHTTPRequest_iface.lpVtbl = &XMLHTTPRequestVtbl;
@@ -2123,6 +2587,35 @@ HRESULT XMLHTTPRequest_create(void **obj)
     return S_OK;
 }

+HRESULT XMLHTTPRequest2_create(void **obj)
+{
+    struct xml_http_request_2 *xhr2;
+    TRACE("(%p)\n", obj);
+
+    if (!(xhr2 = heap_alloc(sizeof(*xhr2)))) return E_OUTOFMEMORY;
+
+    init_httprequest(&xhr2->req);
+    xhr2->IXMLHTTPRequest3_iface.lpVtbl = &XMLHTTPRequest3Vtbl;
+    xhr2->IRtwqAsyncCallback_iface.lpVtbl = &xml_http_request_2_IRtwqAsyncCallbackVtbl;
+    xhr2->IDispatch_iface.lpVtbl = &xml_http_request_2_IDispatchVtbl;
+
+    /* do not call httprequest_put_onreadystatechange to avoid ref cycle */
+    xhr2->req.sink = &xhr2->IDispatch_iface;
+
+    xhr2->callback = NULL;
+    xhr2->callback3 = NULL;
+    xhr2->request_body = NULL;
+    xhr2->response_body = NULL;
+
+    /* for async http requests we need window message queue */
+    RtwqStartup();
+    if (!xhr2_work_queue) RtwqAllocateWorkQueue(RTWQ_MULTITHREADED_WORKQUEUE, &xhr2_work_queue);
+
+    *obj = &xhr2->IXMLHTTPRequest3_iface;
+    TRACE("returning iface %p\n", *obj);
+    return S_OK;
+}
+
 HRESULT ServerXMLHTTP_create(void **obj)
 {
     serverhttp *req;
@@ -2142,3 +2635,4 @@ HRESULT ServerXMLHTTP_create(void **obj)

     return S_OK;
 }
+
diff --git a/dlls/msxml3/msxml_private.h b/dlls/msxml3/msxml_private.h
index 8003c1a9650..59b8c29845d 100644
--- a/dlls/msxml3/msxml_private.h
+++ b/dlls/msxml3/msxml_private.h
@@ -367,6 +367,7 @@ extern HRESULT XMLDocument_create(void**) DECLSPEC_HIDDEN;
 extern HRESULT SAXXMLReader_create(MSXML_VERSION, void**) DECLSPEC_HIDDEN;
 extern HRESULT SAXAttributes_create(MSXML_VERSION, void**) DECLSPEC_HIDDEN;
 extern HRESULT XMLHTTPRequest_create(void **) DECLSPEC_HIDDEN;
+extern HRESULT XMLHTTPRequest2_create(void **) DECLSPEC_HIDDEN;
 extern HRESULT ServerXMLHTTP_create(void **) DECLSPEC_HIDDEN;
 extern HRESULT XSLTemplate_create(void**) DECLSPEC_HIDDEN;
 extern HRESULT MXWriter_create(MSXML_VERSION, void**) DECLSPEC_HIDDEN;
diff --git a/dlls/msxml3/tests/httpreq.c b/dlls/msxml3/tests/httpreq.c
index 2491e499638..511c2b26763 100644
--- a/dlls/msxml3/tests/httpreq.c
+++ b/dlls/msxml3/tests/httpreq.c
@@ -26,9 +26,9 @@
 #include <assert.h>

 #include "windows.h"
-
 #include "msxml2.h"
-#include "msxml2did.h"
+#include "msxml6.h"
+#include "msxml6did.h"
 #include "dispex.h"

 #include "initguid.h"
@@ -1348,6 +1348,17 @@ static IXMLHttpRequest *create_xhr(void)
     return SUCCEEDED(hr) ? ret : NULL;
 }

+static IXMLHTTPRequest2 *create_xhr2(void)
+{
+    IXMLHTTPRequest2 *ret;
+    HRESULT hr;
+
+    hr = CoCreateInstance(&CLSID_FreeThreadedXMLHTTP60, NULL, CLSCTX_INPROC_SERVER,
+        &IID_IXMLHTTPRequest2, (void**)&ret);
+
+    return SUCCEEDED(hr) ? ret : NULL;
+}
+
 static IServerXMLHTTPRequest *create_server_xhr(void)
 {
     IServerXMLHTTPRequest *ret;
@@ -1908,11 +1919,388 @@ static void test_supporterrorinfo(void)
     IServerXMLHTTPRequest_Release(server_xhr);
 }

+struct xhr3_callback
+{
+    IXMLHTTPRequest3Callback IXMLHTTPRequest3Callback_iface;
+    LONG ref;
+    HANDLE event;
+};
+
+static inline struct xhr3_callback *xhr3_callback_from_IXMLHTTPRequest3Callback(IXMLHTTPRequest3Callback *iface)
+{
+    return CONTAINING_RECORD(iface, struct xhr3_callback, IXMLHTTPRequest3Callback_iface);
+}
+
+static HRESULT WINAPI xhr3_callback_QueryInterface(IXMLHTTPRequest3Callback *iface, REFIID riid, void **obj)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IXMLHTTPRequest3Callback) || IsEqualGUID(riid, &IID_IXMLHTTPRequest2Callback) || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        IXMLHTTPRequest3Callback_AddRef(iface);
+        *obj = iface;
+        return S_OK;
+    }
+
+    ok(0, "unexpected interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI xhr3_callback_AddRef(IXMLHTTPRequest3Callback *iface)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    trace("(%p)->(%u)\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI xhr3_callback_Release(IXMLHTTPRequest3Callback *iface)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    trace("(%p)->(%u)\n", This, ref);
+    if (ref == 0) HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI xhr3_callback_OnRedirect(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest2 *request, const WCHAR* redirect_url)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%p %s)\n", This, request, debugstr_w(redirect_url));
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnHeadersAvailable(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest2 *request, DWORD status, const WCHAR *status_str)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    WCHAR *header = NULL;
+    HRESULT hr;
+
+    trace("(%p)->(%p %d %s)\n", This, request, status, debugstr_w(status_str));
+
+    header = (void *)0xdeadbeef;
+    hr = IXMLHTTPRequest2_GetResponseHeader(request, L"Content-Length", &header);
+    trace("Content-Length: %p (%s), hr %#x\n", header, debugstr_w(header), hr);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnDataAvailable(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest2 *request, ISequentialStream *response)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%p %p)\n", This, request, response);
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnResponseReceived(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest2 *request, ISequentialStream *response)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    WCHAR *header = NULL;
+    char *buffer = HeapAlloc( GetProcessHeap(), 0, 256 );
+    ULONG read_size = 0;
+    HRESULT hr;
+
+    memset(buffer, '?', 256);
+    buffer[255] = 0;
+
+    trace("(%p)->(%p %p)\n", This, request, response);
+
+    header = (void *)0xdeadbeef;
+    hr = IXMLHTTPRequest2_GetResponseHeader(request, L"Cache-Control", &header);
+    trace("Cache-Control: %p (%s), hr %#x\n", header, debugstr_w(header), hr);
+
+    header = (void *)0xdeadbeef;
+    hr = IXMLHTTPRequest2_GetResponseHeader(request, L"Expires", &header);
+    trace("Expires: %p (%s), hr %#x\n", header, debugstr_w(header), hr);
+
+    header = (void *)0xdeadbeef;
+    hr = IXMLHTTPRequest2_GetResponseHeader(request, L"Content-Type", &header);
+    trace("Content-Type: %p (%s), hr %#x\n", header, debugstr_w(header), hr);
+
+    read_size = 0xdeadbeef;
+    hr = ISequentialStream_Read(response, buffer, 214, &read_size);
+    trace("Response: (%d) %s, hr %#x\n", read_size, debugstr_a(buffer), hr);
+
+    read_size = 0xdeadbeef;
+    hr = ISequentialStream_Read(response, buffer, 1, &read_size);
+    trace("Response: (%d) %s, hr %#x\n", read_size, debugstr_a(buffer), hr);
+
+    HeapFree( GetProcessHeap(), 0, buffer );
+    SetEvent(This->event);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnError(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest2 *request, HRESULT error)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%p %#x)\n", This, request, error);
+    SetEvent(This->event);
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnServerCertificateReceived(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest3 *request, DWORD errors, DWORD chain_size, const XHR_CERT *chain)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%p %u %u %p)\n", This, request, errors, chain_size, chain);
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnClientCertificateRequested(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest3 *request, DWORD issuers_size, const WCHAR **issuers)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%p %u %p)\n", This, request, issuers_size, issuers);
+    return S_OK;
+}
+
+static const IXMLHTTPRequest3CallbackVtbl xhr3_callback_vtbl =
+{
+    xhr3_callback_QueryInterface,
+    xhr3_callback_AddRef,
+    xhr3_callback_Release,
+    /* IXMLHTTPRequest2Callback methods */
+    xhr3_callback_OnRedirect,
+    xhr3_callback_OnHeadersAvailable,
+    xhr3_callback_OnDataAvailable,
+    xhr3_callback_OnResponseReceived,
+    xhr3_callback_OnError,
+    /* IXMLHTTPRequest3Callback methods */
+    xhr3_callback_OnServerCertificateReceived,
+    xhr3_callback_OnClientCertificateRequested,
+};
+
+static IXMLHTTPRequest2Callback* xhr3_callback_create(HANDLE event)
+{
+    struct xhr3_callback *This = HeapAlloc(GetProcessHeap(), 0, sizeof(*This));
+    ok(This != NULL, "failed to allocate object\n");
+    if (!This) return NULL;
+
+    This->IXMLHTTPRequest3Callback_iface.lpVtbl = &xhr3_callback_vtbl;
+    This->ref = 1;
+    This->event = event;
+
+    return (IXMLHTTPRequest2Callback*)&This->IXMLHTTPRequest3Callback_iface;
+}
+
+struct xhr2_stream
+{
+    IStream IStream_iface;
+    LONG ref;
+    IStream *stream;
+};
+
+static inline struct xhr2_stream *xhr2_stream_from_IStream(IStream *iface)
+{
+    return CONTAINING_RECORD(iface, struct xhr2_stream, IStream_iface);
+}
+
+static HRESULT WINAPI xhr2_stream_QueryInterface(IStream *iface, REFIID riid, void **obj)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IStream) || IsEqualGUID(riid, &IID_ISequentialStream) || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        IStream_AddRef(iface);
+        *obj = iface;
+        return S_OK;
+    }
+
+    ok(0, "unexpected interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI xhr2_stream_AddRef(IStream *iface)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    trace("(%p)->(%u)\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI xhr2_stream_Release(IStream *iface)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    trace("(%p)->(%u)\n", This, ref);
+    if (ref == 0)
+    {
+        IStream_Release(This->stream);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI xhr2_stream_Read(IStream *iface, void *pv, ULONG cb,
+        ULONG *pcbRead)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%p %u %p)\n", This, pv, cb, pcbRead);
+    return IStream_Read(This->stream, pv, cb, pcbRead);
+}
+
+static HRESULT WINAPI xhr2_stream_Write(IStream *iface, const void *pv,
+        ULONG cb, ULONG *pcbWritten)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%p %u %p)\n", This, pv, cb, pcbWritten);
+    return IStream_Write(This->stream, pv, cb, pcbWritten);
+}
+
+static HRESULT WINAPI xhr2_stream_Seek(IStream *iface, LARGE_INTEGER dlibMove,
+        DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%lu, %u %p)\n", This, dlibMove.QuadPart, dwOrigin, plibNewPosition);
+    return IStream_Seek(This->stream, dlibMove, dwOrigin, plibNewPosition);
+}
+
+static HRESULT WINAPI xhr2_stream_SetSize(IStream *iface, ULARGE_INTEGER libNewSize)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%lu)\n", This, libNewSize.QuadPart);
+    return IStream_SetSize(This->stream, libNewSize);
+}
+
+static HRESULT WINAPI xhr2_stream_CopyTo(IStream *iface, IStream *pstm,
+        ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%p %lu %p %p)\n", This, pstm, cb.QuadPart, pcbRead, pcbWritten);
+    return IStream_CopyTo(This->stream, pstm, cb, pcbRead, pcbWritten);
+}
+
+static HRESULT WINAPI xhr2_stream_Commit(IStream *iface, DWORD grfCommitFlags)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%#x)\n", This, grfCommitFlags);
+    return IStream_Commit(This->stream, grfCommitFlags);
+}
+
+static HRESULT WINAPI xhr2_stream_Revert(IStream *iface)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->()\n", This);
+    return IStream_Revert(This->stream);
+}
+
+static HRESULT WINAPI xhr2_stream_LockRegion(IStream *iface, ULARGE_INTEGER libOffset,
+        ULARGE_INTEGER cb, DWORD dwLockType)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%lu %lu %u)\n", This, libOffset.QuadPart, cb.QuadPart, dwLockType);
+    return IStream_LockRegion(This->stream, libOffset, cb, dwLockType);
+}
+
+static HRESULT WINAPI xhr2_stream_UnlockRegion(IStream *iface, ULARGE_INTEGER libOffset,
+        ULARGE_INTEGER cb, DWORD dwLockType)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%lu %lu %u)\n", This, libOffset.QuadPart, cb.QuadPart, dwLockType);
+    return IStream_UnlockRegion(This->stream, libOffset, cb, dwLockType);
+}
+
+static HRESULT WINAPI xhr2_stream_Stat(IStream *iface, STATSTG *pstatstg, DWORD grfStatFlag)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%p %#x)\n", This, pstatstg, grfStatFlag);
+    return IStream_Stat(This->stream, pstatstg, grfStatFlag);
+}
+
+static HRESULT WINAPI xhr2_stream_Clone(IStream *iface, IStream **ppstm)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%p)\n", This, ppstm);
+    return IStream_Clone(This->stream, ppstm);
+}
+
+static const IStreamVtbl xhr2_stream_vtbl =
+{
+    xhr2_stream_QueryInterface,
+    xhr2_stream_AddRef,
+    xhr2_stream_Release,
+    /* IStream methods */
+    xhr2_stream_Read,
+    xhr2_stream_Write,
+    xhr2_stream_Seek,
+    xhr2_stream_SetSize,
+    xhr2_stream_CopyTo,
+    xhr2_stream_Commit,
+    xhr2_stream_Revert,
+    xhr2_stream_LockRegion,
+    xhr2_stream_UnlockRegion,
+    xhr2_stream_Stat,
+    xhr2_stream_Clone
+};
+
+static ISequentialStream *xhr2_stream_create(void)
+{
+    struct xhr2_stream *This = HeapAlloc(GetProcessHeap(), 0, sizeof(*This));
+    ok(This != NULL, "failed to allocate object\n");
+    if (!This) return NULL;
+
+    This->IStream_iface.lpVtbl = &xhr2_stream_vtbl;
+    This->ref = 1;
+    CreateStreamOnHGlobal(NULL, TRUE, &This->stream);
+
+    return (ISequentialStream*)&This->IStream_iface;
+}
+
+static void test_IXMLHTTPRequest2(void)
+{
+    IXMLHTTPRequest2 *xhr2[16];
+    IXMLHTTPRequest2Callback *xhr3_callback;
+    ISequentialStream *stream;
+    HANDLE events[16];
+    HRESULT hr;
+    int i = 0;
+
+    if (!(xhr2[i] = create_xhr2()))
+    {
+        win_skip("IXMLHTTPRequest2 is not available\n");
+        return;
+    }
+
+    events[i] = CreateEventW(NULL, FALSE, FALSE, NULL);
+    if (!(xhr3_callback = xhr3_callback_create(events[i])))
+        return;
+
+    trace("IXMLHTTPRequest2_Open (%p)->(L\"GET\", L\"http://test.winehq.org/\", xhr3_callback, NULL, NULL, NULL, NULL)\n", GetCurrentThreadId(), xhr2[i]);
+    hr = IXMLHTTPRequest2_Open(xhr2[i], L"GET", L"http://test.winehq.org/", xhr3_callback, NULL, NULL, NULL, NULL);
+    ok(SUCCEEDED(hr), "IXMLHTTPRequest2_Send failed %#x\n", hr);
+
+    if ((stream = xhr2_stream_create()))
+    {
+        trace("IXMLHTTPRequest2_Send (%p)->(%p 0)\n", GetCurrentThreadId(), xhr2[i], stream);
+        hr = IXMLHTTPRequest2_Send(xhr2[i], stream, 0);
+        ok(SUCCEEDED(hr), "IXMLHTTPRequest2_Send failed %#x\n", hr);
+
+        ISequentialStream_Release(stream);
+    }
+
+    IXMLHTTPRequest2Callback_Release(xhr3_callback);
+    i++;
+
+    while (i--)
+    {
+        WaitForSingleObject(events[i], INFINITE);
+        IXMLHTTPRequest2_Release(xhr2[i]);
+    }
+}
+
 START_TEST(httpreq)
 {
     IXMLHttpRequest *xhr;

-    CoInitialize(NULL);
+    CoInitializeEx(NULL, COINIT_MULTITHREADED);

     if (!(xhr = create_xhr()))
     {
@@ -1927,6 +2315,7 @@ START_TEST(httpreq)
     test_server_xhr();
     test_safe_httpreq();
     test_supporterrorinfo();
+    test_IXMLHTTPRequest2();

     CoUninitialize();
 }
diff --git a/dlls/msxml3/tests/schema.c b/dlls/msxml3/tests/schema.c
index 219d7144ddb..7ef033237a1 100644
--- a/dlls/msxml3/tests/schema.c
+++ b/dlls/msxml3/tests/schema.c
@@ -32,10 +32,16 @@
 #include "dispex.h"
 #include "cguid.h"

+DEFINE_GUID(CLSID_FreeThreadedDOMDocument60, 0x88d96a06, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_FreeThreadedXMLHTTP60, 0x88d96a09, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
 DEFINE_GUID(CLSID_MXXMLWriter60, 0x88d96a0f, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
 DEFINE_GUID(CLSID_SAXAttributes60, 0x88d96a0e, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
 DEFINE_GUID(CLSID_SAXXMLReader60, 0x88d96a0c, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
 DEFINE_GUID(CLSID_XMLSchemaCache60, 0x88d96a07, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(IID_IXMLHTTPRequest2, 0xe5d37dc0, 0x552a, 0x4d52, 0x9c,0xc0, 0xa1,0x4d,0x54,0x6f,0xbd,0x04);
+DEFINE_GUID(IID_IXMLHTTPRequest3, 0xa1c9feee, 0x0617, 0x4f23, 0x9d,0x58, 0x89,0x61,0xea,0x43,0x56,0x7c);
+DEFINE_GUID(IID_IXMLHTTPRequest2Callback, 0xa44a9299, 0xe321, 0x40de, 0x88,0x66, 0x34,0x1b,0x41,0x66,0x91,0x62);
+DEFINE_GUID(IID_IXMLHTTPRequest3Callback, 0xb9e57830, 0x8c6c, 0x4a6f, 0x9c,0x13, 0x47,0x77,0x2b,0xb0,0x47,0xbb);

 #include "wine/test.h"

diff --git a/dlls/msxml3/uuid.c b/dlls/msxml3/uuid.c
index 333d4f3d3c7..1b4f0452c5f 100644
--- a/dlls/msxml3/uuid.c
+++ b/dlls/msxml3/uuid.c
@@ -43,6 +43,7 @@

 /* Cannot include msxml6 here since we will get a duplicate LIBID_MSXML2 error.  */
 DEFINE_GUID(CLSID_FreeThreadedDOMDocument60, 0x88d96a06, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_FreeThreadedXMLHTTP60, 0x88d96a09, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
 DEFINE_GUID(CLSID_MXNamespaceManager60, 0x88d96a11, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
 DEFINE_GUID(CLSID_MXXMLWriter60, 0x88d96a0f, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
 DEFINE_GUID(CLSID_SAXAttributes60, 0x88d96a0e, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
@@ -51,6 +52,10 @@ DEFINE_GUID(CLSID_ServerXMLHTTP60, 0x88d96a0b, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0
 DEFINE_GUID(CLSID_XMLHTTP60, 0x88d96a0a, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
 DEFINE_GUID(CLSID_XMLSchemaCache60, 0x88d96a07, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
 DEFINE_GUID(CLSID_XSLTemplate60, 0x88d96a08, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(IID_IXMLHTTPRequest2, 0xe5d37dc0, 0x552a, 0x4d52, 0x9c,0xc0, 0xa1,0x4d,0x54,0x6f,0xbd,0x04);
+DEFINE_GUID(IID_IXMLHTTPRequest3, 0xa1c9feee, 0x0617, 0x4f23, 0x9d,0x58, 0x89,0x61,0xea,0x43,0x56,0x7c);
+DEFINE_GUID(IID_IXMLHTTPRequest2Callback, 0xa44a9299, 0xe321, 0x40de, 0x88,0x66, 0x34,0x1b,0x41,0x66,0x91,0x62);
+DEFINE_GUID(IID_IXMLHTTPRequest3Callback, 0xb9e57830, 0x8c6c, 0x4a6f, 0x9c,0x13, 0x47,0x77,0x2b,0xb0,0x47,0xbb);

 /*
  * Note that because of a #define in msxml2.h, we end up initializing
From bc9e13e8843b3417b4398c2036ab8bacbcc8d664 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Mon, 11 Oct 2021 11:01:33 +0200
Subject: [PATCH] msctf: Use list to keep thread managers.

Thread managers were stored in thread local storage,
which have a major flaw that they can't not be released
by another thread.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/msctf/msctf.c          | 46 +++++++----------------
 dlls/msctf/msctf_internal.h |  1 -
 dlls/msctf/threadmgr.c      | 73 ++++++++++++++++++++++++++++++++-----
 3 files changed, 76 insertions(+), 44 deletions(-)

diff --git a/dlls/msctf/msctf.c b/dlls/msctf/msctf.c
index 4ae9e16d453..ee4fe84b8c9 100644
--- a/dlls/msctf/msctf.c
+++ b/dlls/msctf/msctf.c
@@ -67,7 +67,6 @@ static UINT array_size;
 static struct list AtsList = LIST_INIT(AtsList);
 static UINT activated = 0;

-DWORD tlsIndex = 0;
 TfClientId processId = 0;
 ITfCompartmentMgr *globalCompartmentMgr = NULL;

@@ -395,23 +394,19 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
     ActivatedTextService *actsvr;
     ITfCategoryMgr *catmgr;
     AtsEntry *entry;
-    ITfThreadMgrEx *tm = TlsGetValue(tlsIndex);
+    ITfThreadMgr *tm;
     ITfClientId *clientid;

-    if (!tm) return E_UNEXPECTED;
+    if (FAILED(TF_GetThreadMgr(&tm))) return E_UNEXPECTED;

     actsvr = HeapAlloc(GetProcessHeap(),0,sizeof(ActivatedTextService));
-    if (!actsvr) return E_OUTOFMEMORY;
+    if (!actsvr) goto fail;

-    ITfThreadMgrEx_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
+    ITfThreadMgr_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
     ITfClientId_GetClientId(clientid, &lp->clsid, &actsvr->tid);
     ITfClientId_Release(clientid);

-    if (!actsvr->tid)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!actsvr->tid) goto fail;

     actsvr->pITfTextInputProcessor = NULL;
     actsvr->LanguageProfile = *lp;
@@ -438,20 +433,21 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
         deactivate_remove_conflicting_ts(&actsvr->LanguageProfile.catid);

     if (activated > 0)
-        activate_given_ts(actsvr, tm);
+        activate_given_ts(actsvr, (ITfThreadMgrEx *)tm);

     entry = HeapAlloc(GetProcessHeap(),0,sizeof(AtsEntry));
-
-    if (!entry)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!entry) goto fail;

     entry->ats = actsvr;
     list_add_head(&AtsList, &entry->entry);

+    ITfThreadMgr_Release(tm);
     return S_OK;
+
+fail:
+    ITfThreadMgr_Release(tm);
+    HeapFree(GetProcessHeap(), 0, actsvr);
+    return E_OUTOFMEMORY;
 }

 BOOL get_active_textservice(REFCLSID rclsid, TF_LANGUAGEPROFILE *profile)
@@ -555,11 +551,9 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD fdwReason, LPVOID fImpLoad)
     switch (fdwReason)
     {
         case DLL_PROCESS_ATTACH:
-            tlsIndex = TlsAlloc();
             break;
         case DLL_PROCESS_DETACH:
             if (fImpLoad) break;
-            TlsFree(tlsIndex);
             break;
     }
     return TRUE;
@@ -593,20 +587,6 @@ HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim)
     return ThreadMgr_Constructor(NULL,(IUnknown**)pptim);
 }

-/***********************************************************************
- *              TF_GetThreadMgr (MSCTF.@)
- */
-HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
-{
-    TRACE("\n");
-    *pptim = TlsGetValue(tlsIndex);
-
-    if (*pptim)
-        ITfThreadMgr_AddRef(*pptim);
-
-    return S_OK;
-}
-
 /***********************************************************************
  *              SetInputScope(MSCTF.@)
  */
diff --git a/dlls/msctf/msctf_internal.h b/dlls/msctf/msctf_internal.h
index 45a39806c22..84f8ebf81c2 100644
--- a/dlls/msctf/msctf_internal.h
+++ b/dlls/msctf/msctf_internal.h
@@ -36,7 +36,6 @@
 #define COOKIE_MAGIC_INPUTPROCESSORPROFILEACTIVATIONSINK 0x00b0
 #define COOKIE_MAGIC_ACTIVELANGSINK 0x00c0

-extern DWORD tlsIndex DECLSPEC_HIDDEN;
 extern TfClientId processId DECLSPEC_HIDDEN;
 extern ITfCompartmentMgr *globalCompartmentMgr DECLSPEC_HIDDEN;

diff --git a/dlls/msctf/threadmgr.c b/dlls/msctf/threadmgr.c
index 0e054d4e654..23bf24fb118 100644
--- a/dlls/msctf/threadmgr.c
+++ b/dlls/msctf/threadmgr.c
@@ -37,6 +37,17 @@

 WINE_DEFAULT_DEBUG_CHANNEL(msctf);

+static CRITICAL_SECTION ThreadMgrCs;
+static CRITICAL_SECTION_DEBUG ThreadMgrCsDebug =
+{
+    0, 0, &ThreadMgrCs,
+    {&ThreadMgrCsDebug.ProcessLocksList,
+     &ThreadMgrCsDebug.ProcessLocksList },
+     0, 0, {(DWORD_PTR)(__FILE__ ": ThreadMgrCs")}
+};
+static CRITICAL_SECTION ThreadMgrCs = {&ThreadMgrCsDebug, -1, 0, 0, 0, 0};
+struct list ThreadMgrList = LIST_INIT(ThreadMgrList);
+
 typedef struct tagPreservedKey
 {
     struct list     entry;
@@ -98,6 +109,9 @@ typedef struct tagACLMulti {
     struct list     ThreadMgrEventSink;
     struct list     UIElementSink;
     struct list     InputProcessorProfileActivationSink;
+
+    DWORD threadId;
+    struct list entry;
 } ThreadMgr;

 typedef struct tagEnumTfDocumentMgr {
@@ -110,6 +124,11 @@ typedef struct tagEnumTfDocumentMgr {

 static HRESULT EnumTfDocumentMgr_Constructor(struct list* head, IEnumTfDocumentMgrs **ppOut);

+static inline ThreadMgr *impl_from_ITfThreadMgr(ITfThreadMgr *iface)
+{
+    return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
+}
+
 static inline ThreadMgr *impl_from_ITfThreadMgrEx(ITfThreadMgrEx *iface)
 {
     return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
@@ -155,6 +174,35 @@ static inline EnumTfDocumentMgr *impl_from_IEnumTfDocumentMgrs(IEnumTfDocumentMg
     return CONTAINING_RECORD(iface, EnumTfDocumentMgr, IEnumTfDocumentMgrs_iface);
 }

+/***********************************************************************
+ *              TF_GetThreadMgr (MSCTF.@)
+ */
+HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
+{
+    DWORD id = GetCurrentThreadId();
+    ThreadMgr *cursor;
+
+    TRACE("%p\n", pptim);
+
+    if (!pptim)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&ThreadMgrCs);
+    LIST_FOR_EACH_ENTRY(cursor, &ThreadMgrList, ThreadMgr, entry)
+    {
+        if (cursor->threadId == id)
+        {
+            ITfThreadMgrEx_AddRef(&cursor->ITfThreadMgrEx_iface);
+            *pptim = (ITfThreadMgr *)&cursor->ITfThreadMgrEx_iface;
+            LeaveCriticalSection(&ThreadMgrCs);
+            return S_OK;
+        }
+    }
+    LeaveCriticalSection(&ThreadMgrCs);
+    *pptim = NULL;
+    return E_FAIL;
+}
+
 static void ThreadMgr_Destructor(ThreadMgr *This)
 {
     struct list *cursor, *cursor2;
@@ -163,7 +211,9 @@ static void ThreadMgr_Destructor(ThreadMgr *This)
     if (This->focusHook)
         UnhookWindowsHookEx(This->focusHook);

-    TlsSetValue(tlsIndex,NULL);
+    EnterCriticalSection(&ThreadMgrCs);
+    list_remove(&This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
     TRACE("destroying %p\n", This);
     if (This->focus)
         ITfDocumentMgr_Release(This->focus);
@@ -386,17 +436,20 @@ static HRESULT WINAPI ThreadMgr_SetFocus(ITfThreadMgrEx *iface, ITfDocumentMgr *

 static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lParam)
 {
+    ITfThreadMgr *ThreadMgr_iface;
     ThreadMgr *This;

-    This = TlsGetValue(tlsIndex);
-    if (!This)
+    if (FAILED(TF_GetThreadMgr(&ThreadMgr_iface)))
     {
         ERR("Hook proc but no ThreadMgr for this thread. Serious Error\n");
         return 0;
     }
+
+    This = impl_from_ITfThreadMgr(ThreadMgr_iface);
     if (!This->focusHook)
     {
         ERR("Hook proc but no ThreadMgr focus Hook. Serious Error\n");
+        ITfThreadMgr_Release(ThreadMgr_iface);
         return 0;
     }

@@ -417,6 +470,7 @@ static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lPa
         }
     }

+    ITfThreadMgr_Release(ThreadMgr_iface);
     return CallNextHookEx(This->focusHook, nCode, wParam, lParam);
 }

@@ -1346,13 +1400,8 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
         return CLASS_E_NOAGGREGATION;

     /* Only 1 ThreadMgr is created per thread */
-    This = TlsGetValue(tlsIndex);
-    if (This)
-    {
-        ThreadMgr_AddRef(&This->ITfThreadMgrEx_iface);
-        *ppOut = (IUnknown*)&This->ITfThreadMgrEx_iface;
+    if (SUCCEEDED(TF_GetThreadMgr((ITfThreadMgr **)ppOut)))
         return S_OK;
-    }

     This = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(ThreadMgr));
     if (This == NULL)
@@ -1367,7 +1416,6 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     This->ITfUIElementMgr_iface.lpVtbl = &ThreadMgrUIElementMgrVtbl;
     This->ITfSourceSingle_iface.lpVtbl = &SourceSingleVtbl;
     This->refCount = 1;
-    TlsSetValue(tlsIndex,This);

     CompartmentMgr_Constructor((IUnknown*)&This->ITfThreadMgrEx_iface, &IID_IUnknown, (IUnknown**)&This->CompartmentMgr);

@@ -1384,6 +1432,11 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     list_init(&This->UIElementSink);
     list_init(&This->InputProcessorProfileActivationSink);

+    This->threadId = GetCurrentThreadId();
+    EnterCriticalSection(&ThreadMgrCs);
+    list_add_tail(&ThreadMgrList, &This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
+
     TRACE("returning %p\n", This);
     *ppOut = (IUnknown *)&This->ITfThreadMgrEx_iface;
     return S_OK;
From 9bb551b8351ec76729565220bab9509a156b615e Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 4 Nov 2020 18:08:21 +0300
Subject: [PATCH] ws2_32: HACK Fail 'download-alt.easyanticheat.net' DNS name
 resolution.

CW-Bug-Id: #16695
---
 dlls/ws2_32/protocol.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/dlls/ws2_32/protocol.c b/dlls/ws2_32/protocol.c
index 867e9513ca2..134624ad1f3 100644
--- a/dlls/ws2_32/protocol.c
+++ b/dlls/ws2_32/protocol.c
@@ -169,6 +169,13 @@ int WINAPI getaddrinfo( const char *node, const char *service,

     if (node)
     {
+        if (!strcmp(node, "download-alt.easyanticheat.net"))
+        {
+            ERR("HACK: failing download-alt.easyanticheat.net resolution.\n");
+            SetLastError(WSAHOST_NOT_FOUND);
+            return WSAHOST_NOT_FOUND;
+        }
+
         if (!node[0])
         {
             if (!(fqdn = get_fqdn())) return WSA_NOT_ENOUGH_MEMORY;
@@ -926,6 +933,13 @@ struct hostent * WINAPI gethostbyname( const char *name )
         return NULL;
     }

+    if (name && !strcmp(name, "download-alt.easyanticheat.net"))
+    {
+        ERR("HACK: failing download-alt.easyanticheat.net resolution.\n");
+        SetLastError( WSAHOST_NOT_FOUND );
+        return NULL;
+    }
+
     if ((ret = WS_CALL( gethostname, &params )))
     {
         SetLastError( ret );
From b9a6702e81339766285365197f894f38e7c62ed3 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 26 Jun 2020 15:26:53 +0300
Subject: [PATCH] Avoid undefined result in ntdll_wcstoumbs() in case of error.

CW-Bug-Id: #17864

Undefined result is due to RtlUnicodeToUTF8N() not setting output
length on error which is a correct behaviour according to
existing tests.

'Planet Zoo' is affected which passes NULL object name buffer to
NtCreateFile().

Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
---
 dlls/ntdll/unix/env.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
index 6130ad23c15..fe14b48420d 100644
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -658,7 +658,7 @@ DWORD ntdll_umbstowcs( const char *src, DWORD srclen, WCHAR *dst, DWORD dstlen )
  */
 int ntdll_wcstoumbs( const WCHAR *src, DWORD srclen, char *dst, DWORD dstlen, BOOL strict )
 {
-    DWORD i, reslen;
+    DWORD i, reslen = 0;

     if (unix_cp.data)
     {
From 4b3272d0e6a072fa63d668679294e8be7fafa38e Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Sat, 22 May 2021 01:23:33 +0300
Subject: [PATCH] server: Update system regs from set_thread_context handler
 only.

CW-Bug-Id: #18957
---
 server/thread.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/server/thread.c b/server/thread.c
index 4ee25f178ff..6300fda0396 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -1855,8 +1855,6 @@ DECL_HANDLER(select)
         if (ctx->regs[CTX_NATIVE].flags || ctx->regs[CTX_WOW].flags)
         {
             data_size_t size = (ctx->regs[CTX_WOW].flags ? 2 : 1) * sizeof(context_t);
-            unsigned int flags = system_flags & ctx->regs[CTX_NATIVE].flags;
-            if (flags) set_thread_context( current, &ctx->regs[CTX_NATIVE], flags );
             set_reply_data( ctx->regs, min( size, get_reply_max_size() ));
         }
         release_object( ctx );
@@ -2095,7 +2093,7 @@ DECL_HANDLER(set_thread_context)
         unsigned int native_flags = always_native_flags & context->flags;

         if (thread != current) stop_thread( thread );
-        else if (flags) set_thread_context( thread, context, flags );
+        if (system_flags) set_thread_context( thread, context, system_flags );
         if (thread->context && !get_error())
         {
             if (ctx_count == 2)
From ee874587e97ef62a9ac2f4b17ea2c2ffc1d39f10 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 24 May 2021 14:37:35 +0300
Subject: [PATCH] ntdll: Update cached debug registers in call_init_thunk().

CW-Bug-Id: #18957
---
 dlls/ntdll/unix/signal_i386.c   | 14 +++++++++++++-
 dlls/ntdll/unix/signal_x86_64.c | 14 +++++++++++++-
 2 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index 4f471ffb03b..1ad9f86d659 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -2390,7 +2390,19 @@ void DECLSPEC_HIDDEN call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, B
     ((XSAVE_FORMAT *)context.ExtendedRegisters)->MxCsr = 0x1f80;
     if ((ctx = get_cpu_area( IMAGE_FILE_MACHINE_I386 ))) *ctx = context;

-    if (suspend) wait_suspend( &context );
+    if (suspend)
+    {
+        wait_suspend( &context );
+        if (context.ContextFlags & CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386)
+        {
+            x86_thread_data()->dr0 = context.Dr0;
+            x86_thread_data()->dr1 = context.Dr1;
+            x86_thread_data()->dr2 = context.Dr2;
+            x86_thread_data()->dr3 = context.Dr3;
+            x86_thread_data()->dr6 = context.Dr6;
+            x86_thread_data()->dr7 = context.Dr7;
+        }
+    }

     ctx = (CONTEXT *)((ULONG_PTR)context.Esp & ~3) - 1;
     *ctx = context;
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 09465d028c6..03e9b5c007d 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -3294,7 +3294,19 @@ void DECLSPEC_HIDDEN call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, B
         *(XSAVE_FORMAT *)wow_context->ExtendedRegisters = context.u.FltSave;
     }

-    if (suspend) wait_suspend( &context );
+    if (suspend)
+    {
+        wait_suspend( &context );
+        if (context.ContextFlags & CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64)
+        {
+            amd64_thread_data()->dr0 = context.Dr0;
+            amd64_thread_data()->dr1 = context.Dr1;
+            amd64_thread_data()->dr2 = context.Dr2;
+            amd64_thread_data()->dr3 = context.Dr3;
+            amd64_thread_data()->dr6 = context.Dr6;
+            amd64_thread_data()->dr7 = context.Dr7;
+        }
+    }

     ctx = (CONTEXT *)((ULONG_PTR)context.Rsp & ~15) - 1;
     *ctx = context;
From 3bc7d74cb44dfdb3b0311b823723cfd0ff746f21 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Sat, 22 May 2021 03:08:55 +0300
Subject: [PATCH] ntdll: Use cached debug registers in NtGetContextThread() if
 hw debug breakpoints are disabled.

CW-Bug-Id: #18957
---
 dlls/ntdll/unix/signal_i386.c   | 37 ++++++++++++++++++++++++---------
 dlls/ntdll/unix/signal_x86_64.c | 37 ++++++++++++++++++++++++---------
 2 files changed, 54 insertions(+), 20 deletions(-)

diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index 1ad9f86d659..9edd425ac3d 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -990,10 +990,15 @@ NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
     struct syscall_frame *frame = x86_thread_data()->syscall_frame;
     DWORD needed_flags = context->ContextFlags & ~CONTEXT_i386;
     BOOL self = (handle == GetCurrentThread());
+    BOOL use_cached_debug_regs = FALSE;
     NTSTATUS ret;

-    /* debug registers require a server call */
-    if (needed_flags & CONTEXT_DEBUG_REGISTERS) self = FALSE;
+    if (self && needed_flags & CONTEXT_DEBUG_REGISTERS)
+    {
+        /* debug registers require a server call if hw breakpoints are enabled */
+        if (x86_thread_data()->dr7 & 0xff) self = FALSE;
+        else use_cached_debug_regs = TRUE;
+    }

     if (!self)
     {
@@ -1101,15 +1106,27 @@ NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
                 xstate->YmmContext = frame->xstate.YmmContext;
             }
         }
-        /* update the cached version of the debug registers */
-        if (needed_flags & CONTEXT_DEBUG_REGISTERS)
+        if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386))
         {
-            x86_thread_data()->dr0 = context->Dr0;
-            x86_thread_data()->dr1 = context->Dr1;
-            x86_thread_data()->dr2 = context->Dr2;
-            x86_thread_data()->dr3 = context->Dr3;
-            x86_thread_data()->dr6 = context->Dr6;
-            x86_thread_data()->dr7 = context->Dr7;
+            if (use_cached_debug_regs)
+            {
+                context->Dr0 = x86_thread_data()->dr0;
+                context->Dr1 = x86_thread_data()->dr1;
+                context->Dr2 = x86_thread_data()->dr2;
+                context->Dr3 = x86_thread_data()->dr3;
+                context->Dr6 = x86_thread_data()->dr6;
+                context->Dr7 = x86_thread_data()->dr7;
+            }
+            else
+            {
+                /* update the cached version of the debug registers */
+                x86_thread_data()->dr0 = context->Dr0;
+                x86_thread_data()->dr1 = context->Dr1;
+                x86_thread_data()->dr2 = context->Dr2;
+                x86_thread_data()->dr3 = context->Dr3;
+                x86_thread_data()->dr6 = context->Dr6;
+                x86_thread_data()->dr7 = context->Dr7;
+            }
         }
     }

diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 03e9b5c007d..e67907309d0 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -1803,10 +1803,15 @@ NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
 {
     struct syscall_frame *frame = amd64_thread_data()->syscall_frame;
     DWORD needed_flags = context->ContextFlags & ~CONTEXT_AMD64;
+    BOOL use_cached_debug_regs = FALSE;
     BOOL self = (handle == GetCurrentThread());

-    /* debug registers require a server call */
-    if (needed_flags & CONTEXT_DEBUG_REGISTERS) self = FALSE;
+    if (self && needed_flags & CONTEXT_DEBUG_REGISTERS)
+    {
+        /* debug registers require a server call if hw breakpoints are enabled */
+        if (amd64_thread_data()->dr7 & 0xff) self = FALSE;
+        else use_cached_debug_regs = TRUE;
+    }

     if (!self)
     {
@@ -1905,15 +1910,27 @@ NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
             memcpy( &xstate->YmmContext, &frame->xstate.YmmContext, sizeof(xstate->YmmContext) );
         }
     }
-    /* update the cached version of the debug registers */
-    if (needed_flags & CONTEXT_DEBUG_REGISTERS)
+    if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64))
     {
-        amd64_thread_data()->dr0 = context->Dr0;
-        amd64_thread_data()->dr1 = context->Dr1;
-        amd64_thread_data()->dr2 = context->Dr2;
-        amd64_thread_data()->dr3 = context->Dr3;
-        amd64_thread_data()->dr6 = context->Dr6;
-        amd64_thread_data()->dr7 = context->Dr7;
+        if (use_cached_debug_regs)
+        {
+            context->Dr0 = amd64_thread_data()->dr0;
+            context->Dr1 = amd64_thread_data()->dr1;
+            context->Dr2 = amd64_thread_data()->dr2;
+            context->Dr3 = amd64_thread_data()->dr3;
+            context->Dr6 = amd64_thread_data()->dr6;
+            context->Dr7 = amd64_thread_data()->dr7;
+        }
+        else
+        {
+            /* update the cached version of the debug registers */
+            amd64_thread_data()->dr0 = context->Dr0;
+            amd64_thread_data()->dr1 = context->Dr1;
+            amd64_thread_data()->dr2 = context->Dr2;
+            amd64_thread_data()->dr3 = context->Dr3;
+            amd64_thread_data()->dr6 = context->Dr6;
+            amd64_thread_data()->dr7 = context->Dr7;
+        }
     }
     return STATUS_SUCCESS;
 }
From dcc7655978f00ec4aa6a643b3988e7b1f5b4605d Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 21 May 2021 15:10:07 +0300
Subject: [PATCH] ntdll: Read process memory on the client side in
 NtReadVirtualMemory().

CW-Bug-Id: 18957
---
 dlls/ntdll/unix/server.c  |  2 +-
 dlls/ntdll/unix/virtual.c | 46 +++++++++++++++++++++++++++++++++++++++
 server/process.c          |  2 ++
 server/protocol.def       |  1 +
 4 files changed, 50 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index b7873c2955b..6b3fa8e7a11 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1480,7 +1480,7 @@ size_t server_init_process(void)
                                (version > SERVER_PROTOCOL_VERSION) ? "wine" : "wineserver" );
 #if defined(__linux__) && defined(HAVE_PRCTL)
     /* work around Ubuntu's ptrace breakage */
-    if (server_pid != -1) prctl( 0x59616d61 /* PR_SET_PTRACER */, server_pid );
+    if (server_pid != -1) prctl( 0x59616d61 /* PR_SET_PTRACER */, PR_SET_PTRACER_ANY );
 #endif

     /* ignore SIGPIPE so that we get an EPIPE error instead  */
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index a2452943ceb..e7b23e3dcd4 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -64,6 +64,8 @@
 # include <mach/mach_vm.h>
 #endif

+#include <sys/uio.h>
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
@@ -4843,7 +4845,50 @@ NTSTATUS WINAPI NtReadVirtualMemory( HANDLE process, const void *addr, void *buf
                                      SIZE_T size, SIZE_T *bytes_read )
 {
     NTSTATUS status;
+#ifdef linux
+    struct iovec local, remote;
+    int unix_pid;
+    ssize_t ret;
+
+    SERVER_START_REQ( read_process_memory )
+    {
+        req->handle = wine_server_obj_handle( process );
+        status = wine_server_call( req );
+        unix_pid = reply->unix_pid;
+    }
+    SERVER_END_REQ;
+
+    if (status)
+    {
+        WARN( "Could not get unix_pid for process %p, status %#x.\n", process, status );
+        size = 0;
+        goto done;
+    }
+
+    local.iov_base = buffer;
+    local.iov_len = size;

+    remote.iov_base = (void *)addr;
+    remote.iov_len = size;
+
+    if ((ret = process_vm_readv( unix_pid, &local, 1, &remote, 1, 0 )) != size)
+    {
+        WARN( "Error reading memory from process %p, addr %p, size %p, buffer %p, ret %p, errno %d.\n",
+              process, addr, (void *)size, buffer, (void *)ret, errno );
+
+        if (ret == -1)
+        {
+            status = errno == ESRCH ? STATUS_PARTIAL_COPY : errno_to_status( errno );
+            size = 0;
+        }
+        else
+        {
+            status = STATUS_PARTIAL_COPY;
+            size = ret;
+        }
+    }
+done:
+#else
     if (virtual_check_buffer_for_write( buffer, size ))
     {
         SERVER_START_REQ( read_process_memory )
@@ -4860,6 +4905,7 @@ NTSTATUS WINAPI NtReadVirtualMemory( HANDLE process, const void *addr, void *buf
         status = STATUS_ACCESS_VIOLATION;
         size = 0;
     }
+#endif
     if (bytes_read) *bytes_read = size;
     return status;
 }
diff --git a/server/process.c b/server/process.c
index 3b7261ada23..88092d664ec 100644
--- a/server/process.c
+++ b/server/process.c
@@ -1702,6 +1702,8 @@ DECL_HANDLER(read_process_memory)

     if (!(process = get_process_from_handle( req->handle, PROCESS_VM_READ ))) return;

+    reply->unix_pid = process->unix_pid;
+
     if (len)
     {
         char *buffer = mem_alloc( len );
diff --git a/server/protocol.def b/server/protocol.def
index e3f2b6857e5..586122a9928 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1683,6 +1683,7 @@ struct process_info
     obj_handle_t handle;       /* process handle */
     client_ptr_t addr;         /* addr to read from */
 @REPLY
+    int unix_pid;              /* Unix pid of new process */
     VARARG(data,bytes);        /* result data */
 @END

From 157c6cbeb57355384b7ac53558cb96101d3ede10 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 26 Oct 2021 19:07:26 +0300
Subject: [PATCH] ntdll: Don't use Wine frames during exception processing on
 x64.

CW-Bug-ID: #19570
---
 dlls/ntdll/signal_x86_64.c | 65 +++++++++++++++++++++++++++-----------
 1 file changed, 46 insertions(+), 19 deletions(-)

diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index 7e77329363c..5299877baa8 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -346,15 +346,32 @@ __ASM_GLOBAL_FUNC( RtlCaptureContext,
                    "fxsave 0x100(%rcx)\n\t"         /* context->FltSave */
                    "ret" );

-static DWORD __cdecl nested_exception_handler( EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
+DWORD __cdecl nested_exception_handler( EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
                                                CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher )
 {
+    TRACE( "exception flags %#x.\n", rec->ExceptionFlags );
+
     if (!(rec->ExceptionFlags & (EH_UNWINDING | EH_EXIT_UNWIND)))
-        rec->ExceptionFlags |= EH_NESTED_CALL;
+        return ExceptionNestedException;

     return ExceptionContinueSearch;
 }

+/***********************************************************************
+ *		exception_handler_call_wrapper
+ */
+DWORD exception_handler_call_wrapper( EXCEPTION_RECORD *rec, void *frame,
+                                      CONTEXT *context, DISPATCHER_CONTEXT *dispatch );
+__ASM_GLOBAL_FUNC( exception_handler_call_wrapper,
+                   __ASM_SEH(".seh_endprologue\n\t")
+                   "subq $0x28, %rsp\n\t"
+                   __ASM_SEH(".seh_stackalloc 0x28\n\t")
+                   __ASM_SEH(".seh_handler nested_exception_handler, @except\n\t")
+                   "callq *0x30(%r9)\n\t"            /* dispatch->LanguageHandler */
+                   "nop\n\t"
+                   "addq $0x28, %rsp\n\t"
+                   "ret" );
+
 /**********************************************************************
  *           call_handler
  *
@@ -363,19 +380,19 @@ static DWORD __cdecl nested_exception_handler( EXCEPTION_RECORD *rec, EXCEPTION_
  */
 static DWORD call_handler( EXCEPTION_RECORD *rec, CONTEXT *context, DISPATCHER_CONTEXT *dispatch )
 {
-    EXCEPTION_REGISTRATION_RECORD frame;
     DWORD res;

-    frame.Handler = nested_exception_handler;
-    __wine_push_frame( &frame );
-
     TRACE_(seh)( "calling handler %p (rec=%p, frame=%p context=%p, dispatch=%p)\n",
                  dispatch->LanguageHandler, rec, (void *)dispatch->EstablisherFrame, dispatch->ContextRecord, dispatch );
-    res = dispatch->LanguageHandler( rec, (void *)dispatch->EstablisherFrame, context, dispatch );
+    res = exception_handler_call_wrapper( rec, (void *)dispatch->EstablisherFrame, context, dispatch );
     TRACE_(seh)( "handler at %p returned %u\n", dispatch->LanguageHandler, res );

     rec->ExceptionFlags &= EH_NONCONTINUABLE;
-    __wine_pop_frame( &frame );
+    if (res == ExceptionNestedException)
+    {
+        rec->ExceptionFlags |= EH_NESTED_CALL;
+        res = ExceptionContinueSearch;
+    }
     return res;
 }

@@ -974,7 +991,8 @@ PVOID WINAPI RtlVirtualUnwind( ULONG type, ULONG64 base, ULONG64 pc,

 struct unwind_exception_frame
 {
-    EXCEPTION_REGISTRATION_RECORD frame;
+    BYTE dummy[0x28];
+    void *rip;
     DISPATCHER_CONTEXT *dispatch;
 };

@@ -983,7 +1001,7 @@ struct unwind_exception_frame
  *
  * Handler for exceptions happening while calling an unwind handler.
  */
-static DWORD __cdecl unwind_exception_handler( EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
+DWORD __cdecl unwind_exception_handler( EXCEPTION_RECORD *rec, EXCEPTION_REGISTRATION_RECORD *frame,
                                                CONTEXT *context, EXCEPTION_REGISTRATION_RECORD **dispatcher )
 {
     struct unwind_exception_frame *unwind_frame = (struct unwind_exception_frame *)frame;
@@ -1003,27 +1021,36 @@ static DWORD __cdecl unwind_exception_handler( EXCEPTION_RECORD *rec, EXCEPTION_
     return ExceptionCollidedUnwind;
 }

+/***********************************************************************
+ *		exception_handler_call_wrapper
+ */
+DWORD unwind_handler_call_wrapper( EXCEPTION_RECORD *rec, void *frame,
+                                      CONTEXT *context, DISPATCHER_CONTEXT *dispatch );
+__ASM_GLOBAL_FUNC( unwind_handler_call_wrapper,
+                   __ASM_SEH(".seh_endprologue\n\t")
+                   "movq %r9, 0x8(%rsp)\n\t"
+                   "subq $0x28, %rsp\n\t"
+                   __ASM_SEH(".seh_stackalloc 0x28\n\t")
+                   __ASM_SEH(".seh_handler unwind_exception_handler, @except, @unwind\n\t")
+                   "callq *0x30(%r9)\n\t"            /* dispatch->LanguageHandler */
+                   "nop\n\t"
+                   "addq $0x28, %rsp\n\t"
+                   "ret" );
+
 /**********************************************************************
  *           call_unwind_handler
  *
  * Call a single unwind handler.
  */
-static DWORD call_unwind_handler( EXCEPTION_RECORD *rec, DISPATCHER_CONTEXT *dispatch )
+DWORD call_unwind_handler( EXCEPTION_RECORD *rec, DISPATCHER_CONTEXT *dispatch )
 {
-    struct unwind_exception_frame frame;
     DWORD res;

-    frame.frame.Handler = unwind_exception_handler;
-    frame.dispatch = dispatch;
-    __wine_push_frame( &frame.frame );
-
     TRACE( "calling handler %p (rec=%p, frame=%p context=%p, dispatch=%p)\n",
            dispatch->LanguageHandler, rec, (void *)dispatch->EstablisherFrame, dispatch->ContextRecord, dispatch );
-    res = dispatch->LanguageHandler( rec, (void *)dispatch->EstablisherFrame, dispatch->ContextRecord, dispatch );
+    res = unwind_handler_call_wrapper( rec, (void *)dispatch->EstablisherFrame, dispatch->ContextRecord, dispatch );
     TRACE( "handler %p returned %x\n", dispatch->LanguageHandler, res );

-    __wine_pop_frame( &frame.frame );
-
     switch (res)
     {
     case ExceptionContinueSearch:
From de668f7cc3095e57a4d6ba3017b68c2e426c84da Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 31 Mar 2020 20:07:49 +0300
Subject: [PATCH] winex11.drv: Remove active client window from window data
 before deleting it.

CW-Bug-ID: #19216

Fixes a crash with BadDrawable X error which happens when client window is used
in windows.c:sync_client_position() after the GL drawable has been deleted.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49649
---
 dlls/winex11.drv/opengl.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 91119e8d393..f4f4063f9a0 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -251,6 +251,7 @@ enum dc_gl_type
 struct gl_drawable
 {
     LONG                           ref;          /* reference count */
+    HWND                           hwnd;
     enum dc_gl_type                type;         /* type of GL surface */
     GLXDrawable                    drawable;     /* drawable for rendering with GL */
     Window                         window;       /* window if drawable is a GLXWindow */
@@ -1296,10 +1297,23 @@ static void release_gl_drawable( struct gl_drawable *gl )
     {
     case DC_GL_WINDOW:
     case DC_GL_CHILD_WIN:
+    {
+        struct x11drv_win_data *data = get_win_data( gl->hwnd );
+
         TRACE( "destroying %lx drawable %lx\n", gl->window, gl->drawable );
+        if (data)
+        {
+            if (data->client_window == gl->window)
+            {
+                XDeleteContext( data->display, data->client_window, winContext );
+                data->client_window = 0;
+            }
+            release_win_data( data );
+        }
         pglXDestroyWindow( gdi_display, gl->drawable );
         XDestroyWindow( gdi_display, gl->window );
         break;
+    }
     case DC_GL_PIXMAP_WIN:
         TRACE( "destroying pixmap %lx drawable %lx\n", gl->pixmap, gl->drawable );
         pglXDestroyPixmap( gdi_display, gl->drawable );
@@ -1456,6 +1470,7 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel
     /* Default GLX and WGL swap interval is 1, but in case of glXSwapIntervalSGI
      * there is no way to query it, so we have to store it here.
      */
+    gl->hwnd = hwnd;
     gl->swap_interval = 1;
     gl->refresh_swap_interval = TRUE;
     gl->format = format;
From 30b6fff2c0571c145d8e8343886a6da1c7510b38 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 8 May 2020 14:32:09 +0300
Subject: [PATCH] ntdll: Use kernel soft dirty flags for write watches support.

Requires kernel patches to have effect.
---
 dlls/kernel32/tests/virtual.c |  52 ++++++++++++-
 dlls/ntdll/unix/virtual.c     | 141 +++++++++++++++++++++++++++++++---
 2 files changed, 179 insertions(+), 14 deletions(-)

diff --git a/dlls/kernel32/tests/virtual.c b/dlls/kernel32/tests/virtual.c
index a3b2d365c33..0632f72d3b2 100644
--- a/dlls/kernel32/tests/virtual.c
+++ b/dlls/kernel32/tests/virtual.c
@@ -2149,15 +2149,61 @@ static void test_write_watch(void)
     ok( count == 1, "wrong count %lu\n", count );
     ok( results[0] == base + 5*pagesize, "wrong result %p\n", results[0] );

+    ret = pResetWriteWatch( base, size );
+    ok( !ret, "pResetWriteWatch failed %u\n", GetLastError() );
+
+    ret = VirtualProtect( base, 6*pagesize, PAGE_READWRITE, &old_prot );
+    ok( ret, "VirtualProtect failed error %u\n", GetLastError() );
+    ok( old_prot == PAGE_NOACCESS, "wrong old prot %x\n", old_prot );
+
+    base[3*pagesize + 200] = 3;
+    base[5*pagesize + 200] = 3;
+
     ret = VirtualFree( base, size, MEM_DECOMMIT );
     ok( ret, "VirtualFree failed %u\n", GetLastError() );

     count = 64;
     ret = pGetWriteWatch( 0, base, size, results, &count, &pagesize );
     ok( !ret, "GetWriteWatch failed %u\n", GetLastError() );
-    ok( count == 1 || broken(count == 0), /* win98 */
-        "wrong count %lu\n", count );
-    if (count) ok( results[0] == base + 5*pagesize, "wrong result %p\n", results[0] );
+    ok( !count, "wrong count %lu\n", count );
+
+    base = VirtualAlloc( base, size, MEM_COMMIT, PAGE_READWRITE );
+    ok(!!base, "VirtualAlloc failed.\n");
+
+    count = 64;
+    ret = pGetWriteWatch( 0, base, size, results, &count, &pagesize );
+    ok( !ret, "GetWriteWatch failed %u\n", GetLastError() );
+    ok( !count, "wrong count %lu\n", count );
+
+    base[3*pagesize + 200] = 3;
+    ret = VirtualProtect( base, 6*pagesize, PAGE_READWRITE, &old_prot );
+    ok( ret, "VirtualProtect failed error %u\n", GetLastError() );
+    ok( old_prot == PAGE_READWRITE, "wrong old prot %x\n", old_prot );
+
+    base[5*pagesize + 200] = 3;
+    count = 64;
+    ret = pGetWriteWatch( 0, base, size, results, &count, &pagesize );
+    ok( !ret, "GetWriteWatch failed %u\n", GetLastError() );
+    ok( count == 2, "wrong count %lu\n", count );
+    ok( results[0] == base + 3*pagesize && results[1] == base + 5*pagesize, "wrong result %p\n", results[0] );
+
+    ret = VirtualFree( base, size, MEM_DECOMMIT );
+    ok( ret, "VirtualFree failed %u\n", GetLastError() );
+
+    count = 64;
+    ret = pGetWriteWatch( 0, base, size, results, &count, &pagesize );
+    ok( !ret, "GetWriteWatch failed %u\n", GetLastError() );
+    todo_wine ok( count == 1, "wrong count %lu\n", count );
+    ok( results[0] == base + 3*pagesize, "wrong result %p\n", results[0] );
+
+    base = VirtualAlloc( base, size, MEM_COMMIT, PAGE_READWRITE );
+    ok(!!base, "VirtualAlloc failed.\n");
+
+    count = 64;
+    ret = pGetWriteWatch( 0, base, size, results, &count, &pagesize );
+    ok( !ret, "GetWriteWatch failed %u\n", GetLastError() );
+    todo_wine ok( count == 1, "wrong count %lu\n", count );
+    ok( results[0] == base + 3*pagesize, "wrong result %p\n", results[0] );

     VirtualFree( base, 0, MEM_RELEASE );
 }
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index e7b23e3dcd4..1317c3bed59 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -202,6 +202,13 @@ static BYTE **pages_vprot;
 static BYTE *pages_vprot;
 #endif

+static BOOL use_kernel_writewatch;
+static int pagemap_fd, pagemap_reset_fd, clear_refs_fd;
+#define PAGE_FLAGS_BUFFER_LENGTH 1024
+#define PM_SOFT_DIRTY_PAGE (1ull << 57)
+
+static void reset_write_watches( void *base, SIZE_T size );
+
 static struct file_view *view_block_start, *view_block_end, *next_free_view;
 static const size_t view_block_size = 0x100000;
 static void *preload_reserve_start;
@@ -1138,7 +1138,7 @@ static int get_unix_prot( BYTE vprot )
         /* FIXME: Architecture needs implementation of signal_init_early. */
         if (vprot & VPROT_WRITECOPY) prot |= PROT_WRITE | PROT_READ;
 #endif
-        if (vprot & VPROT_WRITEWATCH) prot &= ~PROT_WRITE;
+        if (vprot & VPROT_WRITEWATCH && !use_kernel_writewatch) prot &= ~PROT_WRITE;
     }
     if (!prot) prot = PROT_NONE;
     return prot;
@@ -1591,6 +1598,10 @@ static NTSTATUS create_view( struct file_view **view_ret, void *base, size_t siz
         TRACE( "forcing exec permission on %p-%p\n", base, (char *)base + size - 1 );
         mprotect( base, size, unix_prot | PROT_EXEC );
     }
+
+    if (vprot & VPROT_WRITEWATCH && use_kernel_writewatch)
+        reset_write_watches( view->base, view->size );
+
     return STATUS_SUCCESS;
 }

@@ -1714,7 +1725,7 @@ static BOOL set_vprot( struct file_view *view, void *base, size_t size, BYTE vpr
 {
     int unix_prot = get_unix_prot(vprot);

-    if (view->protect & VPROT_WRITEWATCH)
+    if (!use_kernel_writewatch && view->protect & VPROT_WRITEWATCH)
     {
         /* each page may need different protections depending on write watch flag */
         set_page_vprot_bits( base, size, vprot & ~VPROT_WRITEWATCH, ~vprot & ~VPROT_WRITEWATCH );
@@ -1773,8 +1784,24 @@ static void update_write_watches( void *base, size_t size, size_t accessed_size
  */
 static void reset_write_watches( void *base, SIZE_T size )
 {
-    set_page_vprot_bits( base, size, VPROT_WRITEWATCH, 0 );
-    mprotect_range( base, size, 0, 0 );
+    if (use_kernel_writewatch)
+    {
+        char buffer[17];
+        ssize_t ret;
+
+        memset(buffer, 0, sizeof(buffer));
+        buffer[0] = '6';
+        *(void **)&buffer[1] = base;
+        *(void **)&buffer[1 + 8] = (char *)base + size;
+
+        if ((ret = write(clear_refs_fd, buffer, sizeof(buffer))) != sizeof(buffer))
+            ERR("Could not clear soft dirty bits, ret %zd, error %s.\n", ret, strerror(errno));
+    }
+    else
+    {
+        set_page_vprot_bits( base, size, VPROT_WRITEWATCH, 0 );
+        mprotect_range( base, size, 0, 0 );
+    }
 }


@@ -2660,12 +2687,31 @@ void virtual_init(void)
     size_t size;
     int i;
     pthread_mutexattr_t attr;
+    const char *env_var;

     pthread_mutexattr_init( &attr );
     pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
     pthread_mutex_init( &virtual_mutex, &attr );
     pthread_mutexattr_destroy( &attr );

+    if (!((env_var = getenv("WINE_DISABLE_KERNEL_WRITEWATCH")) && atoi(env_var))
+            && (pagemap_reset_fd = open("/proc/self/pagemap_reset", O_RDONLY)) != -1)
+    {
+        use_kernel_writewatch = TRUE;
+        if ((pagemap_fd = open("/proc/self/pagemap", O_RDONLY)) == -1)
+        {
+            ERR("Could not open pagemap file, error %s.\n", strerror(errno));
+            exit(-1);
+        }
+        if ((clear_refs_fd = open("/proc/self/clear_refs", O_WRONLY)) == -1)
+        {
+            ERR("Could not open clear_refs file, error %s.\n", strerror(errno));
+            exit(-1);
+        }
+        if (ERR_ON(virtual))
+            MESSAGE("wine: using kernel write watches (experimental).\n");
+    }
+
     if (preload_info && *preload_info)
         for (i = 0; (*preload_info)[i].size; i++)
             mmap_add_reserved_area( (*preload_info)[i].addr, (*preload_info)[i].size );
@@ -3283,7 +3329,7 @@ NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack )
         }
         else ret = grow_thread_stack( page, &stack_info );
     }
-    else if (err & EXCEPTION_WRITE_FAULT)
+    else if (!use_kernel_writewatch && err & EXCEPTION_WRITE_FAULT)
     {
         if (vprot & VPROT_WRITEWATCH)
         {
@@ -3650,7 +3650,7 @@ static NTSTATUS check_write_access( void *base, size_t size, BOOL *has_write_wat
     for (i = 0; i < size; i += page_size)
     {
         BYTE vprot = get_page_vprot( addr + i );
-        if (vprot & VPROT_WRITEWATCH) *has_write_watch = TRUE;
+        if (!use_kernel_writewatch && vprot & VPROT_WRITEWATCH) *has_write_watch = TRUE;
         if (vprot & VPROT_WRITECOPY)
         {
             vprot = (vprot & ~VPROT_WRITECOPY) | VPROT_WRITE;
@@ -3659,7 +3659,7 @@ static NTSTATUS check_write_access( void *base, size_t size, BOOL *has_write_wat
         if (!(get_unix_prot( vprot & ~VPROT_WRITEWATCH ) & PROT_WRITE))
             return STATUS_INVALID_USER_BUFFER;
     }
-    if (*has_write_watch)
+    if (!use_kernel_writewatch && *has_write_watch)
         mprotect_range( addr, size, VPROT_WRITE, VPROT_WRITEWATCH | VPROT_WRITECOPY );  /* temporarily enable write access */
     return STATUS_SUCCESS;
 }
@@ -4793,17 +4839,90 @@ NTSTATUS WINAPI NtGetWriteWatch( HANDLE process, ULONG flags, PVOID base, SIZE_T
         char *addr = base;
         char *end = addr + size;

-        while (pos < *count && addr < end)
+        if (use_kernel_writewatch)
+        {
+            static UINT64 buffer[PAGE_FLAGS_BUFFER_LENGTH];
+            unsigned int i, length;
+            ssize_t read_length;
+
+            if (flags & WRITE_WATCH_FLAG_RESET)
+            {
+                if (is_win64)
+                {
+                    addresses[0] = end;
+                    if ((read_length = pread(pagemap_reset_fd, addresses, *count * sizeof(*addresses),
+                            ((ULONG_PTR)addr >> page_shift) * sizeof(*addresses))) == -1)
+                    {
+                        ERR("Error reading page flags, read_length %zd, error %s.\n", read_length, strerror(errno));
+                        status = STATUS_INVALID_ADDRESS;
+                        goto done;
+                    }
+                    *count = read_length / sizeof(*addresses);
+                    *granularity = page_size;
+                    goto done;
+                }
+
+                while (pos < *count && addr < end)
+                {
+                    length = min(PAGE_FLAGS_BUFFER_LENGTH, *count - pos);
+
+                    buffer[0] = (ULONG_PTR)end;
+                    if ((read_length = pread(pagemap_reset_fd, buffer, length * sizeof(*buffer),
+                            ((ULONG_PTR)addr >> page_shift) * sizeof(*buffer))) == -1)
+                    {
+                        ERR("Error reading page flags, read_length %zd, error %s.\n", read_length, strerror(errno));
+                        status = STATUS_INVALID_ADDRESS;
+                        goto done;
+                    }
+                    read_length /= sizeof(*buffer);
+                    for (i = 0; i < read_length; ++i)
+                    {
+                        assert(pos < *count);
+                        addresses[pos++] = (void *)(ULONG_PTR)buffer[i];
+                    }
+                    if (read_length < length)
+                        break;
+                    addr = (char *)(ULONG_PTR)buffer[read_length - 1] + page_size;
+                }
+            }
+            else
+            {
+                while (pos < *count && addr < end)
+                {
+                    length = min(PAGE_FLAGS_BUFFER_LENGTH, (end - addr) >> page_shift);
+
+                    if ((read_length = pread(pagemap_fd, buffer, length * sizeof(*buffer),
+                            ((ULONG_PTR)addr >> page_shift) * sizeof(*buffer))) != length * sizeof(*buffer))
+                    {
+                        ERR("Error reading page flags, read_length %zd, error %s.\n", read_length, strerror(errno));
+                        status = STATUS_INVALID_ADDRESS;
+                        goto done;
+                    }
+                    for (i = 0; i < length && pos < *count; ++i)
+                    {
+                        if (buffer[i] & PM_SOFT_DIRTY_PAGE)
+                            addresses[pos++] = addr;
+
+                        addr += page_size;
+                    }
+                }
+            }
+        }
+        else
         {
-            if (!(get_page_vprot( addr ) & VPROT_WRITEWATCH)) addresses[pos++] = addr;
-            addr += page_size;
+            while (pos < *count && addr < end)
+            {
+                if (!(get_page_vprot( addr ) & VPROT_WRITEWATCH)) addresses[pos++] = addr;
+                addr += page_size;
+            }
+            if (flags & WRITE_WATCH_FLAG_RESET) reset_write_watches( base, addr - (char *)base );
         }
-        if (flags & WRITE_WATCH_FLAG_RESET) reset_write_watches( base, addr - (char *)base );
         *count = pos;
         *granularity = page_size;
     }
     else status = STATUS_INVALID_PARAMETER;

+done:
     server_leave_uninterrupted_section( &virtual_mutex, &sigset );
     return status;
 }
From cd792ea3219c7fb5d29a9e3f1b0344de2f93017b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Tue, 30 Nov 2021 16:32:34 +0300
Subject: [PATCH] ntdll: Implement opening files through nt device paths.

CW-Bug-Id: #19697

For Eternal Return.
---
 dlls/ntdll/unix/file.c | 138 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 136 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 3795eb1dd0d..58bee431168 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -3345,7 +3345,7 @@ static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char


 /******************************************************************************
- *           nt_to_unix_file_name
+ *           nt_to_unix_file_name_internal
  *
  * Convert a file name from NT namespace to Unix namespace.
  *
@@ -3353,7 +3353,7 @@ static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char
  * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
  * returned, but the unix name is still filled in properly.
  */
-NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
+NTSTATUS nt_to_unix_file_name_internal( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
 {
     enum server_fd_type type;
     int old_cwd, root_fd, needs_close;
@@ -3414,6 +3414,140 @@ NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, U
 }


+/* read the contents of an NT symlink object */
+static NTSTATUS read_nt_symlink( HANDLE root, UNICODE_STRING *name, WCHAR *target, size_t length )
+{
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING targetW;
+    NTSTATUS status;
+    HANDLE handle;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.ObjectName = name;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if (!(status = NtOpenSymbolicLinkObject( &handle, SYMBOLIC_LINK_QUERY, &attr )))
+    {
+        targetW.Buffer = target;
+        targetW.MaximumLength = (length - 1) * sizeof(WCHAR);
+        status = NtQuerySymbolicLinkObject( handle, &targetW, NULL );
+        NtClose( handle );
+    }
+
+    return status;
+}
+
+/* try to find dos device based on nt device name */
+static NTSTATUS nt_to_dos_device( WCHAR *name, size_t length, WCHAR *device_ret )
+{
+    static const WCHAR dosdevicesW[] = {'\\','D','o','s','D','e','v','i','c','e','s',0};
+    UNICODE_STRING dosdevW = { sizeof(dosdevicesW) - sizeof(WCHAR), sizeof(dosdevicesW), (WCHAR *)dosdevicesW };
+    WCHAR symlinkW[MAX_DIR_ENTRY_LEN];
+    OBJECT_ATTRIBUTES attr;
+    NTSTATUS status;
+    char data[1024];
+    HANDLE handle;
+    ULONG ctx = 0;
+
+    DIRECTORY_BASIC_INFORMATION *info = (DIRECTORY_BASIC_INFORMATION *)data;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.ObjectName = &dosdevW;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    status = NtOpenDirectoryObject( &handle, FILE_LIST_DIRECTORY, &attr );
+    if (status) return STATUS_BAD_DEVICE_TYPE;
+
+    while (!NtQueryDirectoryObject( handle, info, sizeof(data), TRUE, FALSE, &ctx, NULL ))
+    {
+        if (read_nt_symlink( handle, &info->ObjectName, symlinkW, MAX_DIR_ENTRY_LEN )) continue;
+        if (wcsnicmp( symlinkW, name, length )) continue;
+        if (info->ObjectName.Length != 2 * sizeof(WCHAR) || info->ObjectName.Buffer[1] != ':') continue;
+
+        *device_ret = info->ObjectName.Buffer[0];
+        NtClose( handle );
+        return STATUS_SUCCESS;
+    }
+
+    NtClose( handle );
+    return STATUS_BAD_DEVICE_TYPE;
+}
+
+/******************************************************************************
+ *           nt_to_unix_file_name
+ *
+ * Convert a file name from NT namespace to Unix namespace.
+ *
+ * If disposition is not FILE_OPEN or FILE_OVERWRITE, the last path
+ * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
+ * returned, but the unix name is still filled in properly.
+ */
+
+/*( const UNICODE_STRING *nameW, char **unix_name_ret,
+                               UNICODE_STRING *nt_name, UINT disposition )
+*/
+
+NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
+{
+    static const WCHAR systemrootW[] = {'\\','S','y','s','t','e','m','R','o','o','t','\\',0};
+    static const WCHAR dosprefixW[] = {'\\','?','?','\\'};
+    static const WCHAR deviceW[] = {'\\','D','e','v','i','c','e','\\',0};
+    WCHAR *name, *ptr, *prefix, buffer[3] = {'c',':',0};
+    UNICODE_STRING dospathW, *nameW;
+    OBJECT_ATTRIBUTES attr_copy;
+    size_t offset, name_len;
+    NTSTATUS status;
+
+    if (attr->RootDirectory) return nt_to_unix_file_name_internal( attr, name_ret, disposition );
+
+    nameW = attr->ObjectName;
+
+    if (nameW->Length >= sizeof(deviceW) - sizeof(WCHAR)
+        && !wcsnicmp( nameW->Buffer, deviceW, ARRAY_SIZE(deviceW) - 1 ))
+    {
+        offset = sizeof(deviceW) / sizeof(WCHAR);
+        while (offset * sizeof(WCHAR) < nameW->Length && nameW->Buffer[ offset ] != '\\') offset++;
+        if ((status = nt_to_dos_device( nameW->Buffer, offset, buffer ))) return status;
+        prefix = buffer;
+    }
+    else if (nameW->Length >= sizeof(systemrootW) - sizeof(WCHAR) &&
+             !wcsnicmp( nameW->Buffer, systemrootW, ARRAY_SIZE(systemrootW) - 1 ))
+    {
+        offset = (sizeof(systemrootW) - 1) / sizeof(WCHAR);
+        prefix = user_shared_data->NtSystemRoot;
+    }
+    else
+        return nt_to_unix_file_name_internal( attr, name_ret, disposition );
+
+    name_len = sizeof(dosprefixW) + wcslen(prefix) * sizeof(WCHAR) +
+               nameW->Length - offset * sizeof(WCHAR) + sizeof(WCHAR);
+    if (!(name = malloc( name_len )))
+        return STATUS_NO_MEMORY;
+
+    ptr = name;
+    memcpy( ptr, dosprefixW, sizeof(dosprefixW) );
+    ptr += sizeof(dosprefixW) / sizeof(WCHAR);
+    wcscpy( ptr, prefix );
+    ptr += wcslen(ptr);
+    memcpy( ptr, nameW->Buffer + offset, nameW->Length - offset * sizeof(WCHAR) );
+    ptr[ nameW->Length / sizeof(WCHAR) - offset ] = 0;
+
+    dospathW.Buffer = name;
+    dospathW.Length = wcslen( name ) * sizeof(WCHAR);
+    attr_copy = *attr;
+    attr_copy.ObjectName = &dospathW;
+    status = nt_to_unix_file_name_internal( &attr_copy, name_ret, disposition );
+
+    free( name );
+    return status;
+}
+
 /******************************************************************************
  *           wine_nt_to_unix_file_name
  *
From 026d6a997e628295b0e860601dfc0863ae439f8a Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 7 Dec 2021 11:16:40 +0300
Subject: [PATCH] server: Split waitable object off completion port.

CW-Bug-Id: #19621
---
 server/completion.c | 120 +++++++++++++++++++++++++++++++++++---------
 1 file changed, 96 insertions(+), 24 deletions(-)

diff --git a/server/completion.c b/server/completion.c
index 33266c596da..915a083e642 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -56,15 +56,52 @@ struct type_descr completion_type =
     },
 };

-struct completion
+struct completion_wait
 {
     struct object  obj;
     struct list    queue;
     unsigned int   depth;
 };

+struct completion
+{
+    struct object           obj;
+    struct completion_wait *wait;
+};
+
+static void completion_wait_dump( struct object*, int );
+static int completion_wait_signaled( struct object *obj, struct wait_queue_entry *entry );
+static void completion_wait_destroy( struct object * );
+
+static const struct object_ops completion_wait_ops =
+{
+    sizeof(struct completion_wait), /* size */
+    &no_type,                       /* type */
+    completion_wait_dump,           /* dump */
+    add_queue,                      /* add_queue */
+    remove_queue,                   /* remove_queue */
+    completion_wait_signaled,       /* signaled */
+    NULL,                           /* get_esync_fd */
+    NULL,                           /* get_fsync_idx */
+    no_satisfied,                   /* satisfied */
+    no_signal,                      /* signal */
+    no_get_fd,                      /* get_fd */
+    default_map_access,             /* map_access */
+    default_get_sd,                 /* get_sd */
+    default_set_sd,                 /* set_sd */
+    no_get_full_name,               /* get_full_name */
+    no_lookup_name,                 /* lookup_name */
+    no_link_name,                   /* link_name */
+    NULL,                           /* unlink_name */
+    no_open_file,                   /* open_file */
+    no_kernel_obj_list,             /* get_kernel_obj_list */
+    no_close_handle,                /* close_handle */
+    completion_wait_destroy         /* destroy */
+};
+
 static void completion_dump( struct object*, int );
-static int completion_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int completion_add_queue( struct object *obj, struct wait_queue_entry *entry );
+static void completion_remove_queue( struct object *obj, struct wait_queue_entry *entry );
 static void completion_destroy( struct object * );

 static const struct object_ops completion_ops =
@@ -72,9 +109,9 @@ static const struct object_ops completion_ops =
     sizeof(struct completion), /* size */
     &completion_type,          /* type */
     completion_dump,           /* dump */
-    add_queue,                 /* add_queue */
-    remove_queue,              /* remove_queue */
-    completion_signaled,       /* signaled */
+    completion_add_queue,      /* add_queue */
+    completion_remove_queue,   /* remove_queue */
+    NULL,                      /* signaled */
     NULL,                      /* get_esync_fd */
     NULL,                      /* get_fsync_idx */
     no_satisfied,              /* satisfied */
@@ -102,30 +139,63 @@ struct comp_msg
     unsigned int  status;
 };

-static void completion_destroy( struct object *obj)
+static void completion_wait_destroy( struct object *obj)
 {
-    struct completion *completion = (struct completion *) obj;
+    struct completion_wait *wait = (struct completion_wait *)obj;
     struct comp_msg *tmp, *next;

-    LIST_FOR_EACH_ENTRY_SAFE( tmp, next, &completion->queue, struct comp_msg, queue_entry )
+    LIST_FOR_EACH_ENTRY_SAFE( tmp, next, &wait->queue, struct comp_msg, queue_entry )
     {
         free( tmp );
     }
 }

+static void completion_wait_dump( struct object *obj, int verbose )
+{
+    struct completion_wait *wait = (struct completion_wait *)obj;
+
+    assert( obj->ops == &completion_wait_ops );
+    fprintf( stderr, "Completion depth=%u\n", wait->depth );
+}
+
+static int completion_wait_signaled( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct completion_wait *wait = (struct completion_wait *)obj;
+
+    assert( obj->ops == &completion_wait_ops );
+    return !list_empty( &wait->queue );
+}
+
 static void completion_dump( struct object *obj, int verbose )
 {
-    struct completion *completion = (struct completion *) obj;
+    struct completion *completion = (struct completion *)obj;
+
+    assert( obj->ops == &completion_ops );
+    completion->wait->obj.ops->dump( &completion->wait->obj, verbose );
+}
+
+static int completion_add_queue( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct completion *completion = (struct completion *)obj;
+
+    assert( obj->ops == &completion_ops );
+    return completion->wait->obj.ops->add_queue( &completion->wait->obj, entry );
+}
+
+static void completion_remove_queue( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct completion *completion = (struct completion *)obj;

     assert( obj->ops == &completion_ops );
-    fprintf( stderr, "Completion depth=%u\n", completion->depth );
+    completion->wait->obj.ops->remove_queue( &completion->wait->obj, entry );
 }

-static int completion_signaled( struct object *obj, struct wait_queue_entry *entry )
+static void completion_destroy( struct object *obj )
 {
     struct completion *completion = (struct completion *)obj;

-    return !list_empty( &completion->queue );
+    assert( obj->ops == &completion_ops );
+    release_object( &completion->wait->obj );
 }

 static struct completion *create_completion( struct object *root, const struct unicode_str *name,
@@ -134,15 +204,17 @@ static struct completion *create_completion( struct object *root, const struct u
 {
     struct completion *completion;

-    if ((completion = create_named_object( root, &completion_ops, name, attr, sd )))
+    if (!(completion = create_named_object( root, &completion_ops, name, attr, sd ))) return NULL;
+    if (get_error() == STATUS_OBJECT_NAME_EXISTS) return completion;
+    if (!(completion->wait = alloc_object( &completion_wait_ops )))
     {
-        if (get_error() != STATUS_OBJECT_NAME_EXISTS)
-        {
-            list_init( &completion->queue );
-            completion->depth = 0;
-        }
+        release_object( completion );
+        set_error( STATUS_NO_MEMORY );
+        return NULL;
     }

+    list_init( &completion->wait->queue );
+    completion->wait->depth = 0;
     return completion;
 }

@@ -164,9 +236,9 @@ void add_completion( struct completion *completion, apc_param_t ckey, apc_param_
     msg->status = status;
     msg->information = information;

-    list_add_tail( &completion->queue, &msg->queue_entry );
-    completion->depth++;
-    wake_up( &completion->obj, 1 );
+    list_add_tail( &completion->wait->queue, &msg->queue_entry );
+    completion->wait->depth++;
+    wake_up( &completion->wait->obj, 1 );
 }

 /* create a completion */
@@ -220,13 +292,13 @@ DECL_HANDLER(remove_completion)

     if (!completion) return;

-    entry = list_head( &completion->queue );
+    entry = list_head( &completion->wait->queue );
     if (!entry)
         set_error( STATUS_PENDING );
     else
     {
         list_remove( entry );
-        completion->depth--;
+        completion->wait->depth--;
         msg = LIST_ENTRY( entry, struct comp_msg, queue_entry );
         reply->ckey = msg->ckey;
         reply->cvalue = msg->cvalue;
@@ -245,7 +317,7 @@ DECL_HANDLER(query_completion)

     if (!completion) return;

-    reply->depth = completion->depth;
+    reply->depth = completion->wait->depth;

     release_object( completion );
 }
From 17fd5adb927ccded85add314da85330f1a1dd007 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 7 Dec 2021 12:27:17 +0300
Subject: [PATCH] server: Abandon wait when completion port is closed.

CW-Bug-Id: #19621

Based on patches by Alexey Prokhin.
---
 dlls/ntdll/tests/sync.c | 65 +++++++++++++++++++++++++++++++++++++++++
 server/completion.c     | 25 ++++++++++++----
 2 files changed, 85 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/tests/sync.c b/dlls/ntdll/tests/sync.c
index f930767a8b0..562df0f66b0 100644
--- a/dlls/ntdll/tests/sync.c
+++ b/dlls/ntdll/tests/sync.c
@@ -837,6 +837,70 @@ static void test_tid_alert( char **argv )
     CloseHandle( pi.hThread );
 }

+static HANDLE test_close_io_completion_port_ready, test_close_io_completion_test_ready;
+static HANDLE test_close_io_completion_port;
+
+static DWORD WINAPI test_close_io_completion_thread(void *param)
+{
+    FILE_IO_COMPLETION_INFORMATION info;
+    IO_STATUS_BLOCK iosb;
+    ULONG_PTR key, value;
+    NTSTATUS status;
+    ULONG count;
+    DWORD ret;
+
+    ret = WaitForSingleObject( test_close_io_completion_port_ready, INFINITE );
+    ok( ret == WAIT_OBJECT_0, "Got unexpected ret %#x.\n", ret );
+    SetEvent( test_close_io_completion_test_ready );
+    status = NtRemoveIoCompletion( test_close_io_completion_port, &key, &value, &iosb, NULL );
+    if (status == STATUS_INVALID_HANDLE)
+        skip( "Handle closed before wait started.\n" );
+    else
+        ok( status == STATUS_ABANDONED_WAIT_0, "Got unexpected status %#x.\n", status );
+
+    ret = WaitForSingleObject( test_close_io_completion_port_ready, INFINITE );
+    ok( ret == WAIT_OBJECT_0, "Got unexpected ret %#x.\n", ret );
+    SetEvent( test_close_io_completion_test_ready );
+    count = 0xdeadbeef;
+    status = NtRemoveIoCompletionEx( test_close_io_completion_port, &info, 1, &count, NULL, FALSE );
+    ok( count == 1, "Got unexpected count %u.\n", count );
+    if (status == STATUS_INVALID_HANDLE)
+        skip( "Handle closed before wait started.\n" );
+    else
+        ok( status == STATUS_ABANDONED_WAIT_0, "Got unexpected status %#x.\n", status );
+
+    return 0;
+}
+
+static void test_close_io_completion(void)
+{
+    NTSTATUS status;
+    unsigned int i;
+    HANDLE thread;
+    DWORD ret;
+
+    test_close_io_completion_port_ready = CreateEventA(NULL, FALSE, FALSE, NULL);
+    test_close_io_completion_test_ready = CreateEventA(NULL, FALSE, FALSE, NULL);
+
+    thread = CreateThread( NULL, 0, test_close_io_completion_thread, NULL, 0, NULL );
+    ok( !!thread, "Failed to create thread, error %u.\n", GetLastError() );
+
+    for (i = 0; i < 2; ++i)
+    {
+        status = NtCreateIoCompletion( &test_close_io_completion_port, IO_COMPLETION_ALL_ACCESS, NULL, 0 );
+        ok( !status, "Got unexpected status %#x.\n", status );
+        ret = SignalObjectAndWait( test_close_io_completion_port_ready, test_close_io_completion_test_ready,
+                                   INFINITE, FALSE );
+        ok( ret == WAIT_OBJECT_0, "Got unexpected ret %#x.\n", ret );
+        Sleep(10);
+        status = pNtClose( test_close_io_completion_port );
+        ok( !status, "Got unexpected status %#x.\n", status );
+    }
+
+    WaitForSingleObject( thread, INFINITE );
+    CloseHandle( thread );
+}
+
 START_TEST(sync)
 {
     HMODULE module = GetModuleHandleA("ntdll.dll");
@@ -884,4 +948,5 @@ START_TEST(sync)
     test_keyed_events();
     test_resource();
     test_tid_alert( argv );
+    test_close_io_completion();
 }
diff --git a/server/completion.c b/server/completion.c
index 915a083e642..1d70897db83 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -56,11 +56,14 @@ struct type_descr completion_type =
     },
 };

+struct completion;
+
 struct completion_wait
 {
-    struct object  obj;
-    struct list    queue;
-    unsigned int   depth;
+    struct object      obj;
+    struct completion *completion;
+    struct list        queue;
+    unsigned int       depth;
 };

 struct completion
@@ -71,6 +74,7 @@ struct completion

 static void completion_wait_dump( struct object*, int );
 static int completion_wait_signaled( struct object *obj, struct wait_queue_entry *entry );
+static void completion_wait_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void completion_wait_destroy( struct object * );

 static const struct object_ops completion_wait_ops =
@@ -83,7 +87,7 @@ static const struct object_ops completion_wait_ops =
     completion_wait_signaled,       /* signaled */
     NULL,                           /* get_esync_fd */
     NULL,                           /* get_fsync_idx */
-    no_satisfied,                   /* satisfied */
+    completion_wait_satisfied,      /* satisfied */
     no_signal,                      /* signal */
     no_get_fd,                      /* get_fd */
     default_map_access,             /* map_access */
@@ -163,7 +167,15 @@ static int completion_wait_signaled( struct object *obj, struct wait_queue_entry
     struct completion_wait *wait = (struct completion_wait *)obj;

     assert( obj->ops == &completion_wait_ops );
-    return !list_empty( &wait->queue );
+    return !wait->completion || !list_empty( &wait->queue );
+}
+
+static void completion_wait_satisfied( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct completion_wait *wait = (struct completion_wait *)obj;
+
+    assert( obj->ops == &completion_wait_ops );
+    if (!wait->completion) make_wait_abandoned( entry );
 }

 static void completion_dump( struct object *obj, int verbose )
@@ -195,6 +207,8 @@ static void completion_destroy( struct object *obj )
     struct completion *completion = (struct completion *)obj;

     assert( obj->ops == &completion_ops );
+    completion->wait->completion = NULL;
+    wake_up( &completion->wait->obj, 0 );
     release_object( &completion->wait->obj );
 }

@@ -213,6 +227,7 @@ static struct completion *create_completion( struct object *root, const struct u
         return NULL;
     }

+    completion->wait->completion = completion;
     list_init( &completion->wait->queue );
     completion->wait->depth = 0;
     return completion;
From a4f3fe1348f746376efd595ddc353a976ed650c4 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 7 Dec 2021 13:33:01 +0300
Subject: [PATCH] server: Ensure completion port wait object exists after
 successful wait.

CW-Bug-Id: #19621

Based on the problem analysis by Andrew Eikum.
---
 dlls/ntdll/unix/sync.c |  6 ++++++
 server/completion.c    | 36 ++++++++++++++++++++++++++++++------
 server/protocol.def    |  1 +
 server/thread.c        |  2 ++
 server/thread.h        |  1 +
 5 files changed, 40 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 8bd38f09e44..af0c53d441e 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -1939,6 +1939,7 @@ NTSTATUS WINAPI NtRemoveIoCompletion( HANDLE handle, ULONG_PTR *key, ULONG_PTR *
                                       IO_STATUS_BLOCK *io, LARGE_INTEGER *timeout )
 {
     NTSTATUS status;
+    int waited = 0;

     TRACE( "(%p, %p, %p, %p, %p)\n", handle, key, value, io, timeout );

@@ -1947,6 +1948,7 @@ NTSTATUS WINAPI NtRemoveIoCompletion( HANDLE handle, ULONG_PTR *key, ULONG_PTR *
         SERVER_START_REQ( remove_completion )
         {
             req->handle = wine_server_obj_handle( handle );
+            req->waited = waited;
             if (!(status = wine_server_call( req )))
             {
                 *key            = reply->ckey;
@@ -1959,6 +1961,7 @@ NTSTATUS WINAPI NtRemoveIoCompletion( HANDLE handle, ULONG_PTR *key, ULONG_PTR *
         if (status != STATUS_PENDING) return status;
         status = NtWaitForSingleObject( handle, FALSE, timeout );
         if (status != WAIT_OBJECT_0) return status;
+        waited = 1;
     }
 }

@@ -1970,6 +1973,7 @@ NTSTATUS WINAPI NtRemoveIoCompletionEx( HANDLE handle, FILE_IO_COMPLETION_INFORM
                                         ULONG *written, LARGE_INTEGER *timeout, BOOLEAN alertable )
 {
     NTSTATUS status;
+    int waited = 0;
     ULONG i = 0;

     TRACE( "%p %p %u %p %p %u\n", handle, info, count, written, timeout, alertable );
@@ -1981,6 +1985,7 @@ NTSTATUS WINAPI NtRemoveIoCompletionEx( HANDLE handle, FILE_IO_COMPLETION_INFORM
             SERVER_START_REQ( remove_completion )
             {
                 req->handle = wine_server_obj_handle( handle );
+                req->waited = waited;
                 if (!(status = wine_server_call( req )))
                 {
                     info[i].CompletionKey             = reply->ckey;
@@ -2000,6 +2005,7 @@ NTSTATUS WINAPI NtRemoveIoCompletionEx( HANDLE handle, FILE_IO_COMPLETION_INFORM
         }
         status = NtWaitForSingleObject( handle, alertable, timeout );
         if (status != WAIT_OBJECT_0) break;
+        waited = 1;
     }
     *written = i ? i : 1;
     return status;
diff --git a/server/completion.c b/server/completion.c
index 1d70897db83..cbafe811796 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -173,9 +173,16 @@ static int completion_wait_signaled( struct object *obj, struct wait_queue_entry
 static void completion_wait_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct completion_wait *wait = (struct completion_wait *)obj;
+    struct thread *thread;

     assert( obj->ops == &completion_wait_ops );
-    if (!wait->completion) make_wait_abandoned( entry );
+    if (wait->completion)
+    {
+        thread = get_wait_queue_thread( entry );
+        if (thread->locked_completion) release_object( thread->locked_completion );
+        thread->locked_completion = grab_object( obj );
+    }
+    else make_wait_abandoned( entry );
 }

 static void completion_dump( struct object *obj, int verbose )
@@ -301,19 +308,36 @@ DECL_HANDLER(add_completion)
 /* get completion from completion port */
 DECL_HANDLER(remove_completion)
 {
-    struct completion* completion = get_completion_obj( current->process, req->handle, IO_COMPLETION_MODIFY_STATE );
+    struct completion* completion;
+    struct completion_wait *wait;
     struct list *entry;
     struct comp_msg *msg;

-    if (!completion) return;
+    if (req->waited && (wait = (struct completion_wait *)current->locked_completion))
+        current->locked_completion = NULL;
+    else
+    {
+        if (current->locked_completion)
+        {
+            release_object( current->locked_completion );
+            current->locked_completion = NULL;
+        }
+        completion = get_completion_obj( current->process, req->handle, IO_COMPLETION_MODIFY_STATE );
+        if (!completion) return;
+
+        wait = (struct completion_wait *)grab_object( completion->wait );
+        release_object( completion );
+    }

-    entry = list_head( &completion->wait->queue );
+    assert( wait->obj.ops == &completion_wait_ops );
+
+    entry = list_head( &wait->queue );
     if (!entry)
         set_error( STATUS_PENDING );
     else
     {
         list_remove( entry );
-        completion->wait->depth--;
+        wait->depth--;
         msg = LIST_ENTRY( entry, struct comp_msg, queue_entry );
         reply->ckey = msg->ckey;
         reply->cvalue = msg->cvalue;
@@ -322,7 +346,7 @@ DECL_HANDLER(remove_completion)
         free( msg );
     }

-    release_object( completion );
+    release_object( wait );
 }

 /* get queue depth for completion port */
diff --git a/server/protocol.def b/server/protocol.def
index 586122a9928..b25a3ee2fd6 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3479,6 +3479,7 @@ struct handle_info
 /* get completion from completion port queue */
 @REQ(remove_completion)
     obj_handle_t handle;          /* port handle */
+    int          waited;          /* port was just successfully waited on */
 @REPLY
     apc_param_t   ckey;           /* completion key */
     apc_param_t   cvalue;         /* completion value */
diff --git a/server/thread.c b/server/thread.c
index 6300fda0396..c7cfb1cdded 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -295,6 +295,7 @@ static inline void init_thread_structure( struct thread *thread )

     thread->creation_time = current_time;
     thread->exit_time     = 0;
+    thread->locked_completion = NULL;

     list_init( &thread->mutex_list );
     list_init( &thread->system_apc );
@@ -512,6 +513,7 @@ static void destroy_thread( struct object *obj )
     release_object( thread->process );
     if (thread->id) free_ptid( thread->id );
     if (thread->token) release_object( thread->token );
+    if (thread->locked_completion) release_object( thread->locked_completion );

     if (do_esync())
         close( thread->esync_fd );
diff --git a/server/thread.h b/server/thread.h
index d9c782e7bee..824c4090182 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -95,6 +95,7 @@ struct thread
     data_size_t            desc_len;      /* thread description length in bytes */
     WCHAR                 *desc;          /* thread description string */
     struct timeout_user   *exit_poll;     /* poll if the thread/process has exited already */
+    struct object         *locked_completion; /* completion port wait object successfully waited by the thread */
 };

 extern struct thread *current;
From 74c1b244095cad0efbb48a65049ab638daad4093 Mon Sep 17 00:00:00 2001
From: Alexey Prokhin <alexey@prokhin.ru>
Date: Thu, 23 Apr 2020 12:29:55 +0300
Subject: [PATCH] kernelbase: Set the proper error code in
 GetQueuedCompletionStatus{Ex} when the handle is closed.

Planet Zoo relies on it being ERROR_ABANDONED_WAIT_0.
---
 dlls/kernelbase/sync.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernelbase/sync.c b/dlls/kernelbase/sync.c
index 1ae72c770eb..c6e4150749e 100644
--- a/dlls/kernelbase/sync.c
+++ b/dlls/kernelbase/sync.c
@@ -1067,6 +1067,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetQueuedCompletionStatus( HANDLE port, LPDWORD co
     }

     if (status == STATUS_TIMEOUT) SetLastError( WAIT_TIMEOUT );
+    else if (status == ERROR_WAIT_NO_CHILDREN) SetLastError( ERROR_ABANDONED_WAIT_0 );
     else SetLastError( RtlNtStatusToDosError(status) );
     return FALSE;
 }
@@ -1088,6 +1089,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetQueuedCompletionStatusEx( HANDLE port, OVERLAPP
     if (ret == STATUS_SUCCESS) return TRUE;
     else if (ret == STATUS_TIMEOUT) SetLastError( WAIT_TIMEOUT );
     else if (ret == STATUS_USER_APC) SetLastError( WAIT_IO_COMPLETION );
+    else if (ret == ERROR_WAIT_NO_CHILDREN) SetLastError( ERROR_ABANDONED_WAIT_0 );
     else SetLastError( RtlNtStatusToDosError(ret) );
     return FALSE;
 }
From e9565a4160533f5236e635849495d4203f6853b7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 24 Apr 2020 14:37:58 +0300
Subject: [PATCH] server: Try to retrieve the unix name on handles created from
 file descriptors.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46070
Signed-off-by: Gabriel Ivncescu <gabrielopcode@gmail.com>

Fixes Unity of Command II, and possibly other games that use
Python38.dll.
---
 server/fd.c   | 39 +++++++++++++++++++++++++++++++++++++++
 server/file.c |  1 +
 server/file.h |  2 ++
 3 files changed, 42 insertions(+)

diff --git a/server/fd.c b/server/fd.c
index 7ee687f2dfc..0bd29c016d0 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -2143,6 +2143,45 @@ struct fd *create_anonymous_fd( const struct fd_ops *fd_user_ops, int unix_fd, s
     return NULL;
 }

+void set_unix_name_of_fd( struct fd *fd, const struct stat *fd_st )
+{
+#ifdef __linux__
+    static const char procfs_fmt[] = "/proc/self/fd/%d";
+
+    char path[PATH_MAX], procfs_path[sizeof(procfs_fmt) - 2 /* %d */ + 11];
+    struct stat path_st;
+    ssize_t len;
+
+    sprintf( procfs_path, procfs_fmt, fd->unix_fd );
+    len = readlink( procfs_path, path, sizeof(path) );
+    if (len == -1 || len >= sizeof(path) )
+        return;
+    path[len] = '\0';
+
+    /* Make sure it's an absolute path, has at least one hardlink, and the same inode */
+    if (path[0] != '/' || stat( path, &path_st ) || path_st.st_nlink < 1 ||
+        path_st.st_dev != fd_st->st_dev || path_st.st_ino != fd_st->st_ino)
+        return;
+
+    if (!(fd->unix_name = mem_alloc( len + 1 )))
+        return;
+    memcpy( fd->unix_name, path, len + 1 );
+
+#elif defined(F_GETPATH)
+    char path[PATH_MAX];
+    size_t size;
+
+    if (fcntl( fd->unix_fd, F_GETPATH, path ) == -1 || path[0] != '/')
+        return;
+
+    size = strlen(path) + 1;
+    if (!(fd->unix_name = mem_alloc( size )))
+        return;
+    memcpy( fd->unix_name, path, size );
+
+#endif
+}
+
 /* retrieve the object that is using an fd */
 void *get_fd_user( struct fd *fd )
 {
diff --git a/server/file.c b/server/file.c
index c2b06e29717..dfc59e83034 100644
--- a/server/file.c
+++ b/server/file.c
@@ -157,6 +157,7 @@ struct file *create_file_for_fd( int fd, unsigned int access, unsigned int shari
         release_object( file );
         return NULL;
     }
+    set_unix_name_of_fd( file->fd, &st );
     allow_fd_caching( file->fd );
     return file;
 }
diff --git a/server/file.h b/server/file.h
index 38964d73c13..629862baf8d 100644
--- a/server/file.h
+++ b/server/file.h
@@ -22,6 +22,7 @@
 #define __WINE_SERVER_FILE_H

 #include <sys/types.h>
+#include <sys/stat.h>

 #include "object.h"

@@ -85,6 +86,7 @@ extern struct fd *open_fd( struct fd *root, const char *name, struct unicode_str
                            unsigned int sharing, unsigned int options );
 extern struct fd *create_anonymous_fd( const struct fd_ops *fd_user_ops,
                                        int unix_fd, struct object *user, unsigned int options );
+extern void set_unix_name_of_fd( struct fd *fd, const struct stat *fd_st );
 extern struct fd *dup_fd_object( struct fd *orig, unsigned int access, unsigned int sharing,
                                  unsigned int options );
 extern struct fd *get_fd_object_for_mapping( struct fd *fd, unsigned int access, unsigned int sharing );
From c5a21ea2930f5e391b62c492bdf3f2fd075f310d Mon Sep 17 00:00:00 2001
From: Giovanni Mascellani <gmascellani@codeweavers.com>
Date: Tue, 27 Apr 2021 10:51:12 +0200
Subject: [PATCH] HACK: winex11.drv: Fix drawing of layered windows with a
 client window.

CW-Bug-Id: #18807
---
 dlls/winex11.drv/event.c       |  5 ++++-
 dlls/winex11.drv/x11drv.h      |  2 ++
 dlls/winex11.drv/x11drv_main.c | 12 ++++++++++++
 3 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 5cb08de99eb..b0ef922ca5d 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -992,7 +992,10 @@ static BOOL X11DRV_Expose( HWND hwnd, XEvent *xev )
     rect.right  = pos.x + event->width;
     rect.bottom = pos.y + event->height;

-    if (event->window != data->client_window)
+    if (layered_window_client_hack && event->window == data->client_window)
+        OffsetRect( &rect, data->client_rect.left - data->whole_rect.left,
+                    data->client_rect.top - data->whole_rect.top );
+    if (layered_window_client_hack || event->window != data->client_window)
     {
         if (data->surface)
         {
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index fb4546e302c..ed4abd802c1 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -890,4 +890,6 @@ static inline BOOL is_window_rect_mapped( const RECT *rect )
             max( rect->bottom, rect->top + 1 ) > virtual_rect.top);
 }

+extern BOOL layered_window_client_hack;
+
 #endif  /* __WINE_X11DRV_H */
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 4e49de12138..a03eb52ad46 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -90,6 +90,7 @@ int xfixes_event_base = 0;
 HMODULE x11drv_module = 0;
 char *process_name = NULL;
 HANDLE steam_overlay_event;
+BOOL layered_window_client_hack = FALSE;

 static x11drv_error_callback err_callback;   /* current callback for error */
 static Display *err_callback_display;        /* display callback is set for */
@@ -713,6 +714,17 @@ static BOOL process_attach(void)

     fs_hack_init();

+    {
+        const char *sgi = getenv("SteamGameId");
+        const char *e = getenv("WINE_LAYERED_WINDOW_CLIENT_HACK");
+        layered_window_client_hack =
+            (sgi && (
+                strcmp(sgi, "435150") == 0 || /* Divinity: Original Sin 2 launcher */
+                strcmp(sgi, "227020") == 0 /* Rise of Venice launcher */
+            )) ||
+            (e && *e != '\0' && *e != '0');
+    }
+
     init_user_driver();
     X11DRV_DisplayDevices_Init(FALSE);
     return TRUE;
From e9ecb95ae4a0bde8d6e03776e556aa4c5fdf623b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 10 Sep 2021 09:46:52 +0200
Subject: [PATCH] wine.inf: Force clobber pdffile shell open command.

Cw-Bug-Id: #19035
---
 loader/wine.inf.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index bbaade48799..a702100e248 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -319,7 +319,7 @@ HKCR,Msi.Patch,,2,"Windows Installer Patch"
 HKCR,Msi.Patch\DefaultIcon,,2,"msiexec.exe"
 HKCR,Msi.Patch\shell\Open\command,,2,"%11%\msiexec.exe /p ""%1"""
 HKCR,pdffile,,2,"PDF Document"
-HKCR,pdffile\shell\open\command,,2,"""%11%\winebrowser.exe"" ""%1"""
+HKCR,pdffile\shell\open\command,,,"""%11%\winebrowser.exe"" ""%1"""
 HKCR,rtffile,,2,"Rich Text Document"
 HKCR,rtffile\shell\open\command,,2,"""%16422%\Windows NT\Accessories\wordpad.exe"" ""%1"""
 HKCR,rtffile\shell\print\command,,2,"""%16422%\Windows NT\Accessories\wordpad.exe"" /p ""%1"""
From b94e737d43384fdde0e332b6669d9074f04ef329 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 26 Jul 2021 17:36:04 +0300
Subject: [PATCH] kernel32: Align stack pointer for lstrcpyA() on x64.

For Blood of Steel crash on launch.

CW-Bug-Id: #19148
---
 dlls/kernel32/virtual.c | 40 +++++++++++++++++++++++++++++++++++++++-
 1 file changed, 39 insertions(+), 1 deletion(-)

diff --git a/dlls/kernel32/virtual.c b/dlls/kernel32/virtual.c
index f5693de4e28..800c25d34cd 100644
--- a/dlls/kernel32/virtual.c
+++ b/dlls/kernel32/virtual.c
@@ -36,6 +36,7 @@
 #include "psapi.h"
 #include "wine/exception.h"
 #include "wine/debug.h"
+#include "wine/asm.h"

 #include "kernel_private.h"

@@ -294,7 +295,8 @@ LPWSTR WINAPI lstrcatW( LPWSTR dst, LPCWSTR src )
  *           lstrcpyA   (KERNEL32.@)
  *           lstrcpy    (KERNEL32.@)
  */
-LPSTR WINAPI lstrcpyA( LPSTR dst, LPCSTR src )
+#ifdef __x86_64__
+LPSTR WINAPI lstrcpyA_impl( LPSTR dst, LPCSTR src )
 {
     __TRY
     {
@@ -310,6 +312,42 @@ LPSTR WINAPI lstrcpyA( LPSTR dst, LPCSTR src )
     return dst;
 }

+__ASM_GLOBAL_FUNC( lstrcpyA,
+                   ".byte 0x48, 0x8d, 0xa4, 0x24, 0x00, 0x00, 0x00, 0x00\n\t"
+                   "pushq %rbp\n\t"
+                   __ASM_SEH(".seh_pushreg %rbp\n\t")
+                   __ASM_CFI(".cfi_adjust_cfa_offset 8\n\t")
+                   __ASM_CFI(".cfi_rel_offset %rbp,0\n\t")
+                   "movq %rsp,%rbp\n\t"
+                   __ASM_SEH(".seh_setframe %rbp,0\n\t")
+                   __ASM_CFI(".cfi_def_cfa_register %rbp\n\t")
+                   __ASM_SEH(".seh_endprologue\n\t")
+                   "subq $0x20,%rsp\n\t"
+                   "andq $~15,%rsp\n\t"
+                   "call " __ASM_NAME("lstrcpyA_impl") "\n\t"
+                   "leaq 0(%rbp),%rsp\n\t"
+                   __ASM_CFI(".cfi_def_cfa_register %rsp\n\t")
+                   "popq %rbp\n\t"
+                   __ASM_CFI(".cfi_adjust_cfa_offset -8\n\t")
+                   __ASM_CFI(".cfi_same_value %rbp\n\t")
+                   "ret" )
+#else /* __x86_64__ */
+LPSTR WINAPI lstrcpyA( LPSTR dst, LPCSTR src )
+{
+    __TRY
+    {
+        /* this is how Windows does it */
+        memmove( dst, src, strlen(src)+1 );
+    }
+    __EXCEPT( badptr_handler )
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return NULL;
+    }
+    __ENDTRY
+    return dst;
+}
+#endif

 /***********************************************************************
  *           lstrcpyW   (KERNEL32.@)
From 537afeeb629a14baa467de6c8ce0084a5727edf8 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 14 Jul 2021 20:45:38 +0300
Subject: [PATCH] ntdll: Add stub implementation for
 NtSetInformationFile(FileAllocationInformation).

CW-Bug-Id: #19085
---
 dlls/ntdll/unix/file.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 58bee431168..cf4eb431773 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -4558,6 +4558,15 @@ NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
         else status = STATUS_INVALID_PARAMETER_3;
         break;

+    case FileAllocationInformation:
+    {
+        const FILE_ALLOCATION_INFORMATION *info = ptr;
+
+        FIXME("FileAllocationInformation AllocationSize %p stub.\n", (void *)(ULONG_PTR)info->AllocationSize.QuadPart);
+        io->u.Status = STATUS_SUCCESS;
+        break;
+    }
+
     case FilePipeInformation:
         if (len >= sizeof(FILE_PIPE_INFORMATION))
         {
From c4872f67ec7b9ff5c68f2b82866a0b7f9cf46836 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 14 Jul 2021 20:43:39 +0300
Subject: [PATCH] ntdll: Support '\??\GlobalRoot' prefix in
 get_dos_prefix_len().

CW-Bug-Id: #19085
---
 dlls/ntdll/unix/file.c | 29 ++++++++++++++++++++++-------
 1 file changed, 22 insertions(+), 7 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index cf4eb431773..3f60060bb38 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -2865,16 +2865,31 @@ static inline int get_dos_prefix_len( const UNICODE_STRING *name )
 {
     static const WCHAR nt_prefixW[] = {'\\','?','?','\\'};
     static const WCHAR dosdev_prefixW[] = {'\\','D','o','s','D','e','v','i','c','e','s','\\'};
+    static const WCHAR globalrootW[] = {'\\','?','?','\\','G','l','o','b','a','l','R','o','o','t'};
+    int prefix_len = 0;
+    WCHAR *prefix;
+    USHORT length;

-    if (name->Length >= sizeof(nt_prefixW) &&
-        !memcmp( name->Buffer, nt_prefixW, sizeof(nt_prefixW) ))
-        return ARRAY_SIZE( nt_prefixW );
+    prefix = name->Buffer;
+    length = name->Length;

-    if (name->Length >= sizeof(dosdev_prefixW) &&
-        !wcsnicmp( name->Buffer, dosdev_prefixW, ARRAY_SIZE( dosdev_prefixW )))
-        return ARRAY_SIZE( dosdev_prefixW );
+    if (length >= ARRAY_SIZE( globalrootW ) &&
+        !wcsnicmp( prefix, globalrootW, ARRAY_SIZE( globalrootW )))
+    {
+        WARN("Stripping off GlobalRoot prefix.\n");
+        prefix += ARRAY_SIZE( globalrootW );
+        prefix_len += ARRAY_SIZE( globalrootW );
+        length -= ARRAY_SIZE( globalrootW );
+    }
+
+    if (length >= sizeof(nt_prefixW) &&
+        !memcmp( prefix, nt_prefixW, sizeof(nt_prefixW) ))
+        prefix_len += ARRAY_SIZE( nt_prefixW );
+    else if (length >= sizeof(dosdev_prefixW) &&
+        !wcsnicmp( prefix, dosdev_prefixW, ARRAY_SIZE( dosdev_prefixW )))
+        prefix_len += ARRAY_SIZE( dosdev_prefixW );

-    return 0;
+    return prefix_len;
 }


From c5aa20a70a5e681ba718feb7db9adc357cb7bec0 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 31 Aug 2021 00:41:15 +0300
Subject: [PATCH] winex11.drv: HACK: Mind insert_after X11DRV_WindowPosChanged
 in some cases.

Fixes FH4 rendering black window until focus is lost.

CW-Bug-Id: #19335
---
 dlls/winex11.drv/window.c | 51 ++++++++++++++++++++++++++++++++++-----
 1 file changed, 45 insertions(+), 6 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 4cd2324bff2..815a6279e59 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1481,17 +1481,18 @@ void X11DRV_X_to_window_rect( struct x11drv_win_data *data, RECT *rect, int x, i
  *
  * Synchronize the X window position with the Windows one
  */
-static void sync_window_position( struct x11drv_win_data *data,
+static HWND sync_window_position( struct x11drv_win_data *data,
                                   UINT swp_flags, const RECT *old_window_rect,
                                   const RECT *old_whole_rect, const RECT *old_client_rect )
 {
     DWORD style = GetWindowLongW( data->hwnd, GWL_STYLE );
     DWORD ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
+    HWND prev_window = NULL;
     RECT original_rect = {0};
     XWindowChanges changes;
     unsigned int mask = 0;

-    if (data->managed && data->iconic) return;
+    if (data->managed && data->iconic) return NULL;

     /* resizing a managed maximized window is not allowed */
     if (!(style & WS_MAXIMIZE) || !data->managed)
@@ -1529,9 +1530,10 @@ static void sync_window_position( struct x11drv_win_data *data,
     {
         /* find window that this one must be after */
         HWND prev = GetWindow( data->hwnd, GW_HWNDPREV );
+
         while (prev && !(GetWindowLongW( prev, GWL_STYLE ) & WS_VISIBLE))
             prev = GetWindow( prev, GW_HWNDPREV );
-        if (!prev)  /* top child */
+        if (!(prev_window = prev))  /* top child */
         {
             changes.stack_mode = Above;
             mask |= CWStackMode;
@@ -1552,6 +1554,7 @@ static void sync_window_position( struct x11drv_win_data *data,
     update_net_wm_states( data );
     data->configure_serial = NextRequest( data->display );
     XReconfigureWMWindow( data->display, data->whole_window, data->vis.screen, mask, &changes );
+
     if (!IsRectEmpty( &original_rect ))
     {
         data->whole_rect = original_rect;
@@ -1577,6 +1580,8 @@ static void sync_window_position( struct x11drv_win_data *data,
            data->whole_rect.right - data->whole_rect.left,
            data->whole_rect.bottom - data->whole_rect.top,
            changes.sibling, mask, data->configure_serial );
+
+    return prev_window;
 }


@@ -2733,6 +2738,25 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
 }


+static void restack_windows( struct x11drv_win_data *data, HWND prev )
+{
+    struct x11drv_win_data *prev_data;
+
+    TRACE("data->hwnd %p, prev %p.\n", data->hwnd, prev);
+
+    while (prev)
+    {
+        if (!(prev_data = get_win_data( prev ))) break;
+
+        TRACE( "Raising window %p.\n", prev );
+
+        if (prev_data->whole_window && data->display == prev_data->display)
+            XRaiseWindow( prev_data->display, prev_data->whole_window );
+        release_win_data( prev_data );
+        prev = GetWindow( prev, GW_HWNDPREV );
+    }
+}
+
 /***********************************************************************
  *		WindowPosChanged   (X11DRV.@)
  */
@@ -2745,6 +2769,7 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
     struct x11drv_win_data *data;
     DWORD new_style = GetWindowLongW( hwnd, GWL_STYLE );
     RECT old_window_rect, old_whole_rect, old_client_rect;
+    HWND prev_window = NULL;
     int event_type;

     if (!(data = get_win_data( hwnd ))) return;
@@ -2847,8 +2872,8 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags

     /* don't change position if we are about to minimize or maximize a managed window */
     if ((!event_type || event_type == PropertyNotify) &&
-        !(data->managed && (swp_flags & SWP_STATECHANGED) && (new_style & (WS_MINIMIZE|WS_MAXIMIZE))))
-        sync_window_position( data, swp_flags, &old_window_rect, &old_whole_rect, &old_client_rect );
+            !(data->managed && (swp_flags & SWP_STATECHANGED) && (new_style & (WS_MINIMIZE|WS_MAXIMIZE))))
+        prev_window = sync_window_position( data, swp_flags, &old_window_rect, &old_whole_rect, &old_client_rect );

     if ((new_style & WS_VISIBLE) &&
         ((new_style & WS_MINIMIZE) || is_window_rect_mapped( rectWindow )))
@@ -2864,6 +2889,10 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
             release_win_data( data );
             if (needs_icon) fetch_icon_data( hwnd, 0, 0 );
             if (needs_map) map_window( hwnd, new_style );
+
+            if (!(data = get_win_data( hwnd ))) return;
+            restack_windows( data, prev_window );
+            release_win_data( data );
             return;
         }
         else if ((swp_flags & SWP_STATECHANGED) && (!data->iconic != !(new_style & WS_MINIMIZE)))
@@ -2880,10 +2909,20 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
         else
         {
             if (swp_flags & (SWP_FRAMECHANGED|SWP_STATECHANGED)) set_wm_hints( data );
-            if (!event_type || event_type == PropertyNotify) update_net_wm_states( data );
+            if (!event_type || event_type == PropertyNotify)
+            {
+                update_net_wm_states( data );
+                if (!prev_window && insert_after && data->net_wm_state & (1 << NET_WM_STATE_FULLSCREEN))
+                {
+                    prev_window = GetWindow( hwnd, GW_HWNDPREV );
+                    if (prev_window != insert_after) prev_window = NULL;
+                }
+            }
         }
     }

+    restack_windows( data, prev_window );
+
     XFlush( data->display );  /* make sure changes are done before we start painting again */
     if (data->surface && data->vis.visualid != default_visual.visualid)
         data->surface->funcs->flush( data->surface );
From 5726c4a62f9febce68a352d1e8a99a15325fe25c Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 6 Apr 2021 19:43:48 +0300
Subject: [PATCH] ntdll: Simulate async file read and IO cancellation to
 workaround AC:Odyssey out of order dialogues bug.

CW-Bug-ID: #18881
---
 dlls/ntdll/unix/file.c   | 237 +++++++++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/loader.c |   6 +-
 2 files changed, 242 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 3f60060bb38..850c70a6b2b 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -5295,6 +5295,230 @@ static NTSTATUS set_pending_write( HANDLE device )
     return status;
 }

+static pthread_mutex_t async_file_read_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t async_file_read_cond = PTHREAD_COND_INITIALIZER;
+
+struct async_file_read_job
+{
+    HANDLE handle;
+    int unix_handle;
+    int needs_close;
+    HANDLE event;
+    IO_STATUS_BLOCK *io;
+    void *buffer;
+    ULONG length;
+    LARGE_INTEGER offset;
+    DWORD thread_id;
+    LONG  cancelled;
+    struct list queue_entry;
+    struct async_file_read_job *next;
+};
+
+
+static struct list async_file_read_queue = LIST_INIT( async_file_read_queue );
+static struct async_file_read_job *async_file_read_running, *async_file_read_free;
+
+static void async_file_complete_io( struct async_file_read_job *job, NTSTATUS status, ULONG total )
+{
+    job->io->u.Status = status;
+    job->io->Information = total;
+
+    if (job->event) NtSetEvent( job->event, NULL );
+}
+
+static void *async_file_read_thread(void *dummy)
+{
+    struct async_file_read_job *job, *ptr;
+    ULONG buffer_length = 0;
+    void *buffer = NULL;
+    struct list *entry;
+    NTSTATUS status;
+    ULONG total;
+    int result;
+
+    pthread_mutex_lock( &async_file_read_mutex );
+    while (1)
+    {
+        while (!(entry = list_head( &async_file_read_queue )))
+        {
+            pthread_cond_wait( &async_file_read_cond, &async_file_read_mutex );
+            continue;
+        }
+
+        job = LIST_ENTRY( entry, struct async_file_read_job, queue_entry );
+        list_remove( entry );
+
+        total = 0;
+
+        if ( job->cancelled )
+        {
+            pthread_mutex_unlock( &async_file_read_mutex );
+            status = STATUS_CANCELLED;
+            goto done;
+        }
+
+        job->next = async_file_read_running;
+        async_file_read_running = job;
+        pthread_mutex_unlock( &async_file_read_mutex );
+
+        if (!buffer_length)
+        {
+            buffer = malloc(job->length);
+            buffer_length = job->length;
+        }
+        else if (buffer_length < job->length)
+        {
+            buffer = realloc(buffer, job->length);
+            buffer_length = job->length;
+        }
+
+        while ((result = pread( job->unix_handle, buffer, job->length, job->offset.QuadPart )) == -1)
+        {
+            if (errno != EINTR)
+            {
+                status = errno_to_status( errno );
+                goto done;
+            }
+            if (job->cancelled)
+                break;
+        }
+
+        total = result;
+        status = (total || !job->length) ? STATUS_SUCCESS : STATUS_END_OF_FILE;
+done:
+        if (job->needs_close) close( job->unix_handle );
+
+        if (!InterlockedCompareExchange(&job->cancelled, 1, 0))
+        {
+            if (status == STATUS_SUCCESS)
+                memcpy( job->buffer, buffer, total );
+
+            async_file_complete_io( job, status, total );
+        }
+
+        pthread_mutex_lock( &async_file_read_mutex );
+
+        if (status != STATUS_CANCELLED)
+        {
+            ptr = async_file_read_running;
+            if (job == ptr)
+            {
+                async_file_read_running = job->next;
+            }
+            else
+            {
+                while (ptr && ptr->next != job)
+                    ptr = ptr->next;
+
+                assert( ptr );
+                ptr->next = job->next;
+            }
+        }
+
+        job->next = async_file_read_free;
+        async_file_read_free = job;
+    }
+
+    return NULL;
+}
+
+static pthread_once_t async_file_read_once = PTHREAD_ONCE_INIT;
+
+static void async_file_read_init(void)
+{
+    pthread_t async_file_read_thread_id;
+    pthread_attr_t pthread_attr;
+
+    ERR("HACK: AC Odyssey async read workaround.\n");
+
+    pthread_attr_init( &pthread_attr );
+    pthread_attr_setscope( &pthread_attr, PTHREAD_SCOPE_SYSTEM );
+    pthread_attr_setdetachstate( &pthread_attr, PTHREAD_CREATE_DETACHED );
+
+    pthread_create( &async_file_read_thread_id, &pthread_attr, (void * (*)(void *))async_file_read_thread, NULL);
+    pthread_attr_destroy( &pthread_attr );
+}
+
+static NTSTATUS queue_async_file_read( HANDLE handle, int unix_handle, int needs_close, HANDLE event,
+                            IO_STATUS_BLOCK *io, void *buffer, ULONG length, LARGE_INTEGER *offset )
+{
+    struct async_file_read_job *job;
+
+    pthread_once( &async_file_read_once, async_file_read_init );
+
+    NtResetEvent( event, NULL );
+
+    pthread_mutex_lock( &async_file_read_mutex );
+
+    if (async_file_read_free)
+    {
+        job = async_file_read_free;
+        async_file_read_free = async_file_read_free->next;
+    }
+    else
+    {
+        if (!(job = malloc( sizeof(*job) )))
+        {
+            pthread_mutex_unlock( &async_file_read_mutex );
+            return STATUS_NO_MEMORY;
+        }
+    }
+
+    job->handle = handle;
+    job->unix_handle = unix_handle;
+    job->needs_close = needs_close;
+    job->event = event;
+    job->io = io;
+    job->buffer = buffer;
+    job->length = length;
+    job->offset = *offset;
+    job->thread_id = GetCurrentThreadId();
+    job->cancelled = 0;
+
+    list_add_tail( &async_file_read_queue, &job->queue_entry );
+
+    pthread_cond_signal( &async_file_read_cond );
+    pthread_mutex_unlock( &async_file_read_mutex );
+
+    return STATUS_PENDING;
+}
+
+static NTSTATUS cancel_async_file_read( HANDLE handle, IO_STATUS_BLOCK *io )
+{
+    DWORD thread_id = GetCurrentThreadId();
+    struct async_file_read_job *job;
+    unsigned int count = 0;
+
+    TRACE( "handle %p, io %p.\n", handle, io );
+
+    pthread_mutex_lock( &async_file_read_mutex );
+    job = async_file_read_running;
+    while (job)
+    {
+        if (((io && job->io == io)
+                || (!io && job->handle == handle && job->thread_id == thread_id))
+                && !InterlockedCompareExchange(&job->cancelled, 1, 0))
+        {
+            async_file_complete_io( job, STATUS_CANCELLED, 0 );
+            ++count;
+        }
+        job = job->next;
+    }
+
+    LIST_FOR_EACH_ENTRY( job, &async_file_read_queue, struct async_file_read_job, queue_entry )
+    {
+        if (((io && job->io == io)
+                || (!io && job->handle == handle && job->thread_id == thread_id))
+                && !InterlockedCompareExchange(&job->cancelled, 1, 0))
+        {
+            async_file_complete_io( job, STATUS_CANCELLED, 0 );
+            ++count;
+        }
+    }
+
+    pthread_mutex_unlock( &async_file_read_mutex );
+    return count ? STATUS_SUCCESS : STATUS_NOT_FOUND;
+}

 /******************************************************************************
  *              NtReadFile   (NTDLL.@)
@@ -5336,6 +5560,13 @@ NTSTATUS WINAPI NtReadFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, vo
             goto done;
         }

+        if (ac_odyssey && async_read && length && event && !apc)
+        {
+            status = queue_async_file_read( handle, unix_handle, needs_close, event, io, buffer, length, offset );
+            needs_close = 0;
+            goto err;
+        }
+
         if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
         {
             /* async I/O doesn't make sense on regular files */
@@ -6118,6 +6349,9 @@ NTSTATUS WINAPI NtCancelIoFile( HANDLE handle, IO_STATUS_BLOCK *io_status )

     TRACE( "%p %p\n", handle, io_status );

+    if (ac_odyssey && !cancel_async_file_read( handle, NULL ))
+        return (io_status->u.Status = STATUS_SUCCESS);
+
     SERVER_START_REQ( cancel_async )
     {
         req->handle      = wine_server_obj_handle( handle );
@@ -6143,6 +6377,9 @@ NTSTATUS WINAPI NtCancelIoFileEx( HANDLE handle, IO_STATUS_BLOCK *io, IO_STATUS_

     TRACE( "%p %p %p\n", handle, io, io_status );

+    if (ac_odyssey && !cancel_async_file_read( handle, io ))
+        return (io_status->u.Status = STATUS_SUCCESS);
+
     SERVER_START_REQ( cancel_async )
     {
         req->handle = wine_server_obj_handle( handle );
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 7f3d7834a6c..0f3ec16c52f 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2210,7 +2210,11 @@ static void hacks_init(void)

     if (!strcasecmp(cur_exe, ac_odyssey_exe))
     {
-        ERR("HACK: AC Odyssey sync tweak on.\n");
+        if (do_esync() || do_fsync())
+            ERR("HACK: AC Odyssey sync tweak on.\n");
+        else
+            ERR("Not enabling AC Odyssey sync tweak as esync and fsync are disabled.\n");
+
         ac_odyssey = TRUE;
     }
 }
From c6bad6f294f1d15a7825df71585e695f73bc8561 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 3 Nov 2021 18:07:13 +0300
Subject: [PATCH] ntdll: HACK: Enable WINESTEAMNOEXEC for Mafia II.

CW-Bug-Id: #19605
---
 dlls/ntdll/unix/loader.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 0f3ec16c52f..0a05fb3f10b 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2201,6 +2201,7 @@ static void hacks_init(void)
     static const char ac_odyssey_exe[] = "ACOdyssey.exe";
     char cur_exe[MAX_PATH];
     DWORD cur_exe_len;
+    const char *sgi;
     int fd;

     fd = open("/proc/self/comm", O_RDONLY);
@@ -2216,7 +2217,12 @@ static void hacks_init(void)
             ERR("Not enabling AC Odyssey sync tweak as esync and fsync are disabled.\n");

         ac_odyssey = TRUE;
+        return;
     }
+
+    sgi = getenv("SteamGameId");
+    if (sgi && !strcmp(sgi, "50130"))
+        setenv("WINESTEAMNOEXEC", "1", 0);
 }

 /***********************************************************************
From 48c1e8334c4fa200397acaa0637a008d589f763d Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Mon, 8 Mar 2021 16:41:19 +0100
Subject: [PATCH] webservices: Prefer native.

---
 dlls/webservices/Makefile.in | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/webservices/Makefile.in b/dlls/webservices/Makefile.in
index b58714d3253..c1a6b1438ea 100644
--- a/dlls/webservices/Makefile.in
+++ b/dlls/webservices/Makefile.in
@@ -2,6 +2,8 @@ MODULE    = webservices.dll
 IMPORTLIB = webservices
 IMPORTS   = winhttp rpcrt4 user32 ws2_32

+EXTRADLLFLAGS = -Wb,--prefer-native
+
 C_SRCS = \
 	channel.c \
 	error.c \
From c0236eedd03fb258adc64c646d4a4deff8bd87a0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Oct 2021 01:01:24 +0200
Subject: [PATCH] winex11.drv: Support multiple vulkan surfaces per HWND.

Fixes games failing to render after displaying a video, e.g. Age of
Empires II (2013).

    https://github.com/doitsujin/dxvk/issues/1726
---
 dlls/winex11.drv/vulkan.c | 51 ++++++++++++++++++++-------------------
 dlls/winex11.drv/window.c |  2 +-
 dlls/winex11.drv/x11drv.h |  2 +-
 3 files changed, 28 insertions(+), 27 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 1afb62c0b7d..f1243595e10 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -54,7 +54,6 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION context_section = { &critsect_debug, -1, 0, 0, 0, 0 };

-static XContext vulkan_hwnd_context;
 static XContext vulkan_swapchain_context;

 #define VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR 1000004000
@@ -155,7 +154,6 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR

-    vulkan_hwnd_context = XUniqueContext();
     vulkan_swapchain_context = XUniqueContext();

     return TRUE;
@@ -238,23 +236,30 @@ static void wine_vk_surface_release(struct wine_vk_surface *surface)
     heap_free(surface);
 }

-void wine_vk_surface_destroy(HWND hwnd)
+void wine_vk_surface_destroy(struct wine_vk_surface *surface)
 {
-    struct wine_vk_surface *surface;
-    HDC hdc = 0;
+    TRACE("Detaching surface %p, hwnd %p.\n", surface, surface->hwnd);
+    XReparentWindow(gdi_display, surface->window, get_dummy_parent(), 0, 0);
+    XSync(gdi_display, False);

+    if (surface->hdc) ReleaseDC(surface->hwnd, surface->hdc);
+    surface->hwnd_thread_id = 0;
+    surface->hwnd = 0;
+    surface->hdc = 0;
+    wine_vk_surface_release(surface);
+}
+
+void destroy_vk_surface(HWND hwnd)
+{
+    struct wine_vk_surface *surface, *next;
     EnterCriticalSection(&context_section);
-    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
+    LIST_FOR_EACH_ENTRY_SAFE(surface, next, &surface_list, struct wine_vk_surface, entry)
     {
-        hdc = surface->hdc;
-        surface->hwnd_thread_id = 0;
-        surface->hwnd = 0;
-        surface->hdc = 0;
-        wine_vk_surface_release(surface);
+        if (surface->hwnd != hwnd)
+            continue;
+        wine_vk_surface_destroy(surface);
     }
-    XDeleteContext(gdi_display, (XID)hwnd, vulkan_hwnd_context);
     LeaveCriticalSection(&context_section);
-    if (hdc) ReleaseDC(hwnd, hdc);
 }

 static BOOL wine_vk_surface_set_offscreen(struct wine_vk_surface *surface, BOOL offscreen)
@@ -286,8 +291,12 @@ void sync_vk_surface(HWND hwnd, BOOL known_child)
 {
     struct wine_vk_surface *surface;
     EnterCriticalSection(&context_section);
-    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd)
+            continue;
         wine_vk_surface_set_offscreen(surface, known_child);
+    }
     LeaveCriticalSection(&context_section);
 }

@@ -301,11 +310,7 @@ void vulkan_thread_detach(void)
     {
         if (surface->hwnd_thread_id != thread_id)
             continue;
-
-        TRACE("Detaching surface %p, hwnd %p.\n", surface, surface->hwnd);
-        XReparentWindow(gdi_display, surface->window, get_dummy_parent(), 0, 0);
-        XSync(gdi_display, False);
-        wine_vk_surface_destroy(surface->hwnd);
+        wine_vk_surface_destroy(surface);
     }
     LeaveCriticalSection(&context_section);
 }
@@ -486,6 +491,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,

     if (create_info->hwnd && (GetWindow( create_info->hwnd, GW_CHILD ) || GetAncestor( create_info->hwnd, GA_PARENT ) != GetDesktopWindow()))
     {
+        TRACE("hwnd %p creating offscreen child window surface\n", x11_surface->hwnd);
         if (!wine_vk_surface_set_offscreen(x11_surface, TRUE))
         {
             res = VK_ERROR_INCOMPATIBLE_DRIVER;
@@ -507,11 +513,6 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     }

     EnterCriticalSection(&context_section);
-    if (x11_surface->hwnd)
-    {
-        wine_vk_surface_destroy( x11_surface->hwnd );
-        XSaveContext(gdi_display, (XID)create_info->hwnd, vulkan_hwnd_context, (char *)wine_vk_surface_grab(x11_surface));
-    }
     list_add_tail(&surface_list, &x11_surface->entry);
     LeaveCriticalSection(&context_section);

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 815a6279e59..86b8688a1f2 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2073,7 +2073,7 @@ void CDECL X11DRV_DestroyWindow( HWND hwnd )
     release_win_data( data );
     HeapFree( GetProcessHeap(), 0, data );
     destroy_gl_drawable( hwnd );
-    wine_vk_surface_destroy( hwnd );
+    destroy_vk_surface( hwnd );
 }


diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index ed4abd802c1..70508fd5502 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -652,7 +652,7 @@ extern Window get_dummy_parent(void) DECLSPEC_HIDDEN;
 extern void sync_gl_drawable( HWND hwnd, BOOL known_child ) DECLSPEC_HIDDEN;
 extern void set_gl_drawable_parent( HWND hwnd, HWND parent ) DECLSPEC_HIDDEN;
 extern void destroy_gl_drawable( HWND hwnd ) DECLSPEC_HIDDEN;
-extern void wine_vk_surface_destroy( HWND hwnd ) DECLSPEC_HIDDEN;
+extern void destroy_vk_surface( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void sync_vk_surface( HWND hwnd, BOOL known_child ) DECLSPEC_HIDDEN;
 extern void vulkan_thread_detach(void) DECLSPEC_HIDDEN;

From b5d9ac4b088d4ddf64103a45c841d54fbf308a04 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Oct 2021 00:12:16 +0200
Subject: [PATCH] winex11.drv: Resize vulkan surfaces client rect size changes.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 16 ++++++++++++++++
 dlls/winex11.drv/window.c |  1 +
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 18 insertions(+)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index f1243595e10..5ad3888fb70 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -287,6 +287,18 @@ static BOOL wine_vk_surface_set_offscreen(struct wine_vk_surface *surface, BOOL
     return !offscreen;
 }

+void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *changes)
+{
+    struct wine_vk_surface *surface;
+    EnterCriticalSection(&context_section);
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd) continue;
+        if (surface->window != active) XConfigureWindow(gdi_display, surface->window, mask, changes);
+    }
+    LeaveCriticalSection(&context_section);
+}
+
 void sync_vk_surface(HWND hwnd, BOOL known_child)
 {
     struct wine_vk_surface *surface;
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 86b8688a1f2..e220f2d1357 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1627,6 +1627,7 @@ static void sync_client_position( struct x11drv_win_data *data,
         TRACE( "setting client win %lx pos %d,%d,%dx%d changes=%x\n",
                data->client_window, changes.x, changes.y, changes.width, changes.height, mask );
         XConfigureWindow( data->display, data->client_window, mask, &changes );
+        resize_vk_surfaces( data->hwnd, data->client_window, mask, &changes );
     }
 }

diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 70508fd5502..285e7bd1e98 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -654,6 +654,7 @@ extern void set_gl_drawable_parent( HWND hwnd, HWND parent ) DECLSPEC_HIDDEN;
 extern void destroy_gl_drawable( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void destroy_vk_surface( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void sync_vk_surface( HWND hwnd, BOOL known_child ) DECLSPEC_HIDDEN;
+extern void resize_vk_surfaces( HWND hwnd, Window active, int mask, XWindowChanges *changes ) DECLSPEC_HIDDEN;
 extern void vulkan_thread_detach(void) DECLSPEC_HIDDEN;

 extern void wait_for_withdrawn_state( HWND hwnd, BOOL set ) DECLSPEC_HIDDEN;
From f3a2edda7f4e5b6aad9028ac59dbbe57642f3edc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Oct 2021 00:22:00 +0200
Subject: [PATCH] winex11.drv: Update client_window pointer on surface destroy.

To prevent reusing already destroyed client_window with the thread
display requests.

This lets us restore another client window, as the primary client
window.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 20 ++++++++++++++++++++
 dlls/winex11.drv/window.c | 16 ++++++++++++++++
 dlls/winex11.drv/x11drv.h |  2 ++
 3 files changed, 38 insertions(+)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 5ad3888fb70..f694f812ff8 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -312,6 +312,24 @@ void sync_vk_surface(HWND hwnd, BOOL known_child)
     LeaveCriticalSection(&context_section);
 }

+Window wine_vk_active_surface( HWND hwnd )
+{
+    struct wine_vk_surface *surface, *active = NULL;
+    Window window;
+
+    EnterCriticalSection(&context_section);
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd) continue;
+        active = surface;
+    }
+    if (!active) window = None;
+    else window = active->window;
+    LeaveCriticalSection(&context_section);
+
+    return window;
+}
+
 void vulkan_thread_detach(void)
 {
     struct wine_vk_surface *surface, *next;
@@ -552,6 +570,7 @@ static void X11DRV_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface
         const VkAllocationCallbacks *allocator)
 {
     struct wine_vk_surface *x11_surface = surface_from_handle(surface);
+    HWND hwnd = x11_surface->hwnd;

     TRACE("%p 0x%s %p\n", instance, wine_dbgstr_longlong(surface), allocator);

@@ -564,6 +583,7 @@ static void X11DRV_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface
         pvkDestroySurfaceKHR(instance, x11_surface->surface, NULL /* allocator */);

         wine_vk_surface_release(x11_surface);
+        update_client_window(hwnd);
     }
 }

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index e220f2d1357..507b5c705f8 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1732,6 +1732,22 @@ Window get_dummy_parent(void)
 }


+/**********************************************************************
+ *		update_client_window
+ */
+void update_client_window( HWND hwnd )
+{
+    struct x11drv_win_data *data;
+    if ((data = get_win_data( hwnd )))
+    {
+        data->client_window = wine_vk_active_surface( hwnd );
+        /* make sure any request that could use old client window has been flushed */
+        XFlush( data->display );
+        release_win_data( data );
+    }
+}
+
+
 /**********************************************************************
  *		create_dummy_client_window
  */
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 285e7bd1e98..dec7f15dcdc 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -655,6 +655,7 @@ extern void destroy_gl_drawable( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void destroy_vk_surface( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void sync_vk_surface( HWND hwnd, BOOL known_child ) DECLSPEC_HIDDEN;
 extern void resize_vk_surfaces( HWND hwnd, Window active, int mask, XWindowChanges *changes ) DECLSPEC_HIDDEN;
+extern Window wine_vk_active_surface( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void vulkan_thread_detach(void) DECLSPEC_HIDDEN;

 extern void wait_for_withdrawn_state( HWND hwnd, BOOL set ) DECLSPEC_HIDDEN;
@@ -665,6 +666,7 @@ extern void update_net_wm_states( struct x11drv_win_data *data ) DECLSPEC_HIDDEN
 extern void make_window_embedded( struct x11drv_win_data *data ) DECLSPEC_HIDDEN;
 extern Window create_dummy_client_window(void) DECLSPEC_HIDDEN;
 extern Window create_client_window( HWND hwnd, const XVisualInfo *visual ) DECLSPEC_HIDDEN;
+extern void update_client_window( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void set_window_visual( struct x11drv_win_data *data, const XVisualInfo *vis, BOOL use_alpha ) DECLSPEC_HIDDEN;
 extern void change_systray_owner( Display *display, Window systray_window ) DECLSPEC_HIDDEN;
 extern void update_systray_balloon_position(void) DECLSPEC_HIDDEN;
From 2306cf06c68061cb678c946b73e81ba26181c70a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 12 Dec 2021 14:50:47 +0100
Subject: [PATCH] winex11.drv: Support concurrent Vulkan surfaces using
 XComposite.

---
 dlls/winex11.drv/vulkan.c | 37 ++++++++++++++++++++++++++++++++-----
 1 file changed, 32 insertions(+), 5 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index f694f812ff8..8722f1b64fb 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -67,6 +67,7 @@ struct wine_vk_surface
     Window window;
     VkSurfaceKHR surface; /* native surface */
     VkPresentModeKHR present_mode;
+    BOOL known_child; /* hwnd is or has a child */
     BOOL offscreen; /* drawable is offscreen */
     HDC hdc;
     HWND hwnd;
@@ -302,12 +303,21 @@ void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *chan
 void sync_vk_surface(HWND hwnd, BOOL known_child)
 {
     struct wine_vk_surface *surface;
+    DWORD surface_count = 0;
+
     EnterCriticalSection(&context_section);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
-        if (surface->hwnd != hwnd)
-            continue;
-        wine_vk_surface_set_offscreen(surface, known_child);
+        if (surface->hwnd != hwnd) continue;
+        surface->known_child = known_child;
+        surface_count++;
+    }
+    TRACE("hwnd %p surface_count %u known_child %u\n", hwnd, surface_count, known_child);
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd) continue;
+        if (surface_count > 1) wine_vk_surface_set_offscreen(surface, TRUE);
+        else wine_vk_surface_set_offscreen(surface, known_child);
     }
     LeaveCriticalSection(&context_section);
 }
@@ -315,6 +325,7 @@ void sync_vk_surface(HWND hwnd, BOOL known_child)
 Window wine_vk_active_surface( HWND hwnd )
 {
     struct wine_vk_surface *surface, *active = NULL;
+    DWORD surface_count = 0;
     Window window;

     EnterCriticalSection(&context_section);
@@ -322,9 +333,16 @@ Window wine_vk_active_surface( HWND hwnd )
     {
         if (surface->hwnd != hwnd) continue;
         active = surface;
+        surface_count++;
     }
     if (!active) window = None;
-    else window = active->window;
+    else
+    {
+        TRACE("hwnd %p surface_count %u known_child %u\n", hwnd, surface_count, active->known_child);
+        if (surface_count > 1) wine_vk_surface_set_offscreen(active, TRUE);
+        else wine_vk_surface_set_offscreen(active, active->known_child);
+        window = active->window;
+    }
     LeaveCriticalSection(&context_section);

     return window;
@@ -486,7 +504,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
 {
     VkResult res;
     VkXlibSurfaceCreateInfoKHR create_info_host;
-    struct wine_vk_surface *x11_surface;
+    struct wine_vk_surface *x11_surface, *other;

     TRACE("%p %p %p %p\n", instance, create_info, allocator, surface);

@@ -499,6 +517,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,

     x11_surface->ref = 1;
     x11_surface->hwnd = create_info->hwnd;
+    x11_surface->known_child = FALSE;
     if (x11_surface->hwnd)
     {
         x11_surface->hdc = GetDC(create_info->hwnd);
@@ -521,6 +540,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,

     if (create_info->hwnd && (GetWindow( create_info->hwnd, GW_CHILD ) || GetAncestor( create_info->hwnd, GA_PARENT ) != GetDesktopWindow()))
     {
+        x11_surface->known_child = TRUE;
         TRACE("hwnd %p creating offscreen child window surface\n", x11_surface->hwnd);
         if (!wine_vk_surface_set_offscreen(x11_surface, TRUE))
         {
@@ -543,6 +563,13 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     }

     EnterCriticalSection(&context_section);
+    LIST_FOR_EACH_ENTRY(other, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (other->hwnd != x11_surface->hwnd) continue;
+        TRACE("hwnd %p already has a swapchain, moving surface offscreen\n", x11_surface->hwnd);
+        wine_vk_surface_set_offscreen(other, TRUE);
+        wine_vk_surface_set_offscreen(x11_surface, TRUE);
+    }
     list_add_tail(&surface_list, &x11_surface->entry);
     LeaveCriticalSection(&context_section);

From f1b008fd1a5acef5f92dee412bb54a1423ab067c Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Mon, 22 Nov 2021 20:00:43 +0200
Subject: [PATCH] winex11: Consider only Vulkan surfaces with swapchains for
 offscreen rendering.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

"A native window cannot be associated with more than one non-retired
swapchain at a time."[1]

The hack introduced in 81f5a09134e5 ("winex11: Allow multiple vulkan
surfaces per hwnd") sends surfaces for offscreen rendering using
XComposite when there are multiple surfaces associated with a single
hwnd.

That's overzealous though, as some of the swapchains may be already
destroyed.

E.g. DOOM Eternal with vsync enabled does the following:

    vkCreateWin32SurfaceKHR(vk_inst, &surface_create_info, NULL, &old_surface)
    vkCreateSwapchainKHR(vk_inst, &sc_create_info, NULL, &old_sc);
    vkDestroySwapchainKHR(vk_inst, old_sc, NULL);
    /* old_surface never gets destroyed */

    vkCreateWin32SurfaceKHR(vk_inst, &surface_create_info, NULL, &new_surface);
    vkCreateSwapchainKHR(vk_inst, &sc_create_info, NULL, &new_swapchain);

Which makes the hack kick in and degrades the performance.

This change makes sure that we only count surfaces that have any
swapchains associated with them, whether they are retired or not.

That's a bit of oversimplification, as swapchain can get retired without
new swapchain being created:

"Upon calling vkCreateSwapchainKHR with an oldSwapchain that is not
VK_NULL_HANDLE, oldSwapchain is retiredeven if creation of the new
swapchain fails. The new swapchain is created in the non-retired state
whether or not oldSwapchain is VK_NULL_HANDLE."[2]

but that's unlikely to happen and cause problems.

[1]: https://khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSwapchainKHR.html
[2]: https://khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSwapchainCreateInfoKHR.html

CW-Bug-Id: #19666
---
 dlls/winex11.drv/vulkan.c | 47 ++++++++++++++++++++++-----------------
 1 file changed, 27 insertions(+), 20 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 8722f1b64fb..2d532226ce6 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -69,6 +69,7 @@ struct wine_vk_surface
     VkPresentModeKHR present_mode;
     BOOL known_child; /* hwnd is or has a child */
     BOOL offscreen; /* drawable is offscreen */
+    LONG swapchain_count; /* surface can have one active an many retired swapchains */
     HDC hdc;
     HWND hwnd;
     DWORD hwnd_thread_id;
@@ -303,43 +304,43 @@ void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *chan
 void sync_vk_surface(HWND hwnd, BOOL known_child)
 {
     struct wine_vk_surface *surface;
-    DWORD surface_count = 0;
+    DWORD surface_with_swapchain_count = 0;

     EnterCriticalSection(&context_section);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
+        if (surface->swapchain_count) surface_with_swapchain_count++;
         surface->known_child = known_child;
-        surface_count++;
     }
-    TRACE("hwnd %p surface_count %u known_child %u\n", hwnd, surface_count, known_child);
+    TRACE("hwnd %p surface_with_swapchain_count %u known_child %u\n", hwnd, surface_with_swapchain_count, known_child);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
-        if (surface_count > 1) wine_vk_surface_set_offscreen(surface, TRUE);
+        if (surface_with_swapchain_count > 1) wine_vk_surface_set_offscreen(surface, TRUE);
         else wine_vk_surface_set_offscreen(surface, known_child);
     }
     LeaveCriticalSection(&context_section);
 }

-Window wine_vk_active_surface( HWND hwnd )
+Window wine_vk_active_surface(HWND hwnd)
 {
     struct wine_vk_surface *surface, *active = NULL;
-    DWORD surface_count = 0;
+    DWORD surface_with_swapchain_count = 0;
     Window window;

     EnterCriticalSection(&context_section);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
+        if (surface->swapchain_count) surface_with_swapchain_count++;
         active = surface;
-        surface_count++;
     }
     if (!active) window = None;
     else
     {
-        TRACE("hwnd %p surface_count %u known_child %u\n", hwnd, surface_count, active->known_child);
-        if (surface_count > 1) wine_vk_surface_set_offscreen(active, TRUE);
+        TRACE("hwnd %p surface_with_swapchain_count %u known_child %u\n", hwnd, surface_with_swapchain_count, active->known_child);
+        if (surface_with_swapchain_count > 1) wine_vk_surface_set_offscreen(active, TRUE);
         else wine_vk_surface_set_offscreen(active, active->known_child);
         window = active->window;
     }
@@ -468,7 +469,7 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
         const VkSwapchainCreateInfoKHR *create_info,
         const VkAllocationCallbacks *allocator, VkSwapchainKHR *swapchain)
 {
-    struct wine_vk_surface *x11_surface = surface_from_handle(create_info->surface);
+    struct wine_vk_surface *other, *x11_surface = surface_from_handle(create_info->surface);
     VkSwapchainCreateInfoKHR create_info_host;
     VkResult result;

@@ -488,13 +489,22 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
         create_info_host.presentMode = VK_PRESENT_MODE_FIFO_KHR;
     x11_surface->present_mode = create_info->presentMode;

+    EnterCriticalSection(&context_section);
+    LIST_FOR_EACH_ENTRY(other, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (other->hwnd != x11_surface->hwnd) continue;
+        if (!other->swapchain_count) continue;
+        TRACE("hwnd %p already has a swapchain, moving surface offscreen\n", x11_surface->hwnd);
+        wine_vk_surface_set_offscreen(other, TRUE);
+        wine_vk_surface_set_offscreen(x11_surface, TRUE);
+    }
     result = pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
     if (result == VK_SUCCESS)
     {
-        EnterCriticalSection(&context_section);
+        x11_surface->swapchain_count++;
         XSaveContext(gdi_display, (XID)(*swapchain), vulkan_swapchain_context, (char *)wine_vk_surface_grab(x11_surface));
-        LeaveCriticalSection(&context_section);
     }
+    LeaveCriticalSection(&context_section);
     return result;
 }

@@ -504,7 +514,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
 {
     VkResult res;
     VkXlibSurfaceCreateInfoKHR create_info_host;
-    struct wine_vk_surface *x11_surface, *other;
+    struct wine_vk_surface *x11_surface;

     TRACE("%p %p %p %p\n", instance, create_info, allocator, surface);

@@ -518,6 +528,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     x11_surface->ref = 1;
     x11_surface->hwnd = create_info->hwnd;
     x11_surface->known_child = FALSE;
+    x11_surface->swapchain_count = 0;
     if (x11_surface->hwnd)
     {
         x11_surface->hdc = GetDC(create_info->hwnd);
@@ -563,13 +574,6 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     }

     EnterCriticalSection(&context_section);
-    LIST_FOR_EACH_ENTRY(other, &surface_list, struct wine_vk_surface, entry)
-    {
-        if (other->hwnd != x11_surface->hwnd) continue;
-        TRACE("hwnd %p already has a swapchain, moving surface offscreen\n", x11_surface->hwnd);
-        wine_vk_surface_set_offscreen(other, TRUE);
-        wine_vk_surface_set_offscreen(x11_surface, TRUE);
-    }
     list_add_tail(&surface_list, &x11_surface->entry);
     LeaveCriticalSection(&context_section);

@@ -628,7 +632,10 @@ static void X11DRV_vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapcha

     EnterCriticalSection(&context_section);
     if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface))
+    {
+        surface->swapchain_count--;
         wine_vk_surface_release(surface);
+    }
     XDeleteContext(gdi_display, (XID)swapchain, vulkan_swapchain_context);
     LeaveCriticalSection(&context_section);
 }
From 16cc27b56da8bb6018776392a6e5e8b7909c5453 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Tue, 23 Nov 2021 13:54:34 +0200
Subject: [PATCH] winex11: Don't consider swapchain-less Vulkan surfaces
 active.

---
 dlls/winex11.drv/vulkan.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 2d532226ce6..8c822722591 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -333,8 +333,9 @@ Window wine_vk_active_surface(HWND hwnd)
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
-        if (surface->swapchain_count) surface_with_swapchain_count++;
+        if (!surface->swapchain_count) continue;
         active = surface;
+        surface_with_swapchain_count++;
     }
     if (!active) window = None;
     else
From 223fa293c4faae79fb62f97bec53a831c0ab9229 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 10 Sep 2021 22:21:13 +0300
Subject: [PATCH] winex11.drv: Create offscreen GL drawable for layered windows
 managed through UpdateLayeredWindow().

CW-Bug-ID: #19216
---
 dlls/winex11.drv/opengl.c | 71 ++++++++++++++++++++++++++++-----------
 dlls/winex11.drv/window.c | 37 ++++++++++++++++++++
 dlls/winex11.drv/x11drv.h |  3 ++
 3 files changed, 92 insertions(+), 19 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index f4f4063f9a0..4b2cf1dc4cf 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -248,6 +248,12 @@ enum dc_gl_type
     DC_GL_PBUFFER     /* pseudo memory DC using a PBuffer */
 };

+enum dc_gl_layered_type
+{
+    DC_GL_LAYERED_NONE,
+    DC_GL_LAYERED_UPDATES,
+};
+
 struct gl_drawable
 {
     LONG                           ref;          /* reference count */
@@ -258,6 +264,7 @@ struct gl_drawable
     Pixmap                         pixmap;       /* base pixmap if drawable is a GLXPixmap */
     const struct wgl_pixel_format *format;       /* pixel format for the drawable */
     SIZE                           pixmap_size;  /* pixmap size for GLXPixmap drawables */
+    enum dc_gl_layered_type        layered_type;
     int                            swap_interval;
     BOOL                           refresh_swap_interval;
     BOOL                           mutable_pf;
@@ -1450,6 +1457,19 @@ static GLXContext create_glxcontext(Display *display, struct wgl_context *contex
 }


+static enum dc_gl_layered_type get_gl_layered_type( HWND hwnd )
+{
+    struct x11drv_win_data *data;
+    enum dc_gl_layered_type ret;
+
+    if (!(data = get_win_data( hwnd ))) return DC_GL_LAYERED_NONE;
+    ret = data->layered && !data->layered_attributes ? DC_GL_LAYERED_UPDATES : DC_GL_LAYERED_NONE;
+    release_win_data( data );
+
+    return ret;
+}
+
+
 /***********************************************************************
  *              create_gl_drawable
  */
@@ -1457,6 +1477,7 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel
                                                BOOL mutable_pf )
 {
     struct gl_drawable *gl, *prev;
+    struct x11drv_win_data *data;
     XVisualInfo *visual = format->visual;
     RECT rect;
     int width, height;
@@ -1477,10 +1498,24 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel
     gl->ref = 1;
     gl->mutable_pf = mutable_pf;

-    if (!known_child && !GetWindow( hwnd, GW_CHILD ) && GetAncestor( hwnd, GA_PARENT ) == GetDesktopWindow())  /* childless top-level window */
-    {
-        struct x11drv_win_data *data;
+    gl->layered_type = get_gl_layered_type( hwnd );

+    if (gl->layered_type)
+    {
+        detach_client_window( hwnd );
+        gl->type = DC_GL_PIXMAP_WIN;
+        gl->pixmap = XCreatePixmap( gdi_display, root_window, width, height, visual->depth );
+        if (gl->pixmap)
+        {
+            gl->drawable = pglXCreatePixmap( gdi_display, gl->format->fbconfig, gl->pixmap, NULL );
+            if (!gl->drawable) XFreePixmap( gdi_display, gl->pixmap );
+            gl->pixmap_size.cx = width;
+            gl->pixmap_size.cy = height;
+        }
+        TRACE( "%p created pixmap drawable %lx for layered window, type %u.\n", hwnd, gl->drawable, gl->layered_type );
+    }
+    else if (!known_child && !GetWindow( hwnd, GW_CHILD ) && GetAncestor( hwnd, GA_PARENT ) == GetDesktopWindow())  /* childless top-level window */
+    {
         gl->type = DC_GL_WINDOW;
         gl->window = create_client_window( hwnd, visual );
         if (gl->window)
@@ -1610,6 +1645,7 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
  */
 void sync_gl_drawable( HWND hwnd, BOOL known_child )
 {
+    enum dc_gl_layered_type new_layered_type;
     struct gl_drawable *old, *new;
     struct x11drv_win_data *data;

@@ -1617,20 +1653,17 @@ void sync_gl_drawable( HWND hwnd, BOOL known_child )

     if (!(old = get_gl_drawable( hwnd, 0 ))) return;

-    switch (old->type)
+    new_layered_type = get_gl_layered_type( hwnd );
+    if (old->type == DC_GL_PIXMAP_WIN || (known_child && old->type == DC_GL_WINDOW)
+        || old->layered_type != new_layered_type)
     {
-    case DC_GL_WINDOW:
-        if (!known_child) break; /* Still a childless top-level window */
-        /* fall through */
-    case DC_GL_PIXMAP_WIN:
-        if (!(new = create_gl_drawable( hwnd, old->format, known_child, old->mutable_pf ))) break;
-        mark_drawable_dirty( old, new );
-        XFlush( gdi_display );
-        TRACE( "Recreated GL drawable %lx to replace %lx\n", new->drawable, old->drawable );
-        release_gl_drawable( new );
-        break;
-    default:
-        break;
+        if ((new = create_gl_drawable( hwnd, old->format, known_child, old->mutable_pf )))
+        {
+            mark_drawable_dirty( old, new );
+            XFlush( gdi_display );
+            TRACE( "Recreated GL drawable %lx to replace %lx\n", new->drawable, old->drawable );
+            release_gl_drawable( new );
+        }
     }

     if (DC_GL_PIXMAP_WIN != old->type) {
@@ -3007,7 +3040,7 @@ static void wglFinish(void)
     {
         switch (gl->type)
         {
-        case DC_GL_PIXMAP_WIN: escape.drawable = gl->pixmap; break;
+        case DC_GL_PIXMAP_WIN: if (!gl->layered_type) escape.drawable = gl->pixmap; break;
         case DC_GL_CHILD_WIN:  escape.drawable = gl->window; break;
         default: break;
         }
@@ -3045,7 +3078,7 @@ static void wglFlush(void)
     {
         switch (gl->type)
         {
-        case DC_GL_PIXMAP_WIN: escape.drawable = gl->pixmap; break;
+        case DC_GL_PIXMAP_WIN: if (!gl->layered_type) escape.drawable = gl->pixmap; break;
         case DC_GL_CHILD_WIN:  escape.drawable = gl->window; break;
         default: break;
         }
@@ -4410,7 +4443,7 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
     {
     case DC_GL_PIXMAP_WIN:
         if (ctx) sync_context( ctx );
-        escape.drawable = gl->pixmap;
+        if (!gl->layered_type) escape.drawable = gl->pixmap;
         if (pglXCopySubBufferMESA) {
             /* (glX)SwapBuffers has an implicit glFlush effect, however
              * GLX_MESA_copy_sub_buffer doesn't. Make sure GL is flushed before
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 507b5c705f8..64228299a2e 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1748,6 +1748,30 @@ void update_client_window( HWND hwnd )
 }


+/**********************************************************************
+ *		detach_client_window
+ */
+void detach_client_window( HWND hwnd )
+{
+    struct x11drv_win_data *data;
+
+    if (!(data = get_win_data( hwnd ))) return;
+
+    if (!data->client_window)
+    {
+        release_win_data( data );
+        return;
+    }
+
+    XDeleteContext( data->display, data->client_window, winContext );
+    XReparentWindow( gdi_display, data->client_window, get_dummy_parent(), 0, 0 );
+    TRACE( "%p reparent xwin %lx/%lx\n", data->hwnd, data->whole_window, data->client_window );
+    data->client_window = 0;
+    XFlush( data->display );
+    release_win_data( data );
+}
+
+
 /**********************************************************************
  *		create_dummy_client_window
  */
@@ -2038,6 +2062,7 @@ void CDECL X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
     struct x11drv_win_data *data;
     DWORD changed = style->styleNew ^ style->styleOld;
     HWND parent = GetAncestor( hwnd, GA_PARENT );
+    BOOL need_sync_gl = FALSE;

     if (offset == GWL_STYLE && (changed & WS_CHILD))
     {
@@ -2097,12 +2097,15 @@ void CDECL X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
     if (offset == GWL_EXSTYLE && (changed & WS_EX_LAYERED)) /* changing WS_EX_LAYERED resets attributes */
     {
         data->layered = FALSE;
+        data->layered_attributes = FALSE;
+        need_sync_gl = TRUE;
         set_window_visual( data, &default_visual, FALSE );
         set_window_opacity( data->display, data->whole_window, 0xff );
         if (data->surface) set_surface_color_key( data->surface, CLR_INVALID );
     }
 done:
     release_win_data( data );
+    if (need_sync_gl) sync_gl_drawable( hwnd, FALSE );
 }


@@ -3081,6 +3109,7 @@ void CDECL X11DRV_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
 void CDECL X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags )
 {
     struct x11drv_win_data *data = get_win_data( hwnd );
+    BOOL need_sync_gl;

     if (data)
     {
@@ -3091,7 +3120,9 @@ void CDECL X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alph
         if (data->surface)
             set_surface_color_key( data->surface, (flags & LWA_COLORKEY) ? key : CLR_INVALID );

+        need_sync_gl = !data->layered || !data->layered_attributes;
         data->layered = TRUE;
+        data->layered_attributes = TRUE;
         if (!data->mapped)  /* mapping is delayed until attributes are set */
         {
             DWORD style = GetWindowLongW( data->hwnd, GWL_STYLE );
@@ -3101,10 +3132,12 @@ void CDECL X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alph
             {
                 release_win_data( data );
                 map_window( hwnd, style );
+                if (need_sync_gl) sync_gl_drawable( hwnd, FALSE );
                 return;
             }
         }
         release_win_data( data );
+        if (need_sync_gl) sync_gl_drawable( hwnd, FALSE );
     }
     else
     {
@@ -3133,12 +3166,14 @@ BOOL CDECL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO
     BITMAPINFO *bmi = (BITMAPINFO *)buffer;
     void *src_bits, *dst_bits;
     RECT rect, src_rect;
+    BOOL need_sync_gl;
     HDC hdc = 0;
     HBITMAP dib;
     BOOL mapped, ret = FALSE;

     if (!(data = get_win_data( hwnd ))) return FALSE;

+    need_sync_gl = !data->layered;
     data->layered = TRUE;
     if (!data->embedded && argb_visual.visualid) set_window_visual( data, &argb_visual, TRUE );

@@ -3168,6 +3203,8 @@ BOOL CDECL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO
             map_window( hwnd, style );
     }

+    if (need_sync_gl) sync_gl_drawable( hwnd, FALSE );
+
     if (!surface) return FALSE;
     if (!info->hdcSrc)
     {
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index dec7f15dcdc..7bb0e95d8d3 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -624,6 +624,8 @@ struct x11drv_win_data
     BOOL        embedded : 1;   /* is window an XEMBED client? */
     BOOL        shaped : 1;     /* is window using a custom region shape? */
     BOOL        layered : 1;    /* is window layered and with valid attributes? */
+    BOOL        layered_attributes : 1;
+                                /* is layered window has leyered attributes set (or otherwise managed with UpdateLayeredWindow()? */
     BOOL        use_alpha : 1;  /* does window use an alpha channel? */
     BOOL        skip_taskbar : 1; /* does window should be deleted from taskbar */
     BOOL        add_taskbar : 1; /* does window should be added to taskbar regardless of style */
@@ -667,6 +669,7 @@ extern void make_window_embedded( struct x11drv_win_data *data ) DECLSPEC_HIDDEN
 extern Window create_dummy_client_window(void) DECLSPEC_HIDDEN;
 extern Window create_client_window( HWND hwnd, const XVisualInfo *visual ) DECLSPEC_HIDDEN;
 extern void update_client_window( HWND hwnd ) DECLSPEC_HIDDEN;
+extern void detach_client_window( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void set_window_visual( struct x11drv_win_data *data, const XVisualInfo *vis, BOOL use_alpha ) DECLSPEC_HIDDEN;
 extern void change_systray_owner( Display *display, Window systray_window ) DECLSPEC_HIDDEN;
 extern void update_systray_balloon_position(void) DECLSPEC_HIDDEN;
From 0d10d8f0515c9a242cc21b8ba07b66d97455fddc Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 13 Sep 2021 00:39:05 +0300
Subject: [PATCH] winex11.drv: Always sync windowless GL drawables on size
 change.

CW-Bug-ID: #19216
---
 dlls/winex11.drv/window.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 64228299a2e..76d06b57814 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2815,6 +2815,7 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
     DWORD new_style = GetWindowLongW( hwnd, GWL_STYLE );
     RECT old_window_rect, old_whole_rect, old_client_rect;
     HWND prev_window = NULL;
+    BOOL needs_resize;
     int event_type;

     if (!(data = get_win_data( hwnd ))) return;
@@ -2875,13 +2876,13 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags

     sync_client_position( data, &old_client_rect, &old_whole_rect );

+    needs_resize = !data->client_window && (data->client_rect.right - data->client_rect.left !=
+                   old_client_rect.right - old_client_rect.left ||
+                   data->client_rect.bottom - data->client_rect.top !=
+                   old_client_rect.bottom - old_client_rect.top);
+
     if (!data->whole_window)
     {
-        BOOL needs_resize = (!data->client_window &&
-                             (data->client_rect.right - data->client_rect.left !=
-                              old_client_rect.right - old_client_rect.left ||
-                              data->client_rect.bottom - data->client_rect.top !=
-                              old_client_rect.bottom - old_client_rect.top));
         release_win_data( data );
         if (needs_resize) sync_gl_drawable( hwnd, FALSE );
         return;
@@ -2973,6 +2974,7 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
         data->surface->funcs->flush( data->surface );

     release_win_data( data );
+    if (needs_resize) sync_gl_drawable( hwnd, FALSE );
 }

 /* check if the window icon should be hidden (i.e. moved off-screen) */
From 4e6bfd37f10adfd67d7686ce3d45ab2ccf2d249b Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 10 Sep 2021 21:51:14 +0300
Subject: [PATCH] user32: Allow using surface to paint the client area of
 OpenGL windows.

CW-Bug-ID: #19216
---
 dlls/user32/painting.c | 16 +++++-----------
 server/window.c        |  3 ++-
 2 files changed, 7 insertions(+), 12 deletions(-)

diff --git a/dlls/user32/painting.c b/dlls/user32/painting.c
index 41c0bb3c6e1..65ac7859fa9 100644
--- a/dlls/user32/painting.c
+++ b/dlls/user32/painting.c
@@ -105,7 +105,6 @@ static void update_visible_region( struct dce *dce )
     HRGN vis_rgn = 0;
     HWND top_win = 0;
     DWORD flags = dce->flags;
-    DWORD paint_flags = 0;
     size_t size = 256;
     RECT win_rect, top_rect;
     WND *win;
@@ -142,7 +141,6 @@ static void update_visible_region( struct dce *dce )
                 top_rect.top    = reply->top_rect.top;
                 top_rect.right  = reply->top_rect.right;
                 top_rect.bottom = reply->top_rect.bottom;
-                paint_flags     = reply->paint_flags;
             }
             else size = reply->total_size;
         }
@@ -157,16 +155,12 @@ static void update_visible_region( struct dce *dce )
     if (dce->clip_rgn) CombineRgn( vis_rgn, vis_rgn, dce->clip_rgn,
                                    (flags & DCX_INTERSECTRGN) ? RGN_AND : RGN_DIFF );

-    /* don't use a surface to paint the client area of OpenGL windows */
-    if (!(paint_flags & SET_WINPOS_PIXEL_FORMAT) || (flags & DCX_WINDOW))
+    win = WIN_GetPtr( top_win );
+    if (win && win != WND_DESKTOP && win != WND_OTHER_PROCESS)
     {
-        win = WIN_GetPtr( top_win );
-        if (win && win != WND_DESKTOP && win != WND_OTHER_PROCESS)
-        {
-            surface = win->surface;
-            if (surface) window_surface_add_ref( surface );
-            WIN_ReleasePtr( win );
-        }
+        surface = win->surface;
+        if (surface) window_surface_add_ref( surface );
+        WIN_ReleasePtr( win );
     }

     if (!surface) SetRectEmpty( &top_rect );
diff --git a/server/window.c b/server/window.c
index 7ea91d2a7dc..d8c07b76781 100644
--- a/server/window.c
+++ b/server/window.c
@@ -1150,7 +1150,8 @@ static struct region *get_surface_region( struct window *win )
     set_region_rect( clip, &win->client_rect );
     if (win->win_region && !intersect_window_region( clip, win )) goto error;

-    if ((win->paint_flags & PAINT_HAS_PIXEL_FORMAT) && !subtract_region( region, region, clip ))
+    if (!(win->ex_style & WS_EX_LAYERED) && (win->paint_flags & PAINT_HAS_PIXEL_FORMAT)
+            && !subtract_region( region, region, clip ))
         goto error;

     /* clip children */
From 039ccf7b29a4e2faaec71fbeab25360f59104c3d Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 9 Sep 2021 21:16:26 +0300
Subject: [PATCH] winex11.drv: Use window surface for GL presentation for
 layered windows.

CW-Bug-ID: #19216
---
 dlls/winex11.drv/opengl.c | 87 ++++++++++++++++++++++++++++++++++++---
 1 file changed, 81 insertions(+), 6 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 4b2cf1dc4cf..82906303a85 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -252,6 +252,7 @@ enum dc_gl_layered_type
 {
     DC_GL_LAYERED_NONE,
     DC_GL_LAYERED_UPDATES,
+    DC_GL_LAYERED_ATTRIBUTES,
 };

 struct gl_drawable
@@ -1463,7 +1464,8 @@ static enum dc_gl_layered_type get_gl_layered_type( HWND hwnd )
     enum dc_gl_layered_type ret;

     if (!(data = get_win_data( hwnd ))) return DC_GL_LAYERED_NONE;
-    ret = data->layered && !data->layered_attributes ? DC_GL_LAYERED_UPDATES : DC_GL_LAYERED_NONE;
+    if (data->layered) ret = data->layered_attributes ? DC_GL_LAYERED_ATTRIBUTES : DC_GL_LAYERED_UPDATES;
+    else ret = DC_GL_LAYERED_NONE;
     release_win_data( data );

     return ret;
@@ -3026,17 +3028,87 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer
         general_state_handlers[i].state_handler(RESET, gl, ctx, &state, NULL, NULL, NULL);
 }

+static void update_window_surface(struct gl_drawable *gl, HWND hwnd)
+{
+    char buffer[FIELD_OFFSET( BITMAPINFO, bmiColors[256] )];
+    BITMAPINFO *bmi = (BITMAPINFO *)buffer;
+    struct window_surface *surface;
+    struct x11drv_win_data *data;
+    unsigned int y, width, height, stride, pitch;
+    BYTE *dst_bits, *src_bits;
+    XImage *image;
+    RECT rect;
+
+    TRACE( "gl %p, hwnd %p, gl->layered_type %u.\n", gl, hwnd, gl->layered_type );
+
+    if (gl->layered_type != DC_GL_LAYERED_ATTRIBUTES || !gl->pixmap) return;
+
+    if (!(data = get_win_data( hwnd ))) return;
+
+    surface = data->surface;
+    if (!surface)
+    {
+        TRACE( "No surface.\n" );
+        release_win_data( data );
+        return;
+    }
+
+    rect = data->client_rect;
+    OffsetRect( &rect, -data->whole_rect.left, -data->whole_rect.top );
+
+    dst_bits = surface->funcs->get_info( surface, bmi );
+    surface->funcs->lock( surface );
+
+    rect.right = min( rect.right, abs( bmi->bmiHeader.biWidth ));
+    rect.bottom = min( rect.bottom, abs( bmi->bmiHeader.biHeight ));
+
+    width = min( rect.right - rect.left, gl->pixmap_size.cx );
+    height = min( rect.bottom - rect.top, gl->pixmap_size.cy );
+
+    image = XGetImage( gdi_display, gl->pixmap, 0, 0, width, height,
+                       AllPlanes, ZPixmap );
+    if (!image)
+    {
+        TRACE( "NULL image.\n" );
+        goto done;
+    }
+
+    if (image->bits_per_pixel != bmi->bmiHeader.biBitCount)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Bits per pixel does not match, image %u, bmi %u.\n", image->bits_per_pixel, bmi->bmiHeader.biBitCount);
+        goto done;
+    }
+
+    stride = bmi->bmiHeader.biBitCount / 8;
+    pitch = (bmi->bmiHeader.biWidth * stride + 3) & ~3;
+    src_bits = (BYTE *)image->data;
+    for (y = 0; y < height; ++y)
+        memcpy( dst_bits + (y + rect.top) * pitch + rect.left * stride,
+                src_bits + y * image->bytes_per_line, width * stride );
+
+    add_bounds_rect( surface->funcs->get_bounds( surface ), &rect );
+
+done:
+    surface->funcs->unlock( surface );
+    if (image) XDestroyImage( image );
+    release_win_data( data );
+}
+
 static void wglFinish(void)
 {
     struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    HWND hwnd;

     escape.code = X11DRV_PRESENT_DRAWABLE;
     escape.drawable = 0;
     escape.flush = FALSE;

-    if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
+    if ((gl = get_gl_drawable( (hwnd = WindowFromDC( ctx->hdc )), 0 )))
     {
         switch (gl->type)
         {
@@ -3056,7 +3128,7 @@ static void wglFinish(void)
             ctx->fs_hack = FALSE;
             fs_hack_setup_context(ctx, gl);
         }
-
+        update_window_surface( gl, hwnd );
         release_gl_drawable( gl );
     }

@@ -3069,12 +3141,13 @@ static void wglFlush(void)
     struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    HWND hwnd;

     escape.code = X11DRV_PRESENT_DRAWABLE;
     escape.drawable = 0;
     escape.flush = FALSE;

-    if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
+    if ((gl = get_gl_drawable( (hwnd = WindowFromDC( ctx->hdc )), 0 )))
     {
         switch (gl->type)
         {
@@ -3094,7 +3167,7 @@ static void wglFlush(void)
             ctx->fs_hack = FALSE;
             fs_hack_setup_context(ctx, gl);
         }
-
+        update_window_surface( gl, hwnd );
         release_gl_drawable( gl );
     }

@@ -4418,6 +4491,7 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
     INT64 ust, msc, sbc, target_sbc = 0;
+    HWND hwnd;

     TRACE("(%p)\n", hdc);

@@ -4425,7 +4499,7 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
     escape.drawable = 0;
     escape.flush = !pglXWaitForSbcOML;

-    if (!(gl = get_gl_drawable( WindowFromDC( hdc ), hdc )))
+    if (!(gl = get_gl_drawable( (hwnd = WindowFromDC( hdc )), hdc )))
     {
         SetLastError( ERROR_INVALID_HANDLE );
         return FALSE;
@@ -4490,6 +4564,7 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
     if (escape.drawable && pglXWaitForSbcOML)
         pglXWaitForSbcOML( gdi_display, gl->drawable, target_sbc, &ust, &msc, &sbc );

+    update_window_surface( gl, hwnd );
     release_gl_drawable( gl );

     if (escape.drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
From 212a541186fef119f55f7d5958c3f5919e8353aa Mon Sep 17 00:00:00 2001
From: Piotr Caban <piotr@codeweavers.com>
Date: Tue, 19 Oct 2021 10:39:18 +0200
Subject: [PATCH] HACK: user32: Process WM_PAINT in peek_message for
 WS_EX_COMPOSITED windows.

CW-Bug-Id: #19488
---
 dlls/user32/message.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index bd22a33b1f3..c32d8bd3176 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2906,6 +2906,15 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                                          &info.msg.lParam, &buffer, size ))
                     continue;  /* ignore it */
 	    }
+            /* CXHACK 19488 */
+            if (info.msg.message == WM_PAINT &&
+                    flags == (PM_REMOVE | PM_QS_INPUT | PM_QS_POSTMESSAGE | PM_QS_PAINT | PM_QS_SENDMESSAGE) &&
+                    (GetWindowLongW( info.msg.hwnd, GWL_EXSTYLE ) & WS_EX_COMPOSITED ))
+            {
+                SendMessageW( info.msg.hwnd, info.msg.message, info.msg.wParam, info.msg.lParam );
+                flags &= ~PM_QS_PAINT;
+                continue;
+            }
             *msg = info.msg;
             msg->pt = point_phys_to_win_dpi( info.msg.hwnd, info.msg.pt );
             thread_info->GetMessagePosVal = MAKELONG( msg->pt.x, msg->pt.y );
From c4207272dc0025ba1d3c3e6ed03c5bf96d9ae463 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 3 Sep 2021 17:38:23 -0500
Subject: [PATCH] d3dcompiler: Implement D3DCompile2() on top of
 vkd3d_shader_compile().

This probably isn't what it's going to look like upstream, for several reasons.

CW-Bug-Id: #15810
---
 dlls/d3dcompiler_43/compiler.c     |  189 ++-
 dlls/d3dcompiler_43/vkd3d_shader.h | 1734 ++++++++++++++++++++++++++++
 dlls/d3dcompiler_43/vkd3d_types.h  |   71 ++
 3 files changed, 1972 insertions(+), 22 deletions(-)
 create mode 100644 dlls/d3dcompiler_43/vkd3d_shader.h
 create mode 100644 dlls/d3dcompiler_43/vkd3d_types.h

diff --git a/dlls/d3dcompiler_43/compiler.c b/dlls/d3dcompiler_43/compiler.c
index 112e82d6d44..f9f18f8026f 100644
--- a/dlls/d3dcompiler_43/compiler.c
+++ b/dlls/d3dcompiler_43/compiler.c
@@ -1,6 +1,7 @@
 /*
  * Copyright 2009 Matteo Bruni
  * Copyright 2010 Matteo Bruni for CodeWeavers
+ * Copyright 2016,2018 Jzef Kucia for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -25,8 +26,57 @@
 #include "d3dcompiler_private.h"
 #include "wpp_private.h"

+#define VKD3D_SHADER_NO_PROTOTYPES
+#include "vkd3d_shader.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(d3dcompiler);

+static PFN_vkd3d_shader_compile vkd3d_shader_compile;
+static PFN_vkd3d_shader_free_messages vkd3d_shader_free_messages;
+static PFN_vkd3d_shader_free_shader_code vkd3d_shader_free_shader_code;
+
+static HMODULE vkd3d_shader_handle;
+
+static HRESULT hresult_from_vkd3d_result(int vkd3d_result)
+{
+    switch (vkd3d_result)
+    {
+        case VKD3D_OK:
+            return S_OK;
+        case VKD3D_ERROR_INVALID_SHADER:
+            WARN("Invalid shader bytecode.\n");
+            /* fall-through */
+        case VKD3D_ERROR:
+            return E_FAIL;
+        case VKD3D_ERROR_OUT_OF_MEMORY:
+            return E_OUTOFMEMORY;
+        case VKD3D_ERROR_INVALID_ARGUMENT:
+            return E_INVALIDARG;
+        case VKD3D_ERROR_NOT_IMPLEMENTED:
+            return E_NOTIMPL;
+        default:
+            FIXME("Unhandled vkd3d result %d.\n", vkd3d_result);
+            return E_FAIL;
+    }
+}
+
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
+{
+    switch (reason)
+    {
+        case DLL_PROCESS_ATTACH:
+            DisableThreadLibraryCalls(instance);
+            if ((vkd3d_shader_handle = LoadLibraryW(L"libvkd3d-shader-1.dll")))
+            {
+                vkd3d_shader_compile = (void *)GetProcAddress(vkd3d_shader_handle, "vkd3d_shader_compile");
+                vkd3d_shader_free_messages = (void *)GetProcAddress(vkd3d_shader_handle, "vkd3d_shader_free_messages");
+                vkd3d_shader_free_shader_code = (void *)GetProcAddress(vkd3d_shader_handle, "vkd3d_shader_free_shader_code");
+            }
+    }
+
+    return TRUE;
+}
+
 #define D3DXERR_INVALIDDATA                      0x88760b59

 #define BUFFER_INITIAL_CAPACITY 256
@@ -737,39 +787,134 @@ HRESULT WINAPI D3DAssemble(const void *data, SIZE_T datasize, const char *filena
     return hr;
 }

+static int open_include(const char *filename, bool local, const char *parent_data, void *context,
+        struct vkd3d_shader_code *code)
+{
+    ID3DInclude *iface = context;
+    unsigned int size = 0;
+
+    if (!iface)
+        return VKD3D_ERROR;
+
+    memset(code, 0, sizeof(*code));
+    if (FAILED(ID3DInclude_Open(iface, local ? D3D_INCLUDE_LOCAL : D3D_INCLUDE_SYSTEM,
+            filename, parent_data, &code->code, &size)))
+        return VKD3D_ERROR;
+
+    code->size = size;
+    return VKD3D_OK;
+}
+
+static void close_include(const struct vkd3d_shader_code *code, void *context)
+{
+    ID3DInclude *iface = context;
+
+    ID3DInclude_Close(iface, code->code);
+}
+
 HRESULT WINAPI D3DCompile2(const void *data, SIZE_T data_size, const char *filename,
-        const D3D_SHADER_MACRO *defines, ID3DInclude *include, const char *entrypoint,
-        const char *target, UINT sflags, UINT eflags, UINT secondary_flags,
-        const void *secondary_data, SIZE_T secondary_data_size, ID3DBlob **shader,
-        ID3DBlob **error_messages)
+        const D3D_SHADER_MACRO *macros, ID3DInclude *include, const char *entry_point,
+        const char *profile, UINT flags, UINT effect_flags, UINT secondary_flags,
+        const void *secondary_data, SIZE_T secondary_data_size, ID3DBlob **shader_blob,
+        ID3DBlob **messages_blob)
 {
+    struct d3dcompiler_include_from_file include_from_file;
+    struct vkd3d_shader_preprocess_info preprocess_info;
+    struct vkd3d_shader_hlsl_source_info hlsl_info;
+    struct vkd3d_shader_compile_option options[1];
+    struct vkd3d_shader_compile_info compile_info;
+    struct vkd3d_shader_code byte_code;
+    const D3D_SHADER_MACRO *macro;
+    char *messages;
     HRESULT hr;
+    int ret;

-    TRACE("data %p, data_size %Iu, filename %s, defines %p, include %p, entrypoint %s, "
-            "target %s, sflags %#x, eflags %#x, secondary_flags %#x, secondary_data %p, "
-            "secondary_data_size %Iu, shader %p, error_messages %p.\n",
-            data, data_size, debugstr_a(filename), defines, include, debugstr_a(entrypoint),
-            debugstr_a(target), sflags, eflags, secondary_flags, secondary_data,
-            secondary_data_size, shader, error_messages);
+    TRACE("data %p, data_size %Iu, filename %s, macros %p, include %p, entry_point %s, "
+            "profile %s, flags %#x, effect_flags %#x, secondary_flags %#x, secondary_data %p, "
+            "secondary_data_size %Iu, shader_blob %p, messages_blob %p.\n",
+            data, data_size, debugstr_a(filename), macros, include, debugstr_a(entry_point),
+            debugstr_a(profile), flags, effect_flags, secondary_flags, secondary_data,
+            secondary_data_size, shader_blob, messages_blob);

-    if (secondary_data)
-        FIXME("secondary data not implemented yet\n");
+    if (include == D3D_COMPILE_STANDARD_FILE_INCLUDE)
+    {
+        include_from_file.ID3DInclude_iface.lpVtbl = &d3dcompiler_include_from_file_vtbl;
+        include = &include_from_file.ID3DInclude_iface;
+    }

-    if (shader) *shader = NULL;
-    if (error_messages) *error_messages = NULL;
+    if (flags & ~D3DCOMPILE_DEBUG)
+        FIXME("Ignoring flags %#x.\n", flags);
+    if (effect_flags)
+        FIXME("Ignoring effect flags %#x.\n", effect_flags);
+    if (secondary_flags)
+        FIXME("Ignoring secondary flags %#x.\n", secondary_flags);
+
+    if (messages_blob)
+        *messages_blob = NULL;
+
+    compile_info.type = VKD3D_SHADER_STRUCTURE_TYPE_COMPILE_INFO;
+    compile_info.next = &preprocess_info;
+    compile_info.source.code = data;
+    compile_info.source.size = data_size;
+    compile_info.source_type = VKD3D_SHADER_SOURCE_HLSL;
+    compile_info.target_type = VKD3D_SHADER_TARGET_DXBC_TPF;
+    compile_info.options = options;
+    compile_info.option_count = 0;
+    compile_info.log_level = VKD3D_SHADER_LOG_INFO;
+    compile_info.source_name = filename;
+
+    preprocess_info.type = VKD3D_SHADER_STRUCTURE_TYPE_PREPROCESS_INFO;
+    preprocess_info.next = &hlsl_info;
+    preprocess_info.macros = (const struct vkd3d_shader_macro *)macros;
+    preprocess_info.macro_count = 0;
+    if (macros)
+    {
+        for (macro = macros; macro->Name; ++macro)
+            ++preprocess_info.macro_count;
+    }
+    preprocess_info.pfn_open_include = open_include;
+    preprocess_info.pfn_close_include = close_include;
+    preprocess_info.include_context = include;

-    EnterCriticalSection(&wpp_mutex);
+    hlsl_info.type = VKD3D_SHADER_STRUCTURE_TYPE_HLSL_SOURCE_INFO;
+    hlsl_info.next = NULL;
+    hlsl_info.profile = profile;
+    hlsl_info.entry_point = entry_point;
+    hlsl_info.secondary_code.code = secondary_data;
+    hlsl_info.secondary_code.size = secondary_data_size;

-    hr = preprocess_shader(data, data_size, filename, defines, include, error_messages);
-    if (SUCCEEDED(hr))
+    if (!(flags & D3DCOMPILE_DEBUG))
+        options[compile_info.option_count++].name = VKD3D_SHADER_COMPILE_OPTION_STRIP_DEBUG;
+
+    ret = vkd3d_shader_compile(&compile_info, &byte_code, &messages);
+    if (messages)
     {
-        FIXME("HLSL shader compilation is not yet implemented.\n");
-        hr = E_NOTIMPL;
+        if (messages_blob)
+        {
+            size_t size = strlen(messages);
+            if (FAILED(hr = D3DCreateBlob(size, messages_blob)))
+            {
+                vkd3d_shader_free_messages(messages);
+                vkd3d_shader_free_shader_code(&byte_code);
+                return hr;
+            }
+            memcpy(ID3D10Blob_GetBufferPointer(*messages_blob), messages, size);
+        }
+        else
+            vkd3d_shader_free_messages(messages);
     }

-    HeapFree(GetProcessHeap(), 0, wpp_output);
-    LeaveCriticalSection(&wpp_mutex);
-    return hr;
+    if (!ret)
+    {
+        if (FAILED(hr = D3DCreateBlob(byte_code.size, shader_blob)))
+        {
+            vkd3d_shader_free_shader_code(&byte_code);
+            return hr;
+        }
+        memcpy(ID3D10Blob_GetBufferPointer(*shader_blob), byte_code.code, byte_code.size);
+    }
+
+    return hresult_from_vkd3d_result(ret);
 }

 HRESULT WINAPI D3DCompile(const void *data, SIZE_T data_size, const char *filename,
diff --git a/dlls/d3dcompiler_43/vkd3d_shader.h b/dlls/d3dcompiler_43/vkd3d_shader.h
new file mode 100644
index 00000000000..bb915230e1b
--- /dev/null
+++ b/dlls/d3dcompiler_43/vkd3d_shader.h
@@ -0,0 +1,1734 @@
+/*
+ * Copyright 2017-2019 Jzef Kucia for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __VKD3D_SHADER_H
+#define __VKD3D_SHADER_H
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "vkd3d_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/**
+ * \file vkd3d_shader.h
+ *
+ * \since 1.2
+ *
+ * This file contains definitions for the vkd3d-shader library.
+ *
+ * The vkd3d-shader library provides multiple utilities related to the
+ * compilation, transformation, and reflection of GPU shaders.
+ */
+
+/** The type of a chained structure. */
+enum vkd3d_shader_structure_type
+{
+    /** The structure is a vkd3d_shader_compile_info structure. */
+    VKD3D_SHADER_STRUCTURE_TYPE_COMPILE_INFO,
+    /** The structure is a vkd3d_shader_interface_info structure. */
+    VKD3D_SHADER_STRUCTURE_TYPE_INTERFACE_INFO,
+    /** The structure is a vkd3d_shader_scan_descriptor_info structure. */
+    VKD3D_SHADER_STRUCTURE_TYPE_SCAN_DESCRIPTOR_INFO,
+    /** The structure is a vkd3d_shader_spirv_domain_shader_target_info structure. */
+    VKD3D_SHADER_STRUCTURE_TYPE_SPIRV_DOMAIN_SHADER_TARGET_INFO,
+    /** The structure is a vkd3d_shader_spirv_target_info structure. */
+    VKD3D_SHADER_STRUCTURE_TYPE_SPIRV_TARGET_INFO,
+    /** The structure is a vkd3d_shader_transform_feedback_info structure. */
+    VKD3D_SHADER_STRUCTURE_TYPE_TRANSFORM_FEEDBACK_INFO,
+
+    /**
+     * The structure is a vkd3d_shader_hlsl_source_info structure.
+     * \since 1.3
+     */
+    VKD3D_SHADER_STRUCTURE_TYPE_HLSL_SOURCE_INFO,
+    /**
+     * The structure is a vkd3d_shader_preprocess_info structure.
+     * \since 1.3
+     */
+    VKD3D_SHADER_STRUCTURE_TYPE_PREPROCESS_INFO,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_STRUCTURE_TYPE),
+};
+
+/**
+ * Determines how buffer UAVs are stored.
+ *
+ * This also affects UAV counters in Vulkan environments. In OpenGL
+ * environments, atomic counter buffers are always used for UAV counters.
+ */
+enum vkd3d_shader_compile_option_buffer_uav
+{
+    /** Use buffer textures for buffer UAVs. This is the default value. */
+    VKD3D_SHADER_COMPILE_OPTION_BUFFER_UAV_STORAGE_TEXEL_BUFFER = 0x00000000,
+    /** Use storage buffers for buffer UAVs. */
+    VKD3D_SHADER_COMPILE_OPTION_BUFFER_UAV_STORAGE_BUFFER       = 0x00000001,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_BUFFER_UAV),
+};
+
+enum vkd3d_shader_compile_option_formatting_flags
+{
+    VKD3D_SHADER_COMPILE_OPTION_FORMATTING_NONE    = 0x00000000,
+    VKD3D_SHADER_COMPILE_OPTION_FORMATTING_COLOUR  = 0x00000001,
+    VKD3D_SHADER_COMPILE_OPTION_FORMATTING_INDENT  = 0x00000002,
+    VKD3D_SHADER_COMPILE_OPTION_FORMATTING_OFFSETS = 0x00000004,
+    VKD3D_SHADER_COMPILE_OPTION_FORMATTING_HEADER  = 0x00000008,
+    VKD3D_SHADER_COMPILE_OPTION_FORMATTING_RAW_IDS = 0x00000010,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_FORMATTING_FLAGS),
+};
+
+enum vkd3d_shader_compile_option_name
+{
+    /**
+     * If \a value is nonzero, do not include debug information in the
+     * compiled shader. The default value is zero.
+     *
+     * This option is supported by vkd3d_shader_compile(). However, not all
+     * compilers support generating debug information.
+     */
+    VKD3D_SHADER_COMPILE_OPTION_STRIP_DEBUG = 0x00000001,
+    /** \a value is a member of enum vkd3d_shader_compile_option_buffer_uav. */
+    VKD3D_SHADER_COMPILE_OPTION_BUFFER_UAV  = 0x00000002,
+    /** \a value is a member of enum vkd3d_shader_compile_option_formatting_flags. */
+    VKD3D_SHADER_COMPILE_OPTION_FORMATTING  = 0x00000003,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_NAME),
+};
+
+/**
+ * Various settings which may affect shader compilation or scanning, passed as
+ * part of struct vkd3d_shader_compile_info. For more details, see the
+ * documentation for individual options.
+ */
+struct vkd3d_shader_compile_option
+{
+    /** Name of the option. */
+    enum vkd3d_shader_compile_option_name name;
+    /**
+     * A value associated with the option. The type and interpretation of the
+     * value depends on the option in question.
+     */
+    unsigned int value;
+};
+
+/** Describes which shader stages a resource is visible to. */
+enum vkd3d_shader_visibility
+{
+    /** The resource is visible to all shader stages. */
+    VKD3D_SHADER_VISIBILITY_ALL = 0,
+    /** The resource is visible only to the vertex shader. */
+    VKD3D_SHADER_VISIBILITY_VERTEX = 1,
+    /** The resource is visible only to the hull shader. */
+    VKD3D_SHADER_VISIBILITY_HULL = 2,
+    /** The resource is visible only to the domain shader. */
+    VKD3D_SHADER_VISIBILITY_DOMAIN = 3,
+    /** The resource is visible only to the geometry shader. */
+    VKD3D_SHADER_VISIBILITY_GEOMETRY = 4,
+    /** The resource is visible only to the pixel shader. */
+    VKD3D_SHADER_VISIBILITY_PIXEL = 5,
+
+    /** The resource is visible only to the compute shader. */
+    VKD3D_SHADER_VISIBILITY_COMPUTE = 1000000000,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_VISIBILITY),
+};
+
+/** A generic structure containing a GPU shader, in text or byte-code format. */
+struct vkd3d_shader_code
+{
+    /**
+     * Pointer to the code. Note that textual formats are not null-terminated.
+     * Therefore \a size should not include a null terminator, when this
+     * structure is passed as input to a vkd3d-shader function, and the
+     * allocated string will not include a null terminator when this structure
+     * is used as output.
+     */
+    const void *code;
+    /** Size of \a code, in bytes. */
+    size_t size;
+};
+
+/** The type of a shader resource descriptor. */
+enum vkd3d_shader_descriptor_type
+{
+    /**
+     * The descriptor is a shader resource view. In Direct3D assembly, this is
+     * bound to a t# register.
+     */
+    VKD3D_SHADER_DESCRIPTOR_TYPE_SRV     = 0x0,
+    /**
+     * The descriptor is an unordered access view. In Direct3D assembly, this is
+     * bound to a u# register.
+     */
+    VKD3D_SHADER_DESCRIPTOR_TYPE_UAV     = 0x1,
+    /**
+     * The descriptor is a constant buffer view. In Direct3D assembly, this is
+     * bound to a cb# register.
+     */
+    VKD3D_SHADER_DESCRIPTOR_TYPE_CBV     = 0x2,
+    /**
+     * The descriptor is a sampler. In Direct3D assembly, this is bound to an s#
+     * register.
+     */
+    VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER = 0x3,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_DESCRIPTOR_TYPE),
+};
+
+/**
+ * A common structure describing the bind point of a descriptor or descriptor
+ * array in the target environment.
+ */
+struct vkd3d_shader_descriptor_binding
+{
+    /**
+     * The set of the descriptor. If the target environment does not support
+     * descriptor sets, this value must be set to 0.
+     */
+    unsigned int set;
+    /** The binding index of the descriptor. */
+    unsigned int binding;
+    /**
+     * The size of this descriptor array. Descriptor arrays are not supported in
+     * this version of vkd3d-shader, and therefore this value must be 1.
+     */
+    unsigned int count;
+};
+
+enum vkd3d_shader_binding_flag
+{
+    VKD3D_SHADER_BINDING_FLAG_BUFFER = 0x00000001,
+    VKD3D_SHADER_BINDING_FLAG_IMAGE  = 0x00000002,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_BINDING_FLAG),
+};
+
+enum vkd3d_shader_parameter_type
+{
+    VKD3D_SHADER_PARAMETER_TYPE_UNKNOWN,
+    VKD3D_SHADER_PARAMETER_TYPE_IMMEDIATE_CONSTANT,
+    VKD3D_SHADER_PARAMETER_TYPE_SPECIALIZATION_CONSTANT,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_PARAMETER_TYPE),
+};
+
+enum vkd3d_shader_parameter_data_type
+{
+    VKD3D_SHADER_PARAMETER_DATA_TYPE_UNKNOWN,
+    VKD3D_SHADER_PARAMETER_DATA_TYPE_UINT32,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_PARAMETER_DATA_TYPE),
+};
+
+enum vkd3d_shader_parameter_name
+{
+    VKD3D_SHADER_PARAMETER_NAME_UNKNOWN,
+    VKD3D_SHADER_PARAMETER_NAME_RASTERIZER_SAMPLE_COUNT,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_PARAMETER_NAME),
+};
+
+struct vkd3d_shader_parameter_immediate_constant
+{
+    union
+    {
+        uint32_t u32;
+    } u;
+};
+
+struct vkd3d_shader_parameter_specialization_constant
+{
+    uint32_t id;
+};
+
+struct vkd3d_shader_parameter
+{
+    enum vkd3d_shader_parameter_name name;
+    enum vkd3d_shader_parameter_type type;
+    enum vkd3d_shader_parameter_data_type data_type;
+    union
+    {
+        struct vkd3d_shader_parameter_immediate_constant immediate_constant;
+        struct vkd3d_shader_parameter_specialization_constant specialization_constant;
+    } u;
+};
+
+/**
+ * Describes the mapping of a single resource or resource array to its binding
+ * point in the target environment.
+ *
+ * For example, to map a Direct3D SRV with register space 2, register "t3" to
+ * a Vulkan descriptor in set 4 and with binding 5, set the following members:
+ * - \a type = VKD3D_SHADER_DESCRIPTOR_TYPE_SRV
+ * - \a register_space = 2
+ * - \a register_index = 3
+ * - \a binding.set = 4
+ * - \a binding.binding = 5
+ * - \a binding.count = 1
+ *
+ * This structure is used in struct vkd3d_shader_interface_info.
+ */
+struct vkd3d_shader_resource_binding
+{
+    /** The type of this descriptor. */
+    enum vkd3d_shader_descriptor_type type;
+    /**
+     * Register space of the Direct3D resource. If the source format does not
+     * support multiple register spaces, this parameter must be set to 0.
+     */
+    unsigned int register_space;
+    /** Register index of the DXBC resource. */
+    unsigned int register_index;
+    /** Shader stage(s) to which the resource is visible. */
+    enum vkd3d_shader_visibility shader_visibility;
+    /** A combination of zero or more elements of vkd3d_shader_binding_flag. */
+    unsigned int flags;
+
+    /** The binding in the target environment. */
+    struct vkd3d_shader_descriptor_binding binding;
+};
+
+#define VKD3D_SHADER_DUMMY_SAMPLER_INDEX ~0u
+
+/**
+ * Describes the mapping of a Direct3D resource-sampler pair to a combined
+ * sampler (i.e. sampled image).
+ *
+ * This structure is used in struct vkd3d_shader_interface_info.
+ */
+struct vkd3d_shader_combined_resource_sampler
+{
+    /**
+     * Register space of the Direct3D resource. If the source format does not
+     * support multiple register spaces, this parameter must be set to 0.
+     */
+    unsigned int resource_space;
+    /** Register index of the Direct3D resource. */
+    unsigned int resource_index;
+    /**
+     * Register space of the Direct3D sampler. If the source format does not
+     * support multiple register spaces, this parameter must be set to 0.
+     */
+    unsigned int sampler_space;
+    /** Register index of the Direct3D sampler. */
+    unsigned int sampler_index;
+    /** Shader stage(s) to which the resource is visible. */
+    enum vkd3d_shader_visibility shader_visibility;
+    /** A combination of zero or more elements of vkd3d_shader_binding_flag. */
+    unsigned int flags;
+
+    /** The binding in the target environment. */
+    struct vkd3d_shader_descriptor_binding binding;
+};
+
+/**
+ * Describes the mapping of a single Direct3D UAV counter.
+ *
+ * This structure is used in struct vkd3d_shader_interface_info.
+ */
+struct vkd3d_shader_uav_counter_binding
+{
+    /**
+     * Register space of the Direct3D UAV descriptor. If the source format does
+     * not support multiple register spaces, this parameter must be set to 0.
+     */
+    unsigned int register_space;
+    /** Register index of the Direct3D UAV descriptor. */
+    unsigned int register_index;
+    /** Shader stage(s) to which the UAV counter is visible. */
+    enum vkd3d_shader_visibility shader_visibility;
+
+    /** The binding in the target environment. */
+    struct vkd3d_shader_descriptor_binding binding;
+    unsigned int offset;
+};
+
+/**
+ * Describes the mapping of a Direct3D constant buffer to a range of push
+ * constants in the target environment.
+ *
+ * This structure is used in struct vkd3d_shader_interface_info.
+ */
+struct vkd3d_shader_push_constant_buffer
+{
+    /**
+     * Register space of the Direct3D resource. If the source format does not
+     * support multiple register spaces, this parameter must be set to 0.
+     */
+    unsigned int register_space;
+    /** Register index of the Direct3D resource. */
+    unsigned int register_index;
+    /** Shader stage(s) to which the resource is visible. */
+    enum vkd3d_shader_visibility shader_visibility;
+
+    /** Offset, in bytes, of the target push constants. */
+    unsigned int offset;
+    /** Size, in bytes, of the target push constants. */
+    unsigned int size;
+};
+
+/**
+ * A chained structure describing the interface between a compiled shader and
+ * the target environment.
+ *
+ * For example, when compiling Direct3D shader byte code to SPIR-V, this
+ * structure contains mappings from Direct3D descriptor registers to SPIR-V
+ * descriptor bindings.
+ *
+ * This structure is optional. If omitted, vkd3d_shader_compile() will use a
+ * default mapping, in which resources are mapped to sequential bindings in
+ * register set 0.
+ *
+ * This structure extends vkd3d_shader_compile_info.
+ *
+ * This structure contains only input parameters.
+ */
+struct vkd3d_shader_interface_info
+{
+    /** Must be set to VKD3D_SHADER_STRUCTURE_TYPE_INTERFACE_INFO. */
+    enum vkd3d_shader_structure_type type;
+    /** Optional pointer to a structure containing further parameters. */
+    const void *next;
+
+    /** Pointer to an array of bindings for shader resource descriptors. */
+    const struct vkd3d_shader_resource_binding *bindings;
+    /** Size, in elements, of \ref bindings. */
+    unsigned int binding_count;
+
+    /** Pointer to an array of bindings for push constant buffers. */
+    const struct vkd3d_shader_push_constant_buffer *push_constant_buffers;
+    /** Size, in elements, of \ref push_constant_buffers. */
+    unsigned int push_constant_buffer_count;
+
+    /** Pointer to an array of bindings for combined samplers. */
+    const struct vkd3d_shader_combined_resource_sampler *combined_samplers;
+    /** Size, in elements, of \ref combined_samplers. */
+    unsigned int combined_sampler_count;
+
+    /** Pointer to an array of bindings for UAV counters. */
+    const struct vkd3d_shader_uav_counter_binding *uav_counters;
+    /** Size, in elements, of \ref uav_counters. */
+    unsigned int uav_counter_count;
+};
+
+struct vkd3d_shader_transform_feedback_element
+{
+    unsigned int stream_index;
+    const char *semantic_name;
+    unsigned int semantic_index;
+    uint8_t component_index;
+    uint8_t component_count;
+    uint8_t output_slot;
+};
+
+/* Extends vkd3d_shader_interface_info. */
+struct vkd3d_shader_transform_feedback_info
+{
+    enum vkd3d_shader_structure_type type;
+    const void *next;
+
+    const struct vkd3d_shader_transform_feedback_element *elements;
+    unsigned int element_count;
+    const unsigned int *buffer_strides;
+    unsigned int buffer_stride_count;
+};
+
+/** The format of a shader to be compiled or scanned. */
+enum vkd3d_shader_source_type
+{
+    /**
+     * The shader has no type or is to be ignored. This is not a valid value
+     * for vkd3d_shader_compile() or vkd3d_shader_scan().
+     */
+    VKD3D_SHADER_SOURCE_NONE,
+    /**
+     * A 'Tokenized Program Format' shader embedded in a DXBC container. This is
+     * the format used for Direct3D shader model 4 and 5 shaders.
+     */
+    VKD3D_SHADER_SOURCE_DXBC_TPF,
+    /** High-Level Shader Language source code. */
+    VKD3D_SHADER_SOURCE_HLSL,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_SOURCE_TYPE),
+};
+
+/** The output format of a compiled shader. */
+enum vkd3d_shader_target_type
+{
+    /**
+     * The shader has no type or is to be ignored. This is not a valid value
+     * for vkd3d_shader_compile() or vkd3d_shader_scan().
+     */
+    VKD3D_SHADER_TARGET_NONE,
+    /**
+     * A SPIR-V shader in binary form. This is the format used for Vulkan
+     * shaders.
+     */
+    VKD3D_SHADER_TARGET_SPIRV_BINARY,
+    VKD3D_SHADER_TARGET_SPIRV_TEXT,
+    VKD3D_SHADER_TARGET_D3D_ASM,
+    /**
+     * A 'Tokenized Program Format' shader embedded in a DXBC container. This is
+     * the format used for Direct3D shader model 4 and 5 shaders.
+     */
+    VKD3D_SHADER_TARGET_DXBC_TPF,
+    /**
+     * An 'OpenGL Shading Language' shader.
+     */
+    VKD3D_SHADER_TARGET_GLSL,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_TARGET_TYPE),
+};
+
+/**
+ * Describes the minimum severity of compilation messages returned by
+ * vkd3d_shader_compile() and similar functions.
+ */
+enum vkd3d_shader_log_level
+{
+    /** No messages will be returned. */
+    VKD3D_SHADER_LOG_NONE,
+    /** Only fatal errors which prevent successful compilation will be returned. */
+    VKD3D_SHADER_LOG_ERROR,
+    /** Non-fatal warnings and fatal errors will be returned. */
+    VKD3D_SHADER_LOG_WARNING,
+    /**
+     * All messages, including general informational messages, will be returned.
+     */
+    VKD3D_SHADER_LOG_INFO,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_LOG_LEVEL),
+};
+
+/**
+ * A chained structure containing compilation parameters.
+ */
+struct vkd3d_shader_compile_info
+{
+    /** Must be set to VKD3D_SHADER_STRUCTURE_TYPE_COMPILE_INFO. */
+    enum vkd3d_shader_structure_type type;
+    /**
+     * Optional pointer to a structure containing further parameters. For a list
+     * of valid structures, refer to the respective function documentation. If
+     * no further parameters are needed, this field should be set to NULL.
+     */
+    const void *next;
+
+    /** Input source code or byte code. */
+    struct vkd3d_shader_code source;
+
+    /** Format of the input code passed in \ref source. */
+    enum vkd3d_shader_source_type source_type;
+    /** Desired output format. */
+    enum vkd3d_shader_target_type target_type;
+
+    /**
+     * Pointer to an array of compilation options. This field is ignored if
+     * \ref option_count is zero, but must be valid otherwise.
+     *
+     * If the same option is specified multiple times, only the last value is
+     * used.
+     *
+     * Options not relevant to or not supported by a particular shader compiler
+     * or scanner will be ignored.
+     */
+    const struct vkd3d_shader_compile_option *options;
+    /** Size, in elements, of \ref options. */
+    unsigned int option_count;
+
+    /** Minimum severity of messages returned from the shader function. */
+    enum vkd3d_shader_log_level log_level;
+    /**
+     * Name of the initial source file, which may be used in error messages or
+     * debug information. This parameter is optional and may be NULL.
+     */
+    const char *source_name;
+};
+
+enum vkd3d_shader_spirv_environment
+{
+    VKD3D_SHADER_SPIRV_ENVIRONMENT_NONE,
+    VKD3D_SHADER_SPIRV_ENVIRONMENT_OPENGL_4_5,
+    VKD3D_SHADER_SPIRV_ENVIRONMENT_VULKAN_1_0, /* default target */
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_SPIRV_ENVIRONMENT),
+};
+
+enum vkd3d_shader_spirv_extension
+{
+    VKD3D_SHADER_SPIRV_EXTENSION_NONE,
+    VKD3D_SHADER_SPIRV_EXTENSION_EXT_DEMOTE_TO_HELPER_INVOCATION,
+    VKD3D_SHADER_SPIRV_EXTENSION_EXT_DESCRIPTOR_INDEXING,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_SPIRV_EXTENSION),
+};
+
+/* Extends vkd3d_shader_compile_info. */
+struct vkd3d_shader_spirv_target_info
+{
+    enum vkd3d_shader_structure_type type;
+    const void *next;
+
+    const char *entry_point; /* "main" if NULL. */
+
+    enum vkd3d_shader_spirv_environment environment;
+
+    const enum vkd3d_shader_spirv_extension *extensions;
+    unsigned int extension_count;
+
+    const struct vkd3d_shader_parameter *parameters;
+    unsigned int parameter_count;
+
+    bool dual_source_blending;
+    const unsigned int *output_swizzles;
+    unsigned int output_swizzle_count;
+};
+
+enum vkd3d_shader_tessellator_output_primitive
+{
+    VKD3D_SHADER_TESSELLATOR_OUTPUT_POINT        = 0x1,
+    VKD3D_SHADER_TESSELLATOR_OUTPUT_LINE         = 0x2,
+    VKD3D_SHADER_TESSELLATOR_OUTPUT_TRIANGLE_CW  = 0x3,
+    VKD3D_SHADER_TESSELLATOR_OUTPUT_TRIANGLE_CCW = 0x4,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_TESSELLATOR_OUTPUT_PRIMITIVE),
+};
+
+enum vkd3d_shader_tessellator_partitioning
+{
+    VKD3D_SHADER_TESSELLATOR_PARTITIONING_INTEGER         = 0x1,
+    VKD3D_SHADER_TESSELLATOR_PARTITIONING_POW2            = 0x2,
+    VKD3D_SHADER_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD  = 0x3,
+    VKD3D_SHADER_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN = 0x4,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_TESSELLATOR_PARTITIONING),
+};
+
+/* Extends vkd3d_shader_spirv_target_info. */
+struct vkd3d_shader_spirv_domain_shader_target_info
+{
+    enum vkd3d_shader_structure_type type;
+    const void *next;
+
+    enum vkd3d_shader_tessellator_output_primitive output_primitive;
+    enum vkd3d_shader_tessellator_partitioning partitioning;
+};
+
+/**
+ * A single preprocessor macro, passed as part of struct
+ * vkd3d_shader_preprocess_info.
+ */
+struct vkd3d_shader_macro
+{
+    /**
+     * Pointer to a null-terminated string containing the name of a macro. This
+     * macro must not be a parameterized (i.e. function-like) macro. If this
+     * field is not a valid macro identifier, this macro will be ignored.
+     */
+    const char *name;
+    /**
+     * Optional pointer to a null-terminated string containing the expansion of
+     * the macro. This field may be set to NULL, in which case the macro has an
+     * empty expansion.
+     */
+    const char *value;
+};
+
+/**
+ * Type of a callback function which will be used to open preprocessor includes.
+ *
+ * This callback function is passed as part of struct
+ * vkd3d_shader_preprocess_info.
+ *
+ * If this function fails, vkd3d-shader will emit a compilation error, and the
+ * \a pfn_close_include callback will not be called.
+ *
+ * \param filename Unquoted string used as an argument to the \#include
+ * directive.
+ *
+ * \param local Whether the \#include directive is requesting a local (i.e.
+ * double-quoted) or system (i.e. angle-bracketed) include.
+ *
+ * \param parent_data Unprocessed source code of the file in which this
+ * \#include directive is evaluated. This parameter may be NULL.
+ *
+ * \param context The user-defined pointer passed to struct
+ * vkd3d_shader_preprocess_info.
+ *
+ * \param out Output location for the full contents of the included file. The
+ * code need not be allocated using standard vkd3d functions, but must remain
+ * valid until the corresponding call to \a pfn_close_include. If this function
+ * fails, the contents of this parameter are ignored.
+ *
+ * \return A member of \ref vkd3d_result.
+ */
+typedef int (*PFN_vkd3d_shader_open_include)(const char *filename, bool local,
+        const char *parent_data, void *context, struct vkd3d_shader_code *out);
+/**
+ * Type of a callback function which will be used to close preprocessor
+ * includes.
+ *
+ * This callback function is passed as part of struct
+ * vkd3d_shader_preprocess_info.
+ *
+ * \param code Contents of the included file, which were allocated by the
+ * \ref PFN_vkd3d_shader_open_include callback. The source code was allocated by
+ * the user and thus need not be freed by vkd3d_shader_free_shader_code().
+ *
+ * \param context The user-defined pointer passed to struct
+ * vkd3d_shader_preprocess_info.
+ */
+typedef void (*PFN_vkd3d_shader_close_include)(const struct vkd3d_shader_code *code, void *context);
+
+/**
+ * A chained structure containing preprocessing parameters.
+ *
+ * This structure is optional.
+ *
+ * This structure extends vkd3d_shader_compile_info.
+ *
+ * This structure contains only input parameters.
+ *
+ * \since 1.3
+ */
+struct vkd3d_shader_preprocess_info
+{
+    /** Must be set to VKD3D_SHADER_STRUCTURE_TYPE_PREPROCESS_INFO. */
+    enum vkd3d_shader_structure_type type;
+    /** Optional pointer to a structure containing further parameters. */
+    const void *next;
+
+    /**
+     * Pointer to an array of predefined macros. Each macro in this array will
+     * be expanded as if a corresponding #define statement were prepended to the
+     * source code.
+     *
+     * If the same macro is specified multiple times, only the last value is
+     * used.
+     */
+    const struct vkd3d_shader_macro *macros;
+    /** Size, in elements, of \ref macros. */
+    unsigned int macro_count;
+
+    /**
+     * Optional pointer to a callback function, which will be called in order to
+     * evaluate \#include directives. The function receives parameters
+     * corresponding to the directive's arguments, and should return the
+     * complete text of the included file.
+     *
+     * If this field is set to NULL, or if this structure is omitted,
+     * vkd3d-shader will attempt to open included files using POSIX file APIs.
+     *
+     * If this field is set to NULL, the \ref pfn_close_include field must also
+     * be set to NULL.
+     */
+    PFN_vkd3d_shader_open_include pfn_open_include;
+    /**
+     * Optional pointer to a callback function, which will be called whenever an
+     * included file is closed. This function will be called exactly once for
+     * each successful call to \ref pfn_open_include, and should be used to free
+     * any resources allocated thereby.
+     *
+     * If this field is set to NULL, the \ref pfn_open_include field must also
+     * be set to NULL.
+     */
+    PFN_vkd3d_shader_close_include pfn_close_include;
+    /**
+     * User-defined pointer which will be passed unmodified to the
+     * \ref pfn_open_include and \ref pfn_close_include callbacks.
+     */
+    void *include_context;
+};
+
+/**
+ * A chained structure containing HLSL compilation parameters.
+ *
+ * This structure is optional.
+ *
+ * This structure extends vkd3d_shader_compile_info.
+ *
+ * This structure contains only input parameters.
+ *
+ * \since 1.3
+ */
+struct vkd3d_shader_hlsl_source_info
+{
+    /** Must be set to VKD3D_SHADER_STRUCTURE_TYPE_HLSL_SOURCE_INFO. */
+    enum vkd3d_shader_structure_type type;
+    /** Optional pointer to a structure containing further parameters. */
+    const void *next;
+
+    /**
+     * Optional pointer to a null-terminated string containing the shader entry
+     * point.
+     *
+     * If this parameter is NULL, vkd3d-shader uses the entry point "main".
+     */
+    const char *entry_point;
+    struct vkd3d_shader_code secondary_code;
+    /**
+     * Pointer to a null-terminated string containing the target shader
+     * profile.
+     */
+    const char *profile;
+};
+
+/* root signature 1.0 */
+enum vkd3d_shader_filter
+{
+    VKD3D_SHADER_FILTER_MIN_MAG_MIP_POINT                          = 0x000,
+    VKD3D_SHADER_FILTER_MIN_MAG_POINT_MIP_LINEAR                   = 0x001,
+    VKD3D_SHADER_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT             = 0x004,
+    VKD3D_SHADER_FILTER_MIN_POINT_MAG_MIP_LINEAR                   = 0x005,
+    VKD3D_SHADER_FILTER_MIN_LINEAR_MAG_MIP_POINT                   = 0x010,
+    VKD3D_SHADER_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR            = 0x011,
+    VKD3D_SHADER_FILTER_MIN_MAG_LINEAR_MIP_POINT                   = 0x014,
+    VKD3D_SHADER_FILTER_MIN_MAG_MIP_LINEAR                         = 0x015,
+    VKD3D_SHADER_FILTER_ANISOTROPIC                                = 0x055,
+    VKD3D_SHADER_FILTER_COMPARISON_MIN_MAG_MIP_POINT               = 0x080,
+    VKD3D_SHADER_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR        = 0x081,
+    VKD3D_SHADER_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT  = 0x084,
+    VKD3D_SHADER_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR        = 0x085,
+    VKD3D_SHADER_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT        = 0x090,
+    VKD3D_SHADER_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x091,
+    VKD3D_SHADER_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT        = 0x094,
+    VKD3D_SHADER_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR              = 0x095,
+    VKD3D_SHADER_FILTER_COMPARISON_ANISOTROPIC                     = 0x0d5,
+    VKD3D_SHADER_FILTER_MINIMUM_MIN_MAG_MIP_POINT                  = 0x100,
+    VKD3D_SHADER_FILTER_MINIMUM_MIN_MAG_POINT_MIP_LINEAR           = 0x101,
+    VKD3D_SHADER_FILTER_MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT     = 0x104,
+    VKD3D_SHADER_FILTER_MINIMUM_MIN_POINT_MAG_MIP_LINEAR           = 0x105,
+    VKD3D_SHADER_FILTER_MINIMUM_MIN_LINEAR_MAG_MIP_POINT           = 0x110,
+    VKD3D_SHADER_FILTER_MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR    = 0x111,
+    VKD3D_SHADER_FILTER_MINIMUM_MIN_MAG_LINEAR_MIP_POINT           = 0x114,
+    VKD3D_SHADER_FILTER_MINIMUM_MIN_MAG_MIP_LINEAR                 = 0x115,
+    VKD3D_SHADER_FILTER_MINIMUM_ANISOTROPIC                        = 0x155,
+    VKD3D_SHADER_FILTER_MAXIMUM_MIN_MAG_MIP_POINT                  = 0x180,
+    VKD3D_SHADER_FILTER_MAXIMUM_MIN_MAG_POINT_MIP_LINEAR           = 0x181,
+    VKD3D_SHADER_FILTER_MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT     = 0x184,
+    VKD3D_SHADER_FILTER_MAXIMUM_MIN_POINT_MAG_MIP_LINEAR           = 0x185,
+    VKD3D_SHADER_FILTER_MAXIMUM_MIN_LINEAR_MAG_MIP_POINT           = 0x190,
+    VKD3D_SHADER_FILTER_MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR    = 0x191,
+    VKD3D_SHADER_FILTER_MAXIMUM_MIN_MAG_LINEAR_MIP_POINT           = 0x194,
+    VKD3D_SHADER_FILTER_MAXIMUM_MIN_MAG_MIP_LINEAR                 = 0x195,
+    VKD3D_SHADER_FILTER_MAXIMUM_ANISOTROPIC                        = 0x1d5,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_FILTER),
+};
+
+enum vkd3d_shader_texture_address_mode
+{
+    VKD3D_SHADER_TEXTURE_ADDRESS_MODE_WRAP        = 0x1,
+    VKD3D_SHADER_TEXTURE_ADDRESS_MODE_MIRROR      = 0x2,
+    VKD3D_SHADER_TEXTURE_ADDRESS_MODE_CLAMP       = 0x3,
+    VKD3D_SHADER_TEXTURE_ADDRESS_MODE_BORDER      = 0x4,
+    VKD3D_SHADER_TEXTURE_ADDRESS_MODE_MIRROR_ONCE = 0x5,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_TEXTURE_ADDRESS_MODE),
+};
+
+enum vkd3d_shader_comparison_func
+{
+    VKD3D_SHADER_COMPARISON_FUNC_NEVER         = 0x1,
+    VKD3D_SHADER_COMPARISON_FUNC_LESS          = 0x2,
+    VKD3D_SHADER_COMPARISON_FUNC_EQUAL         = 0x3,
+    VKD3D_SHADER_COMPARISON_FUNC_LESS_EQUAL    = 0x4,
+    VKD3D_SHADER_COMPARISON_FUNC_GREATER       = 0x5,
+    VKD3D_SHADER_COMPARISON_FUNC_NOT_EQUAL     = 0x6,
+    VKD3D_SHADER_COMPARISON_FUNC_GREATER_EQUAL = 0x7,
+    VKD3D_SHADER_COMPARISON_FUNC_ALWAYS        = 0x8,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPARISON_FUNC),
+};
+
+enum vkd3d_shader_static_border_colour
+{
+    VKD3D_SHADER_STATIC_BORDER_COLOUR_TRANSPARENT_BLACK = 0x0,
+    VKD3D_SHADER_STATIC_BORDER_COLOUR_OPAQUE_BLACK      = 0x1,
+    VKD3D_SHADER_STATIC_BORDER_COLOUR_OPAQUE_WHITE      = 0x2,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_STATIC_BORDER_COLOUR),
+};
+
+struct vkd3d_shader_static_sampler_desc
+{
+    enum vkd3d_shader_filter filter;
+    enum vkd3d_shader_texture_address_mode address_u;
+    enum vkd3d_shader_texture_address_mode address_v;
+    enum vkd3d_shader_texture_address_mode address_w;
+    float mip_lod_bias;
+    unsigned int max_anisotropy;
+    enum vkd3d_shader_comparison_func comparison_func;
+    enum vkd3d_shader_static_border_colour border_colour;
+    float min_lod;
+    float max_lod;
+    unsigned int shader_register;
+    unsigned int register_space;
+    enum vkd3d_shader_visibility shader_visibility;
+};
+
+struct vkd3d_shader_descriptor_range
+{
+    enum vkd3d_shader_descriptor_type range_type;
+    unsigned int descriptor_count;
+    unsigned int base_shader_register;
+    unsigned int register_space;
+    unsigned int descriptor_table_offset;
+};
+
+struct vkd3d_shader_root_descriptor_table
+{
+    unsigned int descriptor_range_count;
+    const struct vkd3d_shader_descriptor_range *descriptor_ranges;
+};
+
+struct vkd3d_shader_root_constants
+{
+    unsigned int shader_register;
+    unsigned int register_space;
+    unsigned int value_count;
+};
+
+struct vkd3d_shader_root_descriptor
+{
+    unsigned int shader_register;
+    unsigned int register_space;
+};
+
+enum vkd3d_shader_root_parameter_type
+{
+    VKD3D_SHADER_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE = 0x0,
+    VKD3D_SHADER_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS  = 0x1,
+    VKD3D_SHADER_ROOT_PARAMETER_TYPE_CBV              = 0x2,
+    VKD3D_SHADER_ROOT_PARAMETER_TYPE_SRV              = 0x3,
+    VKD3D_SHADER_ROOT_PARAMETER_TYPE_UAV              = 0x4,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_ROOT_PARAMETER_TYPE),
+};
+
+struct vkd3d_shader_root_parameter
+{
+    enum vkd3d_shader_root_parameter_type parameter_type;
+    union
+    {
+        struct vkd3d_shader_root_descriptor_table descriptor_table;
+        struct vkd3d_shader_root_constants constants;
+        struct vkd3d_shader_root_descriptor descriptor;
+    } u;
+    enum vkd3d_shader_visibility shader_visibility;
+};
+
+enum vkd3d_shader_root_signature_flags
+{
+    VKD3D_SHADER_ROOT_SIGNATURE_FLAG_NONE                               = 0x00,
+    VKD3D_SHADER_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT = 0x01,
+    VKD3D_SHADER_ROOT_SIGNATURE_FLAG_DENY_VERTEX_SHADER_ROOT_ACCESS     = 0x02,
+    VKD3D_SHADER_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS       = 0x04,
+    VKD3D_SHADER_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS     = 0x08,
+    VKD3D_SHADER_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS   = 0x10,
+    VKD3D_SHADER_ROOT_SIGNATURE_FLAG_DENY_PIXEL_SHADER_ROOT_ACCESS      = 0x20,
+    VKD3D_SHADER_ROOT_SIGNATURE_FLAG_ALLOW_STREAM_OUTPUT                = 0x40,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_ROOT_SIGNATURE_FLAGS),
+};
+
+struct vkd3d_shader_root_signature_desc
+{
+    unsigned int parameter_count;
+    const struct vkd3d_shader_root_parameter *parameters;
+    unsigned int static_sampler_count;
+    const struct vkd3d_shader_static_sampler_desc *static_samplers;
+    enum vkd3d_shader_root_signature_flags flags;
+};
+
+/* root signature 1.1 */
+enum vkd3d_shader_root_descriptor_flags
+{
+    VKD3D_SHADER_ROOT_DESCRIPTOR_FLAG_NONE                             = 0x0,
+    VKD3D_SHADER_ROOT_DESCRIPTOR_FLAG_DATA_VOLATILE                    = 0x2,
+    VKD3D_SHADER_ROOT_DESCRIPTOR_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE = 0x4,
+    VKD3D_SHADER_ROOT_DESCRIPTOR_FLAG_DATA_STATIC                      = 0x8,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_ROOT_DESCRIPTOR_FLAGS),
+};
+
+enum vkd3d_shader_descriptor_range_flags
+{
+    VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_NONE                             = 0x0,
+    VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE             = 0x1,
+    VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE                    = 0x2,
+    VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE = 0x4,
+    VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DATA_STATIC                      = 0x8,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_DESCRIPTOR_RANGE_FLAGS),
+};
+
+struct vkd3d_shader_descriptor_range1
+{
+    enum vkd3d_shader_descriptor_type range_type;
+    unsigned int descriptor_count;
+    unsigned int base_shader_register;
+    unsigned int register_space;
+    enum vkd3d_shader_descriptor_range_flags flags;
+    unsigned int descriptor_table_offset;
+};
+
+struct vkd3d_shader_root_descriptor_table1
+{
+    unsigned int descriptor_range_count;
+    const struct vkd3d_shader_descriptor_range1 *descriptor_ranges;
+};
+
+struct vkd3d_shader_root_descriptor1
+{
+    unsigned int shader_register;
+    unsigned int register_space;
+    enum vkd3d_shader_root_descriptor_flags flags;
+};
+
+struct vkd3d_shader_root_parameter1
+{
+    enum vkd3d_shader_root_parameter_type parameter_type;
+    union
+    {
+        struct vkd3d_shader_root_descriptor_table1 descriptor_table;
+        struct vkd3d_shader_root_constants constants;
+        struct vkd3d_shader_root_descriptor1 descriptor;
+    } u;
+    enum vkd3d_shader_visibility shader_visibility;
+};
+
+struct vkd3d_shader_root_signature_desc1
+{
+    unsigned int parameter_count;
+    const struct vkd3d_shader_root_parameter1 *parameters;
+    unsigned int static_sampler_count;
+    const struct vkd3d_shader_static_sampler_desc *static_samplers;
+    enum vkd3d_shader_root_signature_flags flags;
+};
+
+enum vkd3d_shader_root_signature_version
+{
+    VKD3D_SHADER_ROOT_SIGNATURE_VERSION_1_0 = 0x1,
+    VKD3D_SHADER_ROOT_SIGNATURE_VERSION_1_1 = 0x2,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_ROOT_SIGNATURE_VERSION),
+};
+
+struct vkd3d_shader_versioned_root_signature_desc
+{
+    enum vkd3d_shader_root_signature_version version;
+    union
+    {
+        struct vkd3d_shader_root_signature_desc v_1_0;
+        struct vkd3d_shader_root_signature_desc1 v_1_1;
+    } u;
+};
+
+/**
+ * The type of a shader resource, returned as part of struct
+ * vkd3d_shader_descriptor_info.
+ */
+enum vkd3d_shader_resource_type
+{
+    /**
+     * The type is invalid or not applicable for this descriptor. This value is
+     * returned for samplers.
+     */
+    VKD3D_SHADER_RESOURCE_NONE              = 0x0,
+    /** Dimensionless buffer. */
+    VKD3D_SHADER_RESOURCE_BUFFER            = 0x1,
+    /** 1-dimensional texture. */
+    VKD3D_SHADER_RESOURCE_TEXTURE_1D        = 0x2,
+    /** 2-dimensional texture. */
+    VKD3D_SHADER_RESOURCE_TEXTURE_2D        = 0x3,
+    /** Multisampled 2-dimensional texture. */
+    VKD3D_SHADER_RESOURCE_TEXTURE_2DMS      = 0x4,
+    /** 3-dimensional texture. */
+    VKD3D_SHADER_RESOURCE_TEXTURE_3D        = 0x5,
+    /** Cubemap texture. */
+    VKD3D_SHADER_RESOURCE_TEXTURE_CUBE      = 0x6,
+    /** 1-dimensional array texture. */
+    VKD3D_SHADER_RESOURCE_TEXTURE_1DARRAY   = 0x7,
+    /** 2-dimensional array texture. */
+    VKD3D_SHADER_RESOURCE_TEXTURE_2DARRAY   = 0x8,
+    /** Multisampled 2-dimensional array texture. */
+    VKD3D_SHADER_RESOURCE_TEXTURE_2DMSARRAY = 0x9,
+    /** Cubemap array texture. */
+    VKD3D_SHADER_RESOURCE_TEXTURE_CUBEARRAY = 0xa,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_RESOURCE_TYPE),
+};
+
+/**
+ * The type of the data contained in a shader resource, returned as part of
+ * struct vkd3d_shader_descriptor_info. All formats are 32-bit.
+ */
+enum vkd3d_shader_resource_data_type
+{
+    /** Unsigned normalized integer. */
+    VKD3D_SHADER_RESOURCE_DATA_UNORM = 0x1,
+    /** Signed normalized integer. */
+    VKD3D_SHADER_RESOURCE_DATA_SNORM = 0x2,
+    /** Signed integer. */
+    VKD3D_SHADER_RESOURCE_DATA_INT   = 0x3,
+    /** Unsigned integer. */
+    VKD3D_SHADER_RESOURCE_DATA_UINT  = 0x4,
+    /** IEEE floating-point. */
+    VKD3D_SHADER_RESOURCE_DATA_FLOAT = 0x5,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_RESOURCE_DATA_TYPE),
+};
+
+/**
+ * Additional flags describing a shader descriptor, returned as part of struct
+ * vkd3d_shader_descriptor_info.
+ */
+enum vkd3d_shader_descriptor_info_flag
+{
+    /**
+     * The descriptor is a UAV resource, whose counter is read from or written
+     * to by the shader.
+     */
+    VKD3D_SHADER_DESCRIPTOR_INFO_FLAG_UAV_COUNTER             = 0x00000001,
+    /** The descriptor is a UAV resource, which is read from by the shader. */
+    VKD3D_SHADER_DESCRIPTOR_INFO_FLAG_UAV_READ                = 0x00000002,
+    /** The descriptor is a comparison sampler. */
+    VKD3D_SHADER_DESCRIPTOR_INFO_FLAG_SAMPLER_COMPARISON_MODE = 0x00000004,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_DESCRIPTOR_INFO_FLAG),
+};
+
+/**
+ * Describes a single shader descriptor; returned as part of
+ * struct vkd3d_shader_scan_descriptor_info.
+ */
+struct vkd3d_shader_descriptor_info
+{
+    /** Type of the descriptor (for example, SRV, CBV, UAV, or sampler). */
+    enum vkd3d_shader_descriptor_type type;
+    /**
+     * Register space of the resource, or 0 if the shader does not
+     * support multiple register spaces.
+     */
+    unsigned int register_space;
+    /** Register index of the descriptor. */
+    unsigned int register_index;
+    /** Resource type, if applicable, including its dimension. */
+    enum vkd3d_shader_resource_type resource_type;
+    /** Data type contained in the resource (for example, float or integer). */
+    enum vkd3d_shader_resource_data_type resource_data_type;
+    /**
+     * Bitwise combination of zero or more members of
+     * \ref vkd3d_shader_descriptor_info_flag.
+     */
+    unsigned int flags;
+    /**
+     *  Size of this descriptor array, or 1 if a single descriptor.
+     *  For an unbounded array this value is ~0u.
+     */
+    unsigned int count;
+};
+
+/**
+ * A chained structure enumerating the descriptors declared by a shader.
+ *
+ * This structure extends vkd3d_shader_compile_info.
+ */
+struct vkd3d_shader_scan_descriptor_info
+{
+    /**
+     * Input; must be set to VKD3D_SHADER_STRUCTURE_TYPE_SCAN_DESCRIPTOR_INFO.
+     */
+    enum vkd3d_shader_structure_type type;
+    /** Input; optional pointer to a structure containing further parameters. */
+    const void *next;
+
+    /** Output; returns a pointer to an array of descriptors. */
+    struct vkd3d_shader_descriptor_info *descriptors;
+    /** Output; size, in elements, of \ref descriptors. */
+    unsigned int descriptor_count;
+};
+
+/**
+ * Data type of a shader varying, returned as part of struct
+ * vkd3d_shader_signature_element.
+ */
+enum vkd3d_shader_component_type
+{
+    /** The varying has no type. */
+    VKD3D_SHADER_COMPONENT_VOID     = 0x0,
+    /** 32-bit unsigned integer. */
+    VKD3D_SHADER_COMPONENT_UINT     = 0x1,
+    /** 32-bit signed integer. */
+    VKD3D_SHADER_COMPONENT_INT      = 0x2,
+    /** 32-bit IEEE floating-point. */
+    VKD3D_SHADER_COMPONENT_FLOAT    = 0x3,
+    /** Boolean. */
+    VKD3D_SHADER_COMPONENT_BOOL     = 0x4,
+    /** 64-bit IEEE floating-point. */
+    VKD3D_SHADER_COMPONENT_DOUBLE   = 0x5,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPONENT_TYPE),
+};
+
+/** System value semantic, returned as part of struct vkd3d_shader_signature. */
+enum vkd3d_shader_sysval_semantic
+{
+    /** No system value. */
+    VKD3D_SHADER_SV_NONE                      = 0x00,
+    /** Vertex position; SV_Position in Direct3D. */
+    VKD3D_SHADER_SV_POSITION                  = 0x01,
+    /** Clip distance; SV_ClipDistance in Direct3D. */
+    VKD3D_SHADER_SV_CLIP_DISTANCE             = 0x02,
+    /** Cull distance; SV_CullDistance in Direct3D. */
+    VKD3D_SHADER_SV_CULL_DISTANCE             = 0x03,
+    /** Render target layer; SV_RenderTargetArrayIndex in Direct3D. */
+    VKD3D_SHADER_SV_RENDER_TARGET_ARRAY_INDEX = 0x04,
+    /** Viewport index; SV_ViewportArrayIndex in Direct3D. */
+    VKD3D_SHADER_SV_VIEWPORT_ARRAY_INDEX      = 0x05,
+    /** Vertex ID; SV_VertexID in Direct3D. */
+    VKD3D_SHADER_SV_VERTEX_ID                 = 0x06,
+    /** Primtive ID; SV_PrimitiveID in Direct3D. */
+    VKD3D_SHADER_SV_PRIMITIVE_ID              = 0x07,
+    /** Instance ID; SV_InstanceID in Direct3D. */
+    VKD3D_SHADER_SV_INSTANCE_ID               = 0x08,
+    /** Whether the triangle is front-facing; SV_IsFrontFace in Direct3D. */
+    VKD3D_SHADER_SV_IS_FRONT_FACE             = 0x09,
+    /** Sample index; SV_SampleIndex in Direct3D. */
+    VKD3D_SHADER_SV_SAMPLE_INDEX              = 0x0a,
+    VKD3D_SHADER_SV_TESS_FACTOR_QUADEDGE      = 0x0b,
+    VKD3D_SHADER_SV_TESS_FACTOR_QUADINT       = 0x0c,
+    VKD3D_SHADER_SV_TESS_FACTOR_TRIEDGE       = 0x0d,
+    VKD3D_SHADER_SV_TESS_FACTOR_TRIINT        = 0x0e,
+    VKD3D_SHADER_SV_TESS_FACTOR_LINEDET       = 0x0f,
+    VKD3D_SHADER_SV_TESS_FACTOR_LINEDEN       = 0x10,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_SYSVAL_SEMANTIC),
+};
+
+/**
+ * Minimum interpolation precision of a shader varying, returned as part of
+ * struct vkd3d_shader_signature_element.
+ */
+enum vkd3d_shader_minimum_precision
+{
+    VKD3D_SHADER_MINIMUM_PRECISION_NONE      = 0,
+    /** 16-bit floating-point. */
+    VKD3D_SHADER_MINIMUM_PRECISION_FLOAT_16  = 1,
+    /** 10-bit fixed point (2 integer and 8 fractional bits). */
+    VKD3D_SHADER_MINIMUM_PRECISION_FIXED_8_2 = 2,
+    /** 16-bit signed integer. */
+    VKD3D_SHADER_MINIMUM_PRECISION_INT_16    = 4,
+    /** 16-bit unsigned integer. */
+    VKD3D_SHADER_MINIMUM_PRECISION_UINT_16   = 5,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_MINIMUM_PRECISION),
+};
+
+/**
+ * A single shader varying, returned as part of struct vkd3d_shader_signature.
+ */
+struct vkd3d_shader_signature_element
+{
+    /** Semantic name. */
+    const char *semantic_name;
+    /** Semantic index, or 0 if the semantic is not indexed. */
+    unsigned int semantic_index;
+    /**
+     * Stream index of a geometry shader output semantic. If the signature is
+     * not a geometry shader output signature, this field will be set to 0.
+     */
+    unsigned int stream_index;
+    /**
+     * System value semantic. If the varying is not a system value, this field
+     * will be set to VKD3D_SHADER_SV_NONE.
+     */
+    enum vkd3d_shader_sysval_semantic sysval_semantic;
+    /** Data type. */
+    enum vkd3d_shader_component_type component_type;
+    /** Register index. */
+    unsigned int register_index;
+    /** Mask of the register components allocated to this varying. */
+    unsigned int mask;
+    /**
+     * Subset of \ref mask which the shader reads from or writes to. Unlike
+     * Direct3D shader bytecode, the mask for output and tessellation signatures
+     * is not inverted, i.e. bits set in this field denote components which are
+     * written to.
+     */
+    unsigned int used_mask;
+    /** Minimum interpolation precision. */
+    enum vkd3d_shader_minimum_precision min_precision;
+};
+
+/**
+ * Description of a shader input or output signature. This structure is
+ * populated by vkd3d_shader_parse_input_signature().
+ *
+ * The helper function vkd3d_shader_find_signature_element() will look up a
+ * varying element by its semantic name, semantic index, and stream index.
+ */
+struct vkd3d_shader_signature
+{
+    /** Pointer to an array of varyings. */
+    struct vkd3d_shader_signature_element *elements;
+    /** Size, in elements, of \ref elements. */
+    unsigned int element_count;
+};
+
+/** Possible values for a single component of a vkd3d-shader swizzle. */
+enum vkd3d_shader_swizzle_component
+{
+    VKD3D_SHADER_SWIZZLE_X = 0x0,
+    VKD3D_SHADER_SWIZZLE_Y = 0x1,
+    VKD3D_SHADER_SWIZZLE_Z = 0x2,
+    VKD3D_SHADER_SWIZZLE_W = 0x3,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_SWIZZLE_COMPONENT),
+};
+
+/**
+ * A mask selecting one component from a vkd3d-shader swizzle. The component has
+ * type \ref vkd3d_shader_swizzle_component.
+ */
+#define VKD3D_SHADER_SWIZZLE_MASK (0xffu)
+/** The offset, in bits, of the nth parameter of a vkd3d-shader swizzle. */
+#define VKD3D_SHADER_SWIZZLE_SHIFT(idx) (8u * (idx))
+
+/**
+ * A helper macro which returns a vkd3d-shader swizzle with the given
+ * components. The components are specified as the suffixes to members of
+ * \ref vkd3d_shader_swizzle_component. For example, the swizzle ".xwyy" can be
+ * represented as:
+ * \code
+ * VKD3D_SHADER_SWIZZLE(X, W, Y, Y)
+ * \endcode
+ */
+#define VKD3D_SHADER_SWIZZLE(x, y, z, w) \
+        vkd3d_shader_create_swizzle(VKD3D_SHADER_SWIZZLE_ ## x, \
+                VKD3D_SHADER_SWIZZLE_ ## y, \
+                VKD3D_SHADER_SWIZZLE_ ## z, \
+                VKD3D_SHADER_SWIZZLE_ ## w)
+
+/** The identity swizzle ".xyzw". */
+#define VKD3D_SHADER_NO_SWIZZLE VKD3D_SHADER_SWIZZLE(X, Y, Z, W)
+
+/** Build a vkd3d-shader swizzle with the given components. */
+static inline uint32_t vkd3d_shader_create_swizzle(enum vkd3d_shader_swizzle_component x,
+        enum vkd3d_shader_swizzle_component y, enum vkd3d_shader_swizzle_component z,
+        enum vkd3d_shader_swizzle_component w)
+{
+    return ((x & VKD3D_SHADER_SWIZZLE_MASK) << VKD3D_SHADER_SWIZZLE_SHIFT(0))
+            | ((y & VKD3D_SHADER_SWIZZLE_MASK) << VKD3D_SHADER_SWIZZLE_SHIFT(1))
+            | ((z & VKD3D_SHADER_SWIZZLE_MASK) << VKD3D_SHADER_SWIZZLE_SHIFT(2))
+            | ((w & VKD3D_SHADER_SWIZZLE_MASK) << VKD3D_SHADER_SWIZZLE_SHIFT(3));
+}
+
+#ifdef LIBVKD3D_SHADER_SOURCE
+# define VKD3D_SHADER_API VKD3D_EXPORT
+#else
+# define VKD3D_SHADER_API VKD3D_IMPORT
+#endif
+
+#ifndef VKD3D_SHADER_NO_PROTOTYPES
+
+/**
+ * Returns the current version of this library.
+ *
+ * \param major Output location for the major version of this library.
+ *
+ * \param minor Output location for the minor version of this library.
+ *
+ * \return A human-readable string describing the library name and version. This
+ * string is null-terminated and UTF-8 encoded. This may be a pointer to static
+ * data in libvkd3d-shader; it should not be freed.
+ */
+VKD3D_SHADER_API const char *vkd3d_shader_get_version(unsigned int *major, unsigned int *minor);
+/**
+ * Returns the source types supported, with any target type, by
+ * vkd3d_shader_compile().
+ *
+ * Use vkd3d_shader_get_supported_target_types() to determine which target types
+ * are supported for each source type.
+ *
+ * \param count Output location for the size, in elements, of the returned
+ * array.
+ *
+ * \return Pointer to an array of source types supported by this version of
+ * vkd3d-shader. This array may be a pointer to static data in libvkd3d-shader;
+ * it should not be freed.
+ */
+VKD3D_SHADER_API const enum vkd3d_shader_source_type *vkd3d_shader_get_supported_source_types(unsigned int *count);
+/**
+ * Returns the target types supported, with the given source type, by
+ * vkd3d_shader_compile().
+ *
+ * \param source_type Source type for which to enumerate supported target types.
+ *
+ * \param count Output location for the size, in elements, of the returned
+ * array.
+ *
+ * \return Pointer to an array of target types supported by this version of
+ * vkd3d-shader. This array may be a pointer to static data in libvkd3d-shader;
+ * it should not be freed.
+ */
+VKD3D_SHADER_API const enum vkd3d_shader_target_type *vkd3d_shader_get_supported_target_types(
+        enum vkd3d_shader_source_type source_type, unsigned int *count);
+
+/**
+ * Transform a form of GPU shader source code or byte code into another form of
+ * source code or byte code.
+ *
+ * This version of vkd3d-shader supports the following transformations:
+ * - VKD3D_SHADER_SOURCE_DXBC_TPF to VKD3D_SHADER_TARGET_SPIRV_BINARY
+ *
+ * Supported transformations can also be detected at runtime with the functions
+ * vkd3d_shader_get_supported_source_types() and
+ * vkd3d_shader_get_supported_target_types().
+ *
+ * Depending on the source and target types, this function may support the
+ * following chained structures:
+ * - vkd3d_shader_interface_info
+ * - vkd3d_shader_spirv_domain_shader_target_info
+ * - vkd3d_shader_spirv_target_info
+ * - vkd3d_shader_transform_feedback_info
+ *
+ * \param compile_info A chained structure containing compilation parameters.
+ *
+ * \param out A pointer to a vkd3d_shader_code structure in which the compiled
+ * code will be stored.
+ * \n
+ * The compiled shader is allocated by vkd3d-shader and should be freed with
+ * vkd3d_shader_free_shader_code() when no longer needed.
+ *
+ * \param messages Optional output location for error or informational messages
+ * produced by the compiler.
+ * \n
+ * This string is null-terminated and UTF-8 encoded.
+ * \n
+ * The messages are allocated by vkd3d-shader and should be freed with
+ * vkd3d_shader_free_messages() when no longer needed.
+ * \n
+ * The messages returned can be regulated with the \a log_level member of struct
+ * vkd3d_shader_compile_info. Regardless of the requested level, if this
+ * parameter is NULL, no compilation messages will be returned.
+ * \n
+ * If no compilation messages are produced by the compiler, this parameter may
+ * receive NULL instead of a valid string pointer.
+ *
+ * \return A member of \ref vkd3d_result.
+ */
+VKD3D_SHADER_API int vkd3d_shader_compile(const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_code *out, char **messages);
+/**
+ * Free shader messages allocated by another vkd3d-shader function, such as
+ * vkd3d_shader_compile().
+ *
+ * \param messages Messages to free. This pointer is optional and may be NULL,
+ * in which case no action will be taken.
+ */
+VKD3D_SHADER_API void vkd3d_shader_free_messages(char *messages);
+/**
+ * Free shader code allocated by another vkd3d-shader function, such as
+ * vkd3d_shader_compile().
+ *
+ * This function frees the \ref vkd3d_shader_code.code member, but does not free
+ * the structure itself.
+ *
+ * \param code Code to free.
+ */
+VKD3D_SHADER_API void vkd3d_shader_free_shader_code(struct vkd3d_shader_code *code);
+
+/**
+ * Convert a byte code description of a shader root signature to a structural
+ * description which can be easily parsed by C code.
+ *
+ * This function corresponds to
+ * ID3D12VersionedRootSignatureDeserializer::GetUnconvertedRootSignatureDesc().
+ *
+ * This function performs the reverse transformation of
+ * vkd3d_shader_serialize_root_signature().
+ *
+ * This function parses a standalone root signature, and should not be confused
+ * with vkd3d_shader_parse_input_signature().
+ *
+ * \param dxbc Compiled byte code, in DXBC format.
+ *
+ * \param root_signature Output location in which the decompiled root signature
+ * will be stored.
+ * \n
+ * Members of \a root_signature may be allocated by vkd3d-shader. The signature
+ * should be freed with vkd3d_shader_free_root_signature() when no longer
+ * needed.
+ *
+ * \param messages Optional output location for error or informational messages
+ * produced by the compiler.
+ * \n
+ * This parameter behaves identically to the \a messages parameter of
+ * vkd3d_shader_compile().
+ *
+ * \return A member of \ref vkd3d_result.
+ */
+VKD3D_SHADER_API int vkd3d_shader_parse_root_signature(const struct vkd3d_shader_code *dxbc,
+        struct vkd3d_shader_versioned_root_signature_desc *root_signature, char **messages);
+/**
+ * Free a structural representation of a shader root signature allocated by
+ * vkd3d_shader_convert_root_signature() or vkd3d_shader_parse_root_signature().
+ *
+ * This function may free members of struct
+ * vkd3d_shader_versioned_root_signature_desc, but does not free the structure
+ * itself.
+ *
+ * \param root_signature Signature description to free.
+ */
+VKD3D_SHADER_API void vkd3d_shader_free_root_signature(
+        struct vkd3d_shader_versioned_root_signature_desc *root_signature);
+
+/**
+ * Convert a structural description of a shader root signature to a byte code
+ * format capable of being read by ID3D12Device::CreateRootSignature. The
+ * compiled signature is compatible with Microsoft D3D 12.
+ *
+ * This function corresponds to D3D12SerializeVersionedRootSignature().
+ *
+ * \param root_signature Description of the root signature.
+ *
+ * \param dxbc A pointer to a vkd3d_shader_code structure in which the compiled
+ * code will be stored.
+ * \n
+ * The compiled signature is allocated by vkd3d-shader and should be freed with
+ * vkd3d_shader_free_shader_code() when no longer needed.
+ *
+ * \param messages Optional output location for error or informational messages
+ * produced by the compiler.
+ * \n
+ * This parameter behaves identically to the \a messages parameter of
+ * vkd3d_shader_compile().
+ *
+ * \return A member of \ref vkd3d_result.
+ */
+VKD3D_SHADER_API int vkd3d_shader_serialize_root_signature(
+        const struct vkd3d_shader_versioned_root_signature_desc *root_signature,
+        struct vkd3d_shader_code *dxbc, char **messages);
+/**
+ * Convert a structural representation of a root signature to a different
+ * version of structural representation.
+ *
+ * This function corresponds to
+ * ID3D12VersionedRootSignatureDeserializer::GetRootSignatureDescAtVersion().
+ *
+ * \param dst A pointer to a vkd3d_shader_versioned_root_signature_desc
+ * structure in which the converted signature will be stored.
+ * \n
+ * Members of \a dst may be allocated by vkd3d-shader. The signature should be
+ * freed with vkd3d_shader_free_root_signature() when no longer needed.
+ *
+ * \param version The desired version to convert \a src to. This version must
+ * not be equal to \a src->version.
+ *
+ * \param src Input root signature description.
+ *
+ * \return A member of \ref vkd3d_result.
+ */
+VKD3D_SHADER_API int vkd3d_shader_convert_root_signature(struct vkd3d_shader_versioned_root_signature_desc *dst,
+        enum vkd3d_shader_root_signature_version version, const struct vkd3d_shader_versioned_root_signature_desc *src);
+
+/**
+ * Parse shader source code or byte code, returning various types of requested
+ * information.
+ *
+ * Currently this function supports the following code types:
+ * - VKD3D_SHADER_SOURCE_DXBC_TPF
+ *
+ * \param compile_info A chained structure containing scan parameters.
+ * \n
+ * The DXBC_TPF scanner supports the following chained structures:
+ * - vkd3d_shader_scan_descriptor_info
+ * \n
+ * Although the \a compile_info parameter is read-only, chained structures
+ * passed to this function need not be, and may serve as output parameters,
+ * depending on their structure type.
+ *
+ * \param messages Optional output location for error or informational messages
+ * produced by the compiler.
+ * \n
+ * This parameter behaves identically to the \a messages parameter of
+ * vkd3d_shader_compile().
+ *
+ * \return A member of \ref vkd3d_result.
+ */
+VKD3D_SHADER_API int vkd3d_shader_scan(const struct vkd3d_shader_compile_info *compile_info, char **messages);
+/**
+ * Free members of struct vkd3d_shader_scan_descriptor_info() allocated by
+ * vkd3d_shader_scan().
+ *
+ * This function may free members of vkd3d_shader_scan_descriptor_info, but
+ * does not free the structure itself.
+ *
+ * \param scan_descriptor_info Descriptor information to free.
+ */
+VKD3D_SHADER_API void vkd3d_shader_free_scan_descriptor_info(
+        struct vkd3d_shader_scan_descriptor_info *scan_descriptor_info);
+
+/**
+ * Read the input signature of a compiled shader, returning a structural
+ * description which can be easily parsed by C code.
+ *
+ * This function parses a compiled shader. To parse a standalone root signature,
+ * use vkd3d_shader_parse_root_signature().
+ *
+ * \param dxbc Compiled byte code, in DXBC format.
+ *
+ * \param signature Output location in which the parsed root signature will be
+ * stored.
+ * \n
+ * Members of \a signature may be allocated by vkd3d-shader. The signature
+ * should be freed with vkd3d_shader_free_shader_signature() when no longer
+ * needed.
+ *
+ * \param messages Optional output location for error or informational messages
+ * produced by the compiler.
+ * \n
+ * This parameter behaves identically to the \a messages parameter of
+ * vkd3d_shader_compile().
+ *
+ * \return A member of \ref vkd3d_result.
+ */
+VKD3D_SHADER_API int vkd3d_shader_parse_input_signature(const struct vkd3d_shader_code *dxbc,
+        struct vkd3d_shader_signature *signature, char **messages);
+/**
+ * Find a single element of a parsed input signature.
+ *
+ * \param signature The parsed input signature. This structure is normally
+ * populated by vkd3d_shader_parse_input_signature().
+ *
+ * \param semantic_name Semantic name of the desired element. This function
+ * performs a case-insensitive comparison with respect to the ASCII plane.
+ *
+ * \param semantic_index Semantic index of the desired element.
+ *
+ * \param stream_index Geometry shader stream index of the desired element. If
+ * the signature is not a geometry shader output signature, this parameter must
+ * be set to 0.
+ *
+ * \return A description of the element matching the requested parameters, or
+ * NULL if no such element was found. If not NULL, the return value points into
+ * the \a signature parameter and should not be explicitly freed.
+ */
+VKD3D_SHADER_API struct vkd3d_shader_signature_element *vkd3d_shader_find_signature_element(
+        const struct vkd3d_shader_signature *signature, const char *semantic_name,
+        unsigned int semantic_index, unsigned int stream_index);
+/**
+ * Free a structural representation of a shader input signature allocated by
+ * vkd3d_shader_parse_input_signature().
+ *
+ * This function may free members of struct vkd3d_shader_signature, but does not
+ * free the structure itself.
+ *
+ * \param signature Signature description to free.
+ */
+VKD3D_SHADER_API void vkd3d_shader_free_shader_signature(struct vkd3d_shader_signature *signature);
+
+/* 1.3 */
+
+/**
+ * Preprocess the given source code.
+ *
+ * This function supports the following chained structures:
+ * - vkd3d_shader_preprocess_info
+ *
+ * \param compile_info A chained structure containing compilation parameters.
+ *
+ * \param out A pointer to a vkd3d_shader_code structure in which the
+ * preprocessed code will be stored.
+ * \n
+ * The preprocessed shader is allocated by vkd3d-shader and should be freed with
+ * vkd3d_shader_free_shader_code() when no longer needed.
+ *
+ * \param messages Optional output location for error or informational messages
+ * produced by the compiler.
+ * \n
+ * This parameter behaves identically to the \a messages parameter of
+ * vkd3d_shader_compile().
+ *
+ * \return A member of \ref vkd3d_result.
+ *
+ * \since 1.3
+ */
+VKD3D_SHADER_API int vkd3d_shader_preprocess(const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_code *out, char **messages);
+
+#endif  /* VKD3D_SHADER_NO_PROTOTYPES */
+
+/** Type of vkd3d_shader_get_version(). */
+typedef const char *(*PFN_vkd3d_shader_get_version)(unsigned int *major, unsigned int *minor);
+/** Type of vkd3d_shader_get_supported_source_types(). */
+typedef const enum vkd3d_shader_source_type *(*PFN_vkd3d_shader_get_supported_source_types)(unsigned int *count);
+/** Type of vkd3d_shader_get_supported_target_types(). */
+typedef const enum vkd3d_shader_target_type *(*PFN_vkd3d_shader_get_supported_target_types)(
+        enum vkd3d_shader_source_type source_type, unsigned int *count);
+
+/** Type of vkd3d_shader_compile(). */
+typedef int (*PFN_vkd3d_shader_compile)(const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_code *out, char **messages);
+/** Type of vkd3d_shader_free_messages(). */
+typedef void (*PFN_vkd3d_shader_free_messages)(char *messages);
+/** Type of vkd3d_shader_free_shader_code(). */
+typedef void (*PFN_vkd3d_shader_free_shader_code)(struct vkd3d_shader_code *code);
+
+/** Type of vkd3d_shader_parse_root_signature(). */
+typedef int (*PFN_vkd3d_shader_parse_root_signature)(const struct vkd3d_shader_code *dxbc,
+        struct vkd3d_shader_versioned_root_signature_desc *root_signature, char **messages);
+/** Type of vkd3d_shader_free_root_signature(). */
+typedef void (*PFN_vkd3d_shader_free_root_signature)(struct vkd3d_shader_versioned_root_signature_desc *root_signature);
+
+/** Type of vkd3d_shader_serialize_root_signature(). */
+typedef int (*PFN_vkd3d_shader_serialize_root_signature)(
+        const struct vkd3d_shader_versioned_root_signature_desc *root_signature,
+        struct vkd3d_shader_code *dxbc, char **messages);
+
+/** Type of vkd3d_shader_convert_root_signature(). */
+typedef int (*PFN_vkd3d_shader_convert_root_signature)(struct vkd3d_shader_versioned_root_signature_desc *dst,
+        enum vkd3d_shader_root_signature_version version, const struct vkd3d_shader_versioned_root_signature_desc *src);
+
+/** Type of vkd3d_shader_scan(). */
+typedef int (*PFN_vkd3d_shader_scan)(const struct vkd3d_shader_compile_info *compile_info, char **messages);
+/** Type of vkd3d_shader_free_scan_descriptor_info(). */
+typedef void (*PFN_vkd3d_shader_free_scan_descriptor_info)(
+        struct vkd3d_shader_scan_descriptor_info *scan_descriptor_info);
+
+/** Type of vkd3d_shader_parse_input_signature(). */
+typedef int (*PFN_vkd3d_shader_parse_input_signature)(const struct vkd3d_shader_code *dxbc,
+        struct vkd3d_shader_signature *signature, char **messages);
+/** Type of vkd3d_shader_find_signature_element(). */
+typedef struct vkd3d_shader_signature_element * (*PFN_vkd3d_shader_find_signature_element)(
+        const struct vkd3d_shader_signature *signature, const char *semantic_name,
+        unsigned int semantic_index, unsigned int stream_index);
+/** Type of vkd3d_shader_free_shader_signature(). */
+typedef void (*PFN_vkd3d_shader_free_shader_signature)(struct vkd3d_shader_signature *signature);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* __VKD3D_SHADER_H */
diff --git a/dlls/d3dcompiler_43/vkd3d_types.h b/dlls/d3dcompiler_43/vkd3d_types.h
new file mode 100644
index 00000000000..7014f4c25d6
--- /dev/null
+++ b/dlls/d3dcompiler_43/vkd3d_types.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2016-2018 Jzef Kucia for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __VKD3D_TYPES_H
+#define __VKD3D_TYPES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/**
+ * \file vkd3d_types.h
+ *
+ * This file contains definitions for basic types used by vkd3d libraries.
+ */
+
+#define VKD3D_FORCE_32_BIT_ENUM(name) name##_FORCE_32BIT = 0x7fffffff
+
+/**
+ * Result codes returned by some vkd3d functions. Error codes always have
+ * negative values; non-error codes never do.
+ */
+enum vkd3d_result
+{
+    /** Success. */
+    VKD3D_OK = 0,
+    /** An unspecified failure occurred. */
+    VKD3D_ERROR = -1,
+    /** There are not enough resources available to complete the operation. */
+    VKD3D_ERROR_OUT_OF_MEMORY = -2,
+    /** One or more parameters passed to a vkd3d function were invalid. */
+    VKD3D_ERROR_INVALID_ARGUMENT = -3,
+    /** A shader passed to a vkd3d function was invalid. */
+    VKD3D_ERROR_INVALID_SHADER = -4,
+    /** The operation is not implemented in this version of vkd3d. */
+    VKD3D_ERROR_NOT_IMPLEMENTED = -5,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_RESULT),
+};
+
+#ifdef _WIN32
+# define VKD3D_IMPORT __declspec(dllimport)
+# define VKD3D_EXPORT __declspec(dllexport)
+#elif defined(__GNUC__)
+# define VKD3D_IMPORT
+# define VKD3D_EXPORT __attribute__((visibility("default")))
+#else
+# define VKD3D_IMPORT
+# define VKD3D_EXPORT
+#endif
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* __VKD3D_TYPES_H */
From 2c5922871c3135701d7089f11ce717de52a2cbdf Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 14 Dec 2021 13:01:58 +0100
Subject: [PATCH] HACK: server: Fake success when trying to bind to an IPX
 address.

---
 server/sock.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/server/sock.c b/server/sock.c
index f7de57d51e6..7343305d6e0 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -2638,7 +2638,11 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )

         set_async_pending( async );

-        if (bind( unix_fd, &bind_addr.addr, unix_len ) < 0)
+        /* Quake (and similar family) fails if we can't bind to an IPX address. This often
+         * doesn't work on Linux, so just fake success. */
+        if (unix_addr.addr.sa_family == AF_IPX)
+            fprintf( stderr, "wine: HACK: Faking AF_IPX bind success.\n" );
+        else if (bind( unix_fd, &bind_addr.addr, unix_len ) < 0)
         {
             if (errno == EADDRINUSE)
             {
From bdb21c72edcccc71416c399ed432ed5eab426e26 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 10 Feb 2022 16:24:41 +0300
Subject: [PATCH] ntdll: Increase kernel stack size.

---
 dlls/ntdll/unix/unix_private.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 8e2e7d93a38..5f072956087 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -87,7 +87,7 @@ static const SIZE_T page_size = 0x1000;
 static const SIZE_T teb_size = 0x3800;  /* TEB64 + TEB32 + debug info */
 static const SIZE_T signal_stack_mask = 0xffff;
 static const SIZE_T signal_stack_size = 0x10000 - 0x3800;
-static const SIZE_T kernel_stack_size = 0x20000;
+static const SIZE_T kernel_stack_size = 0x60000;
 static const SIZE_T min_kernel_stack  = 0x2000;
 static const LONG teb_offset = 0x2000;

