From 7bd039f34f5fc1123524ddb22769f6e16e7d9c88 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 11 May 2017 10:01:16 -0500
Subject: [PATCH] HACK: ws2_32: Fake success when trying to bind to an IPX
 address

---
 dlls/ws2_32/socket.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 164a48ce751..b9248c9bd5e 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3332,6 +3332,13 @@ int WINAPI WS_bind(SOCKET s, const struct WS_sockaddr* name, int namelen)
                     else if (interface_bind(s, fd, &uaddr.addr))
                         in4->sin_addr.s_addr = htonl(INADDR_ANY);
                 }
+
+                if(name->sa_family ==  WS_AF_IPX){
+                    /* Quake (and similar family) fails if we can't bind to an IPX address. This often
+                     * doesn't work on Linux, so just fake success. */
+                    return 0;
+                }
+
                 if (bind(fd, &uaddr.addr, uaddrlen) < 0)
                 {
                     int loc_errno = errno;

From 134fa05a0e39b63bfec75d0823ebe49e4c9cae64 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 7 Jun 2018 14:37:03 -0500
Subject: [PATCH] HACK: winex11.drv: Disable XIM by default

libx11 has a race condition that causes XIM to crash with "double free
or corruption" errors, see winehq bug 35041. Disabling XIM works around
this, though special input methods (CJK, etc.) will no longer work.
---
 dlls/winex11.drv/x11drv_main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index db87d188236..81a63a20689 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -93,7 +93,7 @@ static void *err_callback_arg;               /* error callback argument */
 static int err_callback_result;              /* error callback result */
 static unsigned long err_serial;             /* serial number of first request */
 static int (*old_error_handler)( Display *, XErrorEvent * );
-static BOOL use_xim = TRUE;
+static BOOL use_xim = FALSE;
 static char input_style[20];
 
 #define IS_OPTION_TRUE(ch) \
From 1091eaf13692b16ed66328ceeebfc587075fec6c Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 25 Oct 2018 12:50:45 -0500
Subject: [PATCH] HACK: wined3d: Fake an AMD card in place of Nvidia cards

Some games assume they can load the nvapi library if the hardware is an
nvidia card. This obviously fails in Wine. So fake that all nvidia
hardware is actually an AMD card, so they don't try to load nvapi.
---
 dlls/wined3d/adapter_gl.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index b8a2060cf46..8259d92ebac 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -1009,6 +1009,14 @@ static const struct wined3d_gpu_description *query_gpu_description(const struct
         vendor = wined3d_settings.pci_vendor_id;
         TRACE("Overriding vendor PCI ID with 0x%04x.\n", vendor);
     }
+    else if(vendor == HW_VENDOR_NVIDIA)
+    {
+        /* XXX: Fake having an AMD card in order to avoid games trying to load
+         * the Windows-only nvapi library. */
+        WARN("Nvidia card detected. Faking an AMD RX 480!\n");
+        vendor = HW_VENDOR_AMD;
+        device = CARD_AMD_RADEON_RX_480;
+    }
 
     if (wined3d_settings.pci_device_id != PCI_DEVICE_NONE)
     {

From aa7fa7ce94bd4e49e3843a8ea398d29882518e43 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 6 Aug 2018 08:06:03 -0500
Subject: [PATCH] server: Set default timeout to 0

The Steam client will be waiting for the wineserver to exit to set up
some environment variables, so make it wait as short as possible.
---
 server/main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/main.c b/server/main.c
index 20d3c48c4d9..aca8738c4c0 100644
--- a/server/main.c
+++ b/server/main.c
@@ -42,7 +42,7 @@
 /* command-line options */
 int debug_level = 0;
 int foreground = 0;
-timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
+timeout_t master_socket_timeout = 0; /* master socket timeout, default is 3 seconds */
 const char *server_argv0;
 
 /* parse-line args */

From 971dc3c4225b33fb5346187cd37e8355f265800f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 18 Jun 2018 07:56:35 -0500
Subject: [PATCH] ntdll: Notice THREADNAME_INFO exceptions and set thread name
 on Linux

Patch by Zeb.
---
 dlls/ntdll/exception.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
index f85381079a2..ffe048de8c0 100644
--- a/dlls/ntdll/exception.c
+++ b/dlls/ntdll/exception.c
@@ -26,6 +26,9 @@
 #include <errno.h>
 #include <signal.h>
 #include <stdarg.h>
+#ifdef HAVE_PRCTL
+#include <sys/prctl.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -143,6 +146,16 @@ void wait_suspend( CONTEXT *context )
 }
 
 
+/* "How to: Set a Thread Name in Native Code"
+ * https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx */
+typedef struct tagTHREADNAME_INFO
+{
+   DWORD   dwType;     /* Must be 0x1000 */
+   LPCSTR  szName;     /* Pointer to name - limited to 9 bytes (8 characters + terminator) */
+   DWORD   dwThreadID; /* Thread ID (-1 = caller thread) */
+   DWORD   dwFlags;    /* Reserved for future use.  Must be zero. */
+} THREADNAME_INFO;
+
 /**********************************************************************
  *           send_debug_event
  *
@@ -162,6 +175,21 @@ NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, int first_chance, CONTEXT *con
     for (i = 0; i < min( rec->NumberParameters, EXCEPTION_MAXIMUM_PARAMETERS ); i++)
         params[i] = rec->ExceptionInformation[i];
 
+    if (rec->ExceptionCode == 0x406d1388)
+    {
+        const THREADNAME_INFO *threadname = (const THREADNAME_INFO *)rec->ExceptionInformation;
+
+        if (threadname->dwThreadID == -1)
+        {
+#ifdef HAVE_PRCTL
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+            prctl( PR_SET_NAME, threadname->szName );
+#endif
+        }
+    }
+
     SERVER_START_REQ( queue_exception_event )
     {
         req->first   = first_chance;
From 7e91b897e69854cb3afe761f48ef7c9b496ecf95 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B3zef=20Kucia?= <jkucia@codeweavers.com>
Date: Wed, 1 May 2019 12:28:12 +0200
Subject: [PATCH] vulkan-1: Prefer built-in DLL.

Games may ship with their own Vulkan loader.
---
 dlls/vulkan-1/vulkan.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/dlls/vulkan-1/vulkan.c b/dlls/vulkan-1/vulkan.c
index d3b35603a17..4926cf9bf4f 100644
--- a/dlls/vulkan-1/vulkan.c
+++ b/dlls/vulkan-1/vulkan.c
@@ -32,10 +32,6 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, void *reserved)
 
     switch (reason)
     {
-        case DLL_WINE_PREATTACH:
-            /* Prefer native as it provides more functionality. */
-            return FALSE;
-
         case DLL_PROCESS_ATTACH:
             DisableThreadLibraryCalls(hinst);
             return TRUE;

From 90e3616c89ef7ed38763a3e3af3e9f0cd59697da Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Mar 2017 20:15:40 +0300
Subject: [PATCH] HACK: dwrite: Don't recommend outline rendering mode

---
 dlls/dwrite/font.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/dwrite/font.c b/dlls/dwrite/font.c
index e22559912c3..41ec809b727 100644
--- a/dlls/dwrite/font.c
+++ b/dlls/dwrite/font.c
@@ -740,7 +740,8 @@ static HRESULT WINAPI dwritefontface_GetRecommendedRenderingMode(IDWriteFontFace
 
     ppem = emSize * ppdip;
 
-    if (ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
+    /* HACK: disable outline rendering mode to workaround d2d issue */
+    if (0 && ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
         *mode = DWRITE_RENDERING_MODE_OUTLINE;
         return S_OK;
     }
From 5c59517008697ce74becddb59a3e6702a963bb49 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Fri, 16 Aug 2019 09:46:25 +0000
Subject: [PATCH] msctf: Use list to keep thread managers.

Thread managers were stored in thread local storage,
which have a major flaw that they can't not be released
by another thread.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/msctf/msctf.c          | 46 +++++++----------------
 dlls/msctf/msctf_internal.h |  1 -
 dlls/msctf/threadmgr.c      | 73 ++++++++++++++++++++++++++++++++-----
 3 files changed, 76 insertions(+), 44 deletions(-)

diff --git a/dlls/msctf/msctf.c b/dlls/msctf/msctf.c
index c6e3a2ca597..fd919295c5a 100644
--- a/dlls/msctf/msctf.c
+++ b/dlls/msctf/msctf.c
@@ -69,7 +69,6 @@ static UINT array_size;
 static struct list AtsList = LIST_INIT(AtsList);
 static UINT activated = 0;
 
-DWORD tlsIndex = 0;
 TfClientId processId = 0;
 ITfCompartmentMgr *globalCompartmentMgr = NULL;
 
@@ -397,23 +396,19 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
     ActivatedTextService *actsvr;
     ITfCategoryMgr *catmgr;
     AtsEntry *entry;
-    ITfThreadMgrEx *tm = TlsGetValue(tlsIndex);
+    ITfThreadMgr *tm;
     ITfClientId *clientid;
 
-    if (!tm) return E_UNEXPECTED;
+    if (FAILED(TF_GetThreadMgr(&tm))) return E_UNEXPECTED;
 
     actsvr = HeapAlloc(GetProcessHeap(),0,sizeof(ActivatedTextService));
-    if (!actsvr) return E_OUTOFMEMORY;
+    if (!actsvr) goto fail;
 
-    ITfThreadMgrEx_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
+    ITfThreadMgr_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
     ITfClientId_GetClientId(clientid, &lp->clsid, &actsvr->tid);
     ITfClientId_Release(clientid);
 
-    if (!actsvr->tid)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!actsvr->tid) goto fail;
 
     actsvr->pITfTextInputProcessor = NULL;
     actsvr->LanguageProfile = *lp;
@@ -440,20 +435,21 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
         deactivate_remove_conflicting_ts(&actsvr->LanguageProfile.catid);
 
     if (activated > 0)
-        activate_given_ts(actsvr, tm);
+        activate_given_ts(actsvr, (ITfThreadMgrEx *)tm);
 
     entry = HeapAlloc(GetProcessHeap(),0,sizeof(AtsEntry));
-
-    if (!entry)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!entry) goto fail;
 
     entry->ats = actsvr;
     list_add_head(&AtsList, &entry->entry);
 
+    ITfThreadMgr_Release(tm);
     return S_OK;
+
+fail:
+    ITfThreadMgr_Release(tm);
+    HeapFree(GetProcessHeap(), 0, actsvr);
+    return E_OUTOFMEMORY;
 }
 
 BOOL get_active_textservice(REFCLSID rclsid, TF_LANGUAGEPROFILE *profile)
@@ -560,11 +556,9 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD fdwReason, LPVOID fImpLoad)
             return FALSE;   /* prefer native version */
         case DLL_PROCESS_ATTACH:
             MSCTF_hinstance = hinst;
-            tlsIndex = TlsAlloc();
             break;
         case DLL_PROCESS_DETACH:
             if (fImpLoad) break;
-            TlsFree(tlsIndex);
             break;
     }
     return TRUE;
@@ -622,20 +616,6 @@ HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim)
     return ThreadMgr_Constructor(NULL,(IUnknown**)pptim);
 }
 
-/***********************************************************************
- *              TF_GetThreadMgr (MSCTF.@)
- */
-HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
-{
-    TRACE("\n");
-    *pptim = TlsGetValue(tlsIndex);
-
-    if (*pptim)
-        ITfThreadMgr_AddRef(*pptim);
-
-    return S_OK;
-}
-
 /***********************************************************************
  *              SetInputScope(MSCTF.@)
  */
diff --git a/dlls/msctf/msctf_internal.h b/dlls/msctf/msctf_internal.h
index 584bb1044ed..ace2bee23d9 100644
--- a/dlls/msctf/msctf_internal.h
+++ b/dlls/msctf/msctf_internal.h
@@ -35,7 +35,6 @@
 #define COOKIE_MAGIC_UIELEMENTSINK 0x00a0
 #define COOKIE_MAGIC_INPUTPROCESSORPROFILEACTIVATIONSINK 0x00b0
 
-extern DWORD tlsIndex DECLSPEC_HIDDEN;
 extern TfClientId processId DECLSPEC_HIDDEN;
 extern ITfCompartmentMgr *globalCompartmentMgr DECLSPEC_HIDDEN;
 
diff --git a/dlls/msctf/threadmgr.c b/dlls/msctf/threadmgr.c
index 2c208fbc04f..2119ea2193b 100644
--- a/dlls/msctf/threadmgr.c
+++ b/dlls/msctf/threadmgr.c
@@ -37,6 +37,17 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msctf);
 
+static CRITICAL_SECTION ThreadMgrCs;
+static CRITICAL_SECTION_DEBUG ThreadMgrCsDebug =
+{
+    0, 0, &ThreadMgrCs,
+    {&ThreadMgrCsDebug.ProcessLocksList,
+     &ThreadMgrCsDebug.ProcessLocksList },
+     0, 0, {(DWORD_PTR)(__FILE__ ": ThreadMgrCs")}
+};
+static CRITICAL_SECTION ThreadMgrCs = {&ThreadMgrCsDebug, -1, 0, 0, 0, 0};
+struct list ThreadMgrList = LIST_INIT(ThreadMgrList);
+
 typedef struct tagPreservedKey
 {
     struct list     entry;
@@ -98,6 +109,9 @@ typedef struct tagACLMulti {
     struct list     ThreadMgrEventSink;
     struct list     UIElementSink;
     struct list     InputProcessorProfileActivationSink;
+
+    DWORD threadId;
+    struct list entry;
 } ThreadMgr;
 
 typedef struct tagEnumTfDocumentMgr {
@@ -110,6 +124,11 @@ typedef struct tagEnumTfDocumentMgr {
 
 static HRESULT EnumTfDocumentMgr_Constructor(struct list* head, IEnumTfDocumentMgrs **ppOut);
 
+static inline ThreadMgr *impl_from_ITfThreadMgr(ITfThreadMgr *iface)
+{
+    return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
+}
+
 static inline ThreadMgr *impl_from_ITfThreadMgrEx(ITfThreadMgrEx *iface)
 {
     return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
@@ -155,6 +174,35 @@ static inline EnumTfDocumentMgr *impl_from_IEnumTfDocumentMgrs(IEnumTfDocumentMg
     return CONTAINING_RECORD(iface, EnumTfDocumentMgr, IEnumTfDocumentMgrs_iface);
 }
 
+/***********************************************************************
+ *              TF_GetThreadMgr (MSCTF.@)
+ */
+HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
+{
+    DWORD id = GetCurrentThreadId();
+    ThreadMgr *cursor;
+
+    TRACE("%p\n", pptim);
+
+    if (!pptim)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&ThreadMgrCs);
+    LIST_FOR_EACH_ENTRY(cursor, &ThreadMgrList, ThreadMgr, entry)
+    {
+        if (cursor->threadId == id)
+        {
+            ITfThreadMgrEx_AddRef(&cursor->ITfThreadMgrEx_iface);
+            *pptim = (ITfThreadMgr *)&cursor->ITfThreadMgrEx_iface;
+            LeaveCriticalSection(&ThreadMgrCs);
+            return S_OK;
+        }
+    }
+    LeaveCriticalSection(&ThreadMgrCs);
+    *pptim = NULL;
+    return E_FAIL;
+}
+
 static void ThreadMgr_Destructor(ThreadMgr *This)
 {
     struct list *cursor, *cursor2;
@@ -163,7 +211,9 @@ static void ThreadMgr_Destructor(ThreadMgr *This)
     if (This->focusHook)
         UnhookWindowsHookEx(This->focusHook);
 
-    TlsSetValue(tlsIndex,NULL);
+    EnterCriticalSection(&ThreadMgrCs);
+    list_remove(&This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
     TRACE("destroying %p\n", This);
     if (This->focus)
         ITfDocumentMgr_Release(This->focus);
@@ -386,17 +436,20 @@ static HRESULT WINAPI ThreadMgr_SetFocus(ITfThreadMgrEx *iface, ITfDocumentMgr *
 
 static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lParam)
 {
+    ITfThreadMgr *ThreadMgr_iface;
     ThreadMgr *This;
 
-    This = TlsGetValue(tlsIndex);
-    if (!This)
+    if (FAILED(TF_GetThreadMgr(&ThreadMgr_iface)))
     {
         ERR("Hook proc but no ThreadMgr for this thread. Serious Error\n");
         return 0;
     }
+
+    This = impl_from_ITfThreadMgr(ThreadMgr_iface);
     if (!This->focusHook)
     {
         ERR("Hook proc but no ThreadMgr focus Hook. Serious Error\n");
+        ITfThreadMgr_Release(ThreadMgr_iface);
         return 0;
     }
 
@@ -417,6 +470,7 @@ static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lPa
         }
     }
 
+    ITfThreadMgr_Release(ThreadMgr_iface);
     return CallNextHookEx(This->focusHook, nCode, wParam, lParam);
 }
 
@@ -1338,13 +1392,8 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
         return CLASS_E_NOAGGREGATION;
 
     /* Only 1 ThreadMgr is created per thread */
-    This = TlsGetValue(tlsIndex);
-    if (This)
-    {
-        ThreadMgr_AddRef(&This->ITfThreadMgrEx_iface);
-        *ppOut = (IUnknown*)&This->ITfThreadMgrEx_iface;
+    if (SUCCEEDED(TF_GetThreadMgr((ITfThreadMgr **)ppOut)))
         return S_OK;
-    }
 
     This = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(ThreadMgr));
     if (This == NULL)
@@ -1359,7 +1408,6 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     This->ITfUIElementMgr_iface.lpVtbl = &ThreadMgrUIElementMgrVtbl;
     This->ITfSourceSingle_iface.lpVtbl = &SourceSingleVtbl;
     This->refCount = 1;
-    TlsSetValue(tlsIndex,This);
 
     CompartmentMgr_Constructor((IUnknown*)&This->ITfThreadMgrEx_iface, &IID_IUnknown, (IUnknown**)&This->CompartmentMgr);
 
@@ -1376,6 +1424,11 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     list_init(&This->UIElementSink);
     list_init(&This->InputProcessorProfileActivationSink);
 
+    This->threadId = GetCurrentThreadId();
+    EnterCriticalSection(&ThreadMgrCs);
+    list_add_tail(&ThreadMgrList, &This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
+
     TRACE("returning %p\n", This);
     *ppOut = (IUnknown *)&This->ITfThreadMgrEx_iface;
     return S_OK;
From ed04e35d3f7af02267fb4e21578b3ccb27703836 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 23 Sep 2019 13:29:16 -0500
Subject: [PATCH] dxdiag: Dump to stdout if no filename is given

---
 programs/dxdiag/main.c   |  8 +++++++-
 programs/dxdiag/output.c | 10 +++++++---
 2 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/programs/dxdiag/main.c b/programs/dxdiag/main.c
index 4533236f0f5..353e9f50fb9 100644
--- a/programs/dxdiag/main.c
+++ b/programs/dxdiag/main.c
@@ -71,7 +71,13 @@ static BOOL process_file_name(const WCHAR *cmdline, enum output_type output_type
         endptr = cmdline + lstrlenW(cmdline);
 
     len = endptr - cmdline;
-    if (len == 0 || len >= filename_len)
+    if (len == 0)
+    {
+        *filename = 0;
+        return TRUE;
+    }
+
+    if (len >= filename_len)
         return FALSE;
 
     memcpy(filename, cmdline, len * sizeof(WCHAR));
diff --git a/programs/dxdiag/output.c b/programs/dxdiag/output.c
index 50240fb2860..f0f6a6da0c3 100644
--- a/programs/dxdiag/output.c
+++ b/programs/dxdiag/output.c
@@ -169,8 +169,12 @@ static BOOL output_text_information(struct dxdiag_information *dxdiag_info, cons
 
     fill_system_text_output_table(dxdiag_info, output_table[0].fields);
 
-    hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
-                        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (filename && *filename)
+        hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    else
+        hFile = GetStdHandle(STD_OUTPUT_HANDLE);
+
     if (hFile == INVALID_HANDLE_VALUE)
     {
         WINE_ERR("File creation failed, last error %u\n", GetLastError());
@@ -227,7 +231,7 @@ static HRESULT save_xml_document(IXMLDOMDocument *xmldoc, const WCHAR *filename)
     VARIANT destVar;
     HRESULT hr;
 
-    if (!bstr)
+    if (!bstr || !filename || !*filename)
         return E_OUTOFMEMORY;
 
     V_VT(&destVar) = VT_BSTR;
From e485252dfad51a7e463643d56fe138129597e4b6 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 23 Sep 2019 08:56:04 -0500
Subject: [PATCH] ntdll: Always add a tail to heap allocations.

Fixes the Rockstar Games Launcher installer (and possibly other
NSIS-based installers) from crashing due to passing a too-small buffer
to GetWindowInfo().
---
 dlls/ntdll/heap.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index 6344157f384..6fefe5d6d80 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -118,9 +118,8 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
 #define HEAP_MIN_SHRINK_SIZE  (HEAP_MIN_DATA_SIZE+sizeof(ARENA_FREE))
 /* minimum size to start allocating large blocks */
 #define HEAP_MIN_LARGE_BLOCK_SIZE  0x7f000
-/* extra size to add at the end of block for tail checking */
-#define HEAP_TAIL_EXTRA_SIZE(flags) \
-    ((flags & HEAP_TAIL_CHECKING_ENABLED) || RUNNING_ON_VALGRIND ? ALIGNMENT : 0)
+/* extra size to add at the end of block to mitigate overruns and allow tail checking */
+#define HEAP_TAIL_EXTRA_SIZE ALIGNMENT
 
 /* size of the blocks on the free lists */
 #define HEAP_FREELIST_SIZE(index) \
@@ -800,7 +799,7 @@ static void HEAP_ShrinkBlock(SUBHEAP *subheap, ARENA_INUSE *pArena, SIZE_T size)
 static void *allocate_large_block( HEAP *heap, DWORD flags, SIZE_T size )
 {
     ARENA_LARGE *arena;
-    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     LPVOID address = NULL;
 
     if (block_size < size) return NULL;  /* overflow */
@@ -1814,7 +1813,7 @@ void * WINAPI DECLSPEC_HOTPATCH RtlAllocateHeap( HANDLE heap, ULONG flags, SIZE_
     if (!heapPtr) return NULL;
     flags &= HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY;
     flags |= heapPtr->flags;
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE( flags );
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size)  /* overflow */
     {
         if (flags & HEAP_GENERATE_EXCEPTIONS) RtlRaiseStatus( STATUS_NO_MEMORY );
@@ -1968,7 +1967,7 @@ PVOID WINAPI RtlReAllocateHeap( HANDLE heap, ULONG flags, PVOID ptr, SIZE_T size
     flags |= heapPtr->flags;
     if (!(flags & HEAP_NO_SERIALIZE)) RtlEnterCriticalSection( &heapPtr->critSection );
 
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size) goto oom;  /* overflow */
     if (rounded_size < HEAP_MIN_DATA_SIZE) rounded_size = HEAP_MIN_DATA_SIZE;
 
From 33cd3de313071c787bece5acc31351c36abd74e9 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Tue, 22 Oct 2019 16:27:51 -0700
Subject: [PATCH] HACK: ntdll: Run WT_EXECUTEINWAITTHREAD wait callbacks
 serially.

On Windows, waits registered with the WT_EXECUTEINWAITTHREAD flag will
often have their callbacks run serially (since they're all handled by
the same wait thread). Running them in parallel can expose race
conditions.
Use a process-wide critical section to serialize these callbacks.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47843
---
 dlls/ntdll/threadpool.c | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 639e032f629..dbd9577d6bc 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -84,6 +84,17 @@ struct wait_work_item
     int CallbackInProgress;
 };
 
+static RTL_CRITICAL_SECTION_DEBUG wait_thread_executeinwaitthread_cs_debug;
+
+static RTL_CRITICAL_SECTION wait_thread_executeinwaitthread_cs = {&wait_thread_executeinwaitthread_cs_debug, -1, 0, 0, 0, 0};
+
+static RTL_CRITICAL_SECTION_DEBUG wait_thread_executeinwaitthread_cs_debug =
+{
+    0, 0, &wait_thread_executeinwaitthread_cs,
+    { &wait_thread_executeinwaitthread_cs_debug.ProcessLocksList, &wait_thread_executeinwaitthread_cs_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": wait_thread_executeinwaitthread_cs") }
+};
+
 struct timer_queue;
 struct queue_timer
 {
@@ -527,7 +538,20 @@ static DWORD CALLBACK wait_thread_proc(LPVOID Arg)
                 TRACE( "Work has been canceled.\n" );
                 break;
             }
+
+            /* HACK: On Windows, waits created with WT_EXECUTEINWAITTHREAD often end up on the same wait thread
+             * and run serialized. Running these waits simultaneously on separate threads may expose race conditions
+             * not seen on Windows.
+             * Use a critical section to ensure these callbacks run serially.
+             */
+            if (wait_work_item->Flags & WT_EXECUTEINWAITTHREAD)
+                enter_critical_section(&wait_thread_executeinwaitthread_cs);
+
             wait_work_item->Callback( wait_work_item->Context, TimerOrWaitFired );
+
+            if (wait_work_item->Flags & WT_EXECUTEINWAITTHREAD)
+                leave_critical_section(&wait_thread_executeinwaitthread_cs);
+
             InterlockedExchange( &wait_work_item->CallbackInProgress, FALSE );
 
             if (wait_work_item->Flags & WT_EXECUTEONLYONCE)
From 5cd65deffffad9073538acf4fd8e794ac07824a5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 9 Oct 2019 09:47:12 +0200
Subject: [PATCH] makedep: Align PE sections so they can be directly mmaped.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This should help linux perf tool match the binary files on disk with the
code regions in memory.

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
---
 tools/makedep.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/tools/makedep.c b/tools/makedep.c
index 6079d1fe28b..18e7b8a913e 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -3245,6 +3245,7 @@ static void output_module( struct makefile *make )
     output_filenames_obj_dir( make, make->res_files );
     output_filenames( all_libs );
     output_filename( make->is_cross ? "$(CROSSLDFLAGS)" : "$(LDFLAGS)" );
+    output_filename( make->is_cross ? "-Wl,--file-alignment,4096" : "" );
     output( "\n" );
 
     if (spec_file && make->importlib)
From 213905a322620eb326b655ab89fbca07316e6357 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 19 Nov 2019 09:59:17 -0600
Subject: [PATCH] HACK: dxgi: Return empty GPU string for Crazy Machines 3

If the GPU string is long enough, the game will crash trying to
dereference part of it. Probably this is due to missing Media Foundation
support. Try to remove this hack after the game's videos successfully
play back.
---
 dlls/dxgi/adapter.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/dlls/dxgi/adapter.c b/dlls/dxgi/adapter.c
index d2fc629c843..5a97590dbce 100644
--- a/dlls/dxgi/adapter.c
+++ b/dlls/dxgi/adapter.c
@@ -161,12 +161,32 @@ static HRESULT dxgi_adapter_get_desc(struct dxgi_adapter *adapter, DXGI_ADAPTER_
     if (FAILED(hr = wined3d_get_adapter_identifier(adapter->factory->wined3d, adapter->ordinal, 0, &adapter_id)))
         return hr;
 
+    {
+        /* HACK for Proton issue #3204
+         *
+         * Due to reading uninitialized memory, the game tries to dereference
+         * part of the GPU Description string if it is long enough. So return
+         * an empty string instead.
+         *
+         * See the bug report for the full description, but we may be able to
+         * remove this hack after implementing enough of Media Foundation for
+         * this game's videos to play back.
+         */
+        const char *sgi = getenv("SteamGameId");
+        if(sgi && !strcmp(sgi, "351920"))
+        {
+            desc->Description[0] = 0;
+            goto skip_description;
+        }
+    }
+
     if (!MultiByteToWideChar(CP_ACP, 0, description, -1, desc->Description, ARRAY_SIZE(description)))
     {
         DWORD err = GetLastError();
         ERR("Failed to translate description %s (%#x).\n", debugstr_a(description), err);
         hr = E_FAIL;
     }
+skip_description:
 
     desc->VendorId = adapter_id.vendor_id;
     desc->DeviceId = adapter_id.device_id;
From 304683886016ec940a9b331ce33fcbaf47e893c3 Mon Sep 17 00:00:00 2001
From: Sven Baars <sbaars@codeweavers.com>
Date: Thu, 5 Dec 2019 13:48:38 +0100
Subject: [PATCH] HACK: ntdll: Return a handle to kernel32 when being asked for
 mfc42.

For some applications mfc42 is loaded, but never actually used. We can
add Steam game IDs when we find more of such applications.
---
 dlls/ntdll/loader.c | 31 +++++++++++++++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 431c247a072..c9fcad79316 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -2869,6 +2881,25 @@ static NTSTATUS find_dll_file( const WCHAR *load_path, const WCHAR *libname,
 done:
     RtlFreeHeap( GetProcessHeap(), 0, dllname );
     if (wow64_old_value) RtlWow64EnableFsRedirectionEx( 1, &wow64_old_value );
+
+    if (status != STATUS_SUCCESS)
+    {
+        /* HACK for Proton issue #17
+         *
+         * Some games try to load mfc42.dll, but then proceed to not use it.
+         * Just return a handle to kernel32 in that case.
+         */
+        static const WCHAR mfc42W[] = {'m','f','c','4','2',0};
+        static const WCHAR kernel32W[] = {'k','e','r','n','e','l','3','2','.','d','l','l',0};
+        const char *sgi = getenv( "SteamGameId" );
+        if (sgi &&
+            !strcmp( sgi, "105450" ) && /* AoE3 */
+            strstriW( libname, mfc42W ))
+        {
+            WARN_(loaddll)( "Using a fake mfc42 handle\n" );
+            status = find_dll_file( load_path, kernel32W, nt_name, pwm, mfc42W, module, image_info, st );
+        }
+    }
     return status;
 }
 
From 4aa052e0c8ae276fc07afcd93d6e290a88214837 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 15 Jan 2020 10:17:23 -0600
Subject: [PATCH] dsound: Initialize primary buffer with device's channel
 layout

Fixes surround sound in some games, like Borderlands GOTY and Dead
Space.
---
 dlls/dsound/dsound.c         | 77 +-----------------------------------
 dlls/dsound/dsound_private.h |  1 -
 dlls/dsound/primary.c        | 75 ++++++++++++++++++++++++++++++++++-
 3 files changed, 76 insertions(+), 77 deletions(-)

diff --git a/dlls/dsound/dsound.c b/dlls/dsound/dsound.c
index 8e2b839fe89..630d8c7e16a 100644
--- a/dlls/dsound/dsound.c
+++ b/dlls/dsound/dsound.c
@@ -23,7 +23,6 @@
 #include <assert.h>
 #include <stdarg.h>
 #include <stdio.h>
-#include <math.h>
 
 #define COBJMACROS
 
@@ -138,9 +137,9 @@ static HRESULT DirectSoundDevice_Create(DirectSoundDevice ** ppDevice)
     device->ref            = 1;
     device->priolevel      = DSSCL_NORMAL;
     device->stopped        = 1;
-    device->speaker_config = DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_WIDE);
 
-    DSOUND_ParseSpeakerConfig(device);
+    device->speaker_config = 0;
+    device->num_speakers = 0;
 
     /* 3D listener initial parameters */
     device->ds3dl.dwSize   = sizeof(DS3DLISTENER);
@@ -1127,75 +1126,3 @@ HRESULT WINAPI DirectSoundCreate8(
 
     return hr;
 }
-
-void DSOUND_ParseSpeakerConfig(DirectSoundDevice *device)
-{
-    switch (DSSPEAKER_CONFIG(device->speaker_config)) {
-        case DSSPEAKER_MONO:
-            device->speaker_angles[0] = M_PI/180.0f * 0.0f;
-            device->speaker_num[0] = 0;
-            device->num_speakers = 1;
-            device->lfe_channel = -1;
-        break;
-
-        case DSSPEAKER_STEREO:
-        case DSSPEAKER_HEADPHONE:
-            device->speaker_angles[0] = M_PI/180.0f * -90.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  90.0f;
-            device->speaker_num[0] = 0; /* Left */
-            device->speaker_num[1] = 1; /* Right */
-            device->num_speakers = 2;
-            device->lfe_channel = -1;
-        break;
-
-        case DSSPEAKER_QUAD:
-            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
-            device->speaker_angles[2] = M_PI/180.0f *   45.0f;
-            device->speaker_angles[3] = M_PI/180.0f *  135.0f;
-            device->speaker_num[0] = 2; /* Rear left */
-            device->speaker_num[1] = 0; /* Front left */
-            device->speaker_num[2] = 1; /* Front right */
-            device->speaker_num[3] = 3; /* Rear right */
-            device->num_speakers = 4;
-            device->lfe_channel = -1;
-        break;
-
-        case DSSPEAKER_5POINT1_BACK:
-            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
-            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
-            device->speaker_angles[3] = M_PI/180.0f *   45.0f;
-            device->speaker_angles[4] = M_PI/180.0f *  135.0f;
-            device->speaker_angles[5] = 9999.0f;
-            device->speaker_num[0] = 4; /* Rear left */
-            device->speaker_num[1] = 0; /* Front left */
-            device->speaker_num[2] = 2; /* Front centre */
-            device->speaker_num[3] = 1; /* Front right */
-            device->speaker_num[4] = 5; /* Rear right */
-            device->speaker_num[5] = 3; /* LFE */
-            device->num_speakers = 6;
-            device->lfe_channel = 3;
-        break;
-
-        case DSSPEAKER_5POINT1_SURROUND:
-            device->speaker_angles[0] = M_PI/180.0f *  -90.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  -30.0f;
-            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
-            device->speaker_angles[3] = M_PI/180.0f *   30.0f;
-            device->speaker_angles[4] = M_PI/180.0f *   90.0f;
-            device->speaker_angles[5] = 9999.0f;
-            device->speaker_num[0] = 4; /* Rear left */
-            device->speaker_num[1] = 0; /* Front left */
-            device->speaker_num[2] = 2; /* Front centre */
-            device->speaker_num[3] = 1; /* Front right */
-            device->speaker_num[4] = 5; /* Rear right */
-            device->speaker_num[5] = 3; /* LFE */
-            device->num_speakers = 6;
-            device->lfe_channel = 3;
-        break;
-
-        default:
-            WARN("unknown speaker_config %u\n", device->speaker_config);
-    }
-}
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 69c4a2f3902..1a3e88a0d29 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -202,7 +202,6 @@ HRESULT IKsPrivatePropertySetImpl_Create(REFIID riid, void **ppv) DECLSPEC_HIDDE
 HRESULT DSOUND_Create(REFIID riid, void **ppv) DECLSPEC_HIDDEN;
 HRESULT DSOUND_Create8(REFIID riid, void **ppv) DECLSPEC_HIDDEN;
 HRESULT IDirectSoundImpl_Create(IUnknown *outer_unk, REFIID riid, void **ppv, BOOL has_ds8) DECLSPEC_HIDDEN;
-void DSOUND_ParseSpeakerConfig(DirectSoundDevice *device) DECLSPEC_HIDDEN;
 
 /* primary.c */
 
diff --git a/dlls/dsound/primary.c b/dlls/dsound/primary.c
index 852ec51b7ff..fdbbc00cd33 100644
--- a/dlls/dsound/primary.c
+++ b/dlls/dsound/primary.c
@@ -24,6 +24,7 @@
  */
 
 #include <stdarg.h>
+#include <math.h>
 
 #define COBJMACROS
 #define NONAMELESSUNION
@@ -110,6 +111,78 @@ static DWORD DSOUND_FindSpeakerConfig(IMMDevice *mmdevice, int channels)
     return def;
 }
 
+static void DSOUND_ParseSpeakerConfig(DirectSoundDevice *device)
+{
+    switch (DSSPEAKER_CONFIG(device->speaker_config)) {
+        case DSSPEAKER_MONO:
+            device->speaker_angles[0] = M_PI/180.0f * 0.0f;
+            device->speaker_num[0] = 0;
+            device->num_speakers = 1;
+            device->lfe_channel = -1;
+        break;
+
+        case DSSPEAKER_STEREO:
+        case DSSPEAKER_HEADPHONE:
+            device->speaker_angles[0] = M_PI/180.0f * -90.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  90.0f;
+            device->speaker_num[0] = 0; /* Left */
+            device->speaker_num[1] = 1; /* Right */
+            device->num_speakers = 2;
+            device->lfe_channel = -1;
+        break;
+
+        case DSSPEAKER_QUAD:
+            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
+            device->speaker_angles[2] = M_PI/180.0f *   45.0f;
+            device->speaker_angles[3] = M_PI/180.0f *  135.0f;
+            device->speaker_num[0] = 2; /* Rear left */
+            device->speaker_num[1] = 0; /* Front left */
+            device->speaker_num[2] = 1; /* Front right */
+            device->speaker_num[3] = 3; /* Rear right */
+            device->num_speakers = 4;
+            device->lfe_channel = -1;
+        break;
+
+        case DSSPEAKER_5POINT1_BACK:
+            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
+            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
+            device->speaker_angles[3] = M_PI/180.0f *   45.0f;
+            device->speaker_angles[4] = M_PI/180.0f *  135.0f;
+            device->speaker_angles[5] = 9999.0f;
+            device->speaker_num[0] = 4; /* Rear left */
+            device->speaker_num[1] = 0; /* Front left */
+            device->speaker_num[2] = 2; /* Front centre */
+            device->speaker_num[3] = 1; /* Front right */
+            device->speaker_num[4] = 5; /* Rear right */
+            device->speaker_num[5] = 3; /* LFE */
+            device->num_speakers = 6;
+            device->lfe_channel = 3;
+        break;
+
+        case DSSPEAKER_5POINT1_SURROUND:
+            device->speaker_angles[0] = M_PI/180.0f *  -90.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  -30.0f;
+            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
+            device->speaker_angles[3] = M_PI/180.0f *   30.0f;
+            device->speaker_angles[4] = M_PI/180.0f *   90.0f;
+            device->speaker_angles[5] = 9999.0f;
+            device->speaker_num[0] = 4; /* Rear left */
+            device->speaker_num[1] = 0; /* Front left */
+            device->speaker_num[2] = 2; /* Front centre */
+            device->speaker_num[3] = 1; /* Front right */
+            device->speaker_num[4] = 5; /* Rear right */
+            device->speaker_num[5] = 3; /* LFE */
+            device->num_speakers = 6;
+            device->lfe_channel = 3;
+        break;
+
+        default:
+            WARN("unknown speaker_config %u\n", device->speaker_config);
+    }
+}
+
 static HRESULT DSOUND_WaveFormat(DirectSoundDevice *device, IAudioClient *client,
 				 BOOL forcewave, WAVEFORMATEX **wfx)
 {
@@ -124,7 +197,7 @@ static HRESULT DSOUND_WaveFormat(DirectSoundDevice *device, IAudioClient *client
         if (FAILED(hr))
             return hr;
 
-        if (mixwfe->Format.nChannels < device->num_speakers) {
+        if (device->num_speakers == 0 || mixwfe->Format.nChannels < device->num_speakers) {
             device->speaker_config = DSOUND_FindSpeakerConfig(device->mmdevice, mixwfe->Format.nChannels);
             DSOUND_ParseSpeakerConfig(device);
         } else if (mixwfe->Format.nChannels > device->num_speakers) {
From 749bf5fcd5f41a39301428a7fccd1e4febcd6f90 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 13 Dec 2019 15:54:28 +0200
Subject: [PATCH] dwmapi: Improve DwmGetWindowAttribute stub.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 dlls/dwmapi/dwmapi_main.c | 26 ++++++++++++++++++++++++--
 1 file changed, 24 insertions(+), 2 deletions(-)

diff --git a/dlls/dwmapi/dwmapi_main.c b/dlls/dwmapi/dwmapi_main.c
index 6378a091f0b..e976fda77f2 100644
--- a/dlls/dwmapi/dwmapi_main.c
+++ b/dlls/dwmapi/dwmapi_main.c
@@ -205,9 +205,31 @@ BOOL WINAPI DwmDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam,
  */
 HRESULT WINAPI DwmGetWindowAttribute(HWND hwnd, DWORD attribute, PVOID pv_attribute, DWORD size)
 {
-    FIXME("(%p %d %p %d) stub\n", hwnd, attribute, pv_attribute, size);
+    if (!hwnd) return E_HANDLE;
+    if (!pv_attribute) return E_INVALIDARG;
 
-    return E_NOTIMPL;
+    switch (attribute)
+    {
+    case DWMWA_NCRENDERING_ENABLED:
+        if (size < sizeof(BOOL)) return E_INVALIDARG;
+
+        WARN("DWMWA_NCRENDERING_ENABLED: always returning FALSE.\n");
+        *(BOOL*)(pv_attribute) = FALSE;
+        break;
+
+    case DWMWA_CLOAKED:
+        if (size < sizeof(DWORD)) return E_INVALIDARG;
+
+        WARN("DWMWA_CLOAKED: always returning 0.\n");
+        *(DWORD*)(pv_attribute) = 0;
+        break;
+
+    default:
+        FIXME("unimplemented attribute %d, size %u, for hwnd %p.\n", attribute, size, hwnd);
+        return E_INVALIDARG;
+    }
+
+    return S_OK;
 }
 
 /**********************************************************************
From 60ac9b821daf372aac3bc85fa97b60f2b6d56c82 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 13 Dec 2019 15:54:29 +0200
Subject: [PATCH] dwmapi/tests: Add basic tests for DwmGetWindowAttribute.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
diff --git a/dlls/dwmapi/tests/Makefile.in b/dlls/dwmapi/tests/Makefile.in
index f365f96c72..947e3312b5 100644
--- a/dlls/dwmapi/tests/Makefile.in
+++ b/dlls/dwmapi/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = dwmapi.dll
-IMPORTS   = dwmapi
+IMPORTS   = dwmapi gdi32 user32
 
 C_SRCS = \
 	dwmapi.c
diff --git a/dlls/dwmapi/tests/dwmapi.c b/dlls/dwmapi/tests/dwmapi.c
index 7c51e77c4a..68babd6eb2 100644
--- a/dlls/dwmapi/tests/dwmapi.c
+++ b/dlls/dwmapi/tests/dwmapi.c
@@ -19,13 +19,40 @@
  *
  */
 
+#include <windows.h>
 #include "dwmapi.h"
-
 #include "wine/test.h"
 
 static HRESULT (WINAPI *pDwmIsCompositionEnabled)(BOOL*);
 static HRESULT (WINAPI *pDwmEnableComposition)(UINT);
 static HRESULT (WINAPI *pDwmGetTransportAttributes)(BOOL*,BOOL*,DWORD*);
+static HWND test_wnd;
+static LRESULT WINAPI test_wndproc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
+{
+    return DefWindowProcA(hwnd, message, wParam, lParam);
+}
+
+static void test_DwmGetWindowAttribute(void)
+{
+    BOOL nc_rendering;
+    HRESULT hr;
+
+    hr = DwmGetWindowAttribute(NULL, DWMWA_NCRENDERING_ENABLED, &nc_rendering, sizeof(nc_rendering));
+    ok(hr == E_HANDLE || broken(hr == E_INVALIDARG) /* Vista */, "DwmGetWindowAttribute(DWMWA_NCRENDERING_ENABLED) returned 0x%08x.\n", hr);
+    hr = DwmGetWindowAttribute(test_wnd, DWMWA_NCRENDERING_ENABLED, NULL, sizeof(nc_rendering));
+    ok(hr == E_INVALIDARG, "DwmGetWindowAttribute(DWMWA_NCRENDERING_ENABLED) returned 0x%08x.\n", hr);
+    hr = DwmGetWindowAttribute(test_wnd, DWMWA_NCRENDERING_ENABLED, &nc_rendering, 0);
+    ok(hr == E_INVALIDARG, "DwmGetWindowAttribute(DWMWA_NCRENDERING_ENABLED) returned 0x%08x.\n", hr);
+    nc_rendering = FALSE;
+    hr = DwmGetWindowAttribute(test_wnd, 0xdeadbeef, &nc_rendering, sizeof(nc_rendering));
+    ok(hr == E_INVALIDARG, "DwmGetWindowAttribute(0xdeadbeef) returned 0x%08x.\n", hr);
+
+    nc_rendering = 0xdeadbeef;
+    hr = DwmGetWindowAttribute(test_wnd, DWMWA_NCRENDERING_ENABLED, &nc_rendering, sizeof(nc_rendering));
+    ok(hr == S_OK, "DwmGetWindowAttribute(DWMWA_NCRENDERING_ENABLED) failed 0x%08x.\n", hr);
+    ok(nc_rendering == FALSE || nc_rendering == TRUE, "non-boolean value 0x%x.\n", nc_rendering);
+}
+
 
 BOOL dwmenabled;
 
@@ -92,6 +119,21 @@ static void test_dwm_get_transport_attributes(void)
 START_TEST(dwmapi)
 {
     HMODULE hmod = LoadLibraryA("dwmapi.dll");
+    HINSTANCE inst = GetModuleHandleA(NULL);
+    WNDCLASSA cls;
+
+    cls.style = 0;
+    cls.lpfnWndProc = test_wndproc;
+    cls.cbClsExtra = 0;
+    cls.cbWndExtra = 0;
+    cls.hInstance = inst;
+    cls.hIcon = 0;
+    cls.hCursor = LoadCursorA(0, (LPCSTR)IDC_ARROW);
+    cls.hbrBackground = GetStockObject(WHITE_BRUSH);
+    cls.lpszMenuName = NULL;
+    cls.lpszClassName = "Test";
+    RegisterClassA(&cls);
+
 
     if (!hmod)
     {
@@ -105,4 +147,14 @@ START_TEST(dwmapi)
 
     test_isdwmenabled();
     test_dwm_get_transport_attributes();
+
+    test_wnd = CreateWindowExA(0, "Test", "Test Window", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+                               100, 100, 200, 200, 0, 0, 0, NULL);
+    ok(test_wnd != NULL, "Failed to create test window.\n");
+
+    test_DwmGetWindowAttribute();
+
+    DestroyWindow(test_wnd);
+    UnregisterClassA("Test", inst);
+
 }
From 1a2e600a9c35a9558b32e7986668d7dc81c8b5ae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 13 Dec 2019 15:54:30 +0200
Subject: [PATCH] dwmapi: Add partial implementation of
 DWMWA_EXTENDED_FRAME_BOUNDS.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 dlls/dwmapi/Makefile.in    |  1 +
 dlls/dwmapi/dwmapi_main.c  |  7 +++++++
 dlls/dwmapi/tests/dwmapi.c | 14 ++++++++++++++
 3 files changed, 22 insertions(+)

diff --git a/dlls/dwmapi/Makefile.in b/dlls/dwmapi/Makefile.in
index 3a3691326f8..d273a22c8f3 100644
--- a/dlls/dwmapi/Makefile.in
+++ b/dlls/dwmapi/Makefile.in
@@ -1,5 +1,6 @@
 MODULE    = dwmapi.dll
 IMPORTLIB = dwmapi
+IMPORTS   = user32
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/dwmapi/dwmapi_main.c b/dlls/dwmapi/dwmapi_main.c
index e976fda77f2..212c88c5a02 100644
--- a/dlls/dwmapi/dwmapi_main.c
+++ b/dlls/dwmapi/dwmapi_main.c
@@ -217,6 +217,13 @@ HRESULT WINAPI DwmGetWindowAttribute(HWND hwnd, DWORD attribute, PVOID pv_attrib
         *(BOOL*)(pv_attribute) = FALSE;
         break;
 
+    case DWMWA_EXTENDED_FRAME_BOUNDS:
+        if (size < sizeof(RECT)) return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
+
+        WARN("DWMWA_EXTENDED_FRAME_BOUNDS: returning window rect.\n");
+        GetWindowRect(hwnd, pv_attribute);
+        break;
+
     case DWMWA_CLOAKED:
         if (size < sizeof(DWORD)) return E_INVALIDARG;
 
diff --git a/dlls/dwmapi/tests/dwmapi.c b/dlls/dwmapi/tests/dwmapi.c
index 0fc8820b095..409f5c85876 100644
--- a/dlls/dwmapi/tests/dwmapi.c
+++ b/dlls/dwmapi/tests/dwmapi.c
@@ -29,6 +29,7 @@ static LRESULT WINAPI test_wndproc(HWND hwnd, UINT message, WPARAM wParam, LPARA
 static void test_DwmGetWindowAttribute(void)
 {
     BOOL nc_rendering;
+    RECT rc, rc2;
     HRESULT hr;
 
     hr = DwmGetWindowAttribute(NULL, DWMWA_NCRENDERING_ENABLED, &nc_rendering, sizeof(nc_rendering));
@@ -45,6 +46,19 @@ static void test_DwmGetWindowAttribute(void)
     hr = DwmGetWindowAttribute(test_wnd, DWMWA_NCRENDERING_ENABLED, &nc_rendering, sizeof(nc_rendering));
     ok(hr == S_OK, "DwmGetWindowAttribute(DWMWA_NCRENDERING_ENABLED) failed 0x%08x.\n", hr);
     ok(nc_rendering == FALSE || nc_rendering == TRUE, "non-boolean value 0x%x.\n", nc_rendering);
+
+    hr = DwmGetWindowAttribute(test_wnd, DWMWA_EXTENDED_FRAME_BOUNDS, &rc, sizeof(rc) - 1);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) || broken(hr == E_INVALIDARG) /* Vista */,
+       "DwmGetWindowAttribute(DWMWA_EXTENDED_FRAME_BOUNDS) returned 0x%08x.\n", hr);
+    hr = DwmGetWindowAttribute(test_wnd, DWMWA_EXTENDED_FRAME_BOUNDS, &rc, sizeof(rc));
+    if (hr != E_HANDLE && hr != DWM_E_COMPOSITIONDISABLED /* Vista */)  /* composition is on */
+    {
+        /* For top-level Windows, the returned rect is always at least as large as GetWindowRect */
+        GetWindowRect(test_wnd, &rc2);
+        ok(hr == S_OK, "DwmGetWindowAttribute(DWMWA_EXTENDED_FRAME_BOUNDS) failed 0x%08x.\n", hr);
+        ok(rc.left >= rc2.left && rc.right <= rc2.right && rc.top >= rc2.top && rc.bottom <= rc2.bottom,
+           "returned rect %s not enclosed in window rect %s.\n", wine_dbgstr_rect(&rc), wine_dbgstr_rect(&rc2));
+    }
 }
 
 START_TEST(dwmapi)
From c099ae745b3a63edee1677a2da01cab5aa5b8562 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 28 Jan 2020 14:30:43 -0600
Subject: [PATCH] winegstreamer: HACK: Try harder to register winegstreamer
 filters.

The IDL declarations should actually be unnecessary with the quartz part, but there's a chance that an application will try to create filters before it creates the graph.
---
 dlls/quartz/filtergraph.c     | 17 +++++++++++++++++
 dlls/winegstreamer/winegstreamer_classes.idl | 21 +++++++++++++++++++++
 2 files changed, 38 insertions(+)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 1ed41bdcec5..0af6e1ded5f 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -5681,11 +5681,28 @@ static const IUnknownVtbl IInner_VTable =
     FilterGraphInner_Release
 };
 
+static BOOL CALLBACK register_winegstreamer_proc(INIT_ONCE *once, void *param, void **ctx)
+{
+    HMODULE mod = LoadLibraryW(L"winegstreamer.dll");
+    if (mod)
+    {
+        HRESULT (WINAPI *proc)(void) = (void *)GetProcAddress(mod, "DllRegisterServer");
+        proc();
+        FreeLibrary(mod);
+    }
+    return TRUE;
+}
+
 static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL threaded)
 {
+    static INIT_ONCE once = INIT_ONCE_STATIC_INIT;
     struct filter_graph *object;
     HRESULT hr;
 
+    /* HACK: our build system makes it difficult to load gstreamer on prefix
+     * creation, so it won't get registered. Do that here instead. */
+    InitOnceExecuteOnce(&once, register_winegstreamer_proc, NULL, NULL);
+
     *out = NULL;
 
     if (!(object = calloc(1, sizeof(*object))))
From aa6ab7464758508b3348b3ce390c1524c9ce32a2 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 30 Jan 2020 10:16:19 -0600
Subject: [PATCH] winegstreamer: HACK: Use a different gst registry file per
 architecture

---
 dlls/winegstreamer/main.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 379f54ab4ec..0fb6b0b5ad3 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -421,9 +421,25 @@ static BOOL CALLBACK init_gstreamer_proc(INIT_ONCE *once, void *param, void **ct
     char **argv = args;
     int argc = 2;
     GError *err = NULL;
+    const char *e;
 
     TRACE("Initializing...\n");
 
+    if ((e = getenv("WINE_GST_REGISTRY_DIR")))
+    {
+        char gst_reg[PATH_MAX];
+#if defined(__x86_64__)
+        const char *arch = "/registry.x86_64.bin";
+#elif defined(__i386__)
+        const char *arch = "/registry.i386.bin";
+#else
+#error Bad arch
+#endif
+        strcpy(gst_reg, e);
+        strcat(gst_reg, arch);
+        setenv("GST_REGISTRY_1_0", gst_reg, 1);
+    }
+
     argv[0] = argv0;
     argv[1] = argv1;
     argv[2] = NULL;
From ddb3e721daa73dc07079e7a15612e274f96f104b Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 6 Dec 2019 11:48:10 -0600
Subject: [PATCH] bcrypt: Allow importing private ECDSA keys.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/bcrypt/bcrypt_main.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/bcrypt/bcrypt_main.c b/dlls/bcrypt/bcrypt_main.c
index 2ac36d3db01..1daaa8ab599 100644
--- a/dlls/bcrypt/bcrypt_main.c
+++ b/dlls/bcrypt/bcrypt_main.c
@@ -1175,6 +1175,10 @@ static NTSTATUS key_import_pair( struct algorithm *alg, const WCHAR *type, BCRYP
             key_size = 32;
             magic = BCRYPT_ECDH_PRIVATE_P256_MAGIC;
             break;
+        case ALG_ID_ECDSA_P256:
+            key_size = 32;
+            magic = BCRYPT_ECDSA_PRIVATE_P256_MAGIC;
+            break;
 
         default:
             FIXME( "algorithm %u does not yet support importing blob of type %s\n", alg->id, debugstr_w(type) );
From 52c36274080a6edc1f1420b08df1ecf0defa9ca3 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 5 Dec 2019 12:41:57 -0600
Subject: [PATCH] bcrypt: Fallback to _gnutls_decode_ber_rs_raw if
 gnutls_decode_rs_value is unavailable.

This can be removed when the runtime ships gnutls >= 3.6
---
 dlls/bcrypt/gnutls.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/bcrypt/gnutls.c b/dlls/bcrypt/gnutls.c
index 868f898bbbb..95f498123ea 100644
--- a/dlls/bcrypt/gnutls.c
+++ b/dlls/bcrypt/gnutls.c
@@ -267,8 +267,11 @@ BOOL gnutls_initialize(void)
     }
     if (!(pgnutls_decode_rs_value = dlsym( libgnutls_handle, "gnutls_decode_rs_value" )))
     {
-        WARN("gnutls_decode_rs_value not found\n");
-        pgnutls_decode_rs_value = compat_gnutls_decode_rs_value;
+        if (!(pgnutls_decode_rs_value = dlsym( libgnutls_handle, "_gnutls_decode_ber_rs_raw" )))
+        {
+            WARN("gnutls_decode_rs_value and legacy alternative _gnutls_decode_ber_rs_raw not found\n");
+            pgnutls_decode_rs_value = compat_gnutls_decode_rs_value;
+        }
     }
 
     if (TRACE_ON( bcrypt ))
From f70d26ade963aab370f80ca33744ca258f839b25 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Mon, 24 Feb 2020 13:32:38 -0600
Subject: [PATCH] ntdll: Partially implement
 JobObjectBasicAccountingInformation.

---
 dlls/kernel32/tests/process.c  |  9 +++++++++
 dlls/ntdll/sync.c              | 20 +++++++++++++++++---
 include/wine/server_protocol.h | 18 +++++++++++++++++-
 server/process.c               | 14 ++++++++++++++
 server/protocol.def            |  8 ++++++++
 server/request.h               |  7 +++++++
 server/trace.c                 | 14 ++++++++++++++
 7 files changed, 86 insertions(+), 4 deletions(-)

diff --git a/dlls/kernel32/tests/process.c b/dlls/kernel32/tests/process.c
index 89ad4175c7e..0489f4c285f 100644
--- a/dlls/kernel32/tests/process.c
+++ b/dlls/kernel32/tests/process.c
@@ -2543,6 +2543,7 @@ static void test_QueryInformationJobObject(void)
     PJOBOBJECT_BASIC_PROCESS_ID_LIST pid_list = (JOBOBJECT_BASIC_PROCESS_ID_LIST *)buf;
     JOBOBJECT_EXTENDED_LIMIT_INFORMATION ext_limit_info;
     JOBOBJECT_BASIC_LIMIT_INFORMATION *basic_limit_info = &ext_limit_info.BasicLimitInformation;
+    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION basic_accounting_info;
     DWORD ret_len;
     PROCESS_INFORMATION pi[2];
     char buffer[50];
@@ -2647,6 +2648,14 @@ static void test_QueryInformationJobObject(void)
     ok(ret_len == sizeof(ext_limit_info), "QueryInformationJobObject returned ret_len=%u\n", ret_len);
     expect_eq_d(0, basic_limit_info->LimitFlags);
 
+    /* test JobObjectBasicAccountingInformation */
+    ret = pQueryInformationJobObject(job, JobObjectBasicAccountingInformation, &basic_accounting_info,
+                                     sizeof(basic_accounting_info), &ret_len);
+    ok(ret, "QueryInformationJobObject error %u\n", GetLastError());
+    ok(ret_len == sizeof(basic_accounting_info), "QueryInformationJobObject returned ret_len=%u\n", ret_len);
+    expect_eq_d(3, basic_accounting_info.TotalProcesses);
+    expect_eq_d(2, basic_accounting_info.ActiveProcesses);
+
     TerminateProcess(pi[0].hProcess, 0);
     CloseHandle(pi[0].hProcess);
     CloseHandle(pi[0].hThread);
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 0265ff96661..a6fe27d00ec 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -784,7 +784,9 @@ NTSTATUS WINAPI NtTerminateJobObject( HANDLE handle, NTSTATUS status )
 NTSTATUS WINAPI NtQueryInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS class, PVOID info,
                                              ULONG len, PULONG ret_len )
 {
-    FIXME( "stub: %p %u %p %u %p\n", handle, class, info, len, ret_len );
+    NTSTATUS ret;
+
+    TRACE( "semi-stub: %p %u %p %u %p\n", handle, class, info, len, ret_len );
 
     if (class >= MaxJobObjectInfoClass)
         return STATUS_INVALID_PARAMETER;
@@ -798,9 +800,21 @@ NTSTATUS WINAPI NtQueryInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS c
                 return STATUS_INFO_LENGTH_MISMATCH;
 
             accounting = (JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *)info;
-            memset(accounting, 0, sizeof(*accounting));
+
+            SERVER_START_REQ(get_job_info)
+            {
+                req->handle = wine_server_obj_handle( handle );
+                if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
+                {
+                    memset(accounting, 0, sizeof(*accounting));
+                    accounting->TotalProcesses = reply->total_processes;
+                    accounting->ActiveProcesses = reply->active_processes;
+                }
+            }
+            SERVER_END_REQ;
+
             if (ret_len) *ret_len = sizeof(*accounting);
-            return STATUS_SUCCESS;
+            return ret;
         }
 
     case JobObjectBasicProcessIdList:
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 82d58f0f32b..5b8774a6aed 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5794,6 +5794,19 @@ struct set_job_completion_port_reply
 };
 
 
+struct get_job_info_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_job_info_reply
+{
+    struct reply_header __header;
+    unsigned int total_processes;
+    unsigned int active_processes;
+};
+
+
 
 struct terminate_job_request
 {
@@ -6301,6 +6314,7 @@ enum request
     REQ_process_in_job,
     REQ_set_job_limits,
     REQ_set_job_completion_port,
+    REQ_get_job_info,
     REQ_terminate_job,
     REQ_suspend_process,
     REQ_resume_process,
@@ -6616,6 +6630,7 @@ union generic_request
     struct process_in_job_request process_in_job_request;
     struct set_job_limits_request set_job_limits_request;
     struct set_job_completion_port_request set_job_completion_port_request;
+    struct get_job_info_request get_job_info_request;
     struct terminate_job_request terminate_job_request;
     struct suspend_process_request suspend_process_request;
     struct resume_process_request resume_process_request;
@@ -6929,6 +6944,7 @@ union generic_reply
     struct process_in_job_reply process_in_job_reply;
     struct set_job_limits_reply set_job_limits_reply;
     struct set_job_completion_port_reply set_job_completion_port_reply;
+    struct get_job_info_reply get_job_info_reply;
     struct terminate_job_reply terminate_job_reply;
     struct suspend_process_reply suspend_process_reply;
     struct resume_process_reply resume_process_reply;
diff --git a/server/process.c b/server/process.c
index f43f96cda08..dacca025572 100644
--- a/server/process.c
+++ b/server/process.c
@@ -164,6 +164,7 @@ struct job
     struct object obj;             /* object header */
     struct list process_list;      /* list of all processes */
     int num_processes;             /* count of running processes */
+    int assign_counter;            /* Number of processes which have been assigned */
     unsigned int limit_flags;      /* limit flags */
     int terminating;               /* job is terminating */
     int signaled;                  /* job is signaled */
@@ -208,6 +209,7 @@ static struct job *create_job_object( struct object *root, const struct unicode_
             /* initialize it if it didn't already exist */
             list_init( &job->process_list );
             job->num_processes = 0;
+            job->assign_counter = 0;
             job->limit_flags = 0;
             job->terminating = 0;
             job->signaled = 0;
@@ -250,6 +252,7 @@ static void add_job_process( struct job *job, struct process *process )
     process->job = (struct job *)grab_object( job );
     list_add_tail( &job->process_list, &process->job_entry );
     job->num_processes++;
+    job->assign_counter++;
 
     add_job_completion( job, JOB_OBJECT_MSG_NEW_PROCESS, get_process_id(process) );
 }
@@ -1750,6 +1753,17 @@ DECL_HANDLER(process_in_job)
     release_object( process );
 }
 
+/* retrieve information about a job */
+DECL_HANDLER(get_job_info)
+{
+    struct job *job = get_job_obj( current->process, req->handle, JOB_OBJECT_QUERY );
+
+    reply->total_processes = job->assign_counter;
+    reply->active_processes = job->num_processes;
+
+    release_object( job );
+}
+
 /* terminate all processes associated with the job */
 DECL_HANDLER(terminate_job)
 {
diff --git a/server/protocol.def b/server/protocol.def
index 1dc9d81a2f5..932c67b1b00 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3966,6 +3966,14 @@ struct handle_info
     client_ptr_t key;             /* key to send with completion messages */
 @END
 
+/* Retrieve information about a job */
+@REQ(get_job_info)
+    obj_handle_t handle;
+@REPLY
+    unsigned int total_processes;
+    unsigned int active_processes;
+@END
+
 
 /* Terminate all processes associated with the job  */
 @REQ(terminate_job)
diff --git a/server/request.h b/server/request.h
index 57d71403d0c..8521cc955e8 100644
--- a/server/request.h
+++ b/server/request.h
@@ -408,6 +408,7 @@ DECL_HANDLER(assign_job);
 DECL_HANDLER(process_in_job);
 DECL_HANDLER(set_job_limits);
 DECL_HANDLER(set_job_completion_port);
+DECL_HANDLER(get_job_info);
 DECL_HANDLER(terminate_job);
 DECL_HANDLER(suspend_process);
 DECL_HANDLER(resume_process);
@@ -722,6 +723,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_process_in_job,
     (req_handler)req_set_job_limits,
     (req_handler)req_set_job_completion_port,
+    (req_handler)req_get_job_info,
     (req_handler)req_terminate_job,
     (req_handler)req_suspend_process,
     (req_handler)req_resume_process,
@@ -2463,6 +2465,11 @@ C_ASSERT( FIELD_OFFSET(struct set_job_completion_port_request, job) == 12 );
 C_ASSERT( FIELD_OFFSET(struct set_job_completion_port_request, port) == 16 );
 C_ASSERT( FIELD_OFFSET(struct set_job_completion_port_request, key) == 24 );
 C_ASSERT( sizeof(struct set_job_completion_port_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct get_job_info_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_job_info_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_job_info_reply, total_processes) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_job_info_reply, active_processes) == 12 );
+C_ASSERT( sizeof(struct get_job_info_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct terminate_job_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct terminate_job_request, status) == 16 );
 C_ASSERT( sizeof(struct terminate_job_request) == 24 );
diff --git a/server/trace.c b/server/trace.c
index f9d13167eb2..b407a7c478e 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4607,6 +4607,17 @@ static void dump_set_job_completion_port_request( const struct set_job_completio
     dump_uint64( ", key=", &req->key );
 }
 
+static void dump_get_job_info_request( const struct get_job_info_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_job_info_reply( const struct get_job_info_reply *req )
+{
+    fprintf( stderr, " total_processes=%08x", req->total_processes );
+    fprintf( stderr, ", active_processes=%08x", req->active_processes );
+}
+
 static void dump_terminate_job_request( const struct terminate_job_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -5028,6 +5039,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_process_in_job_request,
     (dump_func)dump_set_job_limits_request,
     (dump_func)dump_set_job_completion_port_request,
+    (dump_func)dump_get_job_info_request,
     (dump_func)dump_terminate_job_request,
     (dump_func)dump_suspend_process_request,
     (dump_func)dump_resume_process_request,
@@ -5339,6 +5351,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     NULL,
     NULL,
+    (dump_func)dump_get_job_info_reply,
     NULL,
     NULL,
     NULL,
@@ -5650,6 +5663,7 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "process_in_job",
     "set_job_limits",
     "set_job_completion_port",
+    "get_job_info",
     "terminate_job",
     "suspend_process",
     "resume_process",
From 2f720e9aa8ded781ff457bdfab96f3651017299c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 21 Jan 2020 21:05:05 +0100
Subject: [PATCH] winex11.drv: Ignore ClipCursor if desktop window is
 foreground.

---
 dlls/winex11.drv/mouse.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index a5235b69a8d..4b2c9bd41ae 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1625,6 +1625,13 @@ BOOL CDECL X11DRV_ClipCursor( LPCRECT clip )
         HWND foreground = GetForegroundWindow();
         DWORD tid, pid;
 
+        if (foreground == GetDesktopWindow())
+        {
+            WARN( "desktop is foreground, ignoring ClipCursor\n" );
+            ungrab_clipping_window();
+            return TRUE;
+        }
+
         /* forward request to the foreground window if it's in a different thread */
         tid = GetWindowThreadProcessId( foreground, &pid );
         if (tid && tid != GetCurrentThreadId() && pid == GetCurrentProcessId())
From 24a8f709ec8fcf8fa4fcc349a7885c02cc184d74 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 26 Feb 2020 13:09:48 -0600
Subject: [PATCH] ntdll: Don't support reading/writing debug registers

Monster Hunter World continually retrieves these registers, so fast-path
this code. This will break setting debug registers on other threads.
---
 dlls/ntdll/signal_x86_64.c | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index 04f3854388c..9752c3889b6 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -2115,13 +2115,13 @@ NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
     BOOL self = (handle == GetCurrentThread());
 
     /* debug registers require a server call */
-    if (self && (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64)))
+    /*if (self && (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64)))
         self = (amd64_thread_data()->dr0 == context->Dr0 &&
                 amd64_thread_data()->dr1 == context->Dr1 &&
                 amd64_thread_data()->dr2 == context->Dr2 &&
                 amd64_thread_data()->dr3 == context->Dr3 &&
                 amd64_thread_data()->dr6 == context->Dr6 &&
-                amd64_thread_data()->dr7 == context->Dr7);
+                amd64_thread_data()->dr7 == context->Dr7);*/
 
     if (!self)
     {
@@ -2149,7 +2149,15 @@ NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
     needed_flags = context->ContextFlags;
 
     /* debug registers require a server call */
-    if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64)) self = FALSE;
+    if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64)) //self = FALSE;
+    {
+        context->Dr0 = amd64_thread_data()->dr0;
+        context->Dr1 = amd64_thread_data()->dr1;
+        context->Dr2 = amd64_thread_data()->dr2;
+        context->Dr3 = amd64_thread_data()->dr3;
+        context->Dr6 = amd64_thread_data()->dr6;
+        context->Dr7 = amd64_thread_data()->dr7;
+    }
 
     if (!self)
     {
From 8fd9d6bd3d567893f933b7d55615446476745654 Mon Sep 17 00:00:00 2001
From: Vincent Povirk <vincent@codeweavers.com>
Date: Wed, 1 Apr 2020 11:47:05 -0500
Subject: [PATCH] winebrowser: Restore original LD_LIBRARY_PATH before calling
 to system

---
 programs/winebrowser/main.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/programs/winebrowser/main.c b/programs/winebrowser/main.c
index 9cd6812d032..9e5fe2f3129 100644
--- a/programs/winebrowser/main.c
+++ b/programs/winebrowser/main.c
@@ -69,6 +69,17 @@ static char *strdup_unixcp( const WCHAR *str )
     return ret;
 }
 
+static void restore_system_environment(void)
+{
+    const char* orig_ld_path = getenv("ORIG_LD_LIBRARY_PATH");
+
+    if (orig_ld_path)
+    {
+        setenv("LD_LIBRARY_PATH", orig_ld_path, 1);
+        unsetenv("ORIG_LD_LIBRARY_PATH");
+    }
+}
+
 /* try to launch a unix app from a comma separated string of app names */
 static int launch_app( const WCHAR *candidates, const WCHAR *argv1 )
 {
@@ -78,6 +89,11 @@ static int launch_app( const WCHAR *candidates, const WCHAR *argv1 )
 
     if (!(cmdline = strdup_unixcp( argv1 ))) return 1;
 
+    /* PROTON HACK: Restore ORIG_LD_LIBRARY_PATH to LD_LIBRARY_PATH.
+     * System programs may not work correctly with our libraries, in
+     * particular gio on Ubuntu 19.04 is broken by our libgio. */
+    restore_system_environment();
+
     while (*candidates)
     {
         WCHAR **args = CommandLineToArgvW( candidates, &count );
From 3082a724542ba7527fa52eaac3611ed97ff91cac Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 10 Dec 2018 12:48:41 -0600
Subject: [PATCH] xaudio2: Set PulseAudio application name property in the
 environment

So PA doesn't present all Wine applications as "wine-preloader", and
allows PA to store per-application settings.
---
 dlls/winepulse.drv/mmdevdrv.c |  1 +
 dlls/xaudio2_7/xaudio_dll.c   | 21 +++++++++++++++++++++
 2 files changed, 22 insertions(+)

diff --git a/dlls/winepulse.drv/mmdevdrv.c b/dlls/winepulse.drv/mmdevdrv.c
index c80ea4f9d04..6a2906761a7 100644
--- a/dlls/winepulse.drv/mmdevdrv.c
+++ b/dlls/winepulse.drv/mmdevdrv.c
@@ -571,6 +571,7 @@ static HRESULT pulse_connect(void)
     WideCharToMultiByte(CP_UNIXCP, 0, name, -1, str, len, NULL, NULL);
     TRACE("Name: %s\n", str);
     pulse_ctx = pa_context_new(pa_mainloop_get_api(pulse_ml), str);
+    setenv("PULSE_PROP_application.name", str, 1);
     pa_xfree(str);
     if (!pulse_ctx) {
         ERR("Failed to create context\n");
diff --git a/dlls/xaudio2_7/xaudio_dll.c b/dlls/xaudio2_7/xaudio_dll.c
index 4ca04198b6e..483e2b4138a 100644
--- a/dlls/xaudio2_7/xaudio_dll.c
+++ b/dlls/xaudio2_7/xaudio_dll.c
@@ -38,6 +38,7 @@
 #include "wine/asm.h"
 #include "wine/debug.h"
 #include "wine/heap.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(xaudio2);
 
@@ -1948,6 +1949,26 @@ static HRESULT WINAPI XAudio2CF_CreateInstance(IClassFactory *iface, IUnknown *p
     pthread_cond_init(&object->mst.engine_done, NULL);
     pthread_cond_init(&object->mst.engine_ready, NULL);
 
+    /* set PulseAudio's application.name in the environment since FAudio and
+     * SDL provide no way to pass this in */
+    {
+        WCHAR path[MAX_PATH], *name;
+        char *str;
+        DWORD len;
+
+        GetModuleFileNameW(NULL, path, ARRAY_SIZE(path));
+        name = strrchrW(path, '\\');
+        if (!name)
+            name = path;
+        else
+            name++;
+        len = WideCharToMultiByte(CP_UNIXCP, 0, name, -1, NULL, 0, NULL, NULL);
+        str = HeapAlloc(GetProcessHeap(), 0, len);
+        WideCharToMultiByte(CP_UNIXCP, 0, name, -1, str, len, NULL, NULL);
+        setenv("PULSE_PROP_application.name", str, 1);
+        HeapFree(GetProcessHeap(), 0, str);
+    }
+
     FAudioCOMConstructWithCustomAllocatorEXT(
         &object->faudio,
         XAUDIO2_VER,
From b739d48093cce805b7b4f48fdbd9d0bb62bc8013 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 13 Apr 2020 16:25:47 -0700
Subject: [PATCH] HACK: dxgi: Swap around memory sizes for GTA IV

GTA IV ends up using its "Intel integrated" codepath for determining
VRAM size (since nvapi/atiadlxx fail), but this requires that
DedicatedVideoMemory is a very small dummy value, and SharedSystemMemory
is the actual VRAM size.
Swap the memory values around so this works.
---
 dlls/dxgi/adapter.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/dxgi/adapter.c b/dlls/dxgi/adapter.c
index 5a97590dbce..a5563498cdd 100644
--- a/dlls/dxgi/adapter.c
+++ b/dlls/dxgi/adapter.c
@@ -200,6 +200,25 @@ static HRESULT dxgi_adapter_get_desc(struct dxgi_adapter *adapter, DXGI_ADAPTER_
     desc->GraphicsPreemptionGranularity = 0; /* FIXME */
     desc->ComputePreemptionGranularity = 0; /* FIXME */
 
+    {
+        /* HACK
+         *
+         * Grand Theft Auto IV first tries to get VRAM size using nvapi/atiadlxx,
+         * after that fails it falls back to the Intel integrated codepath which
+         * uses DXGI.
+         *
+         * DedicatedVideoMemory must be a dummy value less than 200 MB, then
+         * SharedSystemMemory will be used as the VRAM size.
+         * In case of failure, the game will just use 512 MB as VRAM size.
+         */
+        const char *sgi = getenv("SteamGameId");
+        if(sgi && !strcmp(sgi, "12210"))
+        {
+            desc->SharedSystemMemory = adapter_id.video_memory;
+            desc->DedicatedVideoMemory = 32 * 1024 * 1024;
+        }
+    }
+
     return hr;
 }
 
From c619409f235cf660cdd4fd3295d5e04ec628daa1 Mon Sep 17 00:00:00 2001
From: Alexey Prokhin <alexey@prokhin.ru>
Date: Thu, 23 Apr 2020 12:29:55 +0300
Subject: [PATCH] kernelbase: Set the proper error code in
 GetQueuedCompletionStatus{Ex} when the handle is closed.

Planet Zoo relies on it being ERROR_ABANDONED_WAIT_0.
---
 dlls/kernelbase/sync.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernelbase/sync.c b/dlls/kernelbase/sync.c
index 0ae3aadde92..e95ede8aed5 100644
--- a/dlls/kernelbase/sync.c
+++ b/dlls/kernelbase/sync.c
@@ -960,6 +960,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetQueuedCompletionStatus( HANDLE port, LPDWORD co
     }
 
     if (status == STATUS_TIMEOUT) SetLastError( WAIT_TIMEOUT );
+    else if (status == ERROR_WAIT_NO_CHILDREN) SetLastError( ERROR_ABANDONED_WAIT_0 );
     else SetLastError( RtlNtStatusToDosError(status) );
     return FALSE;
 }
@@ -981,6 +982,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetQueuedCompletionStatusEx( HANDLE port, OVERLAPP
     if (ret == STATUS_SUCCESS) return TRUE;
     else if (ret == STATUS_TIMEOUT) SetLastError( WAIT_TIMEOUT );
     else if (ret == STATUS_USER_APC) SetLastError( WAIT_IO_COMPLETION );
+    else if (ret == ERROR_WAIT_NO_CHILDREN) SetLastError( ERROR_ABANDONED_WAIT_0 );
     else SetLastError( RtlNtStatusToDosError(ret) );
     return FALSE;
 }

From 9cffda4856b5e5057008d165dd38ec971b9af712 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 24 Apr 2020 19:48:20 +0300
Subject: [PATCH] ntdll: Handle NULL object name buffer in
 nt_to_unix_file_name_attr().

Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/ntdll/directory.c  |  8 ++++++++
 dlls/ntdll/tests/file.c | 22 +++++++++++++++++++++-
 2 files changed, 29 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
index 784e720edf8..56f9be0f06e 100644
--- a/dlls/ntdll/directory.c
+++ b/dlls/ntdll/directory.c
@@ -2701,8 +2701,16 @@ NTSTATUS nt_to_unix_file_name_attr( const OBJECT_ATTRIBUTES *attr, ANSI_STRING *
     NTSTATUS status;
     BOOLEAN check_case = !(attr->Attributes & OBJ_CASE_INSENSITIVE);
 
+    if (!attr->ObjectName->Buffer && attr->ObjectName->Length)
+        return STATUS_ACCESS_VIOLATION;
+
     if (!attr->RootDirectory)  /* without root dir fall back to normal lookup */
+    {
+        if (!attr->ObjectName->Buffer)
+            return STATUS_OBJECT_PATH_SYNTAX_BAD;
+
         return wine_nt_to_unix_file_name( attr->ObjectName, unix_name_ret, disposition );
+    }
 
     name     = attr->ObjectName->Buffer;
     name_len = attr->ObjectName->Length / sizeof(WCHAR);

From cb427c70056654bf12fb0d7d6dcb13386d193ff4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 24 Apr 2020 14:37:58 +0300
Subject: [PATCH] server: Try to retrieve the unix name on handles created from
 file descriptors.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46070
Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>

Fixes Unity of Command II, and possibly other games that use
Python38.dll.
---
 server/fd.c   | 39 +++++++++++++++++++++++++++++++++++++++
 server/file.c |  1 +
 server/file.h |  2 ++
 3 files changed, 42 insertions(+)

diff --git a/server/fd.c b/server/fd.c
index 904c99029ca..990a1a708a0 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -2079,6 +2079,45 @@ struct fd *create_anonymous_fd( const struct fd_ops *fd_user_ops, int unix_fd, s
     return NULL;
 }
 
+void set_unix_name_of_fd( struct fd *fd, const struct stat *fd_st )
+{
+#ifdef __linux__
+    static const char procfs_fmt[] = "/proc/self/fd/%d";
+
+    char path[PATH_MAX], procfs_path[sizeof(procfs_fmt) - 2 /* %d */ + 11];
+    struct stat path_st;
+    ssize_t len;
+
+    sprintf( procfs_path, procfs_fmt, fd->unix_fd );
+    len = readlink( procfs_path, path, sizeof(path) );
+    if (len == -1 || len >= sizeof(path) )
+        return;
+    path[len] = '\0';
+
+    /* Make sure it's an absolute path, has at least one hardlink, and the same inode */
+    if (path[0] != '/' || stat( path, &path_st ) || path_st.st_nlink < 1 ||
+        path_st.st_dev != fd_st->st_dev || path_st.st_ino != fd_st->st_ino)
+        return;
+
+    if (!(fd->unix_name = mem_alloc( len + 1 )))
+        return;
+    memcpy( fd->unix_name, path, len + 1 );
+
+#elif defined(F_GETPATH)
+    char path[PATH_MAX];
+    size_t size;
+
+    if (fcntl( fd->unix_fd, F_GETPATH, path ) == -1 || path[0] != '/')
+        return;
+
+    size = strlen(path) + 1;
+    if (!(fd->unix_name = mem_alloc( size )))
+        return;
+    memcpy( fd->unix_name, path, size );
+
+#endif
+}
+
 /* retrieve the object that is using an fd */
 void *get_fd_user( struct fd *fd )
 {
diff --git a/server/file.c b/server/file.c
index e5e367478ce..e469341c746 100644
--- a/server/file.c
+++ b/server/file.c
@@ -147,6 +147,7 @@ struct file *create_file_for_fd( int fd, unsigned int access, unsigned int shari
         release_object( file );
         return NULL;
     }
+    set_unix_name_of_fd( file->fd, &st );
     allow_fd_caching( file->fd );
     return file;
 }
diff --git a/server/file.h b/server/file.h
index 0e43a8170df..7d614569a16 100644
--- a/server/file.h
+++ b/server/file.h
@@ -22,6 +22,7 @@
 #define __WINE_SERVER_FILE_H
 
 #include <sys/types.h>
+#include <sys/stat.h>
 
 #include "object.h"
 
@@ -82,6 +83,7 @@ extern struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t
                            unsigned int access, unsigned int sharing, unsigned int options );
 extern struct fd *create_anonymous_fd( const struct fd_ops *fd_user_ops,
                                        int unix_fd, struct object *user, unsigned int options );
+extern void set_unix_name_of_fd( struct fd *fd, const struct stat *fd_st );
 extern struct fd *dup_fd_object( struct fd *orig, unsigned int access, unsigned int sharing,
                                  unsigned int options );
 extern struct fd *get_fd_object_for_mapping( struct fd *fd, unsigned int access, unsigned int sharing );

From aa34cb2167da7685bc550f2073ebc4c610f28eda Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 13 May 2020 13:55:55 +0300
Subject: [PATCH] ntdll: Add WINE_DISABLE_WRITE_WATCH env var to disable write
 watch support.

Massively improves performance for corert games (Streets of Rage 4).
Could be fixed properly with Linux kernel changes.
---
 dlls/ntdll/virtual.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
index d0cd2639ee9..d2eb7bcc341 100644
--- a/dlls/ntdll/virtual.c
+++ b/dlls/ntdll/virtual.c
@@ -2684,6 +2684,22 @@ NTSTATUS WINAPI NtAllocateVirtualMemory( HANDLE process, PVOID *ret, ULONG_PTR z
 
     TRACE("%p %p %08lx %x %08x\n", process, *ret, size, type, protect );
 
+    if (type & MEM_WRITE_WATCH)
+    {
+        static int disable = -1;
+
+        if (disable == -1)
+        {
+            const char *env_var;
+
+            if ((disable = (env_var = getenv("WINE_DISABLE_WRITE_WATCH")) && atoi(env_var)))
+                FIXME("Disabling write watch support.\n");
+        }
+
+        if (disable)
+            return STATUS_NOT_SUPPORTED;
+    }
+
     if (!size) return STATUS_INVALID_PARAMETER;
     if (zero_bits > 21 && zero_bits < 32) return STATUS_INVALID_PARAMETER_3;
     if (!is_win64 && !is_wow64 && zero_bits >= 32) return STATUS_INVALID_PARAMETER_3;

From 912701cb515acdc8e0ff263552f656cd49f60714 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 13:01:26 +0200
Subject: [PATCH] d3d10core: Implement D3D10CoreRegisterLayers.

---
 dlls/d3d10core/d3d10core_main.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/d3d10core/d3d10core_main.c b/dlls/d3d10core/d3d10core_main.c
index d364be90d6d..5a9a4a211c1 100644
--- a/dlls/d3d10core/d3d10core_main.c
+++ b/dlls/d3d10core/d3d10core_main.c
@@ -29,11 +29,13 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d10core);
 HRESULT WINAPI D3D11CoreCreateDevice(IDXGIFactory *factory, IDXGIAdapter *adapter, unsigned int flags,
         const D3D_FEATURE_LEVEL *feature_levels, unsigned int level_count, ID3D11Device **device);
 
+HRESULT WINAPI D3D11CoreRegisterLayers(void);
+
 HRESULT WINAPI D3D10CoreRegisterLayers(void)
 {
     TRACE("\n");
 
-    return E_NOTIMPL;
+    return D3D11CoreRegisterLayers();
 }
 
 HRESULT WINAPI D3D10CoreCreateDevice(IDXGIFactory *factory, IDXGIAdapter *adapter,

From 376a037ce1391e071835a0bf30ebf1fcec43c367 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 12:59:44 +0200
Subject: [PATCH] dxgi: Add fallback to D3D10CoreRegisterLayers.

If D3D11CoreRegisterLayers is not found in module.
---
 dlls/dxgi/dxgi_main.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/dlls/dxgi/dxgi_main.c b/dlls/dxgi/dxgi_main.c
index 83c3f3734a7..006ab370844 100644
--- a/dlls/dxgi/dxgi_main.c
+++ b/dlls/dxgi/dxgi_main.c
@@ -106,8 +106,8 @@ static HRESULT register_d3d10core_layers(HMODULE d3d10core)
 
     if (!dxgi_main.d3d10core)
     {
-        HRESULT hr;
-        HRESULT (WINAPI *d3d11core_register_layers)(void);
+        HRESULT hr = E_FAIL;
+        HRESULT (WINAPI *register_layers)(void);
         HMODULE mod;
         BOOL ret;
 
@@ -117,8 +117,10 @@ static HRESULT register_d3d10core_layers(HMODULE d3d10core)
             return E_FAIL;
         }
 
-        d3d11core_register_layers = (void *)GetProcAddress(mod, "D3D11CoreRegisterLayers");
-        hr = d3d11core_register_layers();
+        if ((register_layers = (void *)GetProcAddress(mod, "D3D11CoreRegisterLayers")) ||
+            (register_layers = (void *)GetProcAddress(mod, "D3D10CoreRegisterLayers")))
+            hr = register_layers();
+
         if (FAILED(hr))
         {
             ERR("Failed to register d3d11 layers, returning %#x.\n", hr);

From 5b00ca69a1927e1d0df4cf26160228e460568c51 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 9 Jun 2020 14:16:22 +0300
Subject: [PATCH] kernelbase: HACK Add an option to blacklist files.

---
 dlls/kernelbase/file.c | 76 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 75 insertions(+), 1 deletion(-)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index eb2ef57c7d6..c7881fe4516 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -41,6 +41,8 @@
 #include "wine/exception.h"
 #include "wine/debug.h"
 
+#include "wine/heap.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(file);
 
 /* info structure for FindFirstFile handle */
@@ -432,6 +434,72 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileA( LPCSTR name, DWORD access, DWORD sh
     return CreateFileW( nameW, access, sharing, sa, creation, attributes, template );
 }
 
+#define MAX_BLACKLISTED_FILENAMES 32
+
+static struct
+{
+    const WCHAR *name;
+    size_t name_len;
+}
+blacklist_filenames[MAX_BLACKLISTED_FILENAMES];
+
+static unsigned int blacklist_filename_count;
+
+static BOOL CALLBACK init_file_blacklist(PINIT_ONCE init_once, PVOID parameter, PVOID *context)
+{
+    const WCHAR separators[] = L",; ";
+    WCHAR *buffer, *token;
+    DWORD size;
+
+    if (!(size = GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", NULL, 0)))
+        return TRUE;
+
+    if (!(buffer = heap_alloc(sizeof(*buffer) * size)))
+    {
+        ERR("No memory.\n");
+        return FALSE;
+    }
+
+    if (GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", buffer, size) != size - 1)
+    {
+        ERR("Error getting WINE_BLACKLIST_FILES env variable.\n");
+        return FALSE;
+    }
+
+    blacklist_filename_count = 0;
+    token = wcstok(buffer, separators);
+    while (token && blacklist_filename_count < MAX_BLACKLISTED_FILENAMES)
+    {
+        FIXME("Blacklisting %s file.\n", debugstr_w(token));
+        blacklist_filenames[blacklist_filename_count].name = token;
+        blacklist_filenames[blacklist_filename_count++].name_len = wcslen(token);
+        token = wcstok(NULL, separators);
+    }
+
+    if (token && blacklist_filename_count == MAX_BLACKLISTED_FILENAMES)
+        ERR("File black list is too long.\n");
+
+    return TRUE;
+}
+
+static BOOL is_file_blacklisted(LPCWSTR filename)
+{
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+    unsigned int i;
+    size_t len;
+
+    if (!InitOnceExecuteOnce(&init_once, init_file_blacklist, NULL, NULL))
+        return FALSE;
+
+    len = wcslen(filename);
+
+    for (i = 0; i < blacklist_filename_count; ++i)
+        if (blacklist_filenames[i].name_len <= len
+                && !wcsicmp(blacklist_filenames[i].name, filename + len - blacklist_filenames[i].name_len))
+            return TRUE;
+
+    return FALSE;
+}
 
 /*************************************************************************
  *	CreateFileW   (kernelbase.@)
@@ -460,7 +528,6 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileW( LPCWSTR filename, DWORD access, DWO
         FILE_OVERWRITE      /* TRUNCATE_EXISTING */
     };
 
-
     /* sanity checks */
 
     if (!filename || !filename[0])
@@ -905,6 +905,13 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileW( LPCWSTR filename, DWORD access, DWO
            (sharing & FILE_SHARE_WRITE) ? "FILE_SHARE_WRITE " : "",
            (sharing & FILE_SHARE_DELETE) ? "FILE_SHARE_DELETE " : "",
            creation, attributes);
+    
+    if (is_file_blacklisted(filename))
+    {
+        FIXME("\"%s\" is blacklisted.\n", debugstr_w(filename));
+        SetLastError( ERROR_FILE_NOT_FOUND );
+        return INVALID_HANDLE_VALUE;
+    }
 
     if (!wcsncmp( filename, L"\\\\.\\", 4 ))
     {

From 2409bd1f74be116172688a25df725290637c255a Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 10 Jun 2020 16:18:29 -0500
Subject: [PATCH] kernelbase: Apply blacklist automatically to Origin
 executables

---
 dlls/kernelbase/file.c | 54 ++++++++++++++++++++++++++++++++++--------
 1 file changed, 44 insertions(+), 10 deletions(-)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index c7881fe4516..bb4be45da5d 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -447,23 +447,57 @@ static unsigned int blacklist_filename_count;
 
 static BOOL CALLBACK init_file_blacklist(PINIT_ONCE init_once, PVOID parameter, PVOID *context)
 {
+    static WCHAR origin_blacklist[] = L"kernel32.dll;user32.dll";
+
     const WCHAR separators[] = L",; ";
     WCHAR *buffer, *token;
     DWORD size;
 
-    if (!(size = GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", NULL, 0)))
-        return TRUE;
-
-    if (!(buffer = heap_alloc(sizeof(*buffer) * size)))
+    if ((size = GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", NULL, 0)))
     {
-        ERR("No memory.\n");
-        return FALSE;
-    }
+        if (!(buffer = heap_alloc(sizeof(*buffer) * size)))
+        {
+            ERR("No memory.\n");
+            return FALSE;
+        }
 
-    if (GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", buffer, size) != size - 1)
+        if (GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", buffer, size) != size - 1)
+        {
+            ERR("Error getting WINE_BLACKLIST_FILES env variable.\n");
+            return FALSE;
+        }
+    }
+    else
     {
-        ERR("Error getting WINE_BLACKLIST_FILES env variable.\n");
-        return FALSE;
+        static const WCHAR *origin_names[] = {
+            L"igoproxy64.exe",
+            L"igoproxy.exe",
+            L"origin.exe",
+            L"easteamproxy.exe"
+        };
+
+        WCHAR cur_exe[MAX_PATH];
+        DWORD cur_exe_len, i;
+
+        if (!(cur_exe_len = GetModuleFileNameW(NULL, cur_exe, ARRAY_SIZE(cur_exe))))
+            return TRUE;
+
+        buffer = NULL;
+
+        for (i = 0; i < ARRAY_SIZE(origin_names); ++i)
+        {
+            DWORD origin_name_len = wcslen(origin_names[i]);
+            if (cur_exe_len >= origin_name_len &&
+                    wcsicmp(cur_exe + cur_exe_len - origin_name_len, origin_names[i]) == 0)
+            {
+                FIXME("using origin file blacklist for %s\n", debugstr_w(cur_exe));
+                buffer = origin_blacklist;
+                break;
+            }
+        }
+
+        if (!buffer)
+            return TRUE;
     }
 
     blacklist_filename_count = 0;
From eb9b688d1b5d8c2061137100609c0a9b8189301c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 14 Jul 2020 18:25:16 +0200
Subject: [PATCH] dxgi: Implement IDXGIOutput5 and IDXGIOutput6 stubs.

---
 dlls/dxgi/adapter.c      |   2 +-
 dlls/dxgi/dxgi_private.h |   2 +-
 dlls/dxgi/output.c       | 140 ++++++++++++++++++++++++++-------------
 3 files changed, 97 insertions(+), 47 deletions(-)

diff --git a/dlls/dxgi/adapter.c b/dlls/dxgi/adapter.c
index a5563498cdd..ae01c860057 100644
--- a/dlls/dxgi/adapter.c
+++ b/dlls/dxgi/adapter.c
@@ -140,7 +140,7 @@ static HRESULT STDMETHODCALLTYPE dxgi_adapter_EnumOutputs(IWineDXGIAdapter *ifac
         return hr;
     }

-    *output = (IDXGIOutput *)&output_object->IDXGIOutput4_iface;
+    *output = (IDXGIOutput *)&output_object->IDXGIOutput6_iface;

     TRACE("Returning output %p.\n", *output);

diff --git a/dlls/dxgi/dxgi_private.h b/dlls/dxgi/dxgi_private.h
index 5b934498349..3338be7a8de 100644
--- a/dlls/dxgi/dxgi_private.h
+++ b/dlls/dxgi/dxgi_private.h
@@ -142,7 +142,7 @@ HRESULT dxgi_device_init(struct dxgi_device *device, struct dxgi_device_layer *l
 /* IDXGIOutput */
 struct dxgi_output
 {
-    IDXGIOutput4 IDXGIOutput4_iface;
+    IDXGIOutput6 IDXGIOutput6_iface;
     LONG refcount;
     struct wined3d_private_store private_store;
     struct dxgi_adapter *adapter;
diff --git a/dlls/dxgi/output.c b/dlls/dxgi/output.c
index a2331358e69..5d02802c74c 100644
--- a/dlls/dxgi/output.c
+++ b/dlls/dxgi/output.c
@@ -183,18 +183,20 @@ static HRESULT dxgi_output_get_display_mode_list(struct dxgi_output *output,
     return S_OK;
 }

-static inline struct dxgi_output *impl_from_IDXGIOutput4(IDXGIOutput4 *iface)
+static inline struct dxgi_output *impl_from_IDXGIOutput6(IDXGIOutput6 *iface)
 {
-    return CONTAINING_RECORD(iface, struct dxgi_output, IDXGIOutput4_iface);
+    return CONTAINING_RECORD(iface, struct dxgi_output, IDXGIOutput6_iface);
 }

 /* IUnknown methods */

-static HRESULT STDMETHODCALLTYPE dxgi_output_QueryInterface(IDXGIOutput4 *iface, REFIID iid, void **object)
+static HRESULT STDMETHODCALLTYPE dxgi_output_QueryInterface(IDXGIOutput6 *iface, REFIID iid, void **object)
 {
     TRACE("iface %p, iid %s, object %p.\n", iface, debugstr_guid(iid), object);

-    if (IsEqualGUID(iid, &IID_IDXGIOutput4)
+    if (IsEqualGUID(iid, &IID_IDXGIOutput6)
+            || IsEqualGUID(iid, &IID_IDXGIOutput5)
+            || IsEqualGUID(iid, &IID_IDXGIOutput4)
             || IsEqualGUID(iid, &IID_IDXGIOutput3)
             || IsEqualGUID(iid, &IID_IDXGIOutput2)
             || IsEqualGUID(iid, &IID_IDXGIOutput1)
@@ -213,9 +215,9 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_QueryInterface(IDXGIOutput4 *iface,
     return E_NOINTERFACE;
 }

-static ULONG STDMETHODCALLTYPE dxgi_output_AddRef(IDXGIOutput4 *iface)
+static ULONG STDMETHODCALLTYPE dxgi_output_AddRef(IDXGIOutput6 *iface)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);
     ULONG refcount = InterlockedIncrement(&output->refcount);

     TRACE("%p increasing refcount to %u.\n", output, refcount);
@@ -223,9 +225,9 @@ static ULONG STDMETHODCALLTYPE dxgi_output_AddRef(IDXGIOutput4 *iface)
     return refcount;
 }

-static ULONG STDMETHODCALLTYPE dxgi_output_Release(IDXGIOutput4 *iface)
+static ULONG STDMETHODCALLTYPE dxgi_output_Release(IDXGIOutput6 *iface)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);
     ULONG refcount = InterlockedDecrement(&output->refcount);

     TRACE("%p decreasing refcount to %u.\n", output, refcount);
@@ -242,40 +244,40 @@ static ULONG STDMETHODCALLTYPE dxgi_output_Release(IDXGIOutput4 *iface)

 /* IDXGIObject methods */

-static HRESULT STDMETHODCALLTYPE dxgi_output_SetPrivateData(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_SetPrivateData(IDXGIOutput6 *iface,
         REFGUID guid, UINT data_size, const void *data)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);

     TRACE("iface %p, guid %s, data_size %u, data %p.\n", iface, debugstr_guid(guid), data_size, data);

     return dxgi_set_private_data(&output->private_store, guid, data_size, data);
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_SetPrivateDataInterface(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_SetPrivateDataInterface(IDXGIOutput6 *iface,
         REFGUID guid, const IUnknown *object)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);

     TRACE("iface %p, guid %s, object %p.\n", iface, debugstr_guid(guid), object);

     return dxgi_set_private_data_interface(&output->private_store, guid, object);
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_GetPrivateData(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetPrivateData(IDXGIOutput6 *iface,
         REFGUID guid, UINT *data_size, void *data)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);

     TRACE("iface %p, guid %s, data_size %p, data %p.\n", iface, debugstr_guid(guid), data_size, data);

     return dxgi_get_private_data(&output->private_store, guid, data_size, data);
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_GetParent(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetParent(IDXGIOutput6 *iface,
         REFIID riid, void **parent)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);

     TRACE("iface %p, riid %s, parent %p.\n", iface, debugstr_guid(riid), parent);

@@ -284,9 +286,9 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_GetParent(IDXGIOutput4 *iface,

 /* IDXGIOutput methods */

-static HRESULT STDMETHODCALLTYPE dxgi_output_GetDesc(IDXGIOutput4 *iface, DXGI_OUTPUT_DESC *desc)
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetDesc(IDXGIOutput6 *iface, DXGI_OUTPUT_DESC *desc)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);
     struct wined3d_output_desc wined3d_desc;
     HRESULT hr;

@@ -315,10 +317,10 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_GetDesc(IDXGIOutput4 *iface, DXGI_O
     return S_OK;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplayModeList(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplayModeList(IDXGIOutput6 *iface,
         DXGI_FORMAT format, UINT flags, UINT *mode_count, DXGI_MODE_DESC *modes)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);

     FIXME("iface %p, format %s, flags %#x, mode_count %p, modes %p partial stub!\n",
             iface, debug_dxgi_format(format), flags, mode_count, modes);
@@ -327,10 +329,10 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplayModeList(IDXGIOutput4 *if
             format, mode_count, modes, DXGI_MODE_STRUCT_VERSION_0);
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_FindClosestMatchingMode(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_FindClosestMatchingMode(IDXGIOutput6 *iface,
         const DXGI_MODE_DESC *mode, DXGI_MODE_DESC *closest_match, IUnknown *device)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);
     struct wined3d_display_mode wined3d_mode;
     HRESULT hr;

@@ -350,7 +352,7 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_FindClosestMatchingMode(IDXGIOutput
     return hr;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_WaitForVBlank(IDXGIOutput4 *iface)
+static HRESULT STDMETHODCALLTYPE dxgi_output_WaitForVBlank(IDXGIOutput6 *iface)
 {
     static BOOL once = FALSE;

@@ -362,9 +364,9 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_WaitForVBlank(IDXGIOutput4 *iface)
     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_TakeOwnership(IDXGIOutput4 *iface, IUnknown *device, BOOL exclusive)
+static HRESULT STDMETHODCALLTYPE dxgi_output_TakeOwnership(IDXGIOutput6 *iface, IUnknown *device, BOOL exclusive)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);
     HRESULT hr;

     TRACE("iface %p, device %p, exclusive %d.\n", iface, device, exclusive);
@@ -382,9 +384,9 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_TakeOwnership(IDXGIOutput4 *iface,
     return hr;
 }

-static void STDMETHODCALLTYPE dxgi_output_ReleaseOwnership(IDXGIOutput4 *iface)
+static void STDMETHODCALLTYPE dxgi_output_ReleaseOwnership(IDXGIOutput6 *iface)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);

     TRACE("iface %p.\n", iface);

@@ -396,7 +398,7 @@ static void STDMETHODCALLTYPE dxgi_output_ReleaseOwnership(IDXGIOutput4 *iface)
     wined3d_mutex_unlock();
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_GetGammaControlCapabilities(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetGammaControlCapabilities(IDXGIOutput6 *iface,
         DXGI_GAMMA_CONTROL_CAPABILITIES *gamma_caps)
 {
     unsigned int i;
@@ -417,7 +419,7 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_GetGammaControlCapabilities(IDXGIOu
     return S_OK;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_SetGammaControl(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_SetGammaControl(IDXGIOutput6 *iface,
         const DXGI_GAMMA_CONTROL *gamma_control)
 {
     FIXME("iface %p, gamma_control %p stub!\n", iface, gamma_control);
@@ -425,7 +427,7 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_SetGammaControl(IDXGIOutput4 *iface
     return S_OK;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_GetGammaControl(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetGammaControl(IDXGIOutput6 *iface,
         DXGI_GAMMA_CONTROL *gamma_control)
 {
     FIXME("iface %p, gamma_control %p stub!\n", iface, gamma_control);
@@ -433,21 +435,21 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_GetGammaControl(IDXGIOutput4 *iface
     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_SetDisplaySurface(IDXGIOutput4 *iface, IDXGISurface *surface)
+static HRESULT STDMETHODCALLTYPE dxgi_output_SetDisplaySurface(IDXGIOutput6 *iface, IDXGISurface *surface)
 {
     FIXME("iface %p, surface %p stub!\n", iface, surface);

     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplaySurfaceData(IDXGIOutput4 *iface, IDXGISurface *surface)
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplaySurfaceData(IDXGIOutput6 *iface, IDXGISurface *surface)
 {
     FIXME("iface %p, surface %p stub!\n", iface, surface);

     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_GetFrameStatistics(IDXGIOutput4 *iface, DXGI_FRAME_STATISTICS *stats)
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetFrameStatistics(IDXGIOutput6 *iface, DXGI_FRAME_STATISTICS *stats)
 {
     FIXME("iface %p, stats %p stub!\n", iface, stats);

@@ -456,10 +458,10 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_GetFrameStatistics(IDXGIOutput4 *if

 /* IDXGIOutput1 methods */

-static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplayModeList1(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplayModeList1(IDXGIOutput6 *iface,
         DXGI_FORMAT format, UINT flags, UINT *mode_count, DXGI_MODE_DESC1 *modes)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);

     FIXME("iface %p, format %s, flags %#x, mode_count %p, modes %p partial stub!\n",
             iface, debug_dxgi_format(format), flags, mode_count, modes);
@@ -468,10 +470,10 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplayModeList1(IDXGIOutput4 *i
             format, mode_count, modes, DXGI_MODE_STRUCT_VERSION_1);
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_FindClosestMatchingMode1(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_FindClosestMatchingMode1(IDXGIOutput6 *iface,
         const DXGI_MODE_DESC1 *mode, DXGI_MODE_DESC1 *closest_match, IUnknown *device)
 {
-    struct dxgi_output *output = impl_from_IDXGIOutput4(iface);
+    struct dxgi_output *output = impl_from_IDXGIOutput6(iface);
     struct wined3d_display_mode wined3d_mode;
     HRESULT hr;

@@ -491,7 +493,7 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_FindClosestMatchingMode1(IDXGIOutpu
     return hr;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplaySurfaceData1(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplaySurfaceData1(IDXGIOutput6 *iface,
         IDXGIResource *resource)
 {
     FIXME("iface %p, resource %p stub!\n", iface, resource);
@@ -499,7 +501,7 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplaySurfaceData1(IDXGIOutput4
     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE dxgi_output_DuplicateOutput(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_DuplicateOutput(IDXGIOutput6 *iface,
         IUnknown *device, IDXGIOutputDuplication **output_duplication)
 {
     FIXME("iface %p, device %p, output_duplication %p stub!\n", iface, device, output_duplication);
@@ -509,7 +511,7 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_DuplicateOutput(IDXGIOutput4 *iface

 /* IDXGIOutput2 methods */

-static BOOL STDMETHODCALLTYPE dxgi_output_SupportsOverlays(IDXGIOutput4 *iface)
+static BOOL STDMETHODCALLTYPE dxgi_output_SupportsOverlays(IDXGIOutput6 *iface)
 {
     FIXME("iface %p stub!\n", iface);

@@ -518,7 +520,7 @@ static BOOL STDMETHODCALLTYPE dxgi_output_SupportsOverlays(IDXGIOutput4 *iface)

 /* IDXGIOutput3 methods */

-static HRESULT STDMETHODCALLTYPE dxgi_output_CheckOverlaySupport(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_CheckOverlaySupport(IDXGIOutput6 *iface,
         DXGI_FORMAT format, IUnknown *device, UINT *flags)
 {
     FIXME("iface %p, format %#x, device %p, flags %p stub!\n", iface, format, device, flags);
@@ -528,7 +530,7 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_CheckOverlaySupport(IDXGIOutput4 *i

 /* IDXGIOutput4 methods */

-static HRESULT STDMETHODCALLTYPE dxgi_output_CheckOverlayColorSpaceSupport(IDXGIOutput4 *iface,
+static HRESULT STDMETHODCALLTYPE dxgi_output_CheckOverlayColorSpaceSupport(IDXGIOutput6 *iface,
         DXGI_FORMAT format, DXGI_COLOR_SPACE_TYPE color_space, IUnknown *device, UINT *flags)
 {
     FIXME("iface %p, format %#x, color_space %#x, device %p, flags %p stub!\n",
@@ -537,7 +539,50 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_CheckOverlayColorSpaceSupport(IDXGI
     return E_NOTIMPL;
 }

-static const struct IDXGIOutput4Vtbl dxgi_output_vtbl =
+/* IDXGIOutput5 methods */
+
+static HRESULT STDMETHODCALLTYPE dxgi_output_DuplicateOutput1(IDXGIOutput6 *iface,
+        IUnknown *device, UINT flags, UINT format_count, const DXGI_FORMAT *formats,
+        IDXGIOutputDuplication **duplication)
+{
+    FIXME("iface %p, device %p, flags %#x, format_count %d, formats %p, "
+            "output_duplication %p stub!\n", iface, device, flags, format_count,
+            formats, duplication);
+
+    return E_NOTIMPL;
+}
+
+/* IDXGIOutput6 methods */
+
+static HRESULT STDMETHODCALLTYPE dxgi_output_GetDesc1(IDXGIOutput6 *iface,
+        DXGI_OUTPUT_DESC1 *desc)
+{
+    DXGI_OUTPUT_DESC base_desc;
+    HRESULT hr;
+
+    FIXME("iface %p, desc %p stub!\n", iface, desc);
+
+    if (!desc)
+        return E_INVALIDARG;
+
+    if (FAILED(hr = dxgi_output_GetDesc(iface, &base_desc)))
+        return hr;
+
+    memset(desc, 0, sizeof(*desc));
+    memcpy(desc, &base_desc, sizeof(base_desc));
+
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE dxgi_output_CheckHardwareCompositionSupport(IDXGIOutput6 *iface,
+        UINT *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static const struct IDXGIOutput6Vtbl dxgi_output_vtbl =
 {
     dxgi_output_QueryInterface,
     dxgi_output_AddRef,
@@ -571,6 +616,11 @@ static const struct IDXGIOutput4Vtbl dxgi_output_vtbl =
     dxgi_output_CheckOverlaySupport,
     /* IDXGIOutput4 methods */
     dxgi_output_CheckOverlayColorSpaceSupport,
+    /* IDXGIOutput5 methods */
+    dxgi_output_DuplicateOutput1,
+    /* IDXGIOutput6 methods */
+    dxgi_output_GetDesc1,
+    dxgi_output_CheckHardwareCompositionSupport,
 };

 struct dxgi_output *unsafe_impl_from_IDXGIOutput(IDXGIOutput *iface)
@@ -578,13 +628,13 @@ struct dxgi_output *unsafe_impl_from_IDXGIOutput(IDXGIOutput *iface)
     if (!iface)
         return NULL;
     assert(iface->lpVtbl == (IDXGIOutputVtbl *)&dxgi_output_vtbl);
-    return CONTAINING_RECORD(iface, struct dxgi_output, IDXGIOutput4_iface);
+    return CONTAINING_RECORD(iface, struct dxgi_output, IDXGIOutput6_iface);
 }

 static void dxgi_output_init(struct dxgi_output *output, unsigned int output_idx,
         struct dxgi_adapter *adapter)
 {
-    output->IDXGIOutput4_iface.lpVtbl = &dxgi_output_vtbl;
+    output->IDXGIOutput6_iface.lpVtbl = &dxgi_output_vtbl;
     output->refcount = 1;
     output->wined3d_output = wined3d_adapter_get_output(adapter->wined3d_adapter, output_idx);
     wined3d_private_store_init(&output->private_store);
From b3f778dcb0ba405cb05144b7edfa26ade4502a1e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 14 Jul 2020 22:29:08 +0200
Subject: [PATCH] dxgi: Implement IDXGISwapChain4 stub.

---
 dlls/dxgi/swapchain.c | 157 +++++++++++++++++++++++-------------------
 1 file changed, 85 insertions(+), 72 deletions(-)

diff --git a/dlls/dxgi/swapchain.c b/dlls/dxgi/swapchain.c
index a3d0929a39b..97878093a6b 100644
--- a/dlls/dxgi/swapchain.c
+++ b/dlls/dxgi/swapchain.c
@@ -1062,7 +1062,7 @@ static HRESULT hresult_from_vk_result(VkResult vr)

 struct d3d12_swapchain
 {
-    IDXGISwapChain3 IDXGISwapChain3_iface;
+    IDXGISwapChain4 IDXGISwapChain4_iface;
     LONG refcount;
     struct wined3d_private_store private_store;

@@ -1850,14 +1850,14 @@ static HRESULT d3d12_swapchain_recreate_vulkan_swapchain(struct d3d12_swapchain
     return hr;
 }

-static inline struct d3d12_swapchain *d3d12_swapchain_from_IDXGISwapChain3(IDXGISwapChain3 *iface)
+static inline struct d3d12_swapchain *d3d12_swapchain_from_IDXGISwapChain4(IDXGISwapChain4 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d12_swapchain, IDXGISwapChain3_iface);
+    return CONTAINING_RECORD(iface, struct d3d12_swapchain, IDXGISwapChain4_iface);
 }

 /* IUnknown methods */

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_QueryInterface(IDXGISwapChain3 *iface, REFIID iid, void **object)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_QueryInterface(IDXGISwapChain4 *iface, REFIID iid, void **object)
 {
     TRACE("iface %p, iid %s, object %p.\n", iface, debugstr_guid(iid), object);

@@ -1867,7 +1867,8 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_QueryInterface(IDXGISwapChain3
             || IsEqualGUID(iid, &IID_IDXGISwapChain)
             || IsEqualGUID(iid, &IID_IDXGISwapChain1)
             || IsEqualGUID(iid, &IID_IDXGISwapChain2)
-            || IsEqualGUID(iid, &IID_IDXGISwapChain3))
+            || IsEqualGUID(iid, &IID_IDXGISwapChain3)
+            || IsEqualGUID(iid, &IID_IDXGISwapChain4))
     {
         IUnknown_AddRef(iface);
         *object = iface;
@@ -1880,9 +1881,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_QueryInterface(IDXGISwapChain3
     return E_NOINTERFACE;
 }

-static ULONG STDMETHODCALLTYPE d3d12_swapchain_AddRef(IDXGISwapChain3 *iface)
+static ULONG STDMETHODCALLTYPE d3d12_swapchain_AddRef(IDXGISwapChain4 *iface)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);
     ULONG refcount = InterlockedIncrement(&swapchain->refcount);

     TRACE("%p increasing refcount to %u.\n", swapchain, refcount);
@@ -1934,9 +1935,9 @@ static void d3d12_swapchain_destroy(struct d3d12_swapchain *swapchain)
     wined3d_swapchain_state_destroy(swapchain->state);
 }

-static ULONG STDMETHODCALLTYPE d3d12_swapchain_Release(IDXGISwapChain3 *iface)
+static ULONG STDMETHODCALLTYPE d3d12_swapchain_Release(IDXGISwapChain4 *iface)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);
     ULONG refcount = InterlockedDecrement(&swapchain->refcount);

     TRACE("%p decreasing refcount to %u.\n", swapchain, refcount);
@@ -1952,39 +1953,39 @@ static ULONG STDMETHODCALLTYPE d3d12_swapchain_Release(IDXGISwapChain3 *iface)

 /* IDXGIObject methods */

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetPrivateData(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetPrivateData(IDXGISwapChain4 *iface,
         REFGUID guid, UINT data_size, const void *data)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, guid %s, data_size %u, data %p.\n", iface, debugstr_guid(guid), data_size, data);

     return dxgi_set_private_data(&swapchain->private_store, guid, data_size, data);
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetPrivateDataInterface(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetPrivateDataInterface(IDXGISwapChain4 *iface,
         REFGUID guid, const IUnknown *object)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, guid %s, object %p.\n", iface, debugstr_guid(guid), object);

     return dxgi_set_private_data_interface(&swapchain->private_store, guid, object);
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetPrivateData(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetPrivateData(IDXGISwapChain4 *iface,
         REFGUID guid, UINT *data_size, void *data)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, guid %s, data_size %p, data %p.\n", iface, debugstr_guid(guid), data_size, data);

     return dxgi_get_private_data(&swapchain->private_store, guid, data_size, data);
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetParent(IDXGISwapChain3 *iface, REFIID iid, void **parent)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetParent(IDXGISwapChain4 *iface, REFIID iid, void **parent)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, iid %s, parent %p.\n", iface, debugstr_guid(iid), parent);

@@ -1993,9 +1994,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetParent(IDXGISwapChain3 *ifac

 /* IDXGIDeviceSubObject methods */

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetDevice(IDXGISwapChain3 *iface, REFIID iid, void **device)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetDevice(IDXGISwapChain4 *iface, REFIID iid, void **device)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, iid %s, device %p.\n", iface, debugstr_guid(iid), device);

@@ -2213,19 +2214,19 @@ static HRESULT d3d12_swapchain_present(struct d3d12_swapchain *swapchain,
     return hresult_from_vk_result(vr);
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_Present(IDXGISwapChain3 *iface, UINT sync_interval, UINT flags)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_Present(IDXGISwapChain4 *iface, UINT sync_interval, UINT flags)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, sync_interval %u, flags %#x.\n", iface, sync_interval, flags);

     return d3d12_swapchain_present(swapchain, sync_interval, flags);
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetBuffer(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetBuffer(IDXGISwapChain4 *iface,
         UINT buffer_idx, REFIID iid, void **surface)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, buffer_idx %u, iid %s, surface %p.\n",
             iface, buffer_idx, debugstr_guid(iid), surface);
@@ -2240,10 +2241,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetBuffer(IDXGISwapChain3 *ifac
     return ID3D12Resource_QueryInterface(swapchain->buffers[buffer_idx], iid, surface);
 }

-static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH d3d12_swapchain_SetFullscreenState(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH d3d12_swapchain_SetFullscreenState(IDXGISwapChain4 *iface,
         BOOL fullscreen, IDXGIOutput *target)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);
     DXGI_SWAP_CHAIN_FULLSCREEN_DESC *fullscreen_desc = &swapchain->fullscreen_desc;
     const DXGI_SWAP_CHAIN_DESC1 *swapchain_desc = &swapchain->desc;
     struct wined3d_swapchain_desc wined3d_desc;
@@ -2262,7 +2263,7 @@ static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH d3d12_swapchain_SetFullscreen
     {
         IDXGIOutput_AddRef(target);
     }
-    else if (FAILED(hr = IDXGISwapChain3_GetContainingOutput(iface, &target)))
+    else if (FAILED(hr = IDXGISwapChain4_GetContainingOutput(iface, &target)))
     {
         WARN("Failed to get target output for swapchain, hr %#x.\n", hr);
         return hr;
@@ -2296,10 +2297,10 @@ static HRESULT STDMETHODCALLTYPE DECLSPEC_HOTPATCH d3d12_swapchain_SetFullscreen
     return DXGI_ERROR_NOT_CURRENTLY_AVAILABLE;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetFullscreenState(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetFullscreenState(IDXGISwapChain4 *iface,
         BOOL *fullscreen, IDXGIOutput **target)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, fullscreen %p, target %p.\n", iface, fullscreen, target);

@@ -2312,9 +2313,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetFullscreenState(IDXGISwapCha
     return S_OK;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetDesc(IDXGISwapChain3 *iface, DXGI_SWAP_CHAIN_DESC *desc)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetDesc(IDXGISwapChain4 *iface, DXGI_SWAP_CHAIN_DESC *desc)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);
     const DXGI_SWAP_CHAIN_FULLSCREEN_DESC *fullscreen_desc = &swapchain->fullscreen_desc;
     const DXGI_SWAP_CHAIN_DESC1 *swapchain_desc = &swapchain->desc;

@@ -2401,10 +2402,10 @@ static HRESULT d3d12_swapchain_resize_buffers(struct d3d12_swapchain *swapchain,
     return d3d12_swapchain_recreate_vulkan_swapchain(swapchain);
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_ResizeBuffers(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_ResizeBuffers(IDXGISwapChain4 *iface,
         UINT buffer_count, UINT width, UINT height, DXGI_FORMAT format, UINT flags)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, buffer_count %u, width %u, height %u, format %s, flags %#x.\n",
             iface, buffer_count, width, height, debug_dxgi_format(format), flags);
@@ -2412,20 +2413,20 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_ResizeBuffers(IDXGISwapChain3 *
     return d3d12_swapchain_resize_buffers(swapchain, buffer_count, width, height, format, flags);
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_ResizeTarget(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_ResizeTarget(IDXGISwapChain4 *iface,
         const DXGI_MODE_DESC *target_mode_desc)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, target_mode_desc %p.\n", iface, target_mode_desc);

     return dxgi_swapchain_resize_target(swapchain->state, target_mode_desc);
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetContainingOutput(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetContainingOutput(IDXGISwapChain4 *iface,
         IDXGIOutput **output)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);
     IUnknown *device_parent;
     IDXGIFactory *factory;
     IDXGIAdapter *adapter;
@@ -2453,7 +2454,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetContainingOutput(IDXGISwapCh
     return hr;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetFrameStatistics(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetFrameStatistics(IDXGISwapChain4 *iface,
         DXGI_FRAME_STATISTICS *stats)
 {
     FIXME("iface %p, stats %p stub!\n", iface, stats);
@@ -2461,7 +2462,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetFrameStatistics(IDXGISwapCha
     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetLastPresentCount(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetLastPresentCount(IDXGISwapChain4 *iface,
         UINT *last_present_count)
 {
     FIXME("iface %p, last_present_count %p stub!\n", iface, last_present_count);
@@ -2471,9 +2472,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetLastPresentCount(IDXGISwapCh

 /* IDXGISwapChain1 methods */

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetDesc1(IDXGISwapChain3 *iface, DXGI_SWAP_CHAIN_DESC1 *desc)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetDesc1(IDXGISwapChain4 *iface, DXGI_SWAP_CHAIN_DESC1 *desc)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, desc %p.\n", iface, desc);

@@ -2487,10 +2488,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetDesc1(IDXGISwapChain3 *iface
     return S_OK;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetFullscreenDesc(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetFullscreenDesc(IDXGISwapChain4 *iface,
         DXGI_SWAP_CHAIN_FULLSCREEN_DESC *desc)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, desc %p.\n", iface, desc);

@@ -2504,9 +2505,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetFullscreenDesc(IDXGISwapChai
     return S_OK;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetHwnd(IDXGISwapChain3 *iface, HWND *hwnd)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetHwnd(IDXGISwapChain4 *iface, HWND *hwnd)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, hwnd %p.\n", iface, hwnd);

@@ -2520,7 +2521,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetHwnd(IDXGISwapChain3 *iface,
     return S_OK;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetCoreWindow(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetCoreWindow(IDXGISwapChain4 *iface,
         REFIID iid, void **core_window)
 {
     FIXME("iface %p, iid %s, core_window %p stub!\n", iface, debugstr_guid(iid), core_window);
@@ -2531,10 +2532,10 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetCoreWindow(IDXGISwapChain3 *
     return DXGI_ERROR_INVALID_CALL;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_Present1(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_Present1(IDXGISwapChain4 *iface,
         UINT sync_interval, UINT flags, const DXGI_PRESENT_PARAMETERS *present_parameters)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, sync_interval %u, flags %#x, present_parameters %p.\n",
             iface, sync_interval, flags, present_parameters);
@@ -2545,14 +2546,14 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_Present1(IDXGISwapChain3 *iface
     return d3d12_swapchain_present(swapchain, sync_interval, flags);
 }

-static BOOL STDMETHODCALLTYPE d3d12_swapchain_IsTemporaryMonoSupported(IDXGISwapChain3 *iface)
+static BOOL STDMETHODCALLTYPE d3d12_swapchain_IsTemporaryMonoSupported(IDXGISwapChain4 *iface)
 {
     FIXME("iface %p stub!\n", iface);

     return FALSE;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetRestrictToOutput(IDXGISwapChain3 *iface, IDXGIOutput **output)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetRestrictToOutput(IDXGISwapChain4 *iface, IDXGIOutput **output)
 {
     FIXME("iface %p, output %p stub!\n", iface, output);

@@ -2566,28 +2567,28 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetRestrictToOutput(IDXGISwapCh
     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetBackgroundColor(IDXGISwapChain3 *iface, const DXGI_RGBA *color)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetBackgroundColor(IDXGISwapChain4 *iface, const DXGI_RGBA *color)
 {
     FIXME("iface %p, color %p stub!\n", iface, color);

     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetBackgroundColor(IDXGISwapChain3 *iface, DXGI_RGBA *color)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetBackgroundColor(IDXGISwapChain4 *iface, DXGI_RGBA *color)
 {
     FIXME("iface %p, color %p stub!\n", iface, color);

     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetRotation(IDXGISwapChain3 *iface, DXGI_MODE_ROTATION rotation)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetRotation(IDXGISwapChain4 *iface, DXGI_MODE_ROTATION rotation)
 {
     FIXME("iface %p, rotation %#x stub!\n", iface, rotation);

     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetRotation(IDXGISwapChain3 *iface, DXGI_MODE_ROTATION *rotation)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetRotation(IDXGISwapChain4 *iface, DXGI_MODE_ROTATION *rotation)
 {
     FIXME("iface %p, rotation %p stub!\n", iface, rotation);

@@ -2596,23 +2597,23 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetRotation(IDXGISwapChain3 *if

 /* IDXGISwapChain2 methods */

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetSourceSize(IDXGISwapChain3 *iface, UINT width, UINT height)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetSourceSize(IDXGISwapChain4 *iface, UINT width, UINT height)
 {
     FIXME("iface %p, width %u, height %u stub!\n", iface, width, height);

     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetSourceSize(IDXGISwapChain3 *iface, UINT *width, UINT *height)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetSourceSize(IDXGISwapChain4 *iface, UINT *width, UINT *height)
 {
     FIXME("iface %p, width %p, height %p stub!\n", iface, width, height);

     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetMaximumFrameLatency(IDXGISwapChain3 *iface, UINT max_latency)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetMaximumFrameLatency(IDXGISwapChain4 *iface, UINT max_latency)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, max_latency %u.\n", iface, max_latency);

@@ -2632,9 +2633,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetMaximumFrameLatency(IDXGISwa
     return S_OK;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetMaximumFrameLatency(IDXGISwapChain3 *iface, UINT *max_latency)
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetMaximumFrameLatency(IDXGISwapChain4 *iface, UINT *max_latency)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p, max_latency %p.\n", iface, max_latency);

@@ -2648,16 +2649,16 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetMaximumFrameLatency(IDXGISwa
     return S_OK;
 }

-static HANDLE STDMETHODCALLTYPE d3d12_swapchain_GetFrameLatencyWaitableObject(IDXGISwapChain3 *iface)
+static HANDLE STDMETHODCALLTYPE d3d12_swapchain_GetFrameLatencyWaitableObject(IDXGISwapChain4 *iface)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p.\n", iface);

     return swapchain->frame_latency_event;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetMatrixTransform(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetMatrixTransform(IDXGISwapChain4 *iface,
         const DXGI_MATRIX_3X2_F *matrix)
 {
     FIXME("iface %p, matrix %p stub!\n", iface, matrix);
@@ -2665,7 +2666,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetMatrixTransform(IDXGISwapCha
     return E_NOTIMPL;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetMatrixTransform(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetMatrixTransform(IDXGISwapChain4 *iface,
         DXGI_MATRIX_3X2_F *matrix)
 {
     FIXME("iface %p, matrix %p stub!\n", iface, matrix);
@@ -2675,9 +2676,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetMatrixTransform(IDXGISwapCha

 /* IDXGISwapChain3 methods */

-static UINT STDMETHODCALLTYPE d3d12_swapchain_GetCurrentBackBufferIndex(IDXGISwapChain3 *iface)
+static UINT STDMETHODCALLTYPE d3d12_swapchain_GetCurrentBackBufferIndex(IDXGISwapChain4 *iface)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);

     TRACE("iface %p.\n", iface);

@@ -2686,7 +2687,7 @@ static UINT STDMETHODCALLTYPE d3d12_swapchain_GetCurrentBackBufferIndex(IDXGISwa
     return swapchain->current_buffer_index;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_CheckColorSpaceSupport(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_CheckColorSpaceSupport(IDXGISwapChain4 *iface,
         DXGI_COLOR_SPACE_TYPE colour_space, UINT *colour_space_support)
 {
     UINT support_flags = 0;
@@ -2704,7 +2705,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_CheckColorSpaceSupport(IDXGISwa
     return S_OK;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetColorSpace1(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetColorSpace1(IDXGISwapChain4 *iface,
         DXGI_COLOR_SPACE_TYPE colour_space)
 {
     FIXME("iface %p, colour_space %#x semi-stub!\n", iface, colour_space);
@@ -2718,11 +2719,11 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetColorSpace1(IDXGISwapChain3
     return S_OK;
 }

-static HRESULT STDMETHODCALLTYPE d3d12_swapchain_ResizeBuffers1(IDXGISwapChain3 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_ResizeBuffers1(IDXGISwapChain4 *iface,
         UINT buffer_count, UINT width, UINT height, DXGI_FORMAT format, UINT flags,
         const UINT *node_mask, IUnknown * const *present_queue)
 {
-    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain3(iface);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);
     size_t i, count;

     TRACE("iface %p, buffer_count %u, width %u, height %u, format %s, flags %#x, "
@@ -2744,7 +2745,17 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_ResizeBuffers1(IDXGISwapChain3
     return d3d12_swapchain_resize_buffers(swapchain, buffer_count, width, height, format, flags);
 }

-static const struct IDXGISwapChain3Vtbl d3d12_swapchain_vtbl =
+/* IDXGISwapChain4 methods */
+
+static HRESULT STDMETHODCALLTYPE d3d12_swapchain_SetHDRMetaData(IDXGISwapChain4 *iface,
+        DXGI_HDR_METADATA_TYPE type, UINT size, void *metadata)
+{
+    FIXME("iface %p, type %#x size %#x, metadata %p stub!\n", iface, type, size, metadata);
+
+    return E_NOTIMPL;
+}
+
+static const struct IDXGISwapChain4Vtbl d3d12_swapchain_vtbl =
 {
     /* IUnknown methods */
     d3d12_swapchain_QueryInterface,
@@ -2793,6 +2804,8 @@ static const struct IDXGISwapChain3Vtbl d3d12_swapchain_vtbl =
     d3d12_swapchain_CheckColorSpaceSupport,
     d3d12_swapchain_SetColorSpace1,
     d3d12_swapchain_ResizeBuffers1,
+    /* IDXGISwapChain4 methods */
+    d3d12_swapchain_SetHDRMetaData,
 };

 static BOOL load_vkd3d_functions(void *vkd3d_handle)
@@ -2940,7 +2953,7 @@ static HRESULT d3d12_swapchain_init(struct d3d12_swapchain *swapchain, IWineDXGI
         return E_ACCESSDENIED;
     }

-    swapchain->IDXGISwapChain3_iface.lpVtbl = &d3d12_swapchain_vtbl;
+    swapchain->IDXGISwapChain4_iface.lpVtbl = &d3d12_swapchain_vtbl;
     swapchain->refcount = 1;

     swapchain->window = window;
@@ -3126,7 +3139,7 @@ HRESULT d3d12_swapchain_create(IWineDXGIFactory *factory, ID3D12CommandQueue *qu

     TRACE("Created swapchain %p.\n", object);

-    *swapchain = (IDXGISwapChain1 *)&object->IDXGISwapChain3_iface;
+    *swapchain = (IDXGISwapChain1 *)&object->IDXGISwapChain4_iface;

     return S_OK;
 }
From 6085222f76135e10abefdd5f58d3fdcf86a904c8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 15 Jul 2020 09:41:11 +0200
Subject: [PATCH] windows.gaming.input: Add stub dll.

All these interfaces are required for Death Stranding to start.
---
 configure                                     |   2 +
 configure.ac                                  |   1 +
 dlls/combase/Makefile.in                      |   1 +
 dlls/windows.gaming.input/Makefile.in         |   5 +
 .../windows.gaming.input.spec                 |   3 +
 .../windows.gaming.input_main.c               | 703 ++++++++++++++++++
 loader/wine.inf.in                            |   2 +
 7 files changed, 717 insertions(+)
 create mode 100644 dlls/windows.gaming.input/Makefile.in
 create mode 100644 dlls/windows.gaming.input/windows.gaming.input.spec
 create mode 100644 dlls/windows.gaming.input/windows.gaming.input_main.c

diff --git a/configure b/configure
index 4a01c08a0ac..68b56b994e7 100755
--- a/configure
+++ b/configure
@@ -1629,6 +1629,7 @@ enable_wiaservc
 enable_wimgapi
 enable_windowscodecs
 enable_windowscodecsext
+enable_windows_gaming_input
 enable_winealsa_drv
 enable_wineandroid_drv
 enable_winebus_sys
@@ -21086,6 +21087,7 @@ wine_fn_config_makefile dlls/windowscodecs enable_windowscodecs
 wine_fn_config_makefile dlls/windowscodecs/tests enable_tests
 wine_fn_config_makefile dlls/windowscodecsext enable_windowscodecsext
 wine_fn_config_makefile dlls/windowscodecsext/tests enable_tests
+wine_fn_config_makefile dlls/windows.gaming.input enable_windows_gaming_input
 wine_fn_config_makefile dlls/winealsa.drv enable_winealsa_drv
 wine_fn_config_makefile dlls/wineandroid.drv enable_wineandroid_drv
 wine_fn_config_makefile dlls/winebus.sys enable_winebus_sys
diff --git a/configure.ac b/configure.ac
index a148cf02361..8d97bb611b6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3804,6 +3804,7 @@ WINE_CONFIG_MAKEFILE(dlls/windowscodecs)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecs/tests)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecsext)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecsext/tests)
+WINE_CONFIG_MAKEFILE(dlls/windows.gaming.input)
 WINE_CONFIG_MAKEFILE(dlls/winealsa.drv)
 WINE_CONFIG_MAKEFILE(dlls/wineandroid.drv)
 WINE_CONFIG_MAKEFILE(dlls/winebus.sys)
diff --git a/dlls/combase/Makefile.in b/dlls/combase/Makefile.in
index 0f3c9f86322..ce1b08b6a24 100644
--- a/dlls/combase/Makefile.in
+++ b/dlls/combase/Makefile.in
@@ -1,4 +1,5 @@
 MODULE    = combase.dll
+IMPORTLIB = combase
 IMPORTS   = advapi32 ole32 uuid

 EXTRADLLFLAGS = -mno-cygwin
diff --git a/dlls/windows.gaming.input/Makefile.in b/dlls/windows.gaming.input/Makefile.in
new file mode 100644
index 00000000000..882d3388bf9
--- /dev/null
+++ b/dlls/windows.gaming.input/Makefile.in
@@ -0,0 +1,5 @@
+MODULE = windows.gaming.input.dll
+IMPORTS = combase
+EXTRADLLFLAGS = -mno-cygwin
+C_SRCS = \
+	windows.gaming.input_main.c
diff --git a/dlls/windows.gaming.input/windows.gaming.input.spec b/dlls/windows.gaming.input/windows.gaming.input.spec
new file mode 100644
index 00000000000..721493229c2
--- /dev/null
+++ b/dlls/windows.gaming.input/windows.gaming.input.spec
@@ -0,0 +1,3 @@
+1 stdcall -private DllCanUnloadNow()
+2 stdcall -private DllGetActivationFactory(ptr ptr)
+3 stdcall -private DllGetClassObject(ptr ptr ptr)
diff --git a/dlls/windows.gaming.input/windows.gaming.input_main.c b/dlls/windows.gaming.input/windows.gaming.input_main.c
new file mode 100644
index 00000000000..3a65e2554d0
--- /dev/null
+++ b/dlls/windows.gaming.input/windows.gaming.input_main.c
@@ -0,0 +1,703 @@
+#include <stdarg.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+#include "wine/debug.h"
+#include "activation.h"
+#include "objbase.h"
+#include "initguid.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(uwp);
+
+static const char *debugstr_hstring(HSTRING hstr)
+{
+    const WCHAR *str;
+    UINT32 len;
+    if (hstr && !((ULONG_PTR)hstr >> 16)) return "(invalid)";
+    str = WindowsGetStringRawBuffer(hstr, &len);
+    return wine_dbgstr_wn(str, len);
+}
+
+DEFINE_GUID(IID_IGamepadStatics,0x8bbce529,0xd49c,0x39e9,0x95,0x60,0xe4,0x7d,0xde,0x96,0xb7,0xc8);
+DEFINE_GUID(IID_IRawGameControllerStatics,0xeb8d0792,0xe95a,0x4b19,0xaf,0xc7,0x0a,0x59,0xf8,0xbf,0x75,0x9e);
+DEFINE_GUID(IID_IAgileObject,0x94ea2b94,0xe9cc,0x49e0,0xc0,0xff,0xee,0x64,0xca,0x8f,0x5b,0x90);
+
+typedef struct EventRegistrationToken
+{
+  __int64 value;
+} EventRegistrationToken;
+
+typedef struct IVectorView IVectorView;
+
+typedef struct IVectorViewVtbl
+{
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IVectorView *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        IVectorView *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        IVectorView *This);
+
+    /*** IInspectable methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetIids)(
+        IVectorView *This,
+        ULONG *iidCount,
+        IID **iids);
+
+    HRESULT (STDMETHODCALLTYPE *GetRuntimeClassName)(
+        IVectorView *This,
+        HSTRING *className);
+
+    HRESULT (STDMETHODCALLTYPE *GetTrustLevel)(
+        IVectorView *This,
+        TrustLevel *trustLevel);
+
+    /*** IVectorView<T> methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetAt)(
+        IVectorView *This,
+        ULONG index,
+        /* T */ void *out_value);
+
+    HRESULT (STDMETHODCALLTYPE *get_Size)(
+        IVectorView *This,
+        ULONG *out_value);
+
+    HRESULT (STDMETHODCALLTYPE *IndexOf)(
+        IVectorView *This,
+        /* T */ void *value,
+        ULONG *index,
+        BOOLEAN *out_value);
+
+    HRESULT (STDMETHODCALLTYPE *GetMany)(
+        IVectorView *This,
+        ULONG start_index,
+        /* T[] */ void **items,
+        UINT *out_value);
+} IVectorViewVtbl;
+
+struct IVectorView
+{
+    CONST_VTBL IVectorViewVtbl* lpVtbl;
+};
+
+typedef struct IGamepadStatics IGamepadStatics;
+
+typedef struct IGamepadStaticsVtbl
+{
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IGamepadStatics *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        IGamepadStatics *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        IGamepadStatics *This);
+
+    /*** IInspectable methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetIids)(
+        IGamepadStatics *This,
+        ULONG *iidCount,
+        IID **iids);
+
+    HRESULT (STDMETHODCALLTYPE *GetRuntimeClassName)(
+        IGamepadStatics *This,
+        HSTRING *className);
+
+    HRESULT (STDMETHODCALLTYPE *GetTrustLevel)(
+        IGamepadStatics *This,
+        TrustLevel *trustLevel);
+
+    /*** IGamepadStatics methods ***/
+    HRESULT (STDMETHODCALLTYPE *eventadd_GamepadAdded)(
+        IGamepadStatics *This,
+        /* Windows.Foundation.EventHandler<Windows.Gaming.Input.Gamepad*> */
+        void *value,
+        EventRegistrationToken* token);
+    HRESULT (STDMETHODCALLTYPE *eventremove_GamepadAdded)(
+        IGamepadStatics *This,
+        EventRegistrationToken token);
+
+    HRESULT (STDMETHODCALLTYPE *eventadd_GamepadRemoved)(
+        IGamepadStatics *This,
+        /* Windows.Foundation.EventHandler<Windows.Gaming.Input.Gamepad*> */
+        void *value,
+        EventRegistrationToken* token);
+    HRESULT (STDMETHODCALLTYPE *eventremove_GamepadRemoved)(
+        IGamepadStatics *This,
+        EventRegistrationToken token);
+
+    HRESULT (STDMETHODCALLTYPE *get_Gamepads)(
+        IGamepadStatics *This,
+        /* Windows.Foundation.Collections.IVectorView<Windows.Gaming.Input.Gamepad*>* */
+        void **value);
+
+    END_INTERFACE
+} IGamepadStaticsVtbl;
+
+struct IGamepadStatics
+{
+    CONST_VTBL IGamepadStaticsVtbl* lpVtbl;
+};
+
+typedef struct IRawGameControllerStatics IRawGameControllerStatics;
+
+typedef struct IRawGameControllerStaticsVtbl
+{
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IRawGameControllerStatics *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        IRawGameControllerStatics *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        IRawGameControllerStatics *This);
+
+    /*** IInspectable methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetIids)(
+        IRawGameControllerStatics *This,
+        ULONG *iidCount,
+        IID **iids);
+
+    HRESULT (STDMETHODCALLTYPE *GetRuntimeClassName)(
+        IRawGameControllerStatics *This,
+        HSTRING *className);
+
+    HRESULT (STDMETHODCALLTYPE *GetTrustLevel)(
+        IRawGameControllerStatics *This,
+        TrustLevel *trustLevel);
+
+    /*** IRawGameControllerStatics methods ***/
+    HRESULT (STDMETHODCALLTYPE *eventadd_RawGameControllerAdded)(
+        IRawGameControllerStatics *This,
+        /* Windows.Foundation.EventHandler<Windows.Gaming.Input.RawGameController*> */
+        void *value,
+        EventRegistrationToken* token);
+    HRESULT (STDMETHODCALLTYPE *eventremove_RawGameControllerAdded)(
+        IRawGameControllerStatics *This,
+        EventRegistrationToken token);
+
+    HRESULT (STDMETHODCALLTYPE *eventadd_RawGameControllerRemoved)(
+        IRawGameControllerStatics *This,
+        /* Windows.Foundation.EventHandler<Windows.Gaming.Input.RawGameController*> */
+        void *value,
+        EventRegistrationToken* token);
+    HRESULT (STDMETHODCALLTYPE *eventremove_RawGameControllerRemoved)(
+        IRawGameControllerStatics *This,
+        EventRegistrationToken token);
+
+    HRESULT (STDMETHODCALLTYPE *get_RawGameControllers)(
+        IRawGameControllerStatics *This,
+        /* Windows.Foundation.Collections.IVectorView<Windows.Gaming.Input.RawGameController*>* */
+        void **value);
+
+    HRESULT (STDMETHODCALLTYPE *FromGameController)(
+        IRawGameControllerStatics *This,
+        /* Windows.Gaming.Input.IGameController* */
+        void *game_controller,
+        /* Windows.Gaming.Input.RawGameController** */
+        void **value);
+
+    END_INTERFACE
+} IRawGameControllerStaticsVtbl;
+
+struct IRawGameControllerStatics
+{
+    CONST_VTBL IRawGameControllerStaticsVtbl* lpVtbl;
+};
+
+struct windows_gaming_input
+{
+    IActivationFactory IActivationFactory_iface;
+    IGamepadStatics IGamepadStatics_iface;
+    IRawGameControllerStatics IRawGameControllerStatics_iface;
+    IVectorView IVectorView_iface;
+    LONG refcount;
+};
+
+static inline struct windows_gaming_input *impl_from_IActivationFactory(IActivationFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_gaming_input, IActivationFactory_iface);
+}
+
+static inline struct windows_gaming_input *impl_from_IGamepadStatics(IGamepadStatics *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_gaming_input, IGamepadStatics_iface);
+}
+
+static inline struct windows_gaming_input *impl_from_IRawGameControllerStatics(IRawGameControllerStatics *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_gaming_input, IRawGameControllerStatics_iface);
+}
+
+static inline struct windows_gaming_input *impl_from_IVectorView(IVectorView *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_gaming_input, IVectorView_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_QueryInterface(
+        IVectorView *iface, REFIID iid, void **object)
+{
+    TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE vector_view_AddRef(
+        IVectorView *iface)
+{
+    struct windows_gaming_input *impl = impl_from_IVectorView(iface);
+    ULONG rc = InterlockedIncrement(&impl->refcount);
+    TRACE("%p increasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static ULONG STDMETHODCALLTYPE vector_view_Release(
+        IVectorView *iface)
+{
+    struct windows_gaming_input *impl = impl_from_IVectorView(iface);
+    ULONG rc = InterlockedDecrement(&impl->refcount);
+    TRACE("%p decreasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetIids(
+        IVectorView *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetRuntimeClassName(
+        IVectorView *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetTrustLevel(
+        IVectorView *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetAt(
+    IVectorView *iface, ULONG index, void *out_value)
+{
+    FIXME("iface %p, index %#x, out_value %p stub!\n", iface, index, out_value);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_get_Size(
+    IVectorView *iface, ULONG *out_value)
+{
+    FIXME("iface %p, out_value %p stub!\n", iface, out_value);
+    *out_value = 0;
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_IndexOf(
+    IVectorView *iface, void *value, ULONG *index, BOOLEAN *out_value)
+{
+    FIXME("iface %p, value %p, index %p, out_value %p stub!\n", iface, value, index, out_value);
+    *out_value = FALSE;
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetMany(
+    IVectorView *iface, ULONG start_index, void **items, UINT *out_value)
+{
+    FIXME("iface %p, start_index %#x, items %p, out_value %p stub!\n", iface, start_index, items, out_value);
+    *out_value = 0;
+    return S_OK;
+}
+
+static const struct IVectorViewVtbl vector_view_vtbl =
+{
+    vector_view_QueryInterface,
+    vector_view_AddRef,
+    vector_view_Release,
+    /* IInspectable methods */
+    vector_view_GetIids,
+    vector_view_GetRuntimeClassName,
+    vector_view_GetTrustLevel,
+    /*** IVectorView<T> methods ***/
+    vector_view_GetAt,
+    vector_view_get_Size,
+    vector_view_IndexOf,
+    vector_view_GetMany,
+};
+
+static HRESULT STDMETHODCALLTYPE gamepad_statics_QueryInterface(
+        IGamepadStatics *iface, REFIID iid, void **object)
+{
+    TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+
+    if (IsEqualGUID(iid, &IID_IAgileObject))
+    {
+        IUnknown_AddRef(iface);
+        *object = iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE gamepad_statics_AddRef(
+        IGamepadStatics *iface)
+{
+    struct windows_gaming_input *impl = impl_from_IGamepadStatics(iface);
+    ULONG rc = InterlockedIncrement(&impl->refcount);
+    TRACE("%p increasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static ULONG STDMETHODCALLTYPE gamepad_statics_Release(
+        IGamepadStatics *iface)
+{
+    struct windows_gaming_input *impl = impl_from_IGamepadStatics(iface);
+    ULONG rc = InterlockedDecrement(&impl->refcount);
+    TRACE("%p decreasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static HRESULT STDMETHODCALLTYPE gamepad_statics_GetIids(
+        IGamepadStatics *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE gamepad_statics_GetRuntimeClassName(
+        IGamepadStatics *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE gamepad_statics_GetTrustLevel(
+        IGamepadStatics *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE gamepad_statics_eventadd_GamepadAdded(
+    IGamepadStatics *iface, void *value, EventRegistrationToken* token)
+{
+    FIXME("iface %p, value %p, token %p stub!\n", iface, value, token);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE gamepad_statics_eventremove_GamepadAdded(
+    IGamepadStatics *iface, EventRegistrationToken token)
+{
+    FIXME("iface %p, token %#I64x stub!\n", iface, token.value);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE gamepad_statics_eventadd_GamepadRemoved(
+    IGamepadStatics *iface, void *value, EventRegistrationToken* token)
+{
+    FIXME("iface %p, value %p, token %p stub!\n", iface, value, token);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE gamepad_statics_eventremove_GamepadRemoved(
+    IGamepadStatics *iface, EventRegistrationToken token)
+{
+    FIXME("iface %p, token %#I64x stub!\n", iface, token.value);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE gamepad_statics_get_Gamepads(
+    IGamepadStatics *iface, void **value)
+{
+    struct windows_gaming_input *impl = impl_from_IGamepadStatics(iface);
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    *value = &impl->IVectorView_iface;
+    return S_OK;
+}
+
+static const struct IGamepadStaticsVtbl gamepad_statics_vtbl =
+{
+    gamepad_statics_QueryInterface,
+    gamepad_statics_AddRef,
+    gamepad_statics_Release,
+    /* IInspectable methods */
+    gamepad_statics_GetIids,
+    gamepad_statics_GetRuntimeClassName,
+    gamepad_statics_GetTrustLevel,
+    /* IGamepadStatics methods */
+    gamepad_statics_eventadd_GamepadAdded,
+    gamepad_statics_eventremove_GamepadAdded,
+    gamepad_statics_eventadd_GamepadRemoved,
+    gamepad_statics_eventremove_GamepadRemoved,
+    gamepad_statics_get_Gamepads,
+};
+
+static HRESULT STDMETHODCALLTYPE raw_game_controller_statics_QueryInterface(
+        IRawGameControllerStatics *iface, REFIID iid, void **object)
+{
+    TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+
+    if (IsEqualGUID(iid, &IID_IAgileObject))
+    {
+        IUnknown_AddRef(iface);
+        *object = iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE raw_game_controller_statics_AddRef(
+        IRawGameControllerStatics *iface)
+{
+    struct windows_gaming_input *impl = impl_from_IRawGameControllerStatics(iface);
+    ULONG rc = InterlockedIncrement(&impl->refcount);
+    TRACE("%p increasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static ULONG STDMETHODCALLTYPE raw_game_controller_statics_Release(
+        IRawGameControllerStatics *iface)
+{
+    struct windows_gaming_input *impl = impl_from_IRawGameControllerStatics(iface);
+    ULONG rc = InterlockedDecrement(&impl->refcount);
+    TRACE("%p decreasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static HRESULT STDMETHODCALLTYPE raw_game_controller_statics_GetIids(
+        IRawGameControllerStatics *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE raw_game_controller_statics_GetRuntimeClassName(
+        IRawGameControllerStatics *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE raw_game_controller_statics_GetTrustLevel(
+        IRawGameControllerStatics *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE raw_game_controller_statics_eventadd_RawGameControllerAdded(
+    IRawGameControllerStatics *iface, void *value, EventRegistrationToken* token)
+{
+    FIXME("iface %p, value %p, token %p stub!\n", iface, value, token);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE raw_game_controller_statics_eventremove_RawGameControllerAdded(
+    IRawGameControllerStatics *iface, EventRegistrationToken token)
+{
+    FIXME("iface %p, token %#I64x stub!\n", iface, token.value);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE raw_game_controller_statics_eventadd_RawGameControllerRemoved(
+    IRawGameControllerStatics *iface, void *value, EventRegistrationToken* token)
+{
+    FIXME("iface %p, value %p, token %p stub!\n", iface, value, token);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE raw_game_controller_statics_eventremove_RawGameControllerRemoved(
+    IRawGameControllerStatics *iface, EventRegistrationToken token)
+{
+    FIXME("iface %p, token %#I64x stub!\n", iface, token.value);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE raw_game_controller_statics_get_RawGameControllers(
+    IRawGameControllerStatics *iface, void **value)
+{
+    struct windows_gaming_input *impl = impl_from_IRawGameControllerStatics(iface);
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    *value = &impl->IVectorView_iface;
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE raw_game_controller_statics_FromGameController(
+    IRawGameControllerStatics *iface, void *game_controller, void **value)
+{
+    FIXME("iface %p, game_controller %p, value %p stub!\n", iface, game_controller, value);
+    return E_NOTIMPL;
+}
+
+static const struct IRawGameControllerStaticsVtbl raw_game_controller_statics_vtbl =
+{
+    raw_game_controller_statics_QueryInterface,
+    raw_game_controller_statics_AddRef,
+    raw_game_controller_statics_Release,
+    /* IInspectable methods */
+    raw_game_controller_statics_GetIids,
+    raw_game_controller_statics_GetRuntimeClassName,
+    raw_game_controller_statics_GetTrustLevel,
+    /* IRawGameControllerStatics methods */
+    raw_game_controller_statics_eventadd_RawGameControllerAdded,
+    raw_game_controller_statics_eventremove_RawGameControllerAdded,
+    raw_game_controller_statics_eventadd_RawGameControllerRemoved,
+    raw_game_controller_statics_eventremove_RawGameControllerRemoved,
+    raw_game_controller_statics_get_RawGameControllers,
+    raw_game_controller_statics_FromGameController,
+};
+
+static HRESULT STDMETHODCALLTYPE windows_gaming_input_QueryInterface(
+        IActivationFactory *iface, REFIID iid, void **object)
+{
+    struct windows_gaming_input *impl = impl_from_IActivationFactory(iface);
+    TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+
+    if (IsEqualGUID(iid, &IID_IGamepadStatics))
+    {
+        IUnknown_AddRef(iface);
+        *object = &impl->IGamepadStatics_iface;
+        return S_OK;
+    }
+
+    if (IsEqualGUID(iid, &IID_IRawGameControllerStatics))
+    {
+        IUnknown_AddRef(iface);
+        *object = &impl->IRawGameControllerStatics_iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE windows_gaming_input_AddRef(
+        IActivationFactory *iface)
+{
+    struct windows_gaming_input *impl = impl_from_IActivationFactory(iface);
+    ULONG rc = InterlockedIncrement(&impl->refcount);
+    TRACE("%p increasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static ULONG STDMETHODCALLTYPE windows_gaming_input_Release(
+        IActivationFactory *iface)
+{
+    struct windows_gaming_input *impl = impl_from_IActivationFactory(iface);
+    ULONG rc = InterlockedDecrement(&impl->refcount);
+    TRACE("%p decreasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_gaming_input_GetIids(
+        IActivationFactory *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_gaming_input_GetRuntimeClassName(
+        IActivationFactory *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_gaming_input_GetTrustLevel(
+        IActivationFactory *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_gaming_input_ActivateInstance(
+        IActivationFactory *iface, IInspectable **instance)
+{
+    FIXME("iface %p, instance %p stub!\n", iface, instance);
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl activation_factory_vtbl =
+{
+    windows_gaming_input_QueryInterface,
+    windows_gaming_input_AddRef,
+    windows_gaming_input_Release,
+    /* IInspectable methods */
+    windows_gaming_input_GetIids,
+    windows_gaming_input_GetRuntimeClassName,
+    windows_gaming_input_GetTrustLevel,
+    /* IActivationFactory methods */
+    windows_gaming_input_ActivateInstance,
+};
+
+static struct windows_gaming_input windows_gaming_input =
+{
+    {&activation_factory_vtbl},
+    {&gamepad_statics_vtbl},
+    {&raw_game_controller_statics_vtbl},
+    {&vector_view_vtbl},
+    0
+};
+
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
+{
+    TRACE("(%p, %u, %p)\n", instance, reason, reserved);
+
+    switch (reason)
+    {
+    case DLL_WINE_PREATTACH:
+        return FALSE;    /* prefer native version */
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(instance);
+        break;
+    }
+
+    return TRUE;
+}
+
+HRESULT WINAPI DllCanUnloadNow(void)
+{
+    return S_FALSE;
+}
+
+HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, LPVOID *object)
+{
+    FIXME("clsid %s, riid %s, object %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), object);
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+HRESULT WINAPI DllGetActivationFactory(HSTRING classid, IActivationFactory **factory)
+{
+    TRACE("classid %s, factory %p.\n", debugstr_hstring(classid), factory);
+    *factory = &windows_gaming_input.IActivationFactory_iface;
+    IUnknown_AddRef(*factory);
+    return S_OK;
+}
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 12ec40f872e..6a4526afc75 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -707,6 +707,8 @@ HKLM,%MciExtStr%,"wmx",,"MPEGVideo"
 HKLM,%MciExtStr%,"wvx",,"MPEGVideo"

 [Misc]
+HKLM,Software\Microsoft\WindowsRuntime\ActivatableClassId\Windows.Gaming.Input.Gamepad,"DllPath",2,"Windows.Gaming.Input.dll"
+HKLM,Software\Microsoft\WindowsRuntime\ActivatableClassId\Windows.Gaming.Input.RawGameController,"DllPath",2,"Windows.Gaming.Input.dll"
 HKLM,Software\Borland\Database Engine\Settings\SYSTEM\INIT,SHAREDMEMLOCATION,,9000
 HKLM,Software\Clients\Mail,,2,"Native Mail Client"
 HKLM,Software\Clients\Mail\Native Mail Client,,2,"Native Mail Client"
From c993e4b5656aeedb176e6adbe614fc95ad5fd1e8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Tue, 7 Jul 2020 10:05:59 -0500
Subject: [PATCH] api-ms-win-core-systemtopology-l1-1-0: New DLL.

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
(cherry picked from commit 37238a74a5fea133b8dbcf55ca62cd0d80dc49f7)
---
 configure                                                       | 2 ++
 configure.ac                                                    | 1 +
 dlls/api-ms-win-core-systemtopology-l1-1-0/Makefile.in          | 1 +
 .../api-ms-win-core-systemtopology-l1-1-0.spec                  | 2 ++
 tools/make_specfiles                                            | 1 +
 5 files changed, 7 insertions(+)
 create mode 100644 dlls/api-ms-win-core-systemtopology-l1-1-0/Makefile.in
 create mode 100644 dlls/api-ms-win-core-systemtopology-l1-1-0/api-ms-win-core-systemtopology-l1-1-0.spec

diff --git a/configure b/configure
index 673ea905fd8..4a01c08a0ac 100755
--- a/configure
+++ b/configure
@@ -1024,6 +1024,7 @@ enable_api_ms_win_core_synch_l1_2_1
 enable_api_ms_win_core_sysinfo_l1_1_0
 enable_api_ms_win_core_sysinfo_l1_2_0
 enable_api_ms_win_core_sysinfo_l1_2_1
+enable_api_ms_win_core_systemtopology_l1_1_0
 enable_api_ms_win_core_threadpool_l1_1_0
 enable_api_ms_win_core_threadpool_l1_2_0
 enable_api_ms_win_core_threadpool_legacy_l1_1_0
@@ -20228,6 +20229,7 @@ wine_fn_config_makefile dlls/api-ms-win-core-synch-l1-2-1 enable_api_ms_win_core
 wine_fn_config_makefile dlls/api-ms-win-core-sysinfo-l1-1-0 enable_api_ms_win_core_sysinfo_l1_1_0
 wine_fn_config_makefile dlls/api-ms-win-core-sysinfo-l1-2-0 enable_api_ms_win_core_sysinfo_l1_2_0
 wine_fn_config_makefile dlls/api-ms-win-core-sysinfo-l1-2-1 enable_api_ms_win_core_sysinfo_l1_2_1
+wine_fn_config_makefile dlls/api-ms-win-core-systemtopology-l1-1-0 enable_api_ms_win_core_systemtopology_l1_1_0
 wine_fn_config_makefile dlls/api-ms-win-core-threadpool-l1-1-0 enable_api_ms_win_core_threadpool_l1_1_0
 wine_fn_config_makefile dlls/api-ms-win-core-threadpool-l1-2-0 enable_api_ms_win_core_threadpool_l1_2_0
 wine_fn_config_makefile dlls/api-ms-win-core-threadpool-legacy-l1-1-0 enable_api_ms_win_core_threadpool_legacy_l1_1_0
diff --git a/configure.ac b/configure.ac
index 33b0a22e594..a148cf02361 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2947,6 +2947,7 @@ WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-synch-l1-2-1)
 WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-sysinfo-l1-1-0)
 WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-sysinfo-l1-2-0)
 WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-sysinfo-l1-2-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-systemtopology-l1-1-0)
 WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-threadpool-l1-1-0)
 WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-threadpool-l1-2-0)
 WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-threadpool-legacy-l1-1-0)
diff --git a/dlls/api-ms-win-core-systemtopology-l1-1-0/Makefile.in b/dlls/api-ms-win-core-systemtopology-l1-1-0/Makefile.in
new file mode 100644
index 00000000000..beed9fb9c2e
--- /dev/null
+++ b/dlls/api-ms-win-core-systemtopology-l1-1-0/Makefile.in
@@ -0,0 +1 @@
+MODULE    = api-ms-win-core-systemtopology-l1-1-0.dll
diff --git a/dlls/api-ms-win-core-systemtopology-l1-1-0/api-ms-win-core-systemtopology-l1-1-0.spec b/dlls/api-ms-win-core-systemtopology-l1-1-0/api-ms-win-core-systemtopology-l1-1-0.spec
new file mode 100644
index 00000000000..b5365eb9303
--- /dev/null
+++ b/dlls/api-ms-win-core-systemtopology-l1-1-0/api-ms-win-core-systemtopology-l1-1-0.spec
@@ -0,0 +1,2 @@
+@ stdcall GetNumaHighestNodeNumber(ptr) kernelbase.GetNumaHighestNodeNumber
+@ stdcall GetNumaNodeProcessorMaskEx(long ptr) kernelbase.GetNumaNodeProcessorMaskEx
diff --git a/tools/make_specfiles b/tools/make_specfiles
index 7fef3a6821a..fa57df59f47 100755
--- a/tools/make_specfiles
+++ b/tools/make_specfiles
@@ -320,6 +320,7 @@ my @dll_groups =
   "api-ms-win-appmodel-runtime-l1-1-2",
   "api-ms-win-core-path-l1-1-0",
   "api-ms-win-core-quirks-l1-1-0",
+  "api-ms-win-core-systemtopology-l1-1-0",
   "api-ms-win-security-grouppolicy-l1-1-0",
  ],
  [
From 7805fb3c793fbc3c84df32915107df1b1fcb1c93 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 25 Aug 2020 19:07:58 +0200
Subject: [PATCH] windows.media.speech: Add stub dll.

---
 configure.ac                                  |   1 +
 dlls/windows.media.speech.dll/Makefile.in     |   5 +
 .../windows.media.speech.spec                 |   3 +
 .../windows.media.speech_main.c               | 442 ++++++++++++++++++
 loader/wine.inf.in                            |   1 +
 5 files changed, 452 insertions(+)
 create mode 100644 dlls/windows.media.speech.dll/Makefile.in
 create mode 100644 dlls/windows.media.speech.dll/windows.media.speech.spec
 create mode 100644 dlls/windows.media.speech.dll/windows.media.speech_main.c

diff --git a/configure.ac b/configure.ac
index ffe287aeb80..bc8c7123c8b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3894,6 +3894,7 @@ WINE_CONFIG_MAKEFILE(dlls/win87em.dll16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecsext)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecsext/tests)
 WINE_CONFIG_MAKEFILE(dlls/windows.gaming.input)
+WINE_CONFIG_MAKEFILE(dlls/windows.media.speech.dll)
 WINE_CONFIG_MAKEFILE(dlls/winealsa.drv)
 WINE_CONFIG_MAKEFILE(dlls/wineandroid.drv)
 WINE_CONFIG_MAKEFILE(dlls/winebus.sys)
diff --git a/dlls/windows.media.speech.dll/Makefile.in b/dlls/windows.media.speech.dll/Makefile.in
new file mode 100644
index 00000000000..aed947cc441
--- /dev/null
+++ b/dlls/windows.media.speech.dll/Makefile.in
@@ -0,0 +1,5 @@
+MODULE = windows.media.speech.dll
+IMPORTS = combase
+EXTRADLLFLAGS = -mno-cygwin
+C_SRCS = \
+	windows.media.speech_main.c
diff --git a/dlls/windows.media.speech.dll/windows.media.speech.spec b/dlls/windows.media.speech.dll/windows.media.speech.spec
new file mode 100644
index 00000000000..721493229c2
--- /dev/null
+++ b/dlls/windows.media.speech.dll/windows.media.speech.spec
@@ -0,0 +1,3 @@
+1 stdcall -private DllCanUnloadNow()
+2 stdcall -private DllGetActivationFactory(ptr ptr)
+3 stdcall -private DllGetClassObject(ptr ptr ptr)
diff --git a/dlls/windows.media.speech.dll/windows.media.speech_main.c b/dlls/windows.media.speech.dll/windows.media.speech_main.c
new file mode 100644
index 00000000000..63c4a71eea0
--- /dev/null
+++ b/dlls/windows.media.speech.dll/windows.media.speech_main.c
@@ -0,0 +1,442 @@
+#include <stdarg.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+#include "wine/debug.h"
+#include "activation.h"
+#include "objbase.h"
+#include "initguid.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(speech);
+
+DEFINE_GUID(IID_IInstalledVoicesStatic,0x7d526ecc,0x7533,0x4c3f,0x85,0xbe,0x88,0x8c,0x2b,0xae,0xeb,0xdc);
+DEFINE_GUID(IID_IAgileObject,0x94ea2b94,0xe9cc,0x49e0,0xc0,0xff,0xee,0x64,0xca,0x8f,0x5b,0x90);
+
+static const char *debugstr_hstring(HSTRING hstr)
+{
+    const WCHAR *str;
+    UINT32 len;
+    if (hstr && !((ULONG_PTR)hstr >> 16)) return "(invalid)";
+    str = WindowsGetStringRawBuffer(hstr, &len);
+    return wine_dbgstr_wn(str, len);
+}
+
+typedef struct IVectorView IVectorView;
+
+typedef struct IVectorViewVtbl
+{
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IVectorView *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        IVectorView *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        IVectorView *This);
+
+    /*** IInspectable methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetIids)(
+        IVectorView *This,
+        ULONG *iidCount,
+        IID **iids);
+
+    HRESULT (STDMETHODCALLTYPE *GetRuntimeClassName)(
+        IVectorView *This,
+        HSTRING *className);
+
+    HRESULT (STDMETHODCALLTYPE *GetTrustLevel)(
+        IVectorView *This,
+        TrustLevel *trustLevel);
+
+    /*** IVectorView<T> methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetAt)(
+        IVectorView *This,
+        ULONG index,
+        /* T */ void *out_value);
+
+    HRESULT (STDMETHODCALLTYPE *get_Size)(
+        IVectorView *This,
+        ULONG *out_value);
+
+    HRESULT (STDMETHODCALLTYPE *IndexOf)(
+        IVectorView *This,
+        /* T */ void *value,
+        ULONG *index,
+        BOOLEAN *out_value);
+
+    HRESULT (STDMETHODCALLTYPE *GetMany)(
+        IVectorView *This,
+        ULONG start_index,
+        /* T[] */ void **items,
+        UINT *out_value);
+} IVectorViewVtbl;
+
+struct IVectorView
+{
+    CONST_VTBL IVectorViewVtbl* lpVtbl;
+};
+
+typedef struct IInstalledVoicesStatic IInstalledVoicesStatic;
+
+typedef struct IInstalledVoicesStaticVtbl
+{
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IInstalledVoicesStatic *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        IInstalledVoicesStatic *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        IInstalledVoicesStatic *This);
+
+    /*** IInspectable methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetIids)(
+        IInstalledVoicesStatic *This,
+        ULONG *iidCount,
+        IID **iids);
+
+    HRESULT (STDMETHODCALLTYPE *GetRuntimeClassName)(
+        IInstalledVoicesStatic *This,
+        HSTRING *className);
+
+    HRESULT (STDMETHODCALLTYPE *GetTrustLevel)(
+        IInstalledVoicesStatic *This,
+        TrustLevel *trustLevel);
+
+    /*** IInstalledVoicesStatic methods ***/
+    HRESULT (STDMETHODCALLTYPE *get_AllVoices)(
+        IInstalledVoicesStatic *This,
+        /* Windows.Foundation.Collections.IVectorView<Windows.Media.SpeechSynthesis.VoiceInformation*>** */
+        void **value);
+    HRESULT (STDMETHODCALLTYPE *get_DefaultVoice)(
+        IInstalledVoicesStatic *This,
+        /* Windows.Media.SpeechSynthesis.VoiceInformation** */
+        void **value);
+
+    END_INTERFACE
+} IInstalledVoicesStaticVtbl;
+
+struct IInstalledVoicesStatic
+{
+    CONST_VTBL IInstalledVoicesStaticVtbl* lpVtbl;
+};
+
+struct windows_media_speech
+{
+    IActivationFactory IActivationFactory_iface;
+    IInstalledVoicesStatic IInstalledVoicesStatic_iface;
+    IVectorView IVectorView_iface;
+    LONG refcount;
+};
+
+static inline struct windows_media_speech *impl_from_IActivationFactory(IActivationFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_media_speech, IActivationFactory_iface);
+}
+
+static inline struct windows_media_speech *impl_from_IInstalledVoicesStatic(IInstalledVoicesStatic *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_media_speech, IInstalledVoicesStatic_iface);
+}
+
+static inline struct windows_media_speech *impl_from_IVectorView(IVectorView *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_media_speech, IVectorView_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_QueryInterface(
+        IVectorView *iface, REFIID iid, void **object)
+{
+    TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE vector_view_AddRef(
+        IVectorView *iface)
+{
+    struct windows_media_speech *impl = impl_from_IVectorView(iface);
+    ULONG rc = InterlockedIncrement(&impl->refcount);
+    TRACE("%p increasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static ULONG STDMETHODCALLTYPE vector_view_Release(
+        IVectorView *iface)
+{
+    struct windows_media_speech *impl = impl_from_IVectorView(iface);
+    ULONG rc = InterlockedDecrement(&impl->refcount);
+    TRACE("%p decreasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetIids(
+        IVectorView *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetRuntimeClassName(
+        IVectorView *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetTrustLevel(
+        IVectorView *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetAt(
+    IVectorView *iface, ULONG index, void *out_value)
+{
+    FIXME("iface %p, index %#x, out_value %p stub!\n", iface, index, out_value);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_get_Size(
+    IVectorView *iface, ULONG *out_value)
+{
+    FIXME("iface %p, out_value %p stub!\n", iface, out_value);
+    *out_value = 0;
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_IndexOf(
+    IVectorView *iface, void *value, ULONG *index, BOOLEAN *out_value)
+{
+    FIXME("iface %p, value %p, index %p, out_value %p stub!\n", iface, value, index, out_value);
+    *out_value = FALSE;
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetMany(
+    IVectorView *iface, ULONG start_index, void **items, UINT *out_value)
+{
+    FIXME("iface %p, start_index %#x, items %p, out_value %p stub!\n", iface, start_index, items, out_value);
+    *out_value = 0;
+    return S_OK;
+}
+
+static const struct IVectorViewVtbl vector_view_vtbl =
+{
+    vector_view_QueryInterface,
+    vector_view_AddRef,
+    vector_view_Release,
+    /* IInspectable methods */
+    vector_view_GetIids,
+    vector_view_GetRuntimeClassName,
+    vector_view_GetTrustLevel,
+    /*** IVectorView<T> methods ***/
+    vector_view_GetAt,
+    vector_view_get_Size,
+    vector_view_IndexOf,
+    vector_view_GetMany,
+};
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_QueryInterface(
+        IInstalledVoicesStatic *iface, REFIID iid, void **object)
+{
+    TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+
+    if (IsEqualGUID(iid, &IID_IAgileObject))
+    {
+        IUnknown_AddRef(iface);
+        *object = iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE installed_voices_static_AddRef(
+        IInstalledVoicesStatic *iface)
+{
+    struct windows_media_speech *impl = impl_from_IInstalledVoicesStatic(iface);
+    ULONG rc = InterlockedIncrement(&impl->refcount);
+    TRACE("%p increasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static ULONG STDMETHODCALLTYPE installed_voices_static_Release(
+        IInstalledVoicesStatic *iface)
+{
+    struct windows_media_speech *impl = impl_from_IInstalledVoicesStatic(iface);
+    ULONG rc = InterlockedDecrement(&impl->refcount);
+    TRACE("%p decreasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_GetIids(
+        IInstalledVoicesStatic *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_GetRuntimeClassName(
+        IInstalledVoicesStatic *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_GetTrustLevel(
+        IInstalledVoicesStatic *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_get_AllVoices(
+    IInstalledVoicesStatic *iface, void **value)
+{
+    struct windows_media_speech *impl = impl_from_IInstalledVoicesStatic(iface);
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    *value = &impl->IVectorView_iface;
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_get_DefaultVoice(
+    IInstalledVoicesStatic *iface, void **value)
+{
+    struct windows_media_speech *impl = impl_from_IInstalledVoicesStatic(iface);
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    *value = &impl->IVectorView_iface;
+    return S_OK;
+}
+
+static const struct IInstalledVoicesStaticVtbl installed_voices_static_vtbl =
+{
+    installed_voices_static_QueryInterface,
+    installed_voices_static_AddRef,
+    installed_voices_static_Release,
+    /* IInspectable methods */
+    installed_voices_static_GetIids,
+    installed_voices_static_GetRuntimeClassName,
+    installed_voices_static_GetTrustLevel,
+    /* IInstalledVoicesStatic methods */
+    installed_voices_static_get_AllVoices,
+    installed_voices_static_get_DefaultVoice,
+};
+
+static HRESULT STDMETHODCALLTYPE windows_media_speech_QueryInterface(
+        IActivationFactory *iface, REFIID iid, void **object)
+{
+    struct windows_media_speech *impl = impl_from_IActivationFactory(iface);
+    TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+
+    if (IsEqualGUID(iid, &IID_IInstalledVoicesStatic))
+    {
+        IUnknown_AddRef(iface);
+        *object = &impl->IInstalledVoicesStatic_iface;
+        return S_OK;
+    }
+
+    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE windows_media_speech_AddRef(
+        IActivationFactory *iface)
+{
+    struct windows_media_speech *impl = impl_from_IActivationFactory(iface);
+    ULONG rc = InterlockedIncrement(&impl->refcount);
+    TRACE("%p increasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static ULONG STDMETHODCALLTYPE windows_media_speech_Release(
+        IActivationFactory *iface)
+{
+    struct windows_media_speech *impl = impl_from_IActivationFactory(iface);
+    ULONG rc = InterlockedDecrement(&impl->refcount);
+    TRACE("%p decreasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_media_speech_GetIids(
+        IActivationFactory *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_media_speech_GetRuntimeClassName(
+        IActivationFactory *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_media_speech_GetTrustLevel(
+        IActivationFactory *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_media_speech_ActivateInstance(
+        IActivationFactory *iface, IInspectable **instance)
+{
+    FIXME("iface %p, instance %p stub!\n", iface, instance);
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl activation_factory_vtbl =
+{
+    windows_media_speech_QueryInterface,
+    windows_media_speech_AddRef,
+    windows_media_speech_Release,
+    /* IInspectable methods */
+    windows_media_speech_GetIids,
+    windows_media_speech_GetRuntimeClassName,
+    windows_media_speech_GetTrustLevel,
+    /* IActivationFactory methods */
+    windows_media_speech_ActivateInstance,
+};
+
+static struct windows_media_speech windows_media_speech =
+{
+    {&activation_factory_vtbl},
+    {&installed_voices_static_vtbl},
+    {&vector_view_vtbl},
+    0
+};
+
+HRESULT WINAPI DllCanUnloadNow(void)
+{
+    return S_FALSE;
+}
+
+HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, LPVOID *object)
+{
+    FIXME("clsid %s, riid %s, object %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), object);
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+HRESULT WINAPI DllGetActivationFactory(HSTRING classid, IActivationFactory **factory)
+{
+    TRACE("classid %s, factory %p.\n", debugstr_hstring(classid), factory);
+    *factory = &windows_media_speech.IActivationFactory_iface;
+    IUnknown_AddRef(*factory);
+    return S_OK;
+}
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 73d96debd6a..879c1038a95 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -731,6 +731,7 @@ HKLM,%MciExtStr%,"wvx",,"MPEGVideo"
 [Misc]
 HKLM,Software\Microsoft\WindowsRuntime\ActivatableClassId\Windows.Gaming.Input.Gamepad,"DllPath",2,"Windows.Gaming.Input.dll"
 HKLM,Software\Microsoft\WindowsRuntime\ActivatableClassId\Windows.Gaming.Input.RawGameController,"DllPath",2,"Windows.Gaming.Input.dll"
+HKLM,Software\Microsoft\WindowsRuntime\ActivatableClassId\Windows.Media.SpeechSynthesis.SpeechSynthesizer,"DllPath",2,"Windows.Media.Speech.dll"
 HKLM,Software\Borland\Database Engine\Settings\SYSTEM\INIT,SHAREDMEMLOCATION,,9000
 HKLM,Software\Clients\Mail,,2,"Native Mail Client"
 HKLM,Software\Clients\Mail\Native Mail Client,,2,"Native Mail Client"
-- 
2.28.0

From 328a4a388bbfb8a2b3d64a673a7206f5636cc3e5 Mon Sep 17 00:00:00 2001
From: Esdras Tarsis <esdrastarsis@gmail.com>
Date: Wed, 2 Sep 2020 23:41:19 -0300
Subject: [PATCH 1/3] windows.networking.connectivity: Add stub dll.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46534
Signed-off-by: Esdras Tarsis <esdrastarsis@gmail.com>
---
 configure.ac                                  |  1 +
 .../Makefile.in                               |  7 +++
 .../windows.networking.connectivity.spec      |  3 ++
 .../windows.networking.connectivity_main.c    | 54 +++++++++++++++++++
 4 files changed, 65 insertions(+)
 create mode 100644 dlls/windows.networking.connectivity.dll/Makefile.in
 create mode 100644 dlls/windows.networking.connectivity.dll/windows.networking.connectivity.spec
 create mode 100644 dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c

diff --git a/configure.ac b/configure.ac
index 3ccf9436b39..d7c4f5abf6d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3890,6 +3890,7 @@ WINE_CONFIG_MAKEFILE(dlls/windebug.dll16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecsext/tests)
 WINE_CONFIG_MAKEFILE(dlls/windows.gaming.input)
 WINE_CONFIG_MAKEFILE(dlls/windows.media.speech.dll)
+WINE_CONFIG_MAKEFILE(dlls/windows.networking.connectivity.dll)
 WINE_CONFIG_MAKEFILE(dlls/winealsa.drv)
 WINE_CONFIG_MAKEFILE(dlls/wineandroid.drv)
 WINE_CONFIG_MAKEFILE(dlls/winebus.sys)
diff --git a/dlls/windows.networking.connectivity.dll/Makefile.in b/dlls/windows.networking.connectivity.dll/Makefile.in
new file mode 100644
index 00000000000..c1b3b1b332c
--- /dev/null
+++ b/dlls/windows.networking.connectivity.dll/Makefile.in
@@ -0,0 +1,7 @@
+MODULE		= windows.networking.connectivity.dll
+IMPORTS 	= combase uuid
+
+EXTRADLLFLAGS = -mno-cygwin
+
+C_SRCS = \
+	   windows.networking.connectivity_main.c
\ No newline at end of file
diff --git a/dlls/windows.networking.connectivity.dll/windows.networking.connectivity.spec b/dlls/windows.networking.connectivity.dll/windows.networking.connectivity.spec
new file mode 100644
index 00000000000..4b286869e02
--- /dev/null
+++ b/dlls/windows.networking.connectivity.dll/windows.networking.connectivity.spec
@@ -0,0 +1,3 @@
+@ stdcall -private DllCanUnloadNow()
+@ stdcall -private DllGetActivationFactory(ptr ptr)
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
\ No newline at end of file
diff --git a/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c b/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c
new file mode 100644
index 00000000000..8737ac441bc
--- /dev/null
+++ b/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c
@@ -0,0 +1,54 @@
+#include <stdarg.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+#include "wine/debug.h"
+#include "activation.h"
+#include "objbase.h"
+#include "initguid.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(network);
+
+static const char *debugstr_hstring(HSTRING hstr)
+{
+    const WCHAR *str;
+    UINT32 len;
+    if (hstr && !((ULONG_PTR)hstr >> 16)) return "(invalid)";
+    str = WindowsGetStringRawBuffer(hstr, &len);
+    return wine_dbgstr_wn(str, len);
+}
+
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
+{
+    TRACE("(%p, %u, %p)\n", instance, reason, reserved);
+
+    switch (reason)
+    {
+    case DLL_WINE_PREATTACH:
+        return FALSE;   /* prefer native version */
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(instance);
+        break;
+    }
+
+    return TRUE;
+}
+
+HRESULT WINAPI DllCanUnloadNow(void)
+{
+    return S_FALSE;
+}
+
+HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, LPVOID *object)
+{
+    FIXME("clsid %s, riid %s, object %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), object);
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+HRESULT WINAPI DllGetActivationFactory(HSTRING classid, IActivationFactory **factory)
+{
+    FIXME("classid %s, factory %p stub!\n", debugstr_hstring(classid), factory);
+    return E_NOINTERFACE;
+}
\ No newline at end of file
-- 
2.28.0
From 221174d37d4029950f900268a7093e3d48dd078f Mon Sep 17 00:00:00 2001
From: Esdras Tarsis <esdrastarsis@gmail.com>
Date: Wed, 2 Sep 2020 23:53:28 -0300
Subject: [PATCH 2/3] windows.networking.connectivity: Implement
 IActivationFactory stubs.

Signed-off-by: Esdras Tarsis <esdrastarsis@gmail.com>
---
 .../windows.networking.connectivity_main.c    | 90 ++++++++++++++++++-
 1 file changed, 88 insertions(+), 2 deletions(-)

diff --git a/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c b/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c
index 8737ac441bc..8ed544e5644 100644
--- a/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c
+++ b/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c
@@ -20,6 +20,90 @@ static const char *debugstr_hstring(HSTRING hstr)
     return wine_dbgstr_wn(str, len);
 }
 
+struct windows_networking_connectivity
+{
+    IActivationFactory IActivationFactory_iface;
+    LONG refcount;
+};
+
+static inline struct windows_networking_connectivity *impl_from_IActivationFactory(IActivationFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_networking_connectivity, IActivationFactory_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE windows_networking_connectivity_QueryInterface(
+        IActivationFactory *iface, REFIID iid, void **object)
+{
+    TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE windows_networking_connectivity_AddRef(
+        IActivationFactory *iface)
+{
+    struct windows_networking_connectivity *impl = impl_from_IActivationFactory(iface);
+    ULONG rc = InterlockedIncrement(&impl->refcount);
+    TRACE("%p increasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static ULONG STDMETHODCALLTYPE windows_networking_connectivity_Release(
+        IActivationFactory *iface)
+{
+    struct windows_networking_connectivity *impl = impl_from_IActivationFactory(iface);
+    ULONG rc = InterlockedDecrement(&impl->refcount);
+    TRACE("%p decreasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_networking_connectivity_GetIids(
+        IActivationFactory *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_networking_connectivity_GetRuntimeClassName(
+        IActivationFactory *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_networking_connectivity_GetTrustLevel(
+        IActivationFactory *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE windows_networking_connectivity_ActivateInstance(
+        IActivationFactory *iface, IInspectable **instance)
+{
+    FIXME("iface %p, instance %p stub!\n", iface, instance);
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl activation_factory_vtbl =
+{
+    windows_networking_connectivity_QueryInterface,
+    windows_networking_connectivity_AddRef,
+    windows_networking_connectivity_Release,
+    /* IInspectable methods */
+    windows_networking_connectivity_GetIids,
+    windows_networking_connectivity_GetRuntimeClassName,
+    windows_networking_connectivity_GetTrustLevel,
+    /* IActivationFactory methods */
+    windows_networking_connectivity_ActivateInstance,
+};
+
+static struct windows_networking_connectivity windows_networking_connectivity =
+{
+    {&activation_factory_vtbl},
+    0
+};
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     TRACE("(%p, %u, %p)\n", instance, reason, reserved);
@@ -49,6 +133,8 @@ HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, LPVOID *object)
 
 HRESULT WINAPI DllGetActivationFactory(HSTRING classid, IActivationFactory **factory)
 {
-    FIXME("classid %s, factory %p stub!\n", debugstr_hstring(classid), factory);
-    return E_NOINTERFACE;
+    TRACE("classid %s, factory %p.\n", debugstr_hstring(classid), factory);
+    *factory = &windows_networking_connectivity.IActivationFactory_iface;
+    IUnknown_AddRef(*factory);
+    return S_OK;
 }
\ No newline at end of file
-- 
2.28.0
From b9e7c78901421dd486ef407a6f09c280ef2858f1 Mon Sep 17 00:00:00 2001
From: Esdras Tarsis <esdrastarsis@gmail.com>
Date: Wed, 2 Sep 2020 23:57:44 -0300
Subject: [PATCH 3/3] windows.networking.connectivity: Implement
 INetworkInformationStatics stubs.

Signed-off-by: Esdras Tarsis <esdrastarsis@gmail.com>
---
 .../windows.networking.connectivity_main.c    | 319 ++++++++++++++++++
 loader/wine.inf.in                            |   1 +
 2 files changed, 320 insertions(+)

diff --git a/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c b/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c
index 8ed544e5644..b8507acf558 100644
--- a/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c
+++ b/dlls/windows.networking.connectivity.dll/windows.networking.connectivity_main.c
@@ -20,9 +20,127 @@ static const char *debugstr_hstring(HSTRING hstr)
     return wine_dbgstr_wn(str, len);
 }
 
+DEFINE_GUID(IID_INetworkInformationStatics,0x5074f851,0x950d,0x4165,0x9c,0x15,0x36,0x56,0x19,0x48,0x1e,0xea);
+
+typedef struct EventRegistrationToken
+{
+    __int64 value;
+} EventRegistrationToken;
+
+typedef struct IVectorView IVectorView;
+
+typedef struct IVectorViewVtbl
+{
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IVectorView *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        IVectorView *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        IVectorView *This);
+
+    /*** IInspectable methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetIids)(
+        IVectorView *This,
+        ULONG *iidCount,
+        IID **iids);
+
+    HRESULT (STDMETHODCALLTYPE *GetRuntimeClassName)(
+        IVectorView *This,
+        HSTRING *className);
+
+    HRESULT (STDMETHODCALLTYPE *GetTrustLevel)(
+        IVectorView *This,
+        TrustLevel *trustLevel);
+
+    /*** IVectorView<T> methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetAt)(
+        IVectorView *This,
+        ULONG index,
+        /* T */ void *out_value);
+
+    HRESULT (STDMETHODCALLTYPE *get_Size)(
+        IVectorView *This,
+        ULONG *out_value);
+
+    HRESULT (STDMETHODCALLTYPE *IndexOf)(
+        IVectorView *This,
+        /* T */ void *value,
+        ULONG *index,
+        BOOLEAN *out_value);
+
+    HRESULT (STDMETHODCALLTYPE *GetMany)(
+        IVectorView *This,
+        ULONG start_index,
+        /* T[] */ void **items,
+        UINT *out_value);
+} IVectorViewVtbl;
+
+struct IVectorView
+{
+    CONST_VTBL IVectorViewVtbl* lpVtbl;
+};
+
+typedef struct INetworkInformationStatics INetworkInformationStatics;
+
+typedef struct INetworkInformationStaticsVtbl
+{
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        INetworkInformationStatics *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        INetworkInformationStatics *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        INetworkInformationStatics *This);
+
+    /*** IInspectable methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetIids)(
+        INetworkInformationStatics *This,
+        ULONG *iidCount,
+        IID **iids);
+
+    HRESULT (STDMETHODCALLTYPE *GetRuntimeClassName)(
+        INetworkInformationStatics *This,
+        HSTRING *className);
+
+    HRESULT (STDMETHODCALLTYPE *GetTrustLevel)(
+        INetworkInformationStatics *This,
+        TrustLevel *trustLevel);
+
+    /*** INetworkInformationStatics methods ***/
+    HRESULT (STDMETHODCALLTYPE *eventadd_NetworkStatusChanged)(
+        INetworkInformationStatics *This,
+        /* Windows.Foundation.EventHandler<Windows.Networking.Connectivity.NetworkInformation*> */
+        void *value,
+        EventRegistrationToken* token);
+
+    HRESULT (STDMETHODCALLTYPE *eventremove_NetworkStatusChanged)(
+        INetworkInformationStatics *This,
+        EventRegistrationToken token);
+
+    END_INTERFACE
+} INetworkInformationStaticsVtbl;
+
+struct INetworkInformationStatics
+{
+    CONST_VTBL INetworkInformationStaticsVtbl* lpVtbl;
+};
+
 struct windows_networking_connectivity
 {
     IActivationFactory IActivationFactory_iface;
+    INetworkInformationStatics INetworkInformationStatics_iface;
+    IVectorView IVectorView_iface;
     LONG refcount;
 };
 
@@ -31,10 +149,209 @@ static inline struct windows_networking_connectivity *impl_from_IActivationFacto
     return CONTAINING_RECORD(iface, struct windows_networking_connectivity, IActivationFactory_iface);
 }
 
+static inline struct windows_networking_connectivity *impl_from_INetworkInformationStatics(INetworkInformationStatics *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_networking_connectivity, INetworkInformationStatics_iface);
+}
+
+static inline struct windows_networking_connectivity *impl_from_IVectorView(IVectorView *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_networking_connectivity, IVectorView_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_QueryInterface(
+        IVectorView *iface, REFIID iid, void **object)
+{
+    TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+    IUnknown_AddRef(iface);
+    *object = iface;
+    return S_OK;
+}
+
+static ULONG STDMETHODCALLTYPE vector_view_AddRef(
+        IVectorView *iface)
+{
+    struct windows_networking_connectivity *impl = impl_from_IVectorView(iface);
+    ULONG rc = InterlockedIncrement(&impl->refcount);
+    TRACE("%p increasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static ULONG STDMETHODCALLTYPE vector_view_Release(
+        IVectorView *iface)
+{
+    struct windows_networking_connectivity *impl = impl_from_IVectorView(iface);
+    ULONG rc = InterlockedDecrement(&impl->refcount);
+    TRACE("%p decreasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetIids(
+        IVectorView *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetRuntimeClassName(
+        IVectorView *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetTrustLevel(
+        IVectorView *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetAt(
+    IVectorView *iface, ULONG index, void *out_value)
+{
+    FIXME("iface %p, index %#x, out_value %p stub!\n", iface, index, out_value);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_get_Size(
+    IVectorView *iface, ULONG *out_value)
+{
+    FIXME("iface %p, out_value %p stub!\n", iface, out_value);
+    *out_value = 0;
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_IndexOf(
+    IVectorView *iface, void *value, ULONG *index, BOOLEAN *out_value)
+{
+    FIXME("iface %p, value %p, index %p, out_value %p stub!\n", iface, value, index, out_value);
+    *out_value = FALSE;
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_GetMany(
+    IVectorView *iface, ULONG start_index, void **items, UINT *out_value)
+{
+    FIXME("iface %p, start_index %#x, items %p, out_value %p stub!\n", iface, start_index, items, out_value);
+    *out_value = 0;
+    return S_OK;
+}
+
+static const struct IVectorViewVtbl vector_view_vtbl =
+{
+    vector_view_QueryInterface,
+    vector_view_AddRef,
+    vector_view_Release,
+    /* IInspectable methods */
+    vector_view_GetIids,
+    vector_view_GetRuntimeClassName,
+    vector_view_GetTrustLevel,
+    /*** IVectorView<T> methods ***/
+    vector_view_GetAt,
+    vector_view_get_Size,
+    vector_view_IndexOf,
+    vector_view_GetMany,
+};
+
+static HRESULT STDMETHODCALLTYPE network_information_statics_QueryInterface(
+        INetworkInformationStatics *iface, REFIID iid, void **object)
+{
+    TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+
+    if (IsEqualGUID(iid, &IID_IAgileObject))
+    {
+        IUnknown_AddRef(iface);
+        *object = iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE network_information_statics_AddRef(
+        INetworkInformationStatics *iface)
+{
+    struct windows_networking_connectivity *impl = impl_from_INetworkInformationStatics(iface);
+    ULONG rc = InterlockedIncrement(&impl->refcount);
+    TRACE("%p increasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static ULONG STDMETHODCALLTYPE network_information_statics_Release(
+        INetworkInformationStatics *iface)
+{
+    struct windows_networking_connectivity *impl = impl_from_INetworkInformationStatics(iface);
+    ULONG rc = InterlockedDecrement(&impl->refcount);
+    TRACE("%p decreasing refcount to %u.\n", impl, rc);
+    return rc;
+}
+
+static HRESULT STDMETHODCALLTYPE network_information_statics_GetIids(
+        INetworkInformationStatics *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE network_information_statics_GetRuntimeClassName(
+        INetworkInformationStatics *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE network_information_statics_GetTrustLevel(
+        INetworkInformationStatics *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE network_information_statics_eventadd_NetworkStatusChanged(
+    INetworkInformationStatics *iface, void *value, EventRegistrationToken* token)
+{
+    FIXME("iface %p, value %p, token %p stub!\n", iface, value, token);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE network_information_statics_eventremove_NetworkStatusChanged(
+    INetworkInformationStatics *iface, EventRegistrationToken token)
+{
+    FIXME("iface %p, token %#I64x stub!\n", iface, token.value);
+    return S_OK;
+}
+
+static const struct INetworkInformationStaticsVtbl network_information_statics_vtbl =
+{
+    network_information_statics_QueryInterface,
+    network_information_statics_AddRef,
+    network_information_statics_Release,
+    /* IInspectable methods */
+    network_information_statics_GetIids,
+    network_information_statics_GetRuntimeClassName,
+    network_information_statics_GetTrustLevel,
+    /* INetworkInformationStatics methods */
+    network_information_statics_eventadd_NetworkStatusChanged,
+    network_information_statics_eventremove_NetworkStatusChanged,
+};
+
 static HRESULT STDMETHODCALLTYPE windows_networking_connectivity_QueryInterface(
         IActivationFactory *iface, REFIID iid, void **object)
 {
+    struct windows_networking_connectivity *impl = impl_from_IActivationFactory(iface);
     TRACE("iface %p, iid %s, object %p stub!\n", iface, debugstr_guid(iid), object);
+
+    if (IsEqualGUID(iid, &IID_INetworkInformationStatics))
+    {
+        IUnknown_AddRef(iface);
+        *object = &impl->INetworkInformationStatics_iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
     *object = NULL;
     return E_NOINTERFACE;
 }
@@ -101,6 +418,8 @@ static const struct IActivationFactoryVtbl activation_factory_vtbl =
 static struct windows_networking_connectivity windows_networking_connectivity =
 {
     {&activation_factory_vtbl},
+    {&network_information_statics_vtbl},
+    {&vector_view_vtbl},
     0
 };
 
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 164d9f3df61..d3bae5ee3ce 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -732,6 +732,7 @@ HKLM,%MciExtStr%,"wvx",,"MPEGVideo"
 HKLM,Software\Microsoft\WindowsRuntime\ActivatableClassId\Windows.Gaming.Input.Gamepad,"DllPath",2,"Windows.Gaming.Input.dll"
 HKLM,Software\Microsoft\WindowsRuntime\ActivatableClassId\Windows.Gaming.Input.RawGameController,"DllPath",2,"Windows.Gaming.Input.dll"
 HKLM,Software\Microsoft\WindowsRuntime\ActivatableClassId\Windows.Media.SpeechSynthesis.SpeechSynthesizer,"DllPath",2,"Windows.Media.Speech.dll"
+HKLM,Software\Microsoft\WindowsRuntime\ActivatableClassId\Windows.Networking.Connectivity.NetworkInformation,"DllPath",2,"Windows.Networking.Connectivity.dll"
 HKLM,Software\Borland\Database Engine\Settings\SYSTEM\INIT,SHAREDMEMLOCATION,,9000
 HKLM,Software\Clients\Mail,,2,"Native Mail Client"
 HKLM,Software\Clients\Mail\Native Mail Client,,2,"Native Mail Client"
-- 
2.28.0
