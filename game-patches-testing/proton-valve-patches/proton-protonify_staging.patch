From aa88eb017be4c3615d0f8aab8a2e16769a6568ad Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 27 Dec 2017 13:31:59 -0600
Subject: [PATCH] loader: Set up Steam stuff in the registry

---
 loader/wine.inf.in | 19 ++++++++++++++++---
 1 file changed, 16 insertions(+), 3 deletions(-)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 5767b29887c..75d5f4a7216 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -75,7 +75,8 @@ AddReg=\
     Tapi,\
     Timezones,\
     VersionInfo,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient
 
 [DefaultInstall.ntamd64]
 RegisterDlls=RegisterDllsSection
@@ -103,7 +104,8 @@ AddReg=\
     Tapi,\
     Timezones,\
     VersionInfo.ntamd64,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient.ntamd64
 
 [Wow64Install]
 RegisterDlls=RegisterDllsSection
@@ -118,7 +120,8 @@ AddReg=\
     Misc,\
     Tapi,\
     VersionInfo.ntamd64,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient.ntamd64
 
 [DefaultInstall.Services]
 AddService=BITS,0,BITSService
@@ -3750,6 +3750,16 @@ HKLM,Software\Wine\LicenseInformation,"Shell-InBoxGames-Solitaire-EnableGame",0x
 HKLM,Software\Wine\LicenseInformation,"Shell-InBoxGames-SpiderSolitaire-EnableGame",0x10001,0x00000001
 HKLM,Software\Wine\LicenseInformation,"Shell-PremiumInBoxGames-Chess-EnableGame",0x10001,0x00000001
 
+[SteamClient]
+HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16422%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16422%\Steam"
+
+[SteamClient.ntamd64]
+HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"
+
 [DestinationDirs]
 l_intl_section = 11
 inf_section = 17

From bc614834ee153ce33449c06e697b4a30748e9257 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 27 Apr 2017 13:25:04 -0500
Subject: [PATCH] HACK kernelbase: Substitute the current pid for the Steam
 client pid

---
 dlls/kernelbase/process.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 85e0042024c..9c957f02c06 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -220,6 +220,22 @@ HANDLE WINAPI DECLSPEC_HOTPATCH OpenProcess( DWORD access, BOOL inherit, DWORD id )
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
 
+    if(id == 0xfffe)
+        /* STEAMOS HACK:
+         * On Windows, the Steam client puts its process ID into the registry
+         * at:
+         *
+         *   [HKCU\Software\Valve\Steam\ActiveProcess]
+         *   PID=dword:00000008
+         *
+         * Games get that pid from the registry and then query it with
+         * OpenProcess to ensure Steam is running. Since we aren't running the
+         * Windows Steam in Wine, instead we hack this magic number into the
+         * registry and then substitute the game's process itself in its place
+         * so it can query a valid process.
+         */
+        id = GetCurrentProcessId();
+
     cid.UniqueProcess = ULongToHandle(id);
     cid.UniqueThread  = 0;
 
From a277e32030a31abe90af9d38462f1159bc94b7b0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 11 May 2017 10:50:08 -0500
Subject: [PATCH] HACK: kernel32: Swap requests for steamclient.dll with
 lsteamclient

---
 dlls/kernel32/module.c | 63 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 118829895b7..cf3a0b5ed98 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -76,6 +76,23 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
+static HMODULE steamclient_hmod = NULL;
+static HMODULE lsteamclient_hmod = NULL;
+
+static WCHAR *strcasestrW( const WCHAR *str, const WCHAR *sub )
+{
+    while (*str)
+    {
+        const WCHAR *p1 = str, *p2 = sub;
+        while (*p1 && *p2 && tolowerW(*p1) == tolowerW(*p2)) { p1++; p2++; }
+        if (!*p2) return (WCHAR *)str;
+        str++;
+    }
+    return NULL;
+}
+
 /****************************************************************************
  *              GetDllDirectoryA   (KERNEL32.@)
  */
@@ -710,6 +727,10 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
     else
     {
         UNICODE_STRING wstr;
+        if(steamclient_hmod != NULL && strcasestrW(name, steamclientW)){
+            *module = steamclient_hmod;
+            return TRUE;
+        }
         RtlInitUnicodeString( &wstr, name );
         status = LdrGetDllHandle( NULL, 0, &wstr, &ret );
     }
@@ -818,6 +839,11 @@ DWORD WINAPI GetModuleFileNameW( HMODULE hModule, LPWSTR lpFileName, DWORD size
     NTSTATUS nts;
     WIN16_SUBSYSTEM_TIB *win16_tib;
 
+    if(steamclient_hmod != NULL && hModule == steamclient_hmod){
+        memcpy(lpFileName, steamclient_pathW, sizeof(steamclient_pathW));
+        return sizeof(steamclient_pathW)/sizeof(WCHAR);
+    }
+
     if (!hModule && ((win16_tib = NtCurrentTeb()->Tib.SubSystemTib)) && win16_tib->exe_name)
     {
         len = min(size, win16_tib->exe_name->Length / sizeof(WCHAR));
@@ -1194,6 +1220,7 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     NTSTATUS nts;
     HMODULE hModule;
     WCHAR *load_path;
+    const WCHAR *p;
     const DWORD load_library_search_flags = (LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR |
                                              LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
                                              LOAD_LIBRARY_SEARCH_USER_DIRS |
@@ -1207,6 +1234,36 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     if( flags & unsupported_flags)
         FIXME("unsupported flag(s) used (flags: 0x%08x)\n", flags);
 
+    if((p = strcasestrW(libname->Buffer, steamclientW)) &&
+            (p == libname->Buffer ||
+             *(p - 1) != 'l')){
+
+        if(!lsteamclient_hmod)
+            lsteamclient_hmod = LoadLibraryA("lsteamclient.dll");
+
+        if(!steamclient_hmod){
+            HANDLE f = CreateFileW(steamclient_pathW,
+                    GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                    NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+            if(f != INVALID_HANDLE_VALUE){
+                DWORD sz, readed;
+
+                sz = GetFileSize(f, NULL);
+
+                steamclient_hmod = HeapAlloc(GetProcessHeap(), 0, sz);
+                ReadFile(f, steamclient_hmod, sz, &readed, NULL);
+
+                CloseHandle(f);
+            }else{
+                /* this will fail DRM checks, but otherwise should work */
+                ERR("somehow failed to load steamclient\n");
+                steamclient_hmod = lsteamclient_hmod;
+            }
+        }
+
+        return steamclient_hmod;
+    }
+
     if (flags & load_library_search_flags)
         load_path = get_dll_load_path_search_flags( libname->Buffer, flags );
     else
@@ -1362,6 +1419,9 @@ BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary(HINSTANCE hLibModule)
         return FALSE;
     }
 
+    if(steamclient_hmod != NULL && hLibModule == steamclient_hmod)
+        return TRUE;
+
     if ((ULONG_PTR)hLibModule & 3) /* this is a datafile module */
     {
         if ((ULONG_PTR)hLibModule & 1)
@@ -1410,6 +1470,9 @@ FARPROC get_proc_address( HMODULE hModule, LPCSTR function )
 
     if (!hModule) hModule = NtCurrentTeb()->Peb->ImageBaseAddress;
 
+    if(steamclient_hmod != NULL && hModule == steamclient_hmod)
+        hModule = lsteamclient_hmod;
+
     if ((ULONG_PTR)function >> 16)
     {
         ANSI_STRING     str;

From acda0915ca65ea7e818fbb89bae14894602cf845 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 5 Jun 2017 14:41:28 -0500
Subject: [PATCH] HACK: kernel32: Load hard-coded Steam.dll path if relative
 load fails

Some games (Call of Duty is one example) try to just
LoadLibrary("Steam.dll") with no path. If that fails, it complains
"Failed to find Steam". This works on Windows because Steam sets the
PATH environment variable to include <C:\Program Files\Steam\>, which is
where Steam.dll lives, before launching the game. However, the Linux
Steam obviously doesn't do that. For this reason, we place Steam.dll in
there and this hack loads it correctly for the games.

TODO: is this enough? Should we put that path into PATH like on Windows,
in case it tries to load other binaries?
---
 dlls/kernel32/module.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index cf3a0b5ed98..6ca438d3ae2 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -77,6 +77,8 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
+static const WCHAR full_steamdllW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','S','t','e','a','m','.','d','l','l',0};
 static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
@@ -1302,6 +1304,12 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     }
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
+
+    if(!hModule && !strcmpiW(libname->Buffer, steamdllW))
+        /* tried and failed to load Steam.dll from PATH. try again
+         * with known-good path */
+        return LoadLibraryW(full_steamdllW);
+
     return hModule;
 }
 
From 183eac81ab4739735c4f49d25c1384d98f17655d Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 9 Jun 2017 10:31:27 -0500
Subject: [PATCH] HACK: kernel32: Return steamclient instead of lsteamclient
 during GetModuleHandleEx

Found a game which passes the result from GetProcAddress to this. Ugh.
---
 dlls/kernel32/module.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 6ca438d3ae2..a1a2b0e100c 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -725,6 +725,8 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
     {
         void *dummy;
         if (!(ret = RtlPcToFileHeader( (void *)name, &dummy ))) status = STATUS_DLL_NOT_FOUND;
+        if(steamclient_hmod != NULL && ret == lsteamclient_hmod)
+            ret = steamclient_hmod;
     }
     else
     {

From 3835eee939a9e8c6a8f29733307a8531053a3616 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 13 Jun 2017 12:35:56 -0500
Subject: [PATCH] HACK: kernel32: Put Steam program files dir into PATH

---
 dlls/kernel32/module.c | 23 +++++++++++++++++------
 1 file changed, 17 insertions(+), 6 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index a1a2b0e100c..ef0295081c8 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -78,7 +78,7 @@ static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
 static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
-static const WCHAR full_steamdllW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','S','t','e','a','m','.','d','l','l',0};
+static const DWORD steamdllW_len = 9;
 static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
@@ -890,12 +890,18 @@ static const WCHAR *get_dll_system_path(void)
 
     if (!cached_path)
     {
+        static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m',0};
+        static const DWORD steamProgramPathW_len = 22;
         WCHAR *p, *path;
-        int len = 1;
+        int len = 2;
 
+        len += steamProgramPathW_len;
         len += 2 * GetSystemDirectoryW( NULL, 0 );
         len += GetWindowsDirectoryW( NULL, 0 );
         p = path = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );
+        strcpyW(p, steamProgramPathW);
+        p += steamProgramPathW_len;
+        *p++ = ';';
         GetSystemDirectoryW( p, path + len - p);
         p += strlenW(p);
         /* if system directory ends in "32" add 16-bit version too */
@@ -1307,10 +1313,15 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
 
-    if(!hModule && !strcmpiW(libname->Buffer, steamdllW))
-        /* tried and failed to load Steam.dll from PATH. try again
-         * with known-good path */
-        return LoadLibraryW(full_steamdllW);
+    if(!hModule){
+        DWORD len = lstrlenW(libname->Buffer);
+        if(len > steamdllW_len &&
+                !strcmpiW(libname->Buffer + len - steamdllW_len, steamdllW)){
+            /* tried and failed to load some path ending in Steam.dll. try
+             * again without hard-coded path */
+            return LoadLibraryW(steamdllW);
+        }
+    }
 
     return hModule;
 }

From a2f9e2806acdd83aa9121baea4a8a908e2a9e909 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 28 Dec 2017 09:43:36 -0600
Subject: [PATCH] kernel32: Support steamclient64

---
 dlls/kernel32/module.c | 11 ++++++++---
 loader/wine.inf.in     |  1 +
 2 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index ef0295081c8..32f9ddf6718 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -76,10 +76,17 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+#if defined(__x86_64__)
+static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t','6','4',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','6','4','.','d','l','l',0};
+#else
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};
+#endif
+static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m',0};
+static const DWORD steamProgramPathW_len = 28;
 static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
 static const DWORD steamdllW_len = 9;
-static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
 
@@ -890,8 +897,6 @@ static const WCHAR *get_dll_system_path(void)
 
     if (!cached_path)
     {
-        static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m',0};
-        static const DWORD steamProgramPathW_len = 22;
         WCHAR *p, *path;
         int len = 2;
 
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 75d5f4a7216..7fe2f49dcd9 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3758,6 +3758,7 @@ HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16422%\Steam"
 [SteamClient.ntamd64]
 HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll64",,"%16426%\Steam\steamclient64.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"
 
 [DestinationDirs]

From bf02d103fde2c2e54a074b03021f47e4672d4b01 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 5 Nov 2018 18:45:57 +0300
Subject: [PATCH] Add missing InstallPath registry value.

So UPlay won't try to install Steam.
---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 5610c701d..3d71722ac 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3760,6 +3760,7 @@ HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll64",,"%16426%\Steam\steamclient64.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"
+HKLM,Software\Wow6432Node\Valve\Steam,"InstallPath",,"%16422%\Steam"
 
 [DestinationDirs]
 l_intl_section = 11

From bac899cd4531229baa7633d67578b74a2a98468f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 19 Mar 2018 11:34:35 -0500
Subject: [PATCH] kernel32: Don't force-load Steam.dll

This must fail for older DRM which walks up the FS tree searching for
Steam.dll to work correctly.
---
 dlls/kernel32/module.c | 10 ----------
 1 file changed, 10 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 32f9ddf6718..342e408b555 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -1318,16 +1318,6 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
 
-    if(!hModule){
-        DWORD len = lstrlenW(libname->Buffer);
-        if(len > steamdllW_len &&
-                !strcmpiW(libname->Buffer + len - steamdllW_len, steamdllW)){
-            /* tried and failed to load some path ending in Steam.dll. try
-             * again without hard-coded path */
-            return LoadLibraryW(steamdllW);
-        }
-    }
-
     return hModule;
 }
 
From 7bd039f34f5fc1123524ddb22769f6e16e7d9c88 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 11 May 2017 10:01:16 -0500
Subject: [PATCH] HACK: ws2_32: Fake success when trying to bind to an IPX
 address

---
 dlls/ws2_32/socket.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 164a48ce751..b9248c9bd5e 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3332,6 +3332,13 @@ int WINAPI WS_bind(SOCKET s, const struct WS_sockaddr* name, int namelen)
                     else if (interface_bind(s, fd, &uaddr.addr))
                         in4->sin_addr.s_addr = htonl(INADDR_ANY);
                 }
+
+                if(name->sa_family ==  WS_AF_IPX){
+                    /* Quake (and similar family) fails if we can't bind to an IPX address. This often
+                     * doesn't work on Linux, so just fake success. */
+                    return 0;
+                }
+
                 if (bind(fd, &uaddr.addr, uaddrlen) < 0)
                 {
                     int loc_errno = errno;

From 819b923a3b761944b094f5f20b881c501a522f20 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 19 Jan 2018 14:01:07 -0600
Subject: [PATCH] HACK: advapi32: Use steamuser as Wine username

---
 dlls/advapi32/advapi.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/advapi32/advapi.c b/dlls/advapi32/advapi.c
index 1c528ef7419..87792f4fbc9 100644
--- a/dlls/advapi32/advapi.c
+++ b/dlls/advapi32/advapi.c
@@ -84,7 +84,7 @@ GetUserNameA( LPSTR lpszName, LPDWORD lpSize )
 BOOL WINAPI
 GetUserNameW( LPWSTR lpszName, LPDWORD lpSize )
 {
-    const char *name = wine_get_user_name();
+    const char *name = "steamuser"/*wine_get_user_name()*/;
     DWORD i, len = MultiByteToWideChar( CP_UNIXCP, 0, name, -1, NULL, 0 );
     LPWSTR backslash;
 
From ec9e7190ea7045012b6e33e5ee64cd678bec68c9 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 22 Jan 2018 14:32:40 -0600
Subject: [PATCH] HACK: shell32: Never create links to the user's home dirs

---
 dlls/shell32/shellpath.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/dlls/shell32/shellpath.c b/dlls/shell32/shellpath.c
index f08474b3635..2f637f25537 100644
--- a/dlls/shell32/shellpath.c
+++ b/dlls/shell32/shellpath.c
@@ -4424,6 +4424,7 @@ static void _SHCreateSymbolicLinks(void)
     pszPersonal = wine_get_unix_file_name(wszTempPath);
     if (!pszPersonal) return;
 
+#if 0
     hr = XDG_UserDirLookup(xdg_dirs, num, &xdg_results);
     if (FAILED(hr)) xdg_results = NULL;
 
@@ -4477,6 +4478,7 @@ static void _SHCreateSymbolicLinks(void)
     }
     else
     {
+#endif
         /* '$HOME' doesn't exist. Create 'My Pictures', 'My Videos' and 'My Music' subdirs
          * in '%USERPROFILE%\\My Documents' or fail silently if they already exist. */
         pszHome = NULL;
@@ -4486,8 +4488,11 @@ static void _SHCreateSymbolicLinks(void)
             if (_SHAppendToUnixPath(szMyStuffTarget, MAKEINTRESOURCEW(aidsMyStuff[i])))
                 mkdir(szMyStuffTarget, 0777);
         }
+#if 0
     }
+#endif
 
+#if 0
     /* Create symbolic links for 'My Pictures', 'My Videos' and 'My Music'. */
     for (i=0; i < ARRAY_SIZE(aidsMyStuff); i++)
     {
@@ -4532,13 +4537,17 @@ static void _SHCreateSymbolicLinks(void)
         symlink(szMyStuffTarget, pszMyStuff);
         heap_free(pszMyStuff);
     }
+#endif
 
+#if 0
     /* Last but not least, the Desktop folder */
     if (pszHome)
         strcpy(szDesktopTarget, pszHome);
     else
         strcpy(szDesktopTarget, pszPersonal);
+#endif
     heap_free(pszPersonal);
+#if 0
 
     xdg_desktop_dir = xdg_results ? xdg_results[num - 1] : NULL;
     if (xdg_desktop_dir ||
@@ -4565,6 +4574,7 @@ static void _SHCreateSymbolicLinks(void)
             heap_free(xdg_results[i]);
         heap_free(xdg_results);
     }
+#endif
 }
 
 /******************************************************************************

From d012d137e4099d1b12079a49a8a5632d205e0a9f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 24 Sep 2018 12:37:49 -0500
Subject: [PATCH] HACK: dbghelp: Disable DWARF parsing

Patch by Zeb. Our DWARF parser has been known to crash winedbg in some
cases. Since probably no concerned parties are going to be using plain
winedbg, just don't bother parsing anything.
---
 dlls/dbghelp/dwarf.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/dbghelp/dwarf.c b/dlls/dbghelp/dwarf.c
index 31c008abb8f..ce689dbe6cf 100644
--- a/dlls/dbghelp/dwarf.c
+++ b/dlls/dbghelp/dwarf.c
@@ -3516,6 +3516,11 @@ BOOL dwarf2_parse(struct module* module, unsigned long load_offset,
     BOOL                ret = TRUE;
     struct module_format* dwarf2_modfmt;
 
+/* Our DWARF parser has been known to crash winedbg in some cases. Since
+ * probably no concerned parties are going to be using plain winedbg, just don't
+ * bother parsing anything. */
+return FALSE;
+
     dwarf2_init_section(&eh_frame,                fmap, ".eh_frame",     NULL,             &eh_frame_sect);
     dwarf2_init_section(&section[section_debug],  fmap, ".debug_info",   ".zdebug_info",   &debug_sect);
     dwarf2_init_section(&section[section_abbrev], fmap, ".debug_abbrev", ".zdebug_abbrev", &debug_abbrev_sect);

From a13270aea50af90aa6c721080b956870d67d81c2 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 30 Mar 2018 10:40:43 -0500
Subject: [PATCH] winedbg: When crash dialog is not shown, dump crash info to
 stderr

This way the backtrace and such will appear in the log file instead of
going to stdout, which we don't capture.
---
 programs/winedbg/tgt_active.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/programs/winedbg/tgt_active.c b/programs/winedbg/tgt_active.c
index f632ca0414d..72e63327831 100644
--- a/programs/winedbg/tgt_active.c
+++ b/programs/winedbg/tgt_active.c
@@ -874,6 +874,9 @@ enum dbg_start dbg_active_auto(int argc, char* argv[])
         if (event) thread = display_crash_details( event );
         if (thread) dbg_houtput = output = create_temp_file();
         break;
+    case TRUE:
+        dbg_houtput = GetStdHandle(STD_ERROR_HANDLE);
+        break;
     }
 
     input = parser_generate_command_file("echo Modules:", "info share",

From 1091eaf13692b16ed66328ceeebfc587075fec6c Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 25 Oct 2018 12:50:45 -0500
Subject: [PATCH] HACK: wined3d: Fake an AMD card in place of Nvidia cards

Some games assume they can load the nvapi library if the hardware is an
nvidia card. This obviously fails in Wine. So fake that all nvidia
hardware is actually an AMD card, so they don't try to load nvapi.
---
 dlls/wined3d/adapter_gl.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index b8a2060cf46..8259d92ebac 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -1009,6 +1009,14 @@ static const struct wined3d_gpu_description *query_gpu_description(const struct
         vendor = wined3d_settings.pci_vendor_id;
         TRACE("Overriding vendor PCI ID with 0x%04x.\n", vendor);
     }
+    else if(vendor == HW_VENDOR_NVIDIA)
+    {
+        /* XXX: Fake having an AMD card in order to avoid games trying to load
+         * the Windows-only nvapi library. */
+        WARN("Nvidia card detected. Faking an AMD RX 480!\n");
+        vendor = HW_VENDOR_AMD;
+        device = CARD_AMD_RADEON_RX_480;
+    }
 
     if (wined3d_settings.pci_device_id != PCI_DEVICE_NONE)
     {

From 29a2c4f1b8cad98e94c67e4c068d9096969074ee Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 20 Aug 2018 10:58:09 -0500
Subject: [PATCH] secur32: Return real Unix username from
 GetUserNameEx(NameDisplay)

---
 dlls/secur32/secur32.c | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/dlls/secur32/secur32.c b/dlls/secur32/secur32.c
index ec189fda104..1c662adf44b 100644
--- a/dlls/secur32/secur32.c
+++ b/dlls/secur32/secur32.c
@@ -34,6 +34,7 @@
 #include "thunks.h"
 #include "lmcons.h"
 
+#include "wine/library.h"
 #include "wine/list.h"
 #include "wine/debug.h"
 #include "wine/unicode.h"
@@ -1201,9 +1202,25 @@ BOOLEAN WINAPI GetUserNameExW(
             return FALSE;
         }
 
+    case NameDisplay:
+        {
+            const char *name = wine_get_user_name();
+            DWORD len = MultiByteToWideChar( CP_UNIXCP, 0, name, -1, NULL, 0 );
+
+            if (len > *nSize)
+            {
+                SetLastError( ERROR_MORE_DATA );
+                *nSize = len;
+                return FALSE;
+            }
+
+            *nSize = len - 1;
+            MultiByteToWideChar( CP_UNIXCP, 0, name, -1, lpNameBuffer, len );
+            return TRUE;
+        }
+
     case NameUnknown:
     case NameFullyQualifiedDN:
-    case NameDisplay:
     case NameUniqueId:
     case NameCanonical:
     case NameUserPrincipal:


From 63f934962cb97d69ed71604985716e7479f822b1 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 23 Oct 2018 16:18:20 +0300
Subject: [PATCH] wine.inf: Add font registry entries.

---
 loader/wine.inf.in | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 1f94c38d0c6..df2b43d9106 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -181,6 +181,7 @@ CurrentVersion="Software\Microsoft\Windows\CurrentVersion"
 CurrentVersionNT="Software\Microsoft\Windows NT\CurrentVersion"
 FontSubStr="Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes"
 Control="System\CurrentControlSet\Control"
+FontsNT="Software\Microsoft\Windows NT\CurrentVersion\Fonts"
 
 [Classes]
 HKCR,.chm,,2,"chm.file"
@@ -614,6 +615,10 @@ HKLM,%FontSubStr%,"Times New Roman CYR,204",,"Times New Roman,204"
 HKLM,%FontSubStr%,"Times New Roman Greek,161",,"Times New Roman,161"
 HKLM,%FontSubStr%,"Times New Roman TUR,162",,"Times New Roman,162"
 HKLM,System\CurrentControlSet\Hardware Profiles\Current\Software\Fonts,"LogPixels",0x10003,0x00000060
+HKLM,%FontsNT%,"Arial (TrueType)",,"arial.ttf"
+HKLM,%FontsNT%,"Arial Bold (TrueType)",,"arialbd.ttf"
+HKLM,%FontsNT%,"Times New Roman (TrueType)",,"times.ttf"
+HKLM,%FontsNT%,"Courier New (TrueType)",,"cour.ttf"
 
 [MCI]
 HKLM,%Mci32Str%,"AVIVideo",,"mciavi32.dll"
     
From 174d487bf8ef5bec22c3663f50a276ae59d0a931 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 30 Oct 2018 13:04:06 -0500
Subject: [PATCH] wine.inf: Substitute Times New Roman for Palatino Linotype

For AOE2HD launcher.
---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index df2b43d9106..44ce3cd6639 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -619,6 +619,7 @@ HKLM,%FontsNT%,"Arial (TrueType)",,"arial.ttf"
 HKLM,%FontsNT%,"Arial Bold (TrueType)",,"arialbd.ttf"
 HKLM,%FontsNT%,"Times New Roman (TrueType)",,"times.ttf"
 HKLM,%FontsNT%,"Courier New (TrueType)",,"cour.ttf"
+HKCU,Software\Wine\Fonts\Replacements,"Palatino Linotype",,"Times New Roman"
 
 [MCI]
 HKLM,%Mci32Str%,"AVIVideo",,"mciavi32.dll"

From aa7fa7ce94bd4e49e3843a8ea398d29882518e43 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 6 Aug 2018 08:06:03 -0500
Subject: [PATCH] server: Set default timeout to 0

The Steam client will be waiting for the wineserver to exit to set up
some environment variables, so make it wait as short as possible.
---
 server/main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/main.c b/server/main.c
index 20d3c48c4d9..aca8738c4c0 100644
--- a/server/main.c
+++ b/server/main.c
@@ -42,7 +42,7 @@
 /* command-line options */
 int debug_level = 0;
 int foreground = 0;
-timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
+timeout_t master_socket_timeout = 0; /* master socket timeout, default is 3 seconds */
 const char *server_argv0;
 
 /* parse-line args */

From 059a15a1d521a6ba79273b2ade923822b1532205 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 13 Jul 2018 10:40:27 -0500
Subject: [PATCH] HACK: mshtml: Don't install wine-gecko on prefix creation

We only want to install this on demand.
---
 dlls/mshtml/main.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/dlls/mshtml/main.c b/dlls/mshtml/main.c
index 6ce8198aee5..f84d92cc860 100644
--- a/dlls/mshtml/main.c
+++ b/dlls/mshtml/main.c
@@ -530,8 +530,6 @@ HRESULT WINAPI DllRegisterServer(void)
     hres = __wine_register_resources( hInst );
     if(SUCCEEDED(hres))
         hres = register_server(TRUE);
-    if(SUCCEEDED(hres))
-        load_gecko();
 
     return hres;
 }

From 1ef83da3b15171782dc009bb6649665769122aa5 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 15 Jan 2019 10:10:47 -0600
Subject: [PATCH] kernel32: Don't pass SDL_AUDIODRIVER from Linux environment

---
 dlls/kernel32/process.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 9c957f02c06..e14b514ccc1 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -137,6 +137,7 @@ static inline BOOL is_special_env_var( const char *var )
             !strncmp( var, "TEMP=", sizeof("TEMP=")-1 ) ||
             !strncmp( var, "TMP=", sizeof("TMP=")-1 ) ||
             !strncmp( var, "QT_", sizeof("QT_")-1 ) ||
+            !strncmp( var, "SDL_AUDIODRIVER=", sizeof("SDL_AUDIODRIVER=")-1 ) ||
             !strncmp( var, "VK_", sizeof("VK_")-1 ));
 }
 
From 971dc3c4225b33fb5346187cd37e8355f265800f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 18 Jun 2018 07:56:35 -0500
Subject: [PATCH] ntdll: Notice THREADNAME_INFO exceptions and set thread name
 on Linux

Patch by Zeb.
---
 dlls/ntdll/exception.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
index f85381079a2..ffe048de8c0 100644
--- a/dlls/ntdll/exception.c
+++ b/dlls/ntdll/exception.c
@@ -26,6 +26,9 @@
 #include <errno.h>
 #include <signal.h>
 #include <stdarg.h>
+#ifdef HAVE_PRCTL
+#include <sys/prctl.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -143,6 +146,16 @@ void wait_suspend( CONTEXT *context )
 }
 
 
+/* "How to: Set a Thread Name in Native Code"
+ * https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx */
+typedef struct tagTHREADNAME_INFO
+{
+   DWORD   dwType;     /* Must be 0x1000 */
+   LPCSTR  szName;     /* Pointer to name - limited to 9 bytes (8 characters + terminator) */
+   DWORD   dwThreadID; /* Thread ID (-1 = caller thread) */
+   DWORD   dwFlags;    /* Reserved for future use.  Must be zero. */
+} THREADNAME_INFO;
+
 /**********************************************************************
  *           send_debug_event
  *
@@ -162,6 +175,21 @@ NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, int first_chance, CONTEXT *con
     for (i = 0; i < min( rec->NumberParameters, EXCEPTION_MAXIMUM_PARAMETERS ); i++)
         params[i] = rec->ExceptionInformation[i];
 
+    if (rec->ExceptionCode == 0x406d1388)
+    {
+        const THREADNAME_INFO *threadname = (const THREADNAME_INFO *)rec->ExceptionInformation;
+
+        if (threadname->dwThreadID == -1)
+        {
+#ifdef HAVE_PRCTL
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+            prctl( PR_SET_NAME, threadname->szName );
+#endif
+        }
+    }
+
     context_to_server( &server_context, context );
 
     SERVER_START_REQ( queue_exception_event )

From a7542e9e279970c2ab3ac9c6c986b300135286a0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 28 Mar 2018 09:17:30 -0500
Subject: [PATCH] wine.inf: Don't show crash dialog by default

---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 7fe2f49dcd9..e72d0dcaba1 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -540,6 +540,7 @@ HKLM,%CurrentVersionNT%\AeDebug,"Debugger",2,"winedbg --auto %ld %ld"
 HKLM,%CurrentVersionNT%\AeDebug,"Auto",2,"1"
 HKCU,Software\Wine\Debug,"RelayExclude",2,"ntdll.RtlEnterCriticalSection;ntdll.RtlTryEnterCriticalSection;ntdll.RtlLeaveCriticalSection;kernel32.48;kernel32.49;kernel32.94;kernel32.95;kernel32.96;kernel32.97;kernel32.98;kernel32.TlsGetValue;kernel32.TlsSetValue;kernel32.FlsGetValue;kernel32.FlsSetValue;kernel32.SetLastError"
 HKCU,Software\Wine\Debug,"RelayFromExclude",2,"winex11.drv;winemac.drv;user32;gdi32;advapi32;kernel32"
+HKCU,Software\Wine\WineDbg,"ShowCrashDialog",0x00010003,0x00000000
 
 [DirectX]
 HKLM,Software\Microsoft\DirectX,"Version",,"4.09.00.0904"

From 71fce64369f2ace00bc0bb8018b549dd201a5764 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 9 Jan 2019 13:24:54 +0300
Subject: [PATCH] imm32: Automatically initialize COM on window activation.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/imm32/Makefile.in     |   2 +-
 dlls/imm32/imm.c           | 129 ++++++++++++++++++++++++++++++++++++-
 dlls/imm32/imm32.spec      |   1 +
 dlls/user32/focus.c        |   2 +
 dlls/user32/misc.c         |   2 +
 dlls/user32/user_private.h |   1 +
 6 files changed, 135 insertions(+), 2 deletions(-)

diff --git a/dlls/imm32/Makefile.in b/dlls/imm32/Makefile.in
index b190888659b..ad10fc2fa45 100644
--- a/dlls/imm32/Makefile.in
+++ b/dlls/imm32/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = imm32.dll
 IMPORTLIB = imm32
-IMPORTS   = user32 gdi32 advapi32
+IMPORTS   = user32 gdi32 advapi32 ole32
 
 C_SRCS = \
 	imm.c
diff --git a/dlls/imm32/imm.c b/dlls/imm32/imm.c
index 28eb00f355a..129f7e8cb53 100644
--- a/dlls/imm32/imm.c
+++ b/dlls/imm32/imm.c
@@ -19,6 +19,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#define COBJMACROS
+
 #include <stdarg.h>
 #include <stdio.h>
 
@@ -32,6 +34,8 @@
 #include "ddk/imm.h"
 #include "winnls.h"
 #include "winreg.h"
+#include "initguid.h"
+#include "objbase.h"
 #include "wine/list.h"
 #include "wine/unicode.h"
 
@@ -95,8 +99,16 @@ typedef struct _tagIMMThreadData {
     HWND hwndDefault;
     BOOL disableIME;
     DWORD windowRefs;
+    IInitializeSpy IInitializeSpy_iface;
+    ULARGE_INTEGER spy_cookie;
+    BOOL apt_initialized;
 } IMMThreadData;
 
+static inline IMMThreadData *impl_from_IInitializeSpy(IInitializeSpy *iface)
+{
+    return CONTAINING_RECORD(iface, IMMThreadData, IInitializeSpy_iface);
+}
+
 static struct list ImmHklList = LIST_INIT(ImmHklList);
 static struct list ImmThreadDataList = LIST_INIT(ImmThreadDataList);
 
@@ -227,6 +239,88 @@ static DWORD convert_candidatelist_AtoW(
     return ret;
 }
 
+static HRESULT WINAPI initializespy_QueryInterface(IInitializeSpy *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(&IID_IInitializeSpy, riid) ||
+            IsEqualIID(&IID_IUnknown, riid))
+    {
+        *obj = iface;
+        IInitializeSpy_AddRef(iface);
+        return S_OK;
+    }
+
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI initializespy_AddRef(IInitializeSpy *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI initializespy_Release(IInitializeSpy *iface)
+{
+    return 1;
+}
+
+static void imm_couninit_thread(IMMThreadData *thread_data)
+{
+    if (!thread_data->apt_initialized)
+        return;
+
+    thread_data->apt_initialized = FALSE;
+    CoUninitialize();
+}
+
+static HRESULT WINAPI initializespy_PreInitialize(IInitializeSpy *iface, DWORD coinit, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Application requested initialization of different apartment type. */
+    if (!(coinit & COINIT_APARTMENTTHREADED))
+        imm_couninit_thread(thread_data);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI initializespy_PostInitialize(IInitializeSpy *iface, HRESULT hr, DWORD coinit, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Explicit initialization call should return S_OK first time. */
+    if (thread_data->apt_initialized && hr == S_FALSE && refs == 2)
+        hr = S_OK;
+
+    return hr;
+}
+
+static HRESULT WINAPI initializespy_PreUninitialize(IInitializeSpy *iface, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Account for explicit uninitialization calls. */
+    if (thread_data->apt_initialized && refs == 1)
+        thread_data->apt_initialized = FALSE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI initializespy_PostUninitialize(IInitializeSpy *iface, DWORD refs)
+{
+    return S_OK;
+}
+
+static const IInitializeSpyVtbl initializespyvtbl =
+{
+    initializespy_QueryInterface,
+    initializespy_AddRef,
+    initializespy_Release,
+    initializespy_PreInitialize,
+    initializespy_PostInitialize,
+    initializespy_PreUninitialize,
+    initializespy_PostUninitialize,
+};
+
 static IMMThreadData *IMM_GetThreadData(HWND hwnd, DWORD thread)
 {
     IMMThreadData *data;
@@ -253,6 +347,7 @@ static IMMThreadData *IMM_GetThreadData(HWND hwnd, DWORD thread)
         if (data->threadID == thread) return data;
 
     data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data));
+    data->IInitializeSpy_iface.lpVtbl = &initializespyvtbl;
     data->threadID = thread;
     list_add_head(&ImmThreadDataList,&data->entry);
     TRACE("Thread Data Created (%x)\n",thread);
@@ -281,6 +376,7 @@ static void IMM_FreeThreadData(void)
             list_remove(&data->entry);
             LeaveCriticalSection(&threaddata_cs);
             IMM_DestroyContext(data->defaultContext);
+            imm_couninit_thread(data);
             HeapFree(GetProcessHeap(),0,data);
             TRACE("Thread Data Destroyed\n");
             return;
@@ -1627,6 +1723,32 @@ static BOOL needs_ime_window(HWND hwnd)
     return TRUE;
 }
 
+void WINAPI __wine_activate_window(HWND hwnd)
+{
+    IMMThreadData *thread_data;
+
+    TRACE("(%p)\n", hwnd);
+
+    if (!needs_ime_window(hwnd))
+        return;
+
+    thread_data = IMM_GetThreadData(hwnd, 0);
+    if (!thread_data)
+        return;
+
+    if (thread_data->disableIME || disable_ime)
+    {
+        TRACE("IME for this thread is disabled\n");
+        LeaveCriticalSection(&threaddata_cs);
+        return;
+    }
+
+    if (!thread_data->apt_initialized)
+        thread_data->apt_initialized = SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
+
+    LeaveCriticalSection(&threaddata_cs);
+}
+
 /***********************************************************************
  *		__wine_register_window (IMM32.@)
  */
@@ -1656,6 +1778,8 @@ BOOL WINAPI __wine_register_window(HWND hwnd)
     /* Create default IME window */
     if (thread_data->windowRefs == 1)
     {
+        CoRegisterInitializeSpy(&thread_data->IInitializeSpy_iface, &thread_data->spy_cookie);
+
         /* Do not create the window inside of a critical section */
         LeaveCriticalSection(&threaddata_cs);
         new = CreateWindowExW( 0, szwIME, szwDefaultIME,
@@ -1697,8 +1821,11 @@ void WINAPI __wine_unregister_window(HWND hwnd)
           thread_data->windowRefs, thread_data->hwndDefault);
 
     /* Destroy default IME window */
-    if (thread_data->windowRefs == 0 && thread_data->hwndDefault)
+    if (thread_data->windowRefs == 0)
     {
+        CoRevokeInitializeSpy(thread_data->spy_cookie);
+        thread_data->spy_cookie.QuadPart = 0;
+        imm_couninit_thread(thread_data);
         to_destroy = thread_data->hwndDefault;
         thread_data->hwndDefault = NULL;
     }
diff --git a/dlls/imm32/imm32.spec b/dlls/imm32/imm32.spec
index 4197bb81e21..d9cdc794e9e 100644
--- a/dlls/imm32/imm32.spec
+++ b/dlls/imm32/imm32.spec
@@ -117,3 +117,4 @@
 @ stdcall __wine_get_ui_window(ptr)
 @ stdcall __wine_register_window(long)
 @ stdcall __wine_unregister_window(long)
+@ stdcall __wine_activate_window(long)
diff --git a/dlls/user32/focus.c b/dlls/user32/focus.c
index f1c883167ed..50b3323ae9f 100644
--- a/dlls/user32/focus.c
+++ b/dlls/user32/focus.c
@@ -156,6 +156,8 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
                       (LPARAM)previous );
         if (GetAncestor( hwnd, GA_PARENT ) == GetDesktopWindow())
             PostMessageW( GetDesktopWindow(), WM_PARENTNOTIFY, WM_NCACTIVATE, (LPARAM)hwnd );
+
+        imm_activate_window( hwnd );
     }
 
     /* now change focus if necessary */
diff --git a/dlls/user32/misc.c b/dlls/user32/misc.c
index c26c02a3537..5cbcc7db67d 100644
--- a/dlls/user32/misc.c
+++ b/dlls/user32/misc.c
@@ -43,6 +43,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(win);
 static HWND (WINAPI *imm_get_ui_window)(HKL);
 BOOL (WINAPI *imm_register_window)(HWND) = NULL;
 void (WINAPI *imm_unregister_window)(HWND) = NULL;
+void (WINAPI *imm_activate_window)(HWND) = NULL;
 
 /* MSIME messages */
 static UINT WM_MSIME_SERVICE;
@@ -567,6 +568,7 @@ BOOL WINAPI User32InitializeImmEntryTable(DWORD magic)
     imm_get_ui_window = (void*)GetProcAddress(imm32, "__wine_get_ui_window");
     imm_register_window = (void*)GetProcAddress(imm32, "__wine_register_window");
     imm_unregister_window = (void*)GetProcAddress(imm32, "__wine_unregister_window");
+    imm_activate_window = (void*)GetProcAddress(imm32, "__wine_activate_window");
     if (!imm_get_ui_window)
         FIXME("native imm32.dll not supported\n");
     return TRUE;
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 514cf6753f4..b86831d7d95 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -197,6 +197,7 @@ C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo)
 extern INT global_key_state_counter DECLSPEC_HIDDEN;
 extern BOOL (WINAPI *imm_register_window)(HWND) DECLSPEC_HIDDEN;
 extern void (WINAPI *imm_unregister_window)(HWND) DECLSPEC_HIDDEN;
+extern void (WINAPI *imm_activate_window)(HWND) DECLSPEC_HIDDEN;
 
 struct user_key_state_info
 {

From 8a781a3ab721a14fed0a8c1aaccd357cdd71d0ac Mon Sep 17 00:00:00 2001
From: Jactry Zeng <jzeng@codeweavers.com>
Date: Thu, 13 Dec 2018 22:21:34 +0800
Subject: [PATCH] gdi32: Add CJK font replacements.

---
 dlls/gdi32/freetype.c | 172 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 171 insertions(+), 1 deletion(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 0fc41f39021..1d721f50760 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -513,11 +513,22 @@ static const WCHAR external_fonts_reg_key[] = {'S','o','f','t','w','a','r','e','
 static const WCHAR Lucida_Sans_Unicode[] = {'L','u','c','i','d','a',' ','S','a','n','s',' ','U','n','i','c','o','d','e',0};
 static const WCHAR Microsoft_Sans_Serif[] = {'M','i','c','r','o','s','o','f','t',' ','S','a','n','s',' ','S','e','r','i','f',0 };
 static const WCHAR Tahoma[] = {'T','a','h','o','m','a',0};
+/* Japanese fonts */
 static const WCHAR MS_UI_Gothic[] = {'M','S',' ','U','I',' ','G','o','t','h','i','c',0};
+static const WCHAR atMS_UI_Gothic[] = {'@','M','S',' ','U','I',' ','G','o','t','h','i','c',0};
+static const WCHAR MS_PGothic_cp932[]= {0x30fb,0xff6d,0x30fb,0xff73,' ',0x30fb,0xff70,0x7e67,0xff74,0x7e67,0xff77,0x7e5d,0x30fb,0x3051,0};
+/* Simplified Chinese fonts */
 static const WCHAR SimSun[] = {'S','i','m','S','u','n',0};
-static const WCHAR Gulim[] = {'G','u','l','i','m',0};
+static const WCHAR atSimSun[] = {'@','S','i','m','S','u','n',0};
+static const WCHAR Microsoft_YaHei[] = {'M','i','c','r','o','s','o','f','t',' ','Y','a','H','e','i',0};
+static const WCHAR LiSu[] = {'L','i','S','u',0};
+/* Traditional Chinese fonts */
 static const WCHAR PMingLiU[] = {'P','M','i','n','g','L','i','U',0};
+static const WCHAR atPMingLiU[] = {'@','P','M','i','n','g','L','i','U',0};
+/* Korean fonts */
 static const WCHAR Batang[] = {'B','a','t','a','n','g',0};
+static const WCHAR Gulim[] = {'G','u','l','i','m',0};
+static const WCHAR atGulim[] = {'@','G','u','l','i','m',0};
 
 static const WCHAR arial[] = {'A','r','i','a','l',0};
 static const WCHAR bitstream_vera_sans[] = {'B','i','t','s','t','r','e','a','m',' ','V','e','r','a',' ','S','a','n','s',0};
@@ -2365,6 +2376,113 @@ static BOOL map_font_family(const WCHAR *orig, const WCHAR *repl)
     return FALSE;
 }
 
+static const WCHAR new_sc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',0,
+    /* Popular open source Chinese font */
+    'W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR vertical_new_sc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',0,
+    /* popular open source Chinese font */
+    '@','W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR new_tc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',0,
+    /* popular open source Chinese font */
+    'W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR vertical_new_tc_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',0,
+    /* popular open source Chinese font */
+    '@','W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR new_jp_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',0,
+    0
+};
+
+static const WCHAR vertical_new_jp_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',0,
+    0
+};
+
+static const WCHAR new_kr_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',0,
+    0
+};
+
+static const WCHAR vertical_new_kr_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',0,
+    0
+};
+
+static struct font_replacements
+{
+    const WCHAR *replacements[4];
+    const int count;
+    const WCHAR *new_fonts;
+    const WCHAR *vertical_new_fonts;
+    BOOL *font_seen;
+} font_replacements_list[] =
+{
+    /* Simplified Chinese */
+    {
+        {
+            SimSun, atSimSun, Microsoft_YaHei, LiSu
+        }, 4, new_sc_fonts, vertical_new_sc_fonts, NULL
+    },
+    /* Traditional Chinese */
+    {
+        {
+            PMingLiU, atPMingLiU
+        }, 2, new_tc_fonts, vertical_new_tc_fonts, NULL
+    },
+    /* Japanese */
+    {
+        {
+            MS_UI_Gothic, atMS_UI_Gothic, MS_PGothic_cp932
+        }, 3, new_jp_fonts, vertical_new_jp_fonts, NULL
+    },
+    /* Korean */
+    {
+        {
+            Gulim, atGulim
+        }, 2, new_kr_fonts, vertical_new_kr_fonts, NULL
+    }
+};
+
 /***********************************************************
  * The replacement list is a way to map an entire font
  * family onto another family.  For example adding
@@ -2383,6 +2501,7 @@ static void LoadReplaceList(void)
     DWORD valuelen, datalen, i = 0, type, dlen, vlen;
     LPWSTR value;
     LPVOID data;
+    int replacement_count = sizeof(font_replacements_list)/sizeof(font_replacements_list[0]);
 
     /* @@ Wine registry key: HKCU\Software\Wine\Fonts\Replacements */
     if(RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Fonts\\Replacements", &hkey) == ERROR_SUCCESS)
@@ -2401,6 +2520,25 @@ static void LoadReplaceList(void)
             /* "NewName"="Oldname" */
             if(!find_family_from_any_name(value))
             {
+                int j;
+
+                for (j = 0; j < replacement_count; j++)
+                {
+                    int k;
+
+                    struct font_replacements *replacement = &font_replacements_list[j];
+
+                    replacement->font_seen = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                                                       replacement->count * sizeof(BOOL));
+                    for (k = 0; k < replacement->count; k++)
+                    {
+                        if (!replacement->font_seen[k] && !lstrcmpW(value, replacement->replacements[k]))
+                        {
+                            replacement->font_seen[k] = TRUE;
+                            break;
+                        }
+                    }
+                }
                 if (type == REG_MULTI_SZ)
                 {
                     WCHAR *replace = data;
@@ -2421,6 +2559,38 @@ static void LoadReplaceList(void)
 	    dlen = datalen;
 	    vlen = valuelen;
 	}
+
+        for (i = 0; i < replacement_count; i++)
+        {
+            int j;
+            struct font_replacements *replacement = &font_replacements_list[i];
+
+            for (j = 0; j < replacement->count; j++)
+            {
+                if (!replacement->font_seen ||
+                    (!replacement->font_seen[j] && !find_family_from_any_name(replacement->replacements[j])))
+                {
+                    const WCHAR *replace;
+
+                    if (replacement->replacements[j][0] == '@')
+                        replace = replacement->vertical_new_fonts;
+                    else
+                        replace = replacement->new_fonts;
+
+                    while (*replace)
+                    {
+                        if (map_font_family(replacement->replacements[j], replace))
+                        {
+                            TRACE("Replace %s with %s\n", wine_dbgstr_w(replacement->replacements[j]),
+                                  wine_dbgstr_w(replace));
+                            break;
+                        }
+                        replace += strlenW(replace) + 1;
+                    }
+                }
+            }
+            HeapFree(GetProcessHeap(), 0, replacement->font_seen);
+        }
 	HeapFree(GetProcessHeap(), 0, data);
 	HeapFree(GetProcessHeap(), 0, value);
 	RegCloseKey(hkey);

From 17d19e1b23bce6fc6ff5b4e61131c9c58fd57ae5 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 28 Mar 2018 09:21:41 -0500
Subject: [PATCH] HACK: Don't build winemenubuilder

---
 configure          | 2 --
 configure.ac       | 1 -
 loader/wine.inf.in | 1 -
 3 files changed, 4 deletions(-)

diff --git a/configure b/configure
index 649a8917f54..4581015d576 100755
--- a/configure
+++ b/configure
@@ -1746,7 +1746,6 @@ enable_wineconsole
 enable_winedbg
 enable_winedevice
 enable_winefile
-enable_winemenubuilder
 enable_winemine
 enable_winemsibuilder
 enable_winepath
@@ -20315,7 +20314,6 @@ wine_fn_config_makefile programs/wineconsole enable_wineconsole
 wine_fn_config_makefile programs/winedbg enable_winedbg
 wine_fn_config_makefile programs/winedevice enable_winedevice
 wine_fn_config_makefile programs/winefile enable_winefile
-wine_fn_config_makefile programs/winemenubuilder enable_winemenubuilder
 wine_fn_config_makefile programs/winemine enable_winemine
 wine_fn_config_makefile programs/winemsibuilder enable_winemsibuilder
 wine_fn_config_makefile programs/winepath enable_winepath
diff --git a/configure.ac b/configure.ac
index 704da15f404..d4168e410bc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3998,7 +3998,6 @@ WINE_CONFIG_MAKEFILE(programs/wineconsole)
 WINE_CONFIG_MAKEFILE(programs/winedbg)
 WINE_CONFIG_MAKEFILE(programs/winedevice)
 WINE_CONFIG_MAKEFILE(programs/winefile)
-WINE_CONFIG_MAKEFILE(programs/winemenubuilder)
 WINE_CONFIG_MAKEFILE(programs/winemine)
 WINE_CONFIG_MAKEFILE(programs/winemsibuilder)
 WINE_CONFIG_MAKEFILE(programs/winepath)
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 2b049eb91f8..e6948a73427 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3598,7 +3598,6 @@ HKR,Parameters,"ServiceDll",,"%11%\schedsvc.dll"
 HKLM,%CurrentVersionNT%\SvcHost,"netsvcs",0x00010008,"Schedule"
 
 [Services]
-HKLM,%CurrentVersion%\RunServices,"winemenubuilder",2,"%11%\winemenubuilder.exe -a -r"
 HKLM,"System\CurrentControlSet\Services\Eventlog\Application",,16
 HKLM,"System\CurrentControlSet\Services\Eventlog\System","Sources",0x10000,""
 HKLM,"System\CurrentControlSet\Services\Tcpip\Parameters","DataBasePath",2,"%11%\drivers"

From 7e91b897e69854cb3afe761f48ef7c9b496ecf95 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B3zef=20Kucia?= <jkucia@codeweavers.com>
Date: Wed, 1 May 2019 12:28:12 +0200
Subject: [PATCH] vulkan-1: Prefer built-in DLL.

Games may ship with their own Vulkan loader.
---
 dlls/vulkan-1/vulkan.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/dlls/vulkan-1/vulkan.c b/dlls/vulkan-1/vulkan.c
index d3b35603a17..4926cf9bf4f 100644
--- a/dlls/vulkan-1/vulkan.c
+++ b/dlls/vulkan-1/vulkan.c
@@ -32,10 +32,6 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, void *reserved)
 
     switch (reason)
     {
-        case DLL_WINE_PREATTACH:
-            /* Prefer native as it provides more functionality. */
-            return FALSE;
-
         case DLL_PROCESS_ATTACH:
             DisableThreadLibraryCalls(hinst);
             return TRUE;

From 90e3616c89ef7ed38763a3e3af3e9f0cd59697da Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Mar 2017 20:15:40 +0300
Subject: [PATCH] HACK: dwrite: Don't recommend outline rendering mode

---
 dlls/dwrite/font.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/dwrite/font.c b/dlls/dwrite/font.c
index e22559912c3..41ec809b727 100644
--- a/dlls/dwrite/font.c
+++ b/dlls/dwrite/font.c
@@ -740,7 +740,8 @@ static HRESULT WINAPI dwritefontface_GetRecommendedRenderingMode(IDWriteFontFace
 
     ppem = emSize * ppdip;
 
-    if (ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
+    /* HACK: disable outline rendering mode to workaround d2d issue */
+    if (0 && ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
         *mode = DWRITE_RENDERING_MODE_OUTLINE;
         return S_OK;
     }

From 5c59517008697ce74becddb59a3e6702a963bb49 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Fri, 16 Aug 2019 09:46:25 +0000
Subject: [PATCH] msctf: Use list to keep thread managers.

Thread managers were stored in thread local storage,
which have a major flaw that they can't not be released
by another thread.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/msctf/msctf.c          | 46 +++++++----------------
 dlls/msctf/msctf_internal.h |  1 -
 dlls/msctf/threadmgr.c      | 73 ++++++++++++++++++++++++++++++++-----
 3 files changed, 76 insertions(+), 44 deletions(-)

diff --git a/dlls/msctf/msctf.c b/dlls/msctf/msctf.c
index c6e3a2ca597..fd919295c5a 100644
--- a/dlls/msctf/msctf.c
+++ b/dlls/msctf/msctf.c
@@ -69,7 +69,6 @@ static UINT array_size;
 static struct list AtsList = LIST_INIT(AtsList);
 static UINT activated = 0;
 
-DWORD tlsIndex = 0;
 TfClientId processId = 0;
 ITfCompartmentMgr *globalCompartmentMgr = NULL;
 
@@ -397,23 +396,19 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
     ActivatedTextService *actsvr;
     ITfCategoryMgr *catmgr;
     AtsEntry *entry;
-    ITfThreadMgrEx *tm = TlsGetValue(tlsIndex);
+    ITfThreadMgr *tm;
     ITfClientId *clientid;
 
-    if (!tm) return E_UNEXPECTED;
+    if (FAILED(TF_GetThreadMgr(&tm))) return E_UNEXPECTED;
 
     actsvr = HeapAlloc(GetProcessHeap(),0,sizeof(ActivatedTextService));
-    if (!actsvr) return E_OUTOFMEMORY;
+    if (!actsvr) goto fail;
 
-    ITfThreadMgrEx_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
+    ITfThreadMgr_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
     ITfClientId_GetClientId(clientid, &lp->clsid, &actsvr->tid);
     ITfClientId_Release(clientid);
 
-    if (!actsvr->tid)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!actsvr->tid) goto fail;
 
     actsvr->pITfTextInputProcessor = NULL;
     actsvr->LanguageProfile = *lp;
@@ -440,20 +435,21 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
         deactivate_remove_conflicting_ts(&actsvr->LanguageProfile.catid);
 
     if (activated > 0)
-        activate_given_ts(actsvr, tm);
+        activate_given_ts(actsvr, (ITfThreadMgrEx *)tm);
 
     entry = HeapAlloc(GetProcessHeap(),0,sizeof(AtsEntry));
-
-    if (!entry)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!entry) goto fail;
 
     entry->ats = actsvr;
     list_add_head(&AtsList, &entry->entry);
 
+    ITfThreadMgr_Release(tm);
     return S_OK;
+
+fail:
+    ITfThreadMgr_Release(tm);
+    HeapFree(GetProcessHeap(), 0, actsvr);
+    return E_OUTOFMEMORY;
 }
 
 BOOL get_active_textservice(REFCLSID rclsid, TF_LANGUAGEPROFILE *profile)
@@ -560,11 +556,9 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD fdwReason, LPVOID fImpLoad)
             return FALSE;   /* prefer native version */
         case DLL_PROCESS_ATTACH:
             MSCTF_hinstance = hinst;
-            tlsIndex = TlsAlloc();
             break;
         case DLL_PROCESS_DETACH:
             if (fImpLoad) break;
-            TlsFree(tlsIndex);
             break;
     }
     return TRUE;
@@ -622,20 +616,6 @@ HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim)
     return ThreadMgr_Constructor(NULL,(IUnknown**)pptim);
 }
 
-/***********************************************************************
- *              TF_GetThreadMgr (MSCTF.@)
- */
-HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
-{
-    TRACE("\n");
-    *pptim = TlsGetValue(tlsIndex);
-
-    if (*pptim)
-        ITfThreadMgr_AddRef(*pptim);
-
-    return S_OK;
-}
-
 /***********************************************************************
  *              SetInputScope(MSCTF.@)
  */
diff --git a/dlls/msctf/msctf_internal.h b/dlls/msctf/msctf_internal.h
index 584bb1044ed..ace2bee23d9 100644
--- a/dlls/msctf/msctf_internal.h
+++ b/dlls/msctf/msctf_internal.h
@@ -35,7 +35,6 @@
 #define COOKIE_MAGIC_UIELEMENTSINK 0x00a0
 #define COOKIE_MAGIC_INPUTPROCESSORPROFILEACTIVATIONSINK 0x00b0
 
-extern DWORD tlsIndex DECLSPEC_HIDDEN;
 extern TfClientId processId DECLSPEC_HIDDEN;
 extern ITfCompartmentMgr *globalCompartmentMgr DECLSPEC_HIDDEN;
 
diff --git a/dlls/msctf/threadmgr.c b/dlls/msctf/threadmgr.c
index 2c208fbc04f..2119ea2193b 100644
--- a/dlls/msctf/threadmgr.c
+++ b/dlls/msctf/threadmgr.c
@@ -37,6 +37,17 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msctf);
 
+static CRITICAL_SECTION ThreadMgrCs;
+static CRITICAL_SECTION_DEBUG ThreadMgrCsDebug =
+{
+    0, 0, &ThreadMgrCs,
+    {&ThreadMgrCsDebug.ProcessLocksList,
+     &ThreadMgrCsDebug.ProcessLocksList },
+     0, 0, {(DWORD_PTR)(__FILE__ ": ThreadMgrCs")}
+};
+static CRITICAL_SECTION ThreadMgrCs = {&ThreadMgrCsDebug, -1, 0, 0, 0, 0};
+struct list ThreadMgrList = LIST_INIT(ThreadMgrList);
+
 typedef struct tagPreservedKey
 {
     struct list     entry;
@@ -98,6 +109,9 @@ typedef struct tagACLMulti {
     struct list     ThreadMgrEventSink;
     struct list     UIElementSink;
     struct list     InputProcessorProfileActivationSink;
+
+    DWORD threadId;
+    struct list entry;
 } ThreadMgr;
 
 typedef struct tagEnumTfDocumentMgr {
@@ -110,6 +124,11 @@ typedef struct tagEnumTfDocumentMgr {
 
 static HRESULT EnumTfDocumentMgr_Constructor(struct list* head, IEnumTfDocumentMgrs **ppOut);
 
+static inline ThreadMgr *impl_from_ITfThreadMgr(ITfThreadMgr *iface)
+{
+    return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
+}
+
 static inline ThreadMgr *impl_from_ITfThreadMgrEx(ITfThreadMgrEx *iface)
 {
     return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
@@ -155,6 +174,35 @@ static inline EnumTfDocumentMgr *impl_from_IEnumTfDocumentMgrs(IEnumTfDocumentMg
     return CONTAINING_RECORD(iface, EnumTfDocumentMgr, IEnumTfDocumentMgrs_iface);
 }
 
+/***********************************************************************
+ *              TF_GetThreadMgr (MSCTF.@)
+ */
+HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
+{
+    DWORD id = GetCurrentThreadId();
+    ThreadMgr *cursor;
+
+    TRACE("%p\n", pptim);
+
+    if (!pptim)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&ThreadMgrCs);
+    LIST_FOR_EACH_ENTRY(cursor, &ThreadMgrList, ThreadMgr, entry)
+    {
+        if (cursor->threadId == id)
+        {
+            ITfThreadMgrEx_AddRef(&cursor->ITfThreadMgrEx_iface);
+            *pptim = (ITfThreadMgr *)&cursor->ITfThreadMgrEx_iface;
+            LeaveCriticalSection(&ThreadMgrCs);
+            return S_OK;
+        }
+    }
+    LeaveCriticalSection(&ThreadMgrCs);
+    *pptim = NULL;
+    return E_FAIL;
+}
+
 static void ThreadMgr_Destructor(ThreadMgr *This)
 {
     struct list *cursor, *cursor2;
@@ -163,7 +211,9 @@ static void ThreadMgr_Destructor(ThreadMgr *This)
     if (This->focusHook)
         UnhookWindowsHookEx(This->focusHook);
 
-    TlsSetValue(tlsIndex,NULL);
+    EnterCriticalSection(&ThreadMgrCs);
+    list_remove(&This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
     TRACE("destroying %p\n", This);
     if (This->focus)
         ITfDocumentMgr_Release(This->focus);
@@ -386,17 +436,20 @@ static HRESULT WINAPI ThreadMgr_SetFocus(ITfThreadMgrEx *iface, ITfDocumentMgr *
 
 static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lParam)
 {
+    ITfThreadMgr *ThreadMgr_iface;
     ThreadMgr *This;
 
-    This = TlsGetValue(tlsIndex);
-    if (!This)
+    if (FAILED(TF_GetThreadMgr(&ThreadMgr_iface)))
     {
         ERR("Hook proc but no ThreadMgr for this thread. Serious Error\n");
         return 0;
     }
+
+    This = impl_from_ITfThreadMgr(ThreadMgr_iface);
     if (!This->focusHook)
     {
         ERR("Hook proc but no ThreadMgr focus Hook. Serious Error\n");
+        ITfThreadMgr_Release(ThreadMgr_iface);
         return 0;
     }
 
@@ -417,6 +470,7 @@ static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lPa
         }
     }
 
+    ITfThreadMgr_Release(ThreadMgr_iface);
     return CallNextHookEx(This->focusHook, nCode, wParam, lParam);
 }
 
@@ -1338,13 +1392,8 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
         return CLASS_E_NOAGGREGATION;
 
     /* Only 1 ThreadMgr is created per thread */
-    This = TlsGetValue(tlsIndex);
-    if (This)
-    {
-        ThreadMgr_AddRef(&This->ITfThreadMgrEx_iface);
-        *ppOut = (IUnknown*)&This->ITfThreadMgrEx_iface;
+    if (SUCCEEDED(TF_GetThreadMgr((ITfThreadMgr **)ppOut)))
         return S_OK;
-    }
 
     This = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(ThreadMgr));
     if (This == NULL)
@@ -1359,7 +1408,6 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     This->ITfUIElementMgr_iface.lpVtbl = &ThreadMgrUIElementMgrVtbl;
     This->ITfSourceSingle_iface.lpVtbl = &SourceSingleVtbl;
     This->refCount = 1;
-    TlsSetValue(tlsIndex,This);
 
     CompartmentMgr_Constructor((IUnknown*)&This->ITfThreadMgrEx_iface, &IID_IUnknown, (IUnknown**)&This->CompartmentMgr);
 
@@ -1376,6 +1424,11 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     list_init(&This->UIElementSink);
     list_init(&This->InputProcessorProfileActivationSink);
 
+    This->threadId = GetCurrentThreadId();
+    EnterCriticalSection(&ThreadMgrCs);
+    list_add_tail(&ThreadMgrList, &This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
+
     TRACE("returning %p\n", This);
     *ppOut = (IUnknown *)&This->ITfThreadMgrEx_iface;
     return S_OK;
From 57f18487fb073df1adf3fcdb0726175d530aa737 Mon Sep 17 00:00:00 2001
From: Juuso Alasuutari <juuso.alasuutari@gmail.com>
Date: Sun, 18 Aug 2019 09:27:13 +0300
Subject: [PATCH] kernel32: Ensure that the loader lock is released before
 returning from GetModuleHandleExW().

Signed-off-by: Juuso Alasuutari <juuso.alasuutari@gmail.com>
Reviewed-by: Richard Yao <ryao@gentoo.org>
---
 dlls/kernel32/module.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 9ae687cb840..4289f20d3c2 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -479,6 +479,8 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
         UNICODE_STRING wstr;
         if(steamclient_hmod != NULL && strcasestrW(name, steamclientW)){
             *module = steamclient_hmod;
+            if (lock)
+                LdrUnlockLoaderLock( 0, magic );
             return TRUE;
         }
         RtlInitUnicodeString( &wstr, name );

From ed04e35d3f7af02267fb4e21578b3ccb27703836 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 23 Sep 2019 13:29:16 -0500
Subject: [PATCH] dxdiag: Dump to stdout if no filename is given

---
 programs/dxdiag/main.c   |  8 +++++++-
 programs/dxdiag/output.c | 10 +++++++---
 2 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/programs/dxdiag/main.c b/programs/dxdiag/main.c
index 4533236f0f5..353e9f50fb9 100644
--- a/programs/dxdiag/main.c
+++ b/programs/dxdiag/main.c
@@ -71,7 +71,13 @@ static BOOL process_file_name(const WCHAR *cmdline, enum output_type output_type
         endptr = cmdline + lstrlenW(cmdline);
 
     len = endptr - cmdline;
-    if (len == 0 || len >= filename_len)
+    if (len == 0)
+    {
+        *filename = 0;
+        return TRUE;
+    }
+
+    if (len >= filename_len)
         return FALSE;
 
     memcpy(filename, cmdline, len * sizeof(WCHAR));
diff --git a/programs/dxdiag/output.c b/programs/dxdiag/output.c
index 50240fb2860..f0f6a6da0c3 100644
--- a/programs/dxdiag/output.c
+++ b/programs/dxdiag/output.c
@@ -169,8 +169,12 @@ static BOOL output_text_information(struct dxdiag_information *dxdiag_info, cons
 
     fill_system_text_output_table(dxdiag_info, output_table[0].fields);
 
-    hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
-                        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (filename && *filename)
+        hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    else
+        hFile = GetStdHandle(STD_OUTPUT_HANDLE);
+
     if (hFile == INVALID_HANDLE_VALUE)
     {
         WINE_ERR("File creation failed, last error %u\n", GetLastError());
@@ -227,7 +231,7 @@ static HRESULT save_xml_document(IXMLDOMDocument *xmldoc, const WCHAR *filename)
     VARIANT destVar;
     HRESULT hr;
 
-    if (!bstr)
+    if (!bstr || !filename || !*filename)
         return E_OUTOFMEMORY;
 
     V_VT(&destVar) = VT_BSTR;
From e485252dfad51a7e463643d56fe138129597e4b6 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 23 Sep 2019 08:56:04 -0500
Subject: [PATCH] ntdll: Always add a tail to heap allocations.

Fixes the Rockstar Games Launcher installer (and possibly other
NSIS-based installers) from crashing due to passing a too-small buffer
to GetWindowInfo().
---
 dlls/ntdll/heap.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index 6344157f384..6fefe5d6d80 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -118,9 +118,8 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
 #define HEAP_MIN_SHRINK_SIZE  (HEAP_MIN_DATA_SIZE+sizeof(ARENA_FREE))
 /* minimum size to start allocating large blocks */
 #define HEAP_MIN_LARGE_BLOCK_SIZE  0x7f000
-/* extra size to add at the end of block for tail checking */
-#define HEAP_TAIL_EXTRA_SIZE(flags) \
-    ((flags & HEAP_TAIL_CHECKING_ENABLED) || RUNNING_ON_VALGRIND ? ALIGNMENT : 0)
+/* extra size to add at the end of block to mitigate overruns and allow tail checking */
+#define HEAP_TAIL_EXTRA_SIZE ALIGNMENT
 
 /* size of the blocks on the free lists */
 #define HEAP_FREELIST_SIZE(index) \
@@ -800,7 +799,7 @@ static void HEAP_ShrinkBlock(SUBHEAP *subheap, ARENA_INUSE *pArena, SIZE_T size)
 static void *allocate_large_block( HEAP *heap, DWORD flags, SIZE_T size )
 {
     ARENA_LARGE *arena;
-    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     LPVOID address = NULL;
 
     if (block_size < size) return NULL;  /* overflow */
@@ -1814,7 +1813,7 @@ void * WINAPI DECLSPEC_HOTPATCH RtlAllocateHeap( HANDLE heap, ULONG flags, SIZE_
     if (!heapPtr) return NULL;
     flags &= HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY;
     flags |= heapPtr->flags;
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE( flags );
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size)  /* overflow */
     {
         if (flags & HEAP_GENERATE_EXCEPTIONS) RtlRaiseStatus( STATUS_NO_MEMORY );
@@ -1968,7 +1967,7 @@ PVOID WINAPI RtlReAllocateHeap( HANDLE heap, ULONG flags, PVOID ptr, SIZE_T size
     flags |= heapPtr->flags;
     if (!(flags & HEAP_NO_SERIALIZE)) RtlEnterCriticalSection( &heapPtr->critSection );
 
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size) goto oom;  /* overflow */
     if (rounded_size < HEAP_MIN_DATA_SIZE) rounded_size = HEAP_MIN_DATA_SIZE;
 

From 21b43e000eb18207eb7ee68267d8ef38da6ad1c0 Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:14 -0600
Subject: [PATCH] advapi32: Replace SERV_dup() with strdupAW()

The strdupAW() function in advapi32_misc.h behaves exactly the same as
SERV_dup(). Switching calls to strdupAW() will reduce the complexity
when moving the services RPC functions into sechost by allowing moving
the service.c file with few changes.

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 dlls/advapi32/advapi32_misc.h |  1 -
 dlls/advapi32/eventlog.c      | 12 +++----
 dlls/advapi32/security.c      | 22 ++++++-------
 dlls/advapi32/service.c       | 60 ++++++++++++-----------------------
 4 files changed, 38 insertions(+), 57 deletions(-)

diff --git a/dlls/advapi32/advapi32_misc.h b/dlls/advapi32/advapi32_misc.h
index 77b56420ba3..65bd8aa8529 100644
--- a/dlls/advapi32/advapi32_misc.h
+++ b/dlls/advapi32/advapi32_misc.h
@@ -31,7 +31,6 @@ BOOL ADVAPI_GetComputerSid(PSID sid) DECLSPEC_HIDDEN;
 
 BOOL lookup_local_wellknown_name(const LSA_UNICODE_STRING*, PSID, LPDWORD, LPWSTR, LPDWORD, PSID_NAME_USE, BOOL*) DECLSPEC_HIDDEN;
 BOOL lookup_local_user_name(const LSA_UNICODE_STRING*, PSID, LPDWORD, LPWSTR, LPDWORD, PSID_NAME_USE, BOOL*) DECLSPEC_HIDDEN;
-WCHAR *SERV_dup(const char *str) DECLSPEC_HIDDEN;
 const WCHAR *get_wellknown_privilege_name(const LUID *) DECLSPEC_HIDDEN;
 
 /* memory allocation functions */
diff --git a/dlls/advapi32/eventlog.c b/dlls/advapi32/eventlog.c
index 6f8d26b5161..4349408a007 100644
--- a/dlls/advapi32/eventlog.c
+++ b/dlls/advapi32/eventlog.c
@@ -57,7 +57,7 @@ BOOL WINAPI BackupEventLogA( HANDLE hEventLog, LPCSTR lpBackupFileName )
     LPWSTR backupW;
     BOOL ret;
 
-    backupW = SERV_dup(lpBackupFileName);
+    backupW = strdupAW(lpBackupFileName);
     ret = BackupEventLogW(hEventLog, backupW);
     heap_free(backupW);
 
@@ -114,7 +114,7 @@ BOOL WINAPI ClearEventLogA( HANDLE hEventLog, LPCSTR lpBackupFileName )
     LPWSTR backupW;
     BOOL ret;
 
-    backupW = SERV_dup(lpBackupFileName);
+    backupW = strdupAW(lpBackupFileName);
     ret = ClearEventLogW(hEventLog, backupW);
     heap_free(backupW);
 
@@ -430,8 +430,8 @@ HANDLE WINAPI OpenBackupEventLogA( LPCSTR lpUNCServerName, LPCSTR lpFileName )
     LPWSTR uncnameW, filenameW;
     HANDLE handle;
 
-    uncnameW = SERV_dup(lpUNCServerName);
-    filenameW = SERV_dup(lpFileName);
+    uncnameW = strdupAW(lpUNCServerName);
+    filenameW = strdupAW(lpFileName);
     handle = OpenBackupEventLogW(uncnameW, filenameW);
     heap_free(uncnameW);
     heap_free(filenameW);
@@ -489,8 +489,8 @@ HANDLE WINAPI OpenEventLogA( LPCSTR uncname, LPCSTR source )
     LPWSTR uncnameW, sourceW;
     HANDLE handle;
 
-    uncnameW = SERV_dup(uncname);
-    sourceW = SERV_dup(source);
+    uncnameW = strdupAW(uncname);
+    sourceW = strdupAW(source);
     handle = OpenEventLogW(uncnameW, sourceW);
     heap_free(uncnameW);
     heap_free(sourceW);
diff --git a/dlls/advapi32/security.c b/dlls/advapi32/security.c
index 74eda932826..326058e2f76 100644
--- a/dlls/advapi32/security.c
+++ b/dlls/advapi32/security.c
@@ -1020,7 +1020,7 @@ GetFileSecurityA( LPCSTR lpFileName,
     BOOL r;
     LPWSTR name;
 
-    name = SERV_dup(lpFileName);
+    name = strdupAW(lpFileName);
     r = GetFileSecurityW( name, RequestedInformation, pSecurityDescriptor,
                           nLength, lpnLengthNeeded );
     heap_free( name );
@@ -1049,7 +1049,7 @@ LookupAccountSidA(
     DWORD accountSizeW = *accountSize;
     DWORD domainSizeW = *domainSize;
 
-    systemW = SERV_dup(system);
+    systemW = strdupAW(system);
     if (account)
         accountW = heap_alloc( accountSizeW * sizeof(WCHAR) );
     if (domain)
@@ -1303,7 +1303,7 @@ BOOL WINAPI SetFileSecurityA( LPCSTR lpFileName,
     BOOL r;
     LPWSTR name;
 
-    name = SERV_dup(lpFileName);
+    name = strdupAW(lpFileName);
     r = SetFileSecurityW( name, RequestedInformation, pSecurityDescriptor );
     heap_free( name );
 
@@ -2251,7 +2251,7 @@ static DWORD trustee_name_A_to_W(TRUSTEE_FORM form, char *trustee_nameA, WCHAR *
     {
     case TRUSTEE_IS_NAME:
     {
-        *ptrustee_nameW = SERV_dup(trustee_nameA);
+        *ptrustee_nameW = strdupAW(trustee_nameA);
         return ERROR_SUCCESS;
     }
     case TRUSTEE_IS_OBJECTS_AND_NAME:
@@ -2266,9 +2266,9 @@ static DWORD trustee_name_A_to_W(TRUSTEE_FORM form, char *trustee_nameA, WCHAR *
 
             objW->ObjectsPresent = objA->ObjectsPresent;
             objW->ObjectType = objA->ObjectType;
-            objW->ObjectTypeName = SERV_dup(objA->ObjectTypeName);
-            objW->InheritedObjectTypeName = SERV_dup(objA->InheritedObjectTypeName);
-            objW->ptstrName = SERV_dup(objA->ptstrName);
+            objW->ObjectTypeName = strdupAW(objA->ObjectTypeName);
+            objW->InheritedObjectTypeName = strdupAW(objA->InheritedObjectTypeName);
+            objW->ptstrName = strdupAW(objA->ptstrName);
         }
 
         *ptrustee_nameW = (WCHAR *)objW;
@@ -2648,7 +2648,7 @@ DWORD WINAPI SetNamedSecurityInfoA(LPSTR pObjectName,
     TRACE("%s %d %d %p %p %p %p\n", debugstr_a(pObjectName), ObjectType,
            SecurityInfo, psidOwner, psidGroup, pDacl, pSacl);
 
-    wstr = SERV_dup(pObjectName);
+    wstr = strdupAW(pObjectName);
     r = SetNamedSecurityInfoW( wstr, ObjectType, SecurityInfo, psidOwner,
                            psidGroup, pDacl, pSacl );
 
@@ -3323,7 +3323,7 @@ BOOL WINAPI ConvertStringSecurityDescriptorToSecurityDescriptorA(
     if(!StringSecurityDescriptor)
         return FALSE;
 
-    StringSecurityDescriptorW = SERV_dup(StringSecurityDescriptor);
+    StringSecurityDescriptorW = strdupAW(StringSecurityDescriptor);
     ret = ConvertStringSecurityDescriptorToSecurityDescriptorW(StringSecurityDescriptorW,
                                                                StringSDRevision, SecurityDescriptor,
                                                                SecurityDescriptorSize);
@@ -3833,7 +3833,7 @@ BOOL WINAPI ConvertStringSidToSidA(LPCSTR StringSid, PSID* Sid)
         SetLastError(ERROR_INVALID_PARAMETER);
     else
     {
-        WCHAR *wStringSid = SERV_dup(StringSid);
+        WCHAR *wStringSid = strdupAW(StringSid);
         bret = ConvertStringSidToSidW(wStringSid, Sid);
         heap_free(wStringSid);
     }
@@ -4096,7 +4096,7 @@ DWORD WINAPI GetNamedSecurityInfoA(LPSTR pObjectName,
     TRACE("%s %d %d %p %p %p %p %p\n", pObjectName, ObjectType, SecurityInfo,
         ppsidOwner, ppsidGroup, ppDacl, ppSacl, ppSecurityDescriptor);
 
-    wstr = SERV_dup(pObjectName);
+    wstr = strdupAW(pObjectName);
     r = GetNamedSecurityInfoW( wstr, ObjectType, SecurityInfo, ppsidOwner,
                            ppsidGroup, ppDacl, ppSacl, ppSecurityDescriptor );
 
diff --git a/dlls/advapi32/service.c b/dlls/advapi32/service.c
index 2781a128239..3bf6fdfd47f 100644
--- a/dlls/advapi32/service.c
+++ b/dlls/advapi32/service.c
@@ -113,24 +113,6 @@ static BOOL stop_service;
 
 extern HANDLE CDECL __wine_make_process_system(void);
 
-/******************************************************************************
- * String management functions (same behaviour as strdup)
- * NOTE: the caller of those functions is responsible for calling HeapFree
- * in order to release the memory allocated by those functions.
- */
-LPWSTR SERV_dup( LPCSTR str )
-{
-    UINT len;
-    LPWSTR wstr;
-
-    if( !str )
-        return NULL;
-    len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
-    wstr = heap_alloc( len*sizeof (WCHAR) );
-    MultiByteToWideChar( CP_ACP, 0, str, -1, wstr, len );
-    return wstr;
-}
-
 static inline LPWSTR SERV_dupmulti(LPCSTR str)
 {
     UINT len = 0, n = 0;
@@ -884,8 +866,8 @@ SC_HANDLE WINAPI OpenSCManagerA( LPCSTR lpMachineName, LPCSTR lpDatabaseName,
     LPWSTR machineW, databaseW;
     SC_HANDLE ret;
 
-    machineW = SERV_dup(lpMachineName);
-    databaseW = SERV_dup(lpDatabaseName);
+    machineW = strdupAW(lpMachineName);
+    databaseW = strdupAW(lpDatabaseName);
     ret = OpenSCManagerW(machineW, databaseW, dwDesiredAccess);
     heap_free(databaseW);
     heap_free(machineW);
@@ -1037,7 +1019,7 @@ SC_HANDLE WINAPI OpenServiceA( SC_HANDLE hSCManager, LPCSTR lpServiceName,
 
     TRACE("%p %s 0x%08x\n", hSCManager, debugstr_a(lpServiceName), dwDesiredAccess);
 
-    lpServiceNameW = SERV_dup(lpServiceName);
+    lpServiceNameW = strdupAW(lpServiceName);
     ret = OpenServiceW( hSCManager, lpServiceNameW, dwDesiredAccess);
     heap_free(lpServiceNameW);
     return ret;
@@ -1171,13 +1153,13 @@ CreateServiceA( SC_HANDLE hSCManager, LPCSTR lpServiceName,
     TRACE("%p %s %s\n", hSCManager,
           debugstr_a(lpServiceName), debugstr_a(lpDisplayName));
 
-    lpServiceNameW = SERV_dup( lpServiceName );
-    lpDisplayNameW = SERV_dup( lpDisplayName );
-    lpBinaryPathNameW = SERV_dup( lpBinaryPathName );
-    lpLoadOrderGroupW = SERV_dup( lpLoadOrderGroup );
+    lpServiceNameW = strdupAW( lpServiceName );
+    lpDisplayNameW = strdupAW( lpDisplayName );
+    lpBinaryPathNameW = strdupAW( lpBinaryPathName );
+    lpLoadOrderGroupW = strdupAW( lpLoadOrderGroup );
     lpDependenciesW = SERV_dupmulti( lpDependencies );
-    lpServiceStartNameW = SERV_dup( lpServiceStartName );
-    lpPasswordW = SERV_dup( lpPassword );
+    lpServiceStartNameW = strdupAW( lpServiceStartName );
+    lpPasswordW = strdupAW( lpPassword );
 
     r = CreateServiceW( hSCManager, lpServiceNameW, lpDisplayNameW,
             dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl,
@@ -1269,7 +1251,7 @@ BOOL WINAPI StartServiceA( SC_HANDLE hService, DWORD dwNumServiceArgs,
         lpwstr = heap_alloc( dwNumServiceArgs*sizeof(LPWSTR) );
 
     for(i=0; i<dwNumServiceArgs; i++)
-        lpwstr[i]=SERV_dup(lpServiceArgVectors[i]);
+        lpwstr[i]=strdupAW(lpServiceArgVectors[i]);
 
     r = StartServiceW(hService, dwNumServiceArgs, (LPCWSTR *)lpwstr);
 
@@ -2108,7 +2090,7 @@ BOOL WINAPI GetServiceKeyNameA( SC_HANDLE hSCManager, LPCSTR lpDisplayName,
     TRACE("%p %s %p %p\n", hSCManager,
           debugstr_a(lpDisplayName), lpServiceName, lpcchBuffer);
 
-    lpDisplayNameW = SERV_dup(lpDisplayName);
+    lpDisplayNameW = strdupAW(lpDisplayName);
     if (lpServiceName)
         lpServiceNameW = heap_alloc(*lpcchBuffer * sizeof(WCHAR));
     else
@@ -2231,7 +2213,7 @@ BOOL WINAPI GetServiceDisplayNameA( SC_HANDLE hSCManager, LPCSTR lpServiceName,
     TRACE("%p %s %p %p\n", hSCManager,
           debugstr_a(lpServiceName), lpDisplayName, lpcchBuffer);
 
-    lpServiceNameW = SERV_dup(lpServiceName);
+    lpServiceNameW = strdupAW(lpServiceName);
     if (lpDisplayName)
         lpDisplayNameW = heap_alloc(*lpcchBuffer * sizeof(WCHAR));
     else
@@ -2374,12 +2356,12 @@ BOOL WINAPI ChangeServiceConfigA( SC_HANDLE hService, DWORD dwServiceType,
           lpdwTagId, lpDependencies, debugstr_a(lpServiceStartName),
           debugstr_a(lpPassword), debugstr_a(lpDisplayName) );
 
-    wBinaryPathName = SERV_dup( lpBinaryPathName );
-    wLoadOrderGroup = SERV_dup( lpLoadOrderGroup );
+    wBinaryPathName = strdupAW( lpBinaryPathName );
+    wLoadOrderGroup = strdupAW( lpLoadOrderGroup );
     wDependencies = SERV_dupmulti( lpDependencies );
-    wServiceStartName = SERV_dup( lpServiceStartName );
-    wPassword = SERV_dup( lpPassword );
-    wDisplayName = SERV_dup( lpDisplayName );
+    wServiceStartName = strdupAW( lpServiceStartName );
+    wPassword = strdupAW( lpPassword );
+    wDisplayName = strdupAW( lpDisplayName );
 
     r = ChangeServiceConfigW( hService, dwServiceType,
             dwStartType, dwErrorControl, wBinaryPathName,
@@ -2411,7 +2393,7 @@ BOOL WINAPI ChangeServiceConfig2A( SC_HANDLE hService, DWORD dwInfoLevel,
         LPSERVICE_DESCRIPTIONA sd = lpInfo;
         SERVICE_DESCRIPTIONW sdw;
 
-        sdw.lpDescription = SERV_dup( sd->lpDescription );
+        sdw.lpDescription = strdupAW( sd->lpDescription );
 
         r = ChangeServiceConfig2W( hService, dwInfoLevel, &sdw );
 
@@ -2423,8 +2405,8 @@ BOOL WINAPI ChangeServiceConfig2A( SC_HANDLE hService, DWORD dwInfoLevel,
         SERVICE_FAILURE_ACTIONSW faw;
 
         faw.dwResetPeriod = fa->dwResetPeriod;
-        faw.lpRebootMsg = SERV_dup( fa->lpRebootMsg );
-        faw.lpCommand = SERV_dup( fa->lpCommand );
+        faw.lpRebootMsg = strdupAW( fa->lpRebootMsg );
+        faw.lpCommand = strdupAW( fa->lpCommand );
         faw.cActions = fa->cActions;
         faw.lpsaActions = fa->lpsaActions;
 
@@ -2589,7 +2571,7 @@ SERVICE_STATUS_HANDLE WINAPI RegisterServiceCtrlHandlerExA( LPCSTR name, LPHANDL
     LPWSTR nameW;
     SERVICE_STATUS_HANDLE ret;
 
-    nameW = SERV_dup(name);
+    nameW = strdupAW(name);
     ret = RegisterServiceCtrlHandlerExW( nameW, handler, context );
     heap_free( nameW );
     return ret;

From 113bb7dc9b661b2ed1701266122d0e56c98562b0 Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:16 -0600
Subject: [PATCH] sechost: Implement I_ScRegisterDeviceNotification()

Implement I_ScRegisterDeviceNotification and
I_ScUnregisterDeviceNotification in sechost via RPC to services.exe

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 dlls/sechost/sechost.spec |   2 +
 dlls/sechost/service.c    | 141 ++++++++++++++++++++++++++++++++++++++
 include/wine/svcctl.idl   |  13 ++++
 include/winsvc.h          |  14 ++++
 programs/services/rpc.c   | 124 ++++++++++++++++++++++++++++++++-
 5 files changed, 293 insertions(+), 1 deletion(-)

diff --git a/dlls/sechost/sechost.spec b/dlls/sechost/sechost.spec
index 985f638f8ff..1deb3406195 100644
--- a/dlls/sechost/sechost.spec
+++ b/dlls/sechost/sechost.spec
@@ -17,6 +17,8 @@
 @ stdcall GetServiceDisplayNameW(ptr wstr ptr ptr)
 @ stdcall GetServiceKeyNameA(long str ptr ptr)
 @ stdcall GetServiceKeyNameW(long wstr ptr ptr)
+@ stdcall I_ScRegisterDeviceNotification(ptr ptr long)
+@ stdcall I_ScUnregisterDeviceNotification(ptr)
 @ stdcall LockServiceDatabase(ptr)
 @ stdcall NotifyServiceStatusChangeW(ptr long ptr)
 @ stdcall OpenSCManagerA(str str long)
diff --git a/dlls/sechost/service.c b/dlls/sechost/service.c
index 71eda08605a..ac9d8684999 100644
--- a/dlls/sechost/service.c
+++ b/dlls/sechost/service.c
@@ -96,6 +96,14 @@ typedef struct notify_data_t {
 
 static struct list notify_list = LIST_INIT(notify_list);
 
+struct device_notify_registration {
+    DEVICE_NOTIFICATION_DETAILS details;
+    struct list entry;
+};
+
+static struct list device_notify_list = LIST_INIT(device_notify_list);
+HANDLE device_notify_thread = NULL;
+
 static CRITICAL_SECTION service_cs;
 static CRITICAL_SECTION_DEBUG service_cs_debug =
 {
@@ -2767,3 +2775,136 @@ DWORD WINAPI NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask,
 
     return ERROR_SUCCESS;
 }
+
+static DWORD WINAPI device_notification_thread(void *user)
+{
+    DWORD err;
+    struct device_notify_registration *registration;
+    SC_DEV_NOTIFY_RPC_HANDLE handle = NULL;
+    DWORD code;
+    DWORD buf_size;
+    BYTE *buf;
+
+    __TRY
+    {
+        err = svcctl_OpenDeviceNotificationHandle(NULL, &handle);
+    }
+    __EXCEPT(rpc_filter)
+    {
+        err = map_exception_code(GetExceptionCode());
+    }
+    __ENDTRY
+
+    if (!handle)
+    {
+        WARN("OpenDeviceNotificationHandle server call failed: %d\n", err);
+        return 1;
+    }
+
+    for (;;)
+    {
+        buf = NULL;
+        __TRY
+        {
+            /* GetDeviceNotificationResults blocks until there is an event */
+            err = svcctl_GetDeviceNotificationResults(handle, &code, &buf, &buf_size);
+        }
+        __EXCEPT(rpc_filter)
+        {
+            err = map_exception_code(GetExceptionCode());
+        }
+        __ENDTRY
+
+        if (err != ERROR_SUCCESS)
+        {
+            WARN("GetDeviceNotificationResults server call failed: %d\n", err);
+            if (buf)
+                MIDL_user_free(buf);
+            Sleep(100);
+            continue;
+        }
+
+        EnterCriticalSection(&service_cs);
+        LIST_FOR_EACH_ENTRY(registration, &device_notify_list, struct device_notify_registration, entry)
+        {
+            registration->details.pNotificationCallback(registration->details.hRecipient,
+                    code, (DEV_BROADCAST_HDR *) buf);
+        }
+        LeaveCriticalSection(&service_cs);
+        MIDL_user_free(buf);
+    }
+}
+
+/******************************************************************************
+ * I_ScRegisterDeviceNotification [SECHOST.@]
+ */
+HDEVNOTIFY WINAPI I_ScRegisterDeviceNotification(DEVICE_NOTIFICATION_DETAILS *details, LPVOID filter, DWORD flags)
+{
+    struct device_notify_registration *registration;
+
+    TRACE("(%p)\n", details->hRecipient);
+
+    /* This implementation is not overly concerned with sending too many
+     * messages, so support for filters is not yet implemented.
+     */
+    if (filter)
+        FIXME("Notification filters are not yet implemented! All device notification events will be sent.\n");
+
+    if (!details || !details->pNotificationCallback)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return NULL;
+    }
+
+    registration = heap_alloc(sizeof(struct device_notify_registration));
+    if (!registration)
+    {
+        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+        return NULL;
+    }
+
+    memcpy(&registration->details, details, sizeof(DEVICE_NOTIFICATION_DETAILS));
+
+    EnterCriticalSection(&service_cs);
+    list_add_tail(&device_notify_list, &registration->entry);
+
+    if (!device_notify_thread)
+        device_notify_thread = CreateThread(NULL, 0, &device_notification_thread, NULL, 0, NULL);
+
+    LeaveCriticalSection(&service_cs);
+
+    return (HDEVNOTIFY) registration;
+}
+
+/******************************************************************************
+ * I_ScUnregisterDeviceNotification [SECHOST.@]
+ */
+BOOL WINAPI I_ScUnregisterDeviceNotification(HDEVNOTIFY notificationHandle)
+{
+    struct device_notify_registration *item, *registration = NULL;
+
+    TRACE("(%p)\n", notificationHandle);
+
+    EnterCriticalSection(&service_cs);
+    LIST_FOR_EACH_ENTRY(item, &device_notify_list, struct device_notify_registration, entry)
+    {
+        if (item == notificationHandle)
+        {
+            registration = item;
+            break;
+        }
+    }
+
+    if (registration)
+        list_remove(&registration->entry);
+    LeaveCriticalSection(&service_cs);
+
+    if (!registration)
+    {
+        SetLastError(ERROR_INVALID_HANDLE);
+        return FALSE;
+    }
+
+    heap_free(registration);
+    return TRUE;
+}
diff --git a/include/wine/svcctl.idl b/include/wine/svcctl.idl
index c14cd6bb50c..0d75cf73c4c 100644
--- a/include/wine/svcctl.idl
+++ b/include/wine/svcctl.idl
@@ -62,6 +62,7 @@ interface svcctl
     typedef [context_handle] void *SC_RPC_HANDLE;
     typedef [context_handle] void *SC_RPC_LOCK;
     typedef [context_handle] void *SC_NOTIFY_RPC_HANDLE;
+    typedef [context_handle] void *SC_DEV_NOTIFY_RPC_HANDLE;
 
     /* undocumented access rights */
     cpp_quote("#define SERVICE_SET_STATUS   0x8000")
@@ -805,4 +806,16 @@ typedef [switch_type(DWORD)] union _SC_RPC_SERVICE_CONTROL_OUT_PARAMSW {
         [in] DWORD info_level,
         [out] SC_RPC_CONFIG_INFOW *info
     );
+
+    /* Not compatible with Windows function 57 */
+    DWORD svcctl_OpenDeviceNotificationHandle(
+        [in, string, unique] SVCCTL_HANDLEW machinename,
+        [out] SC_DEV_NOTIFY_RPC_HANDLE *handle);
+
+    /* Not compatible with Windows function 58 */
+    DWORD svcctl_GetDeviceNotificationResults(
+        [in] SC_DEV_NOTIFY_RPC_HANDLE handle,
+        [out] DWORD *event_code,
+        [out, size_is(,*event_size)] BYTE **event,
+        [out] DWORD *event_size);
 }
diff --git a/include/winsvc.h b/include/winsvc.h
index aa5e9f1ae88..d420535447a 100644
--- a/include/winsvc.h
+++ b/include/winsvc.h
@@ -376,6 +376,18 @@ typedef struct _QUERY_SERVICE_LOCK_STATUSW
 
 DECL_WINELIB_TYPE_AW(QUERY_SERVICE_LOCK_STATUS)
 
+#ifndef HDEVNOTIFY
+typedef  PVOID           HDEVNOTIFY;
+#endif
+#include "dbt.h"
+typedef DWORD (CALLBACK *REGISTER_DEVICE_NOTIFY_CALLBACK)(HANDLE hRecipient,
+    DWORD flags, DEV_BROADCAST_HDR *);
+typedef struct _DEVICE_NOTIFICATION_DETAILS
+{
+    REGISTER_DEVICE_NOTIFY_CALLBACK pNotificationCallback;
+    HANDLE hRecipient;
+} DEVICE_NOTIFICATION_DETAILS;
+
 /* Service control handler function prototype */
 
 typedef VOID (WINAPI *LPHANDLER_FUNCTION)(DWORD);
@@ -445,6 +457,8 @@ WINADVAPI BOOL        WINAPI StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENT
 WINADVAPI BOOL        WINAPI StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW*);
 #define                      StartServiceCtrlDispatcher WINELIB_NAME_AW(StartServiceCtrlDispatcher)
 WINADVAPI BOOL        WINAPI UnlockServiceDatabase(SC_LOCK);
+WINADVAPI HDEVNOTIFY  WINAPI I_ScRegisterDeviceNotification(DEVICE_NOTIFICATION_DETAILS *details, LPVOID filter, DWORD flags);
+WINADVAPI BOOL        WINAPI I_ScUnregisterDeviceNotification(HDEVNOTIFY notificationHandle);
 
 #ifdef __cplusplus
 } /* extern "C" */
diff --git a/programs/services/rpc.c b/programs/services/rpc.c
index 41501024dac..d48438cebd9 100644
--- a/programs/services/rpc.c
+++ b/programs/services/rpc.c
@@ -59,7 +59,8 @@ typedef enum
     SC_HTYPE_DONT_CARE = 0,
     SC_HTYPE_MANAGER,
     SC_HTYPE_SERVICE,
-    SC_HTYPE_NOTIFY
+    SC_HTYPE_NOTIFY,
+    SC_HTYPE_DEV_NOTIFY
 } SC_HANDLE_TYPE;
 
 struct sc_handle
@@ -83,6 +84,23 @@ struct sc_notify_handle
     SC_RPC_NOTIFY_PARAMS_LIST *params_list;
 };
 
+struct devnotify_event
+{
+    struct list entry;
+    DWORD code;
+    BYTE *data;
+    DWORD data_size;
+};
+
+struct sc_dev_notify_handle
+{
+    struct sc_handle hdr;
+    struct list entry;
+    HANDLE event;
+    CRITICAL_SECTION cs;
+    struct list event_list;
+};
+
 struct sc_service_handle       /* service handle */
 {
     struct sc_handle hdr;
@@ -117,6 +135,9 @@ static const WCHAR emptyW[] = {0};
 static PTP_CLEANUP_GROUP cleanup_group;
 HANDLE exit_event;
 
+static struct list devnotify_listeners = LIST_INIT(devnotify_listeners);
+CRITICAL_SECTION device_notifications_cs;
+
 static void CALLBACK group_cancel_callback(void *object, void *userdata)
 {
     struct process_entry *process = object;
@@ -264,6 +285,15 @@ static DWORD validate_notify_handle(SC_RPC_HANDLE handle, DWORD needed_access, s
     return err;
 }
 
+static DWORD validate_dev_notify_handle(SC_RPC_HANDLE handle, DWORD needed_access, struct sc_dev_notify_handle **notify)
+{
+    struct sc_handle *hdr;
+    DWORD err = validate_context_handle(handle, SC_HTYPE_DEV_NOTIFY, needed_access, &hdr);
+    if (err == ERROR_SUCCESS)
+        *notify = (struct sc_dev_notify_handle *)hdr;
+    return err;
+}
+
 DWORD __cdecl svcctl_OpenSCManagerW(
     MACHINE_HANDLEW MachineName, /* Note: this parameter is ignored */
     LPCWSTR DatabaseName,
@@ -323,6 +353,28 @@ static void SC_RPC_HANDLE_destroy(SC_RPC_HANDLE handle)
             HeapFree(GetProcessHeap(), 0, service);
             break;
         }
+        case SC_HTYPE_DEV_NOTIFY:
+        {
+            struct devnotify_event *event, *next;
+            struct sc_dev_notify_handle *listener = (struct sc_dev_notify_handle *)hdr;
+
+            /* Destroy this handle and stop sending events to this caller */
+            EnterCriticalSection(&device_notifications_cs);
+            WINE_TRACE("Removing device notification listener from list (%p)\n", listener);
+            list_remove(&listener->entry);
+            LeaveCriticalSection(&device_notifications_cs);
+
+            LIST_FOR_EACH_ENTRY_SAFE(event, next, &listener->event_list, struct devnotify_event, entry)
+            {
+                list_remove(&event->entry);
+                MIDL_user_free(event->data);
+                HeapFree(GetProcessHeap(), 0, event);
+            }
+
+            CloseHandle(listener->event);
+            HeapFree(GetProcessHeap(), 0, listener);
+            break;
+        }
         default:
             WINE_ERR("invalid handle type %d\n", hdr->type);
             RpcRaiseException(ERROR_INVALID_HANDLE);
@@ -2129,12 +2181,78 @@ DWORD __cdecl svcctl_QueryServiceConfig2A(
     return ERROR_CALL_NOT_IMPLEMENTED;
 }
 
+DWORD __cdecl svcctl_OpenDeviceNotificationHandle(
+    MACHINE_HANDLEW MachineName, /* Note: this parameter is ignored */
+    SC_DEV_NOTIFY_RPC_HANDLE *handle)
+{
+    struct sc_dev_notify_handle *listener;
+
+    if (!(listener = HeapAlloc(GetProcessHeap(), 0, sizeof(*listener))))
+        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
+
+    listener->hdr.type = SC_HTYPE_DEV_NOTIFY;
+    listener->hdr.access = 0;
+
+    InitializeCriticalSection(&listener->cs);
+    listener->event = CreateEventW(NULL, TRUE, FALSE, NULL);
+    list_init(&listener->event_list);
+
+    WINE_TRACE("Adding listener to list (%p)\n", listener);
+    EnterCriticalSection(&device_notifications_cs);
+    list_add_tail(&devnotify_listeners, &listener->entry);
+    LeaveCriticalSection(&device_notifications_cs);
+
+    *handle = &listener->hdr;
+    return ERROR_SUCCESS;
+}
+
+DWORD __cdecl svcctl_GetDeviceNotificationResults(
+    SC_DEV_NOTIFY_RPC_HANDLE handle,
+    LPDWORD code,
+    BYTE **event_dest,
+    LPDWORD event_dest_size)
+{
+    struct devnotify_event *event;
+    struct sc_dev_notify_handle *listener;
+    DWORD err;
+
+    if ((err = validate_dev_notify_handle(handle, 0, &listener)) != 0)
+        return err;
+
+    if (!event_dest || !event_dest_size || !code)
+        return ERROR_INVALID_PARAMETER;
+
+    do
+    {
+        /* block until there is a result */
+        WaitForSingleObject(listener->event, INFINITE);
+
+        EnterCriticalSection(&listener->cs);
+        if ((event = LIST_ENTRY(list_head(&listener->event_list), struct devnotify_event, entry)))
+            list_remove(&event->entry);
+        else
+            ResetEvent(listener->event);
+        LeaveCriticalSection(&listener->cs);
+    } while (!event);
+
+    WINE_TRACE("Got an event (%p)\n", event);
+    *code = event->code;
+
+    *event_dest = event->data;
+    *event_dest_size = event->data_size;
+
+    HeapFree(GetProcessHeap(), 0, event);
+    return ERROR_SUCCESS;
+}
+
 DWORD RPC_Init(void)
 {
     WCHAR transport[] = SVCCTL_TRANSPORT;
     WCHAR endpoint[] = SVCCTL_ENDPOINT;
     DWORD err;
 
+    InitializeCriticalSection(&device_notifications_cs);
+
     if (!(cleanup_group = CreateThreadpoolCleanupGroup()))
     {
         WINE_ERR("CreateThreadpoolCleanupGroup failed with error %u\n", GetLastError());
@@ -2183,6 +2301,10 @@ void __RPC_USER SC_NOTIFY_RPC_HANDLE_rundown(SC_NOTIFY_RPC_HANDLE handle)
 {
 }
 
+void __RPC_USER SC_DEV_NOTIFY_RPC_HANDLE_rundown(SC_DEV_NOTIFY_RPC_HANDLE handle)
+{
+}
+
 void  __RPC_FAR * __RPC_USER MIDL_user_allocate(SIZE_T len)
 {
     return HeapAlloc(GetProcessHeap(), 0, len);

From ffad3279fca6ed9ab199a0ed735c715b77a4fe46 Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:17 -0600
Subject: [PATCH] ntoskrnl.exe: Implement sending of device notifications

Send device notifications via RPC to services.exe

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 dlls/ntoskrnl.exe/Makefile.in        |   4 +-
 dlls/ntoskrnl.exe/ntoskrnl_private.h |   5 +
 dlls/ntoskrnl.exe/pnp.c              |   1 +
 dlls/ntoskrnl.exe/rpc.c              | 182 +++++++++++++++++++++++++++
 dlls/ntoskrnl.exe/svcctl.idl         |   3 +
 include/wine/svcctl.idl              |   7 ++
 programs/services/rpc.c              |  45 +++++++
 7 files changed, 246 insertions(+), 1 deletion(-)
 create mode 100644 dlls/ntoskrnl.exe/rpc.c
 create mode 100644 dlls/ntoskrnl.exe/svcctl.idl

diff --git a/dlls/ntoskrnl.exe/Makefile.in b/dlls/ntoskrnl.exe/Makefile.in
index a75ca9768d9..441238177a2 100644
--- a/dlls/ntoskrnl.exe/Makefile.in
+++ b/dlls/ntoskrnl.exe/Makefile.in
@@ -1,7 +1,7 @@
 MODULE    = ntoskrnl.exe
 IMPORTLIB = ntoskrnl
 IMPORTS   = advapi32 hal
-DELAYIMPORTS = setupapi user32
+DELAYIMPORTS = setupapi user32 rpcrt4
 
 EXTRADLLFLAGS = -mno-cygwin
 
@@ -9,6 +9,8 @@ C_SRCS = \
 	instr.c \
 	ntoskrnl.c \
 	pnp.c \
+	rpc.c \
 	sync.c
+IDL_SRCS  = svcctl.idl
 
 RC_SRCS = ntoskrnl.rc
diff --git a/dlls/ntoskrnl.exe/ntoskrnl_private.h b/dlls/ntoskrnl.exe/ntoskrnl_private.h
index 2823a1cd4f1..69e5f60e7c6 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl_private.h
+++ b/dlls/ntoskrnl.exe/ntoskrnl_private.h
@@ -22,6 +22,8 @@
 #define __WINE_NTOSKRNL_PRIVATE_H
 
 #include "wine/asm.h"
+#include "winuser.h"
+#include "dbt.h"
 
 static inline LPCSTR debugstr_us( const UNICODE_STRING *us )
 {
@@ -82,6 +82,8 @@ static const WCHAR servicesW[] = {'\\','R','e','g','i','s','t','r','y',
                                   '\\','C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t',
                                   '\\','S','e','r','v','i','c','e','s',
                                   '\\',0};
+
+DWORD send_device_notification( DEV_BROADCAST_DEVICEINTERFACE_W *broadcast, BOOL enable );
 
 struct wine_device
 {
     DEVICE_OBJECT device_obj;
diff --git a/dlls/ntoskrnl.exe/pnp.c b/dlls/ntoskrnl.exe/pnp.c
index 9725b5a6e16..f874fc9b3b8 100644
--- a/dlls/ntoskrnl.exe/pnp.c
+++ b/dlls/ntoskrnl.exe/pnp.c
@@ -672,6 +672,7 @@ NTSTATUS WINAPI IoSetDeviceInterfaceState( UNICODE_STRING *name, BOOLEAN enable
         lstrcpynW( broadcast->dbcc_name, name->Buffer, namelen + 1 );
         BroadcastSystemMessageW( BSF_FORCEIFHUNG | BSF_QUERY, NULL, WM_DEVICECHANGE,
             enable ? DBT_DEVICEARRIVAL : DBT_DEVICEREMOVECOMPLETE, (LPARAM)broadcast );
+        send_device_notification( broadcast, enable );
 
         heap_free( broadcast );
     }
diff --git a/dlls/ntoskrnl.exe/rpc.c b/dlls/ntoskrnl.exe/rpc.c
new file mode 100644
index 00000000000..a4779a168a4
--- /dev/null
+++ b/dlls/ntoskrnl.exe/rpc.c
@@ -0,0 +1,182 @@
+/*
+ * RPC connection with services.exe
+ *
+ * Copyright 1995 Sven Verdoolaege
+ * Copyright 2005 Mike McCormack
+ * Copyright 2007 Rolf Kalbermatter
+ * Copyright 2019 Micah N Gorrell for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winreg.h"
+#include "winsvc.h"
+#include "winternl.h"
+#include "dbt.h"
+#include "svcctl.h"
+#include "wine/exception.h"
+#include "ddk/ntifs.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+#include "wine/rbtree.h"
+
+#include "ntoskrnl_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(plugplay);
+
+/******************************************************************************
+ * RPC connection with services.exe
+ */
+void __RPC_FAR * __RPC_USER MIDL_user_allocate(SIZE_T len)
+{
+    return heap_alloc(len);
+}
+
+void __RPC_USER MIDL_user_free(void __RPC_FAR * ptr)
+{
+    heap_free(ptr);
+}
+
+static handle_t rpc_wstr_bind(RPC_WSTR str)
+{
+    WCHAR transport[] = SVCCTL_TRANSPORT;
+    WCHAR endpoint[] = SVCCTL_ENDPOINT;
+    RPC_WSTR binding_str;
+    RPC_STATUS status;
+    handle_t rpc_handle;
+
+    status = RpcStringBindingComposeW(NULL, transport, str, endpoint, NULL, &binding_str);
+    if (status != RPC_S_OK)
+    {
+        ERR("RpcStringBindingComposeW failed (%d)\n", (DWORD)status);
+        return NULL;
+    }
+
+    status = RpcBindingFromStringBindingW(binding_str, &rpc_handle);
+    RpcStringFreeW(&binding_str);
+
+    if (status != RPC_S_OK)
+    {
+        ERR("Couldn't connect to services.exe: error code %u\n", (DWORD)status);
+        return NULL;
+    }
+
+    return rpc_handle;
+}
+
+static handle_t rpc_cstr_bind(RPC_CSTR str)
+{
+    RPC_CSTR transport = (RPC_CSTR)SVCCTL_TRANSPORTA;
+    RPC_CSTR endpoint = (RPC_CSTR)SVCCTL_ENDPOINTA;
+    RPC_CSTR binding_str;
+    RPC_STATUS status;
+    handle_t rpc_handle;
+
+    status = RpcStringBindingComposeA(NULL, transport, str, endpoint, NULL, &binding_str);
+    if (status != RPC_S_OK)
+    {
+        ERR("RpcStringBindingComposeW failed (%d)\n", (DWORD)status);
+        return NULL;
+    }
+
+    status = RpcBindingFromStringBindingA(binding_str, &rpc_handle);
+    RpcStringFreeA(&binding_str);
+
+    if (status != RPC_S_OK)
+    {
+        ERR("Couldn't connect to services.exe: error code %u\n", (DWORD)status);
+        return NULL;
+    }
+
+    return rpc_handle;
+}
+
+DECLSPEC_HIDDEN handle_t __RPC_USER MACHINE_HANDLEA_bind(MACHINE_HANDLEA MachineName)
+{
+    return rpc_cstr_bind((RPC_CSTR)MachineName);
+}
+
+DECLSPEC_HIDDEN void __RPC_USER MACHINE_HANDLEA_unbind(MACHINE_HANDLEA MachineName, handle_t h)
+{
+    RpcBindingFree(&h);
+}
+
+DECLSPEC_HIDDEN handle_t __RPC_USER MACHINE_HANDLEW_bind(MACHINE_HANDLEW MachineName)
+{
+    return rpc_wstr_bind((RPC_WSTR)MachineName);
+}
+
+DECLSPEC_HIDDEN void __RPC_USER MACHINE_HANDLEW_unbind(MACHINE_HANDLEW MachineName, handle_t h)
+{
+    RpcBindingFree(&h);
+}
+
+DECLSPEC_HIDDEN handle_t __RPC_USER SVCCTL_HANDLEW_bind(SVCCTL_HANDLEW MachineName)
+{
+    return rpc_wstr_bind((RPC_WSTR)MachineName);
+}
+
+DECLSPEC_HIDDEN void __RPC_USER SVCCTL_HANDLEW_unbind(SVCCTL_HANDLEW MachineName, handle_t h)
+{
+    RpcBindingFree(&h);
+}
+
+static LONG WINAPI rpc_filter(EXCEPTION_POINTERS *eptr)
+{
+    return I_RpcExceptionFilter(eptr->ExceptionRecord->ExceptionCode);
+}
+
+static DWORD map_exception_code(DWORD exception_code)
+{
+    switch (exception_code)
+    {
+    case RPC_X_NULL_REF_POINTER:
+        return ERROR_INVALID_ADDRESS;
+    case RPC_X_ENUM_VALUE_OUT_OF_RANGE:
+    case RPC_X_BYTE_COUNT_TOO_SMALL:
+        return ERROR_INVALID_PARAMETER;
+    case RPC_S_INVALID_BINDING:
+    case RPC_X_SS_IN_NULL_CONTEXT:
+        return ERROR_INVALID_HANDLE;
+    default:
+        return exception_code;
+    }
+}
+
+DWORD send_device_notification(DEV_BROADCAST_DEVICEINTERFACE_W *broadcast, BOOL enable)
+{
+    DWORD err;
+
+    __TRY
+    {
+        err = svcctl_SendDeviceNotification(NULL,
+                    enable ? DBT_DEVICEARRIVAL : DBT_DEVICEREMOVECOMPLETE,
+                    (const BYTE *) broadcast, broadcast->dbcc_size);
+    }
+    __EXCEPT(rpc_filter)
+    {
+        err = map_exception_code(GetExceptionCode());
+    }
+    __ENDTRY
+
+    TRACE("send result (%d)\n", err);
+    return err;
+}
diff --git a/dlls/ntoskrnl.exe/svcctl.idl b/dlls/ntoskrnl.exe/svcctl.idl
new file mode 100644
index 00000000000..b1bc8545d78
--- /dev/null
+++ b/dlls/ntoskrnl.exe/svcctl.idl
@@ -0,0 +1,3 @@
+#pragma makedep client
+
+#include "wine/svcctl.idl"
diff --git a/include/wine/svcctl.idl b/include/wine/svcctl.idl
index 0d75cf73c4c..2399f3f5fd6 100644
--- a/include/wine/svcctl.idl
+++ b/include/wine/svcctl.idl
@@ -818,4 +818,11 @@ typedef [switch_type(DWORD)] union _SC_RPC_SERVICE_CONTROL_OUT_PARAMSW {
         [out] DWORD *event_code,
         [out, size_is(,*event_size)] BYTE **event,
         [out] DWORD *event_size);
+
+    /* Not compatible with Windows function 59 */
+    DWORD svcctl_SendDeviceNotification(
+        [in, string, unique] SVCCTL_HANDLEW machinename,
+        [in] DWORD event_code,
+        [in, size_is(event_size)] const BYTE *event,
+        [in] DWORD event_size);
 }
diff --git a/programs/services/rpc.c b/programs/services/rpc.c
index d48438cebd9..a9a12a0565c 100644
--- a/programs/services/rpc.c
+++ b/programs/services/rpc.c
@@ -2245,6 +2245,51 @@ DWORD __cdecl svcctl_GetDeviceNotificationResults(
     return ERROR_SUCCESS;
 }
 
+DWORD __cdecl svcctl_SendDeviceNotification(
+    MACHINE_HANDLEW MachineName, /* Note: this parameter is ignored */
+    DWORD code,
+    const BYTE *event_buf,
+    DWORD event_buf_size)
+{
+    struct sc_dev_notify_handle *listener;
+    struct devnotify_event *event;
+
+    if (!event_buf)
+        return ERROR_INVALID_PARAMETER;
+
+    EnterCriticalSection(&device_notifications_cs);
+    LIST_FOR_EACH_ENTRY(listener, &devnotify_listeners, struct sc_dev_notify_handle, entry)
+    {
+        WINE_TRACE("Triggering listener %p\n", listener);
+
+        event = HeapAlloc(GetProcessHeap(), 0, sizeof(struct devnotify_event));
+        if (event)
+            event->data = MIDL_user_allocate(event_buf_size);
+
+        if (!event || !event->data)
+        {
+            HeapFree(GetProcessHeap(), 0, event);
+
+            LeaveCriticalSection(&device_notifications_cs);
+            return ERROR_NOT_ENOUGH_SERVER_MEMORY;
+        }
+
+        event->code = code;
+        memcpy(event->data, event_buf, event_buf_size);
+        event->data_size = event_buf_size;
+
+        EnterCriticalSection(&listener->cs);
+        list_add_tail(&listener->event_list, &event->entry);
+        LeaveCriticalSection(&listener->cs);
+
+        SetEvent(listener->event);
+    }
+    WINE_TRACE("Done triggering registrations\n");
+    LeaveCriticalSection(&device_notifications_cs);
+
+    return ERROR_SUCCESS;
+}
+
 DWORD RPC_Init(void)
 {
     WCHAR transport[] = SVCCTL_TRANSPORT;

From 0d3322b962c33f4fe603ba82af4f8cd2a7f23727 Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:18 -0600
Subject: [PATCH] user32: Implement RegisterDeviceNotification()

Implement RegisterDeviceNotification() and UnregisterDeviceNotification()
using I_ScRegisterDeviceNotification() and
I_ScUnregisterDeviceNotification() in sechost.dll

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 dlls/user32/Makefile.in |  2 +-
 dlls/user32/misc.c      | 73 +++++++++++++++++++++++++++++++++++------
 include/winuser.h       |  4 ++-
 3 files changed, 67 insertions(+), 12 deletions(-)

diff --git a/dlls/user32/Makefile.in b/dlls/user32/Makefile.in
index d420dcb45aa..bd3660331eb 100644
--- a/dlls/user32/Makefile.in
+++ b/dlls/user32/Makefile.in
@@ -1,7 +1,7 @@
 EXTRADEFS = -D_USER32_ -D_WINABLE_
 MODULE    = user32.dll
 IMPORTLIB = user32
-IMPORTS   = gdi32 version advapi32
+IMPORTS   = gdi32 version advapi32 sechost
 EXTRAINCL = $(PNG_CFLAGS)
 DELAYIMPORTS = hid imm32 setupapi usp10
 
diff --git a/dlls/user32/misc.c b/dlls/user32/misc.c
index 60d45dff471..8042c044059 100644
--- a/dlls/user32/misc.c
+++ b/dlls/user32/misc.c
@@ -4,6 +4,7 @@
  * Copyright 1995 Thomas Sandford
  * Copyright 1997 Marcus Meissner
  * Copyright 1998 Turchanov Sergey
+ * Copyright 2019 Micah N Gorrell for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -37,6 +38,7 @@
 #include "devguid.h"
 #include "setupapi.h"
 #include "user_private.h"
+#include "winsvc.h"
 
 #include "wine/unicode.h"
 #include "wine/debug.h"
@@ -602,17 +604,39 @@ DWORD WINAPI RegisterTasklist (DWORD x)
     return TRUE;
 }
 
+static DWORD CALLBACK devnotify_window_callback(HANDLE hRecipient, DWORD flags, DEV_BROADCAST_HDR *dbh)
+{
+    SendMessageTimeoutW(hRecipient, WM_DEVICECHANGE, flags,
+        (LPARAM) dbh, SMTO_ABORTIFHUNG, 2000, NULL);
+    return 0;
+}
+
+static DWORD CALLBACK devnotify_service_callback(HANDLE hRecipient, DWORD flags, DEV_BROADCAST_HDR *dbh)
+{
+    FIXME("Support for service handles is not yet implemented!\n");
+    ControlService(hRecipient, SERVICE_CONTROL_DEVICEEVENT, NULL);
+    return 0;
+}
+
+static DWORD CALLBACK devnotify_null_callback(HANDLE hRecipient, DWORD flags, DEV_BROADCAST_HDR *dbh)
+{
+    /* The WM_DEVICECHANGE event is broadcast directly from ntoskrnl.exe so
+     * nothing needs to be done here. */
+    return 0;
+}
 
 /***********************************************************************
  *		RegisterDeviceNotificationA (USER32.@)
  *
  * See RegisterDeviceNotificationW.
  */
-HDEVNOTIFY WINAPI RegisterDeviceNotificationA(HANDLE hnd, LPVOID notifyfilter, DWORD flags)
+HDEVNOTIFY WINAPI RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID pNotificationFilter, DWORD dwFlags)
 {
-    FIXME("(hwnd=%p, filter=%p,flags=0x%08x) returns a fake device notification handle!\n",
-          hnd,notifyfilter,flags );
-    return (HDEVNOTIFY) 0xcafecafe;
+    TRACE("(hwnd=%p, filter=%p,flags=0x%08x)\n",
+        hRecipient,pNotificationFilter,dwFlags);
+    if (pNotificationFilter)
+        FIXME("The notification filter will requires an A->W when filter support is implemented\n");
+    return RegisterDeviceNotificationW(hRecipient, pNotificationFilter, dwFlags);
 }
 
 /***********************************************************************
@@ -640,19 +664,48 @@ HDEVNOTIFY WINAPI RegisterDeviceNotificationA(HANDLE hnd, LPVOID notifyfilter, D
  */
 HDEVNOTIFY WINAPI RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID pNotificationFilter, DWORD dwFlags)
 {
-    FIXME("(hwnd=%p, filter=%p,flags=0x%08x) returns a fake device notification handle!\n",
-          hRecipient,pNotificationFilter,dwFlags );
-    return (HDEVNOTIFY) 0xcafeaffe;
+    DEVICE_NOTIFICATION_DETAILS details;
+
+    TRACE("(hwnd=%p, filter=%p,flags=0x%08x)\n",
+        hRecipient,pNotificationFilter,dwFlags);
+
+    if (dwFlags & DEVICE_NOTIFY_ALL_INTERFACE_CLASSES)
+    {
+        dwFlags &= ~DEVICE_NOTIFY_ALL_INTERFACE_CLASSES;
+        pNotificationFilter = NULL;
+    }
+
+    details.hRecipient = hRecipient;
+
+    switch (dwFlags) {
+    case DEVICE_NOTIFY_WINDOW_HANDLE:
+        details.pNotificationCallback = devnotify_window_callback;
+        break;
+
+    case DEVICE_NOTIFY_SERVICE_HANDLE:
+        details.pNotificationCallback = devnotify_service_callback;
+        break;
+
+    default:
+        SetLastError(ERROR_INVALID_FLAGS);
+        return 0;
+    }
+
+    if (!hRecipient)
+        details.pNotificationCallback = devnotify_null_callback;
+
+    return I_ScRegisterDeviceNotification(&details, pNotificationFilter, 0);
 }
 
 /***********************************************************************
  *		UnregisterDeviceNotification (USER32.@)
  *
  */
-BOOL  WINAPI UnregisterDeviceNotification(HDEVNOTIFY hnd)
+BOOL WINAPI UnregisterDeviceNotification(HDEVNOTIFY hnd)
 {
-    FIXME("(handle=%p), STUB!\n", hnd);
-    return TRUE;
+    TRACE("(hnd=%p)\n", hnd);
+
+    return I_ScUnregisterDeviceNotification(hnd);
 }
 
 /***********************************************************************
diff --git a/include/winuser.h b/include/winuser.h
index 60bc473225b..165f835b7df 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -3088,7 +3088,9 @@ typedef struct tagTRACKMOUSEEVENT {
 typedef  PVOID           HDEVNOTIFY;
 typedef  HDEVNOTIFY     *PHDEVNOTIFY;
 
-#define DEVICE_NOTIFY_WINDOW_HANDLE     0x00000000
+#define DEVICE_NOTIFY_WINDOW_HANDLE         0x00000000
+#define DEVICE_NOTIFY_SERVICE_HANDLE        0x00000001
+#define DEVICE_NOTIFY_ALL_INTERFACE_CLASSES 0x00000004
 
 /* used for GetWindowInfo() */
 

From 5211a69e640010b6c151ef9b3a004af20ff9da74 Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:19 -0600
Subject: [PATCH] user32/tests: Add test for RegisterDeviceNotification()

Add test for API usage of RegisterDeviceNotification() and
UnregisterDeviceNotification(). Unfortunately an automated way of
triggering the actual notifications has not been found, so this test is
not complete.

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 dlls/user32/tests/input.c | 70 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 69 insertions(+), 1 deletion(-)

diff --git a/dlls/user32/tests/input.c b/dlls/user32/tests/input.c
index 4a9be550bdc..6eaf812e8d8 100644
--- a/dlls/user32/tests/input.c
+++ b/dlls/user32/tests/input.c
@@ -54,6 +54,9 @@
 #include "winbase.h"
 #include "winuser.h"
 #include "winnls.h"
+#include "dbt.h"
+#include "initguid.h"
+#include "ddk/hidclass.h"
 
 #include "wine/test.h"
 
@@ -2827,10 +2830,73 @@ static void test_GetPointerType(void)
     ok(type == PT_MOUSE, " type %d\n", type );
 }
 
+static void test_RegisterDeviceNotification(void)
+{
+    static const WCHAR mainwindowclassW[] = {'M','a','i','n','W','i','n','d','o','w','C','l','a','s','s',0};
+    static const WCHAR message_windowW[] = {'m','e','s','s','a','g','e',' ','w','i','n','d','o','w',0};
+
+    HDEVNOTIFY hnotify1, hnotify2;
+    DEV_BROADCAST_DEVICEINTERFACE_W dbh;
+    HWND hwnd;
+    WNDCLASSEXW cls;
+    BOOL ret;
+
+    memset(&cls, 0, sizeof(cls));
+    cls.cbSize = sizeof(cls);
+    cls.hInstance = 0;
+    cls.lpszClassName = mainwindowclassW;
+    cls.lpfnWndProc = DefWindowProcW;
+
+    RegisterClassExW(&cls);
+
+    hwnd = CreateWindowExW(0, mainwindowclassW, message_windowW, 0,
+                           0, 0, 0, 0, HWND_MESSAGE, 0, 0, NULL);
+    ok(hwnd != 0, "CreateWindowExW with parent HWND_MESSAGE failed\n");
+
+    memset(&dbh, 0, sizeof(dbh));
+
+    dbh.dbcc_size = sizeof(dbh);
+    dbh.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
+    dbh.dbcc_classguid = GUID_DEVINTERFACE_HID;
+
+    /* Test RegisterDeviceNotification behavior */
+
+    /* Prior to Windows 8 a NULL recipient handle caused a failure, but more
+     * recent versions of windows allow it.
+     */
+    hnotify1 = RegisterDeviceNotificationW(NULL, &dbh, DEVICE_NOTIFY_WINDOW_HANDLE);
+    /* ok(hnotify1 != 0, "RegisterDeviceNotificationW failed when called with a NULL recipient window handle\n"); */
+    if (hnotify1 != 0)
+    {
+        ret = UnregisterDeviceNotification(hnotify1);
+        ok(ret, "UnregisterDeviceNotification failed with a valid handle\n");
+    }
+
+    hnotify1 = RegisterDeviceNotificationW(hwnd, &dbh, DEVICE_NOTIFY_WINDOW_HANDLE);
+    ok(hnotify1 != 0, "RegisterDeviceNotificationW failed when called with a message only window as recipient\n");
+
+    hnotify2 = RegisterDeviceNotificationW(hwnd, &dbh, DEVICE_NOTIFY_WINDOW_HANDLE);
+    ok(hnotify2 != 0, "RegisterDeviceNotificationW failed when called with a window that has already been registered as a recipient\n");
+
+    ret = UnregisterDeviceNotification(hnotify1);
+    ok(ret, "UnregisterDeviceNotification failed with a valid handle\n");
+    ret = UnregisterDeviceNotification(hnotify2);
+    ok(ret, "UnregisterDeviceNotification failed with a valid handle\n");
+    ret = UnregisterDeviceNotification(hnotify1);
+    ok(!ret, "UnregisterDeviceNotification succeeded with an already released handle\n");
+    ret = UnregisterDeviceNotification(NULL);
+    ok(!ret, "UnregisterDeviceNotification succeeded with NULL handle\n");
+
+    hnotify1 = RegisterDeviceNotificationW(hwnd, &dbh, 0xffff);
+    ok(hnotify1 == 0, "RegisterDeviceNotificationW accepted invalid flags\n");
+
+    /* FIXME: Find a way to trigger a device notification for testing */
+    DestroyWindow(hwnd);
+}
+
 START_TEST(input)
 {
     POINT pos;
-
     init_function_pointers();
     GetCursorPos( &pos );
 
@@ -2877,4 +2943,6 @@ START_TEST(input)
         test_GetPointerType();
     else
         win_skip("GetPointerType is not available\n");
+
+    test_RegisterDeviceNotification();
 }

From 0e73cb52ebe360bbe7810f8b627ce7328e498a6a Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:20 -0600
Subject: [PATCH] sechost/tests: Add test for I_ScRegisterDeviceNotification()

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 configure                      |   1 +
 configure.ac                   |   1 +
 dlls/sechost/tests/Makefile.in |   5 ++
 dlls/sechost/tests/devnotify.c | 102 +++++++++++++++++++++++++++++++++
 4 files changed, 109 insertions(+)
 create mode 100644 dlls/sechost/tests/Makefile.in
 create mode 100644 dlls/sechost/tests/devnotify.c

diff --git a/configure b/configure
index 31ad9f73349..5cfba68cac7 100755
--- a/configure
+++ b/configure
@@ -20703,6 +20703,7 @@ wine_fn_config_makefile dlls/scrrun enable_scrrun
 wine_fn_config_makefile dlls/scrrun/tests enable_tests
 wine_fn_config_makefile dlls/scsiport.sys enable_scsiport_sys
 wine_fn_config_makefile dlls/sechost enable_sechost
+wine_fn_config_makefile dlls/sechost/tests enable_tests
 wine_fn_config_makefile dlls/secur32 enable_secur32
 wine_fn_config_makefile dlls/secur32/tests enable_tests
 wine_fn_config_makefile dlls/security enable_security
diff --git a/configure.ac b/configure.ac
index 9844cae70d7..4a0b6e49c21 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3623,6 +3623,7 @@ WINE_CONFIG_MAKEFILE(dlls/scrrun)
 WINE_CONFIG_MAKEFILE(dlls/scrrun/tests)
 WINE_CONFIG_MAKEFILE(dlls/scsiport.sys)
 WINE_CONFIG_MAKEFILE(dlls/sechost)
+WINE_CONFIG_MAKEFILE(dlls/sechost/tests)
 WINE_CONFIG_MAKEFILE(dlls/secur32)
 WINE_CONFIG_MAKEFILE(dlls/secur32/tests)
 WINE_CONFIG_MAKEFILE(dlls/security)
diff --git a/dlls/sechost/tests/Makefile.in b/dlls/sechost/tests/Makefile.in
new file mode 100644
index 00000000000..603bc77bb0a
--- /dev/null
+++ b/dlls/sechost/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL   = sechost.dll
+IMPORTS   = sechost
+
+C_SRCS = \
+	devnotify.c
diff --git a/dlls/sechost/tests/devnotify.c b/dlls/sechost/tests/devnotify.c
new file mode 100644
index 00000000000..7231f86b722
--- /dev/null
+++ b/dlls/sechost/tests/devnotify.c
@@ -0,0 +1,102 @@
+/* Test device notification registration via sechost
+ *
+ * Copyright 2019 Micah N Gorrell for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <assert.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "winnls.h"
+#include "dbt.h"
+#include "initguid.h"
+#include "ddk/hidclass.h"
+
+#include "wine/test.h"
+
+typedef DWORD (CALLBACK *REGISTER_DEVICE_NOTIFY_CALLBACK)(HANDLE hRecipient, DWORD flags,
+    DEV_BROADCAST_HDR *);
+
+typedef struct
+{
+    REGISTER_DEVICE_NOTIFY_CALLBACK pNotificationCallback;
+    HWND                            hRecipient;
+} REGISTER_DEVICE_NOTIFY;
+
+static HDEVNOTIFY (WINAPI * pI_ScRegisterDeviceNotification)(REGISTER_DEVICE_NOTIFY *data, LPVOID filter, DWORD flags);
+static DWORD (WINAPI * pI_ScUnregisterDeviceNotification)(HDEVNOTIFY notify);
+
+static void init_function_pointers(void)
+{
+    HMODULE hdll = LoadLibraryA("sechost.dll");
+
+#define GET_PROC(func) \
+    if (!(p ## func = (void*)GetProcAddress(hdll, #func))) \
+      trace("GetProcAddress(%s) failed\n", #func)
+
+    GET_PROC(I_ScRegisterDeviceNotification);
+    GET_PROC(I_ScUnregisterDeviceNotification);
+#undef GET_PROC
+}
+
+static DWORD CALLBACK change_callback(HANDLE hRecipient, DWORD flags, DEV_BROADCAST_HDR *dbh)
+{
+    return 0;
+}
+
+static void test_RegisterDeviceNotification(void)
+{
+    HDEVNOTIFY hnotify;
+    REGISTER_DEVICE_NOTIFY data;
+    DEV_BROADCAST_DEVICEINTERFACE_W dbh;
+    BOOL ret;
+
+    memset(&dbh, 0, sizeof(dbh));
+
+    dbh.dbcc_size = sizeof(dbh);
+    dbh.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
+    dbh.dbcc_classguid = GUID_DEVINTERFACE_HID;
+
+    data.pNotificationCallback = change_callback;
+    data.hRecipient = NULL;
+
+    /* Test I_ScRegisterDeviceNotification behavior */
+    /* FIXME: Behavior of other flags hasn't yet been learned */
+    hnotify = pI_ScRegisterDeviceNotification(&data, &dbh, 2);
+    ok(hnotify != 0, "I_ScRegisterDeviceNotification failed\n");
+
+    ret = pI_ScUnregisterDeviceNotification(hnotify);
+    ok(ret, "I_ScUnregisterDeviceNotification failed with a valid handle\n");
+    ret = pI_ScUnregisterDeviceNotification(hnotify);
+    ok(!ret, "I_ScUnregisterDeviceNotification succeeded with an already released handle\n");
+    ret = pI_ScUnregisterDeviceNotification(NULL);
+    ok(!ret, "I_ScUnregisterDeviceNotification succeeded with a NULL handle\n");
+
+    /* FIXME: Find a way to trigger a device notification for testing */
+}
+
+START_TEST(devnotify)
+{
+    init_function_pointers();
+
+    if (pI_ScRegisterDeviceNotification && pI_ScUnregisterDeviceNotification)
+        test_RegisterDeviceNotification();
+    else
+        win_skip("I_ScRegisterDeviceNotification is not available\n");
+}
