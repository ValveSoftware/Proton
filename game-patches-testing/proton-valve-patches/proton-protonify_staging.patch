From 171675e5015b0946ea755d7d2c4182f4cfa5358a Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Sat, 5 Oct 2019 01:33:26 +0200
Subject: Revert kernel32: Move SearchPath functions to kernelbase.

This reverts commit 8d25965e12717b266f2fc74bb10d915234d16772

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 23c25b7acd..1786c876fa 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -1324,8 +1324,8 @@
 @ stdcall -i386 -private -norelay SUnMapLS_IP_EBP_8() krnl386.exe16.SUnMapLS_IP_EBP_8
 @ stdcall -import ScrollConsoleScreenBufferA(long ptr ptr ptr ptr)
 @ stdcall -import ScrollConsoleScreenBufferW(long ptr ptr ptr ptr)
-@ stdcall -import SearchPathA(str str str long ptr ptr)
-@ stdcall -import SearchPathW(wstr wstr wstr long ptr ptr)
+@ stdcall SearchPathA(str str str long ptr ptr)
+@ stdcall SearchPathW(wstr wstr wstr long ptr ptr)
 @ stdcall SetCPGlobal(long)
 @ stdcall SetCalendarInfoA(long long long str)
 @ stdcall SetCalendarInfoW(long long long wstr)
diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
index bbe0fe268f..b580e36756 100644
--- a/dlls/kernel32/path.c
+++ b/dlls/kernel32/path.c
@@ -254,6 +254,300 @@ DWORD WINAPI GetShortPathNameA( LPCSTR longpath, LPSTR shortpath, DWORD shortlen
     return copy_filename_WtoA( shortpathW, shortpath, shortlen );
 }
 
+/***********************************************************************
+ *           contains_pathW
+ *
+ * Check if the file name contains a path; helper for SearchPathW.
+ * A relative path is not considered a path unless it starts with ./ or ../
+ */
+static inline BOOL contains_pathW (LPCWSTR name)
+{
+    if (RtlDetermineDosPathNameType_U( name ) != RELATIVE_PATH) return TRUE;
+    if (name[0] != '.') return FALSE;
+    if (name[1] == '/' || name[1] == '\\') return TRUE;
+    return (name[1] == '.' && (name[2] == '/' || name[2] == '\\'));
+}
+
+/***********************************************************************
+ *	find_actctx_dllpath
+ *
+ * Find the path (if any) of the dll from the activation context.
+ * Returned path doesn't include a name.
+ */
+static NTSTATUS find_actctx_dllpath(const WCHAR *libname, WCHAR **path)
+{
+    static const WCHAR winsxsW[] = {'\\','w','i','n','s','x','s','\\'};
+    static const WCHAR dotManifestW[] = {'.','m','a','n','i','f','e','s','t',0};
+
+    ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION *info;
+    ACTCTX_SECTION_KEYED_DATA data;
+    UNICODE_STRING nameW;
+    NTSTATUS status;
+    SIZE_T needed, size = 1024;
+    WCHAR *p;
+
+    RtlInitUnicodeString( &nameW, libname );
+    data.cbSize = sizeof(data);
+    status = RtlFindActivationContextSectionString( FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX, NULL,
+                                                    ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
+                                                    &nameW, &data );
+    if (status != STATUS_SUCCESS) return status;
+
+    for (;;)
+    {
+        if (!(info = HeapAlloc( GetProcessHeap(), 0, size )))
+        {
+            status = STATUS_NO_MEMORY;
+            goto done;
+        }
+        status = RtlQueryInformationActivationContext( 0, data.hActCtx, &data.ulAssemblyRosterIndex,
+                                                       AssemblyDetailedInformationInActivationContext,
+                                                       info, size, &needed );
+        if (status == STATUS_SUCCESS) break;
+        if (status != STATUS_BUFFER_TOO_SMALL) goto done;
+        HeapFree( GetProcessHeap(), 0, info );
+        size = needed;
+        /* restart with larger buffer */
+    }
+
+    if (!info->lpAssemblyManifestPath || !info->lpAssemblyDirectoryName)
+    {
+        status = STATUS_SXS_KEY_NOT_FOUND;
+        goto done;
+    }
+
+    if ((p = strrchrW( info->lpAssemblyManifestPath, '\\' )))
+    {
+        DWORD dirlen = info->ulAssemblyDirectoryNameLength / sizeof(WCHAR);
+
+        p++;
+        if (strncmpiW( p, info->lpAssemblyDirectoryName, dirlen ) || strcmpiW( p + dirlen, dotManifestW ))
+        {
+            /* manifest name does not match directory name, so it's not a global
+             * windows/winsxs manifest; use the manifest directory name instead */
+            dirlen = p - info->lpAssemblyManifestPath;
+            needed = (dirlen + 1) * sizeof(WCHAR);
+            if (!(*path = p = HeapAlloc( GetProcessHeap(), 0, needed )))
+            {
+                status = STATUS_NO_MEMORY;
+                goto done;
+            }
+            memcpy( p, info->lpAssemblyManifestPath, dirlen * sizeof(WCHAR) );
+            *(p + dirlen) = 0;
+            goto done;
+        }
+    }
+
+    needed = (strlenW( DIR_Windows ) * sizeof(WCHAR) +
+              sizeof(winsxsW) + info->ulAssemblyDirectoryNameLength + 2*sizeof(WCHAR));
+
+    if (!(*path = p = HeapAlloc( GetProcessHeap(), 0, needed )))
+    {
+        status = STATUS_NO_MEMORY;
+        goto done;
+    }
+    strcpyW( p, DIR_Windows );
+    p += strlenW(p);
+    memcpy( p, winsxsW, sizeof(winsxsW) );
+    p += ARRAY_SIZE( winsxsW );
+    memcpy( p, info->lpAssemblyDirectoryName, info->ulAssemblyDirectoryNameLength );
+    p += info->ulAssemblyDirectoryNameLength / sizeof(WCHAR);
+    *p++ = '\\';
+    *p = 0;
+done:
+    HeapFree( GetProcessHeap(), 0, info );
+    RtlReleaseActivationContext( data.hActCtx );
+    return status;
+}
+
+/***********************************************************************
+ * SearchPathW [KERNEL32.@]
+ *
+ * Searches for a specified file in the search path.
+ *
+ * PARAMS
+ *    path	[I] Path to search (NULL means default)
+ *    name	[I] Filename to search for.
+ *    ext	[I] File extension to append to file name. The first
+ *		    character must be a period. This parameter is
+ *                  specified only if the filename given does not
+ *                  contain an extension.
+ *    buflen	[I] size of buffer, in characters
+ *    buffer	[O] buffer for found filename
+ *    lastpart  [O] address of pointer to last used character in
+ *                  buffer (the final '\')
+ *
+ * RETURNS
+ *    Success: length of string copied into buffer, not including
+ *             terminating null character. If the filename found is
+ *             longer than the length of the buffer, the length of the
+ *             filename is returned.
+ *    Failure: Zero
+ *
+ * NOTES
+ *    If the file is not found, calls SetLastError(ERROR_FILE_NOT_FOUND)
+ *    (tested on NT 4.0)
+ */
+DWORD WINAPI SearchPathW( LPCWSTR path, LPCWSTR name, LPCWSTR ext, DWORD buflen,
+                          LPWSTR buffer, LPWSTR *lastpart )
+{
+    DWORD ret = 0;
+
+    if (!name || !name[0])
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return 0;
+    }
+
+    /* If the name contains an explicit path, ignore the path */
+
+    if (contains_pathW(name))
+    {
+        /* try first without extension */
+        if (RtlDoesFileExists_U( name ))
+            return GetFullPathNameW( name, buflen, buffer, lastpart );
+
+        if (ext)
+        {
+            LPCWSTR p = strrchrW( name, '.' );
+            if (p && !strchrW( p, '/' ) && !strchrW( p, '\\' ))
+                ext = NULL;  /* Ignore the specified extension */
+        }
+
+        /* Allocate a buffer for the file name and extension */
+        if (ext)
+        {
+            LPWSTR tmp;
+            DWORD len = strlenW(name) + strlenW(ext);
+
+            if (!(tmp = HeapAlloc( GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR) )))
+            {
+                SetLastError( ERROR_OUTOFMEMORY );
+                return 0;
+            }
+            strcpyW( tmp, name );
+            strcatW( tmp, ext );
+            if (RtlDoesFileExists_U( tmp ))
+                ret = GetFullPathNameW( tmp, buflen, buffer, lastpart );
+            HeapFree( GetProcessHeap(), 0, tmp );
+        }
+    }
+    else if (path && path[0])  /* search in the specified path */
+    {
+        ret = RtlDosSearchPath_U( path, name, ext, buflen * sizeof(WCHAR),
+                                  buffer, lastpart ) / sizeof(WCHAR);
+    }
+    else  /* search in active context and default path */
+    {
+        WCHAR *dll_path = NULL, *search = NULL;
+        DWORD req_len, name_len;
+
+        req_len = name_len = strlenW(name);
+
+        if (strchrW( name, '.' )) ext = NULL;
+        if (ext)
+        {
+            DWORD ext_len = strlenW(ext);
+
+            req_len += ext_len;
+            name_len += ext_len;
+
+            search = HeapAlloc( GetProcessHeap(), 0, (name_len + ext_len + 1) * sizeof(WCHAR) );
+            if (!search)
+            {
+                SetLastError( ERROR_OUTOFMEMORY );
+                return 0;
+            }
+            strcpyW( search, name );
+            strcatW( search, ext );
+            name = search;
+
+            /* now that we have combined name we don't need extension any more */
+        }
+
+        /* When file is found with activation context no attempt is made
+          to check if it's really exist, path is returned only basing on context info. */
+        if (find_actctx_dllpath( name, &dll_path ) == STATUS_SUCCESS)
+        {
+            DWORD path_len;
+
+            path_len = strlenW(dll_path);
+            req_len += path_len;
+
+            if (lastpart) *lastpart = NULL;
+
+            /* count null termination char too */
+            if (req_len + 1 <= buflen)
+            {
+                memcpy( buffer, dll_path, path_len * sizeof(WCHAR) );
+                memcpy( &buffer[path_len], name, name_len * sizeof(WCHAR) );
+                buffer[req_len] = 0;
+                if (lastpart) *lastpart = buffer + path_len;
+                ret = req_len;
+            }
+            else
+                ret = req_len + 1;
+
+            HeapFree( GetProcessHeap(), 0, dll_path );
+        }
+        else if (!RtlGetSearchPath( &dll_path ))
+        {
+            ret = RtlDosSearchPath_U( dll_path, name, NULL, buflen * sizeof(WCHAR),
+                                      buffer, lastpart ) / sizeof(WCHAR);
+            RtlReleasePath( dll_path );
+        }
+        HeapFree( GetProcessHeap(), 0, search );
+    }
+
+    if (!ret) SetLastError( ERROR_FILE_NOT_FOUND );
+    else TRACE( "found %s\n", debugstr_w(buffer) );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           SearchPathA   (KERNEL32.@)
+ *
+ * See SearchPathW.
+ */
+DWORD WINAPI SearchPathA( LPCSTR path, LPCSTR name, LPCSTR ext,
+                          DWORD buflen, LPSTR buffer, LPSTR *lastpart )
+{
+    WCHAR *pathW = NULL, *nameW, *extW = NULL;
+    WCHAR bufferW[MAX_PATH];
+    DWORD ret;
+
+    if (!name)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return 0;
+    }
+
+    if (!(nameW = FILE_name_AtoW( name, FALSE ))) return 0;
+    if (path && !(pathW = FILE_name_AtoW( path, TRUE ))) return 0;
+    
+    if (ext && !(extW = FILE_name_AtoW( ext, TRUE )))
+    {
+        HeapFree( GetProcessHeap(), 0, pathW );
+        return 0;
+    }
+
+    ret = SearchPathW(pathW, nameW, extW, MAX_PATH, bufferW, NULL);
+
+    HeapFree( GetProcessHeap(), 0, pathW );
+    HeapFree( GetProcessHeap(), 0, extW );
+
+    if (!ret) return 0;
+    if (ret > MAX_PATH)
+    {
+        SetLastError(ERROR_FILENAME_EXCED_RANGE);
+        return 0;
+    }
+    ret = copy_filename_WtoA( bufferW, buffer, buflen );
+    if (buflen > ret && lastpart)
+        *lastpart = strrchr(buffer, '\\') + 1;
+    return ret;
+}
 
 static BOOL is_same_file(HANDLE h1, HANDLE h2)
 {
diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index af21687aa3..7a6f843f43 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -63,137 +63,6 @@ static void WINAPI read_write_apc( void *apc_user, PIO_STATUS_BLOCK io, ULONG re
  ***********************************************************************/
 
 
-/***********************************************************************
- *	contains_path
- *
- * Check if the file name contains a path; helper for SearchPathW.
- * A relative path is not considered a path unless it starts with ./ or ../
- */
-static inline BOOL contains_path( const WCHAR *name )
-{
-    if (RtlDetermineDosPathNameType_U( name ) != RELATIVE_PATH) return TRUE;
-    if (name[0] != '.') return FALSE;
-    if (name[1] == '/' || name[1] == '\\') return TRUE;
-    return (name[1] == '.' && (name[2] == '/' || name[2] == '\\'));
-}
-
-
-/***********************************************************************
- *	append_ext
- */
-static WCHAR *append_ext( const WCHAR *name, const WCHAR *ext )
-{
-    const WCHAR *p;
-    WCHAR *ret;
-    DWORD len;
-
-    if (!ext) return NULL;
-    p = wcsrchr( name, '.' );
-    if (p && !wcschr( p, '/' ) && !wcschr( p, '\\' )) return NULL;
-
-    len = lstrlenW( name ) + lstrlenW( ext );
-    if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR) )))
-    {
-        lstrcpyW( ret, name );
-        lstrcatW( ret, ext );
-    }
-    return ret;
-}
-
-
-/***********************************************************************
- *	find_actctx_dllpath
- *
- * Find the path (if any) of the dll from the activation context.
- * Returned path doesn't include a name.
- */
-static NTSTATUS find_actctx_dllpath( const WCHAR *name, WCHAR **path )
-{
-    static const WCHAR winsxsW[] = {'\\','w','i','n','s','x','s','\\'};
-    static const WCHAR dotManifestW[] = {'.','m','a','n','i','f','e','s','t',0};
-
-    ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION *info;
-    ACTCTX_SECTION_KEYED_DATA data;
-    UNICODE_STRING nameW;
-    NTSTATUS status;
-    SIZE_T needed, size = 1024;
-    WCHAR *p;
-
-    RtlInitUnicodeString( &nameW, name );
-    data.cbSize = sizeof(data);
-    status = RtlFindActivationContextSectionString( FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX, NULL,
-                                                    ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
-                                                    &nameW, &data );
-    if (status != STATUS_SUCCESS) return status;
-
-    for (;;)
-    {
-        if (!(info = RtlAllocateHeap( GetProcessHeap(), 0, size )))
-        {
-            status = STATUS_NO_MEMORY;
-            goto done;
-        }
-        status = RtlQueryInformationActivationContext( 0, data.hActCtx, &data.ulAssemblyRosterIndex,
-                                                       AssemblyDetailedInformationInActivationContext,
-                                                       info, size, &needed );
-        if (status == STATUS_SUCCESS) break;
-        if (status != STATUS_BUFFER_TOO_SMALL) goto done;
-        RtlFreeHeap( GetProcessHeap(), 0, info );
-        size = needed;
-        /* restart with larger buffer */
-    }
-
-    if (!info->lpAssemblyManifestPath || !info->lpAssemblyDirectoryName)
-    {
-        status = STATUS_SXS_KEY_NOT_FOUND;
-        goto done;
-    }
-
-    if ((p = wcsrchr( info->lpAssemblyManifestPath, '\\' )))
-    {
-        DWORD dirlen = info->ulAssemblyDirectoryNameLength / sizeof(WCHAR);
-
-        p++;
-        if (wcsnicmp( p, info->lpAssemblyDirectoryName, dirlen ) || wcsicmp( p + dirlen, dotManifestW ))
-        {
-            /* manifest name does not match directory name, so it's not a global
-             * windows/winsxs manifest; use the manifest directory name instead */
-            dirlen = p - info->lpAssemblyManifestPath;
-            needed = (dirlen + 1) * sizeof(WCHAR);
-            if (!(*path = p = HeapAlloc( GetProcessHeap(), 0, needed )))
-            {
-                status = STATUS_NO_MEMORY;
-                goto done;
-            }
-            memcpy( p, info->lpAssemblyManifestPath, dirlen * sizeof(WCHAR) );
-            *(p + dirlen) = 0;
-            goto done;
-        }
-    }
-
-    needed = (lstrlenW( windows_dir ) * sizeof(WCHAR) +
-              sizeof(winsxsW) + info->ulAssemblyDirectoryNameLength + 2*sizeof(WCHAR));
-
-    if (!(*path = p = RtlAllocateHeap( GetProcessHeap(), 0, needed )))
-    {
-        status = STATUS_NO_MEMORY;
-        goto done;
-    }
-    lstrcpyW( p, windows_dir );
-    p += lstrlenW(p);
-    memcpy( p, winsxsW, sizeof(winsxsW) );
-    p += ARRAY_SIZE( winsxsW );
-    memcpy( p, info->lpAssemblyDirectoryName, info->ulAssemblyDirectoryNameLength );
-    p += info->ulAssemblyDirectoryNameLength / sizeof(WCHAR);
-    *p++ = '\\';
-    *p = 0;
-done:
-    RtlFreeHeap( GetProcessHeap(), 0, info );
-    RtlReleaseActivationContext( data.hActCtx );
-    return status;
-}
-
-
 /***********************************************************************
  *           copy_filename_WtoA
  *
@@ -1452,119 +1321,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH NeedCurrentDirectoryForExePathW( LPCWSTR name )
 }
 
 
-/***********************************************************************
- *	SearchPathA   (kernelbase.@)
- */
-DWORD WINAPI DECLSPEC_HOTPATCH SearchPathA( LPCSTR path, LPCSTR name, LPCSTR ext,
-                                            DWORD buflen, LPSTR buffer, LPSTR *lastpart )
-{
-    WCHAR *pathW = NULL, *nameW, *extW = NULL;
-    WCHAR bufferW[MAX_PATH];
-    DWORD ret;
-
-    if (!name)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return 0;
-    }
-
-    if (!(nameW = file_name_AtoW( name, FALSE ))) return 0;
-    if (path && !(pathW = file_name_AtoW( path, TRUE ))) return 0;
-    if (ext && !(extW = file_name_AtoW( ext, TRUE )))
-    {
-        RtlFreeHeap( GetProcessHeap(), 0, pathW );
-        return 0;
-    }
-
-    ret = SearchPathW( pathW, nameW, extW, MAX_PATH, bufferW, NULL );
-
-    RtlFreeHeap( GetProcessHeap(), 0, pathW );
-    RtlFreeHeap( GetProcessHeap(), 0, extW );
-
-    if (!ret) return 0;
-    if (ret > MAX_PATH)
-    {
-        SetLastError( ERROR_FILENAME_EXCED_RANGE );
-        return 0;
-    }
-    ret = copy_filename_WtoA( bufferW, buffer, buflen );
-    if (buflen > ret && lastpart) *lastpart = strrchr(buffer, '\\') + 1;
-    return ret;
-}
-
-
-/***********************************************************************
- *	SearchPathW   (kernelbase.@)
- */
-DWORD WINAPI DECLSPEC_HOTPATCH SearchPathW( LPCWSTR path, LPCWSTR name, LPCWSTR ext, DWORD buflen,
-                                            LPWSTR buffer, LPWSTR *lastpart )
-{
-    DWORD ret = 0;
-    WCHAR *name_ext;
-
-    if (!name || !name[0])
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return 0;
-    }
-
-    /* If the name contains an explicit path, ignore the path */
-
-    if (contains_path( name ))
-    {
-        /* try first without extension */
-        if (RtlDoesFileExists_U( name )) return GetFullPathNameW( name, buflen, buffer, lastpart );
-
-        if ((name_ext = append_ext( name, ext )))
-        {
-            if (RtlDoesFileExists_U( name_ext ))
-                ret = GetFullPathNameW( name_ext, buflen, buffer, lastpart );
-            RtlFreeHeap( GetProcessHeap(), 0, name_ext );
-        }
-    }
-    else if (path && path[0])  /* search in the specified path */
-    {
-        ret = RtlDosSearchPath_U( path, name, ext, buflen * sizeof(WCHAR),
-                                  buffer, lastpart ) / sizeof(WCHAR);
-    }
-    else  /* search in active context and default path */
-    {
-        WCHAR *dll_path = NULL, *name_ext = append_ext( name, ext );
-
-        if (name_ext) name = name_ext;
-
-        /* When file is found with activation context no attempt is made
-          to check if it's really exist, path is returned only basing on context info. */
-        if (find_actctx_dllpath( name, &dll_path ) == STATUS_SUCCESS)
-        {
-            ret = lstrlenW( dll_path ) + lstrlenW( name ) + 1;
-
-            /* count null termination char too */
-            if (ret <= buflen)
-            {
-                lstrcpyW( buffer, dll_path );
-                lstrcatW( buffer, name );
-                if (lastpart) *lastpart = buffer + lstrlenW( dll_path );
-                ret--;
-            }
-            else if (lastpart) *lastpart = NULL;
-            RtlFreeHeap( GetProcessHeap(), 0, dll_path );
-        }
-        else if (!RtlGetSearchPath( &dll_path ))
-        {
-            ret = RtlDosSearchPath_U( dll_path, name, NULL, buflen * sizeof(WCHAR),
-                                      buffer, lastpart ) / sizeof(WCHAR);
-            RtlReleasePath( dll_path );
-        }
-        RtlFreeHeap( GetProcessHeap(), 0, name_ext );
-    }
-
-    if (!ret) SetLastError( ERROR_FILE_NOT_FOUND );
-    else TRACE( "found %s\n", debugstr_w(buffer) );
-    return ret;
-}
-
-
 /***********************************************************************
  *	SetCurrentDirectoryA   (kernelbase.@)
  */
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index c1fa479525..f80f6097dc 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -1385,8 +1385,8 @@
 # @ stub SaveStateRootFolderPath
 @ stdcall ScrollConsoleScreenBufferA(long ptr ptr ptr ptr)
 @ stdcall ScrollConsoleScreenBufferW(long ptr ptr ptr ptr)
-@ stdcall SearchPathA(str str str long ptr ptr)
-@ stdcall SearchPathW(wstr wstr wstr long ptr ptr)
+@ stdcall SearchPathA(str str str long ptr ptr) kernel32.SearchPathA
+@ stdcall SearchPathW(wstr wstr wstr long ptr ptr) kernel32.SearchPathW
 @ stdcall SetAclInformation(ptr ptr long long)
 # @ stub SetCachedSigningLevel
 @ stdcall SetCalendarInfoW(long long long wstr) kernel32.SetCalendarInfoW
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 5b70dfd874..4a3e0f4722 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -92,7 +92,7 @@ static BOOL load_library_as_datafile( LPCWSTR load_path, DWORD flags, LPCWSTR na
 
     if (flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE) protect |= SEC_IMAGE;
 
-    if (SearchPathW( NULL, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
+    if (SearchPathW( load_path, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
     {
         file = CreateFileW( filenameW, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE,
                             NULL, OPEN_EXISTING, 0, 0 );


From ea7454188b454ab164133982ac818b084b696647 Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Fri, 4 Oct 2019 03:13:09 +0200
Subject: Revert c5dc41e980b311a9d49122c6e3e33a1c4483c660,
 a5d45e9ae5a6a88f859c1ca1f05b4c93a0817103,
 619bd16e7a7486ca72cde1df01791629efb61341 Conflicting with our proton meta
 patchset

Staging edition

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 73cb8260cf..e051ac0e7a 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -140,7 +140,7 @@
 @ stdcall AddAtomW(wstr)
 @ stdcall AddConsoleAliasA(str str str)
 @ stdcall AddConsoleAliasW(wstr wstr wstr)
-@ stdcall -import AddDllDirectory(wstr)
+@ stdcall AddDllDirectory(wstr)
 # @ stub AddIntegrityLabelToBoundaryDescriptor
 # @ stub AddLocalAlternateComputerNameA
 # @ stub AddLocalAlternateComputerNameW
@@ -528,7 +528,7 @@
 @ stdcall -import FreeEnvironmentStringsA(ptr)
 @ stdcall -import FreeEnvironmentStringsW(ptr)
 @ stub -i386 FreeLSCallback
-@ stdcall -import FreeLibrary(long)
+@ stdcall FreeLibrary(long)
 @ stdcall FreeLibraryAndExitThread(long long)
 @ stdcall FreeLibraryWhenCallbackReturns(ptr ptr) ntdll.TpCallbackUnloadDllOnCompletion
 @ stdcall -import FreeResource(long)
@@ -1042,10 +1042,10 @@
 @ stdcall LeaveCriticalSection(ptr) ntdll.RtlLeaveCriticalSection
 @ stdcall LeaveCriticalSectionWhenCallbackReturns(ptr ptr) ntdll.TpCallbackLeaveCriticalSectionOnCompletion
 # @ stub LoadAppInitDlls
-@ stdcall -import LoadLibraryA(str)
-@ stdcall -import LoadLibraryExA( str long long)
-@ stdcall -import LoadLibraryExW(wstr long long)
-@ stdcall -import LoadLibraryW(wstr)
+@ stdcall LoadLibraryA(str)
+@ stdcall LoadLibraryExA( str long long)
+@ stdcall LoadLibraryExW(wstr long long)
+@ stdcall LoadLibraryW(wstr)
 @ stdcall LoadModule(str ptr)
 @ stdcall -import LoadResource(long long)
 # @ stub LoadStringBaseExW
@@ -1274,7 +1274,7 @@
 @ stdcall ReplaceFileW(wstr wstr wstr long ptr ptr)
 # @ stub RemoveDirectoryTransactedA
 # @ stub RemoveDirectoryTransactedW
-@ stdcall -import RemoveDllDirectory(ptr)
+@ stdcall RemoveDllDirectory(ptr)
 # @ stub RemoveSecureMemoryCacheCallback
 # @ stub ReplacePartitionUnit
 @ stdcall RequestDeviceWakeup(long)
@@ -1379,7 +1379,7 @@
 @ stub SetDaylightFlag
 @ stdcall SetDefaultCommConfigA(str ptr long)
 @ stdcall SetDefaultCommConfigW(wstr ptr long)
-@ stdcall -import SetDefaultDllDirectories(long)
+@ stdcall SetDefaultDllDirectories(long)
 @ stdcall SetDllDirectoryA(str)
 @ stdcall SetDllDirectoryW(wstr)
 # @ stub SetDynamicTimeZoneInformation
diff --git a/dlls/kernel32/kernel_private.h b/dlls/kernel32/kernel_private.h
index af85bee84d..fdfb7a3e83 100644
--- a/dlls/kernel32/kernel_private.h
+++ b/dlls/kernel32/kernel_private.h
@@ -65,6 +65,9 @@ extern void FILE_SetDosError(void) DECLSPEC_HIDDEN;
 extern WCHAR *FILE_name_AtoW( LPCSTR name, BOOL alloc ) DECLSPEC_HIDDEN;
 extern DWORD FILE_name_WtoA( LPCWSTR src, INT srclen, LPSTR dest, INT destlen ) DECLSPEC_HIDDEN;
 
+/* module.c */
+extern WCHAR *MODULE_get_dll_load_path( LPCWSTR module, int safe_mode ) DECLSPEC_HIDDEN;
+
 extern BOOL NLS_IsUnicodeOnlyLcid(LCID) DECLSPEC_HIDDEN;
 
 /* environ.c */
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index b7f19ffe36..131c2f9621 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -47,6 +47,34 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
+#define NE_FFLAGS_LIBMODULE 0x8000
+
+struct dll_dir_entry
+{
+    struct list entry;
+    WCHAR       dir[1];
+};
+
+static struct list dll_dir_list = LIST_INIT( dll_dir_list );  /* extra dirs from AddDllDirectory */
+static DWORD default_search_flags;  /* default flags set by SetDefaultDllDirectories */
+
+/* to keep track of LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE file handles */
+struct exclusive_datafile
+{
+    struct list entry;
+    HMODULE     module;
+    HANDLE      file;
+};
+static struct list exclusive_datafile_list = LIST_INIT( exclusive_datafile_list );
+
+static CRITICAL_SECTION dlldir_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &dlldir_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": dlldir_section") }
+};
+static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 /****************************************************************************
  *              GetDllDirectoryA   (KERNEL32.@)
@@ -135,6 +163,73 @@ BOOL WINAPI SetDllDirectoryW( LPCWSTR dir )
 }
 
 
+/****************************************************************************
+ *              AddDllDirectory   (KERNEL32.@)
+ */
+DLL_DIRECTORY_COOKIE WINAPI AddDllDirectory( const WCHAR *dir )
+{
+    WCHAR path[MAX_PATH];
+    DWORD len;
+    struct dll_dir_entry *ptr;
+    DOS_PATHNAME_TYPE type = RtlDetermineDosPathNameType_U( dir );
+
+    if (type != ABSOLUTE_PATH && type != ABSOLUTE_DRIVE_PATH)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return NULL;
+    }
+    if (!(len = GetFullPathNameW( dir, MAX_PATH, path, NULL ))) return NULL;
+    if (GetFileAttributesW( path ) == INVALID_FILE_ATTRIBUTES) return NULL;
+
+    if (!(ptr = HeapAlloc( GetProcessHeap(), 0, offsetof(struct dll_dir_entry, dir[++len] )))) return NULL;
+    memcpy( ptr->dir, path, len * sizeof(WCHAR) );
+    TRACE( "%s\n", debugstr_w( ptr->dir ));
+
+    RtlEnterCriticalSection( &dlldir_section );
+    list_add_head( &dll_dir_list, &ptr->entry );
+    RtlLeaveCriticalSection( &dlldir_section );
+    return ptr;
+}
+
+
+/****************************************************************************
+ *              RemoveDllDirectory   (KERNEL32.@)
+ */
+BOOL WINAPI RemoveDllDirectory( DLL_DIRECTORY_COOKIE cookie )
+{
+    struct dll_dir_entry *ptr = cookie;
+
+    TRACE( "%s\n", debugstr_w( ptr->dir ));
+
+    RtlEnterCriticalSection( &dlldir_section );
+    list_remove( &ptr->entry );
+    HeapFree( GetProcessHeap(), 0, ptr );
+    RtlLeaveCriticalSection( &dlldir_section );
+    return TRUE;
+}
+
+
+/*************************************************************************
+ *           SetDefaultDllDirectories   (KERNEL32.@)
+ */
+BOOL WINAPI SetDefaultDllDirectories( DWORD flags )
+{
+    /* LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR doesn't make sense in default dirs */
+    const DWORD load_library_search_flags = (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
+                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
+                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
+                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
+
+    if (!flags || (flags & ~load_library_search_flags))
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
+    default_search_flags = flags;
+    return TRUE;
+}
+
+
 /***********************************************************************
  *             GetBinaryTypeW                     [KERNEL32.@]
  *
@@ -273,6 +368,564 @@ BOOL WINAPI GetBinaryTypeA( LPCSTR lpApplicationName, LPDWORD lpBinaryType )
     return GetBinaryTypeW(NtCurrentTeb()->StaticUnicodeString.Buffer, lpBinaryType);
 }
 
+/***********************************************************************
+ *           get_dll_system_path
+ */
+static const WCHAR *get_dll_system_path(void)
+{
+    static WCHAR *cached_path;
+
+    if (!cached_path)
+    {
+        WCHAR *p, *path;
+        int len = 1;
+
+        len += 2 * GetSystemDirectoryW( NULL, 0 );
+        len += GetWindowsDirectoryW( NULL, 0 );
+        p = path = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );
+        GetSystemDirectoryW( p, path + len - p);
+        p += strlenW(p);
+        /* if system directory ends in "32" add 16-bit version too */
+        if (p[-2] == '3' && p[-1] == '2')
+        {
+            *p++ = ';';
+            GetSystemDirectoryW( p, path + len - p);
+            p += strlenW(p) - 2;
+        }
+        *p++ = ';';
+        GetWindowsDirectoryW( p, path + len - p);
+        cached_path = path;
+    }
+    return cached_path;
+}
+
+/***********************************************************************
+ *           get_dll_safe_mode
+ */
+static BOOL get_dll_safe_mode(void)
+{
+    static const WCHAR keyW[] = {'\\','R','e','g','i','s','t','r','y','\\',
+                                 'M','a','c','h','i','n','e','\\',
+                                 'S','y','s','t','e','m','\\',
+                                 'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
+                                 'C','o','n','t','r','o','l','\\',
+                                 'S','e','s','s','i','o','n',' ','M','a','n','a','g','e','r',0};
+    static const WCHAR valueW[] = {'S','a','f','e','D','l','l','S','e','a','r','c','h','M','o','d','e',0};
+
+    static int safe_mode = -1;
+
+    if (safe_mode == -1)
+    {
+        char buffer[offsetof(KEY_VALUE_PARTIAL_INFORMATION, Data[sizeof(DWORD)])];
+        KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
+        OBJECT_ATTRIBUTES attr;
+        UNICODE_STRING nameW;
+        HANDLE hkey;
+        DWORD size = sizeof(buffer);
+
+        attr.Length = sizeof(attr);
+        attr.RootDirectory = 0;
+        attr.ObjectName = &nameW;
+        attr.Attributes = 0;
+        attr.SecurityDescriptor = NULL;
+        attr.SecurityQualityOfService = NULL;
+
+        safe_mode = 1;
+        RtlInitUnicodeString( &nameW, keyW );
+        if (!NtOpenKey( &hkey, KEY_READ, &attr ))
+        {
+            RtlInitUnicodeString( &nameW, valueW );
+            if (!NtQueryValueKey( hkey, &nameW, KeyValuePartialInformation, buffer, size, &size ) &&
+                info->Type == REG_DWORD && info->DataLength == sizeof(DWORD))
+                safe_mode = !!*(DWORD *)info->Data;
+            NtClose( hkey );
+        }
+        if (!safe_mode) TRACE( "SafeDllSearchMode disabled through the registry\n" );
+    }
+    return safe_mode;
+}
+
+/******************************************************************
+ *		get_module_path_end
+ *
+ * Returns the end of the directory component of the module path.
+ */
+static inline const WCHAR *get_module_path_end(const WCHAR *module)
+{
+    const WCHAR *p;
+    const WCHAR *mod_end = module;
+    if (!module) return mod_end;
+
+    if ((p = strrchrW( mod_end, '\\' ))) mod_end = p;
+    if ((p = strrchrW( mod_end, '/' ))) mod_end = p;
+    if (mod_end == module + 2 && module[1] == ':') mod_end++;
+    if (mod_end == module && module[0] && module[1] == ':') mod_end += 2;
+
+    return mod_end;
+}
+
+
+/******************************************************************
+ *		append_path_len
+ *
+ * Append a counted string to the load path. Helper for MODULE_get_dll_load_path.
+ */
+static inline WCHAR *append_path_len( WCHAR *p, const WCHAR *str, DWORD len )
+{
+    if (!len) return p;
+    memcpy( p, str, len * sizeof(WCHAR) );
+    p[len] = ';';
+    return p + len + 1;
+}
+
+
+/******************************************************************
+ *		append_path
+ *
+ * Append a string to the load path. Helper for MODULE_get_dll_load_path.
+ */
+static inline WCHAR *append_path( WCHAR *p, const WCHAR *str )
+{
+    return append_path_len( p, str, strlenW(str) );
+}
+
+
+/******************************************************************
+ *		MODULE_get_dll_load_path
+ *
+ * Compute the load path to use for a given dll.
+ * Returned pointer must be freed by caller.
+ */
+WCHAR *MODULE_get_dll_load_path( LPCWSTR module, int safe_mode )
+{
+    static const WCHAR pathW[] = {'P','A','T','H',0};
+    static const WCHAR dotW[] = {'.',0};
+
+    const WCHAR *system_path = get_dll_system_path();
+    const WCHAR *mod_end = NULL;
+    UNICODE_STRING name, value;
+    WCHAR *p, *ret;
+    int len = 0, path_len = 0, dlldir_len;
+
+    /* adjust length for module name */
+
+    if (module)
+        mod_end = get_module_path_end( module );
+    /* if module is NULL or doesn't contain a path, fall back to directory
+     * process was loaded from */
+    if (module == mod_end)
+    {
+        module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+        mod_end = get_module_path_end( module );
+    }
+    len += (mod_end - module) + 1;
+
+    len += strlenW( system_path ) + 2;
+
+    /* get the PATH variable */
+
+    RtlInitUnicodeString( &name, pathW );
+    value.Length = 0;
+    value.MaximumLength = 0;
+    value.Buffer = NULL;
+    if (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
+        path_len = value.Length;
+
+    dlldir_len = GetDllDirectoryW( 0, NULL );
+
+    if (safe_mode == -1) safe_mode = get_dll_safe_mode();
+    if (dlldir_len > 1) len += dlldir_len;
+    else len += 2;  /* current directory */
+    if ((p = ret = HeapAlloc( GetProcessHeap(), 0, path_len + len * sizeof(WCHAR) )))
+    {
+        if (module) p = append_path_len( p, module, mod_end - module );
+
+        if (dlldir_len > 1)
+        {
+            GetDllDirectoryW( len - (p - ret), p );
+            p += strlenW(p);
+            *p++ = ';';
+        }
+        else if (!safe_mode) p = append_path( p, dotW );
+
+        p = append_path( p, system_path );
+
+        if (dlldir_len <= 1 && safe_mode) p = append_path( p, dotW );
+    }
+    if (!ret) return NULL;
+
+    value.Buffer = p;
+    value.MaximumLength = path_len;
+
+    while (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
+    {
+        WCHAR *new_ptr;
+
+        /* grow the buffer and retry */
+        path_len = value.Length;
+        if (!(new_ptr = HeapReAlloc( GetProcessHeap(), 0, ret, path_len + len * sizeof(WCHAR) )))
+        {
+            HeapFree( GetProcessHeap(), 0, ret );
+            return NULL;
+        }
+        value.Buffer = new_ptr + (value.Buffer - ret);
+        value.MaximumLength = path_len;
+        ret = new_ptr;
+    }
+    value.Buffer[value.Length / sizeof(WCHAR)] = 0;
+    return ret;
+}
+
+
+/******************************************************************
+ *		get_dll_load_path_search_flags
+ */
+static WCHAR *get_dll_load_path_search_flags( LPCWSTR module, DWORD flags )
+{
+    const WCHAR *image = NULL, *mod_end, *image_end;
+    struct dll_dir_entry *dir;
+    WCHAR *p, *ret;
+    int len = 1;
+
+    if (flags & LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)
+        flags |= (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
+                  LOAD_LIBRARY_SEARCH_USER_DIRS |
+                  LOAD_LIBRARY_SEARCH_SYSTEM32);
+
+    if (flags & LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR)
+    {
+        DWORD type = RtlDetermineDosPathNameType_U( module );
+        if (type != ABSOLUTE_DRIVE_PATH && type != ABSOLUTE_PATH)
+        {
+            SetLastError( ERROR_INVALID_PARAMETER );
+            return NULL;
+        }
+        mod_end = get_module_path_end( module );
+        len += (mod_end - module) + 1;
+    }
+    else module = NULL;
+
+    RtlEnterCriticalSection( &dlldir_section );
+
+    if (flags & LOAD_LIBRARY_SEARCH_APPLICATION_DIR)
+    {
+        image = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+        image_end = get_module_path_end( image );
+        len += (image_end - image) + 1;
+    }
+
+    if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
+    {
+        LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
+            len += strlenW( dir->dir ) + 1;
+        len += GetDllDirectoryW( 0, NULL );
+    }
+
+    if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) len += GetSystemDirectoryW( NULL, 0 );
+
+    if ((p = ret = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+    {
+        if (module) p = append_path_len( p, module, mod_end - module );
+        if (image) p = append_path_len( p, image, image_end - image );
+        if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
+        {
+            LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
+                p = append_path( p, dir->dir );
+            GetDllDirectoryW( ret + len - p, p );
+            if (*p)
+            {
+                p += strlenW(p);
+                *p++ = ';';
+            }
+        }
+        if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) GetSystemDirectoryW( p, ret + len - p );
+        else
+        {
+            if (p > ret) p--;
+            *p = 0;
+        }
+    }
+
+    RtlLeaveCriticalSection( &dlldir_section );
+    return ret;
+}
+
+
+/******************************************************************
+ *		load_library_as_datafile
+ */
+static BOOL load_library_as_datafile( LPCWSTR name, HMODULE *hmod, DWORD flags )
+{
+    static const WCHAR dotDLL[] = {'.','d','l','l',0};
+
+    WCHAR filenameW[MAX_PATH];
+    HANDLE hFile = INVALID_HANDLE_VALUE;
+    HANDLE mapping;
+    HMODULE module = 0;
+    DWORD protect = PAGE_READONLY;
+    DWORD sharing = FILE_SHARE_READ | FILE_SHARE_DELETE;
+
+    *hmod = 0;
+
+    if (flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE) protect |= SEC_IMAGE;
+
+    if (SearchPathW( NULL, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
+    {
+        hFile = CreateFileW( filenameW, GENERIC_READ, sharing, NULL, OPEN_EXISTING, 0, 0 );
+    }
+    if (hFile == INVALID_HANDLE_VALUE) return FALSE;
+
+    mapping = CreateFileMappingW( hFile, NULL, protect, 0, 0, NULL );
+    if (!mapping) goto failed;
+
+    module = MapViewOfFile( mapping, FILE_MAP_READ, 0, 0, 0 );
+    CloseHandle( mapping );
+    if (!module) goto failed;
+
+    if (!(flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE))
+    {
+        /* make sure it's a valid PE file */
+        if (!RtlImageNtHeader( module )) goto failed;
+        *hmod = (HMODULE)((char *)module + 1); /* set bit 0 for data file module */
+
+        if (flags & LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE)
+        {
+            struct exclusive_datafile *file = HeapAlloc( GetProcessHeap(), 0, sizeof(*file) );
+            if (!file) goto failed;
+            file->module = *hmod;
+            file->file   = hFile;
+            list_add_head( &exclusive_datafile_list, &file->entry );
+            TRACE( "delaying close %p for module %p\n", file->file, file->module );
+            return TRUE;
+        }
+    }
+    else *hmod = (HMODULE)((char *)module + 2); /* set bit 1 for image resource module */
+
+    CloseHandle( hFile );
+    return TRUE;
+
+failed:
+    if (module) UnmapViewOfFile( module );
+    CloseHandle( hFile );
+    return FALSE;
+}
+
+
+/******************************************************************
+ *		load_library
+ *
+ * Helper for LoadLibraryExA/W.
+ */
+static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
+{
+    NTSTATUS nts;
+    HMODULE hModule;
+    WCHAR *load_path;
+    const DWORD load_library_search_flags = (LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR |
+                                             LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
+                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
+                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
+                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
+    const DWORD unsupported_flags = (LOAD_IGNORE_CODE_AUTHZ_LEVEL |
+                                     LOAD_LIBRARY_REQUIRE_SIGNED_TARGET);
+
+    if( flags & unsupported_flags)
+        FIXME("unsupported flag(s) used (flags: 0x%08x)\n", flags);
+
+    if (flags & LOAD_WITH_ALTERED_SEARCH_PATH)
+    {
+        if (flags & load_library_search_flags)
+        {
+            SetLastError( ERROR_INVALID_PARAMETER );
+            return 0;
+        }
+        if (default_search_flags) flags |= default_search_flags | LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR;
+    }
+    else if (!(flags & load_library_search_flags)) flags |= default_search_flags;
+
+    if (flags & load_library_search_flags)
+        load_path = get_dll_load_path_search_flags( libname->Buffer, flags );
+    else
+        load_path = MODULE_get_dll_load_path( flags & LOAD_WITH_ALTERED_SEARCH_PATH ? libname->Buffer : NULL, -1 );
+    if (!load_path) return 0;
+
+    if (flags & (LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE | LOAD_LIBRARY_AS_IMAGE_RESOURCE))
+    {
+        ULONG_PTR magic;
+
+        LdrLockLoaderLock( 0, NULL, &magic );
+        if (!LdrGetDllHandle( load_path, flags, libname, &hModule ))
+        {
+            LdrAddRefDll( 0, hModule );
+            LdrUnlockLoaderLock( 0, magic );
+            goto done;
+        }
+        if (load_library_as_datafile( libname->Buffer, &hModule, flags ))
+        {
+            LdrUnlockLoaderLock( 0, magic );
+            goto done;
+        }
+        LdrUnlockLoaderLock( 0, magic );
+        flags |= DONT_RESOLVE_DLL_REFERENCES; /* Just in case */
+        /* Fallback to normal behaviour */
+    }
+
+    nts = LdrLoadDll( load_path, flags, libname, &hModule );
+    if (nts != STATUS_SUCCESS)
+    {
+        hModule = 0;
+        if (nts == STATUS_DLL_NOT_FOUND && (GetVersion() & 0x80000000))
+            SetLastError( ERROR_DLL_NOT_FOUND );
+        else
+            SetLastError( RtlNtStatusToDosError( nts ) );
+    }
+done:
+    HeapFree( GetProcessHeap(), 0, load_path );
+    return hModule;
+}
+
+
+/******************************************************************
+ *		LoadLibraryExA          (KERNEL32.@)
+ *
+ * Load a dll file into the process address space.
+ *
+ * PARAMS
+ *  libname [I] Name of the file to load
+ *  hfile   [I] Reserved, must be 0.
+ *  flags   [I] Flags for loading the dll
+ *
+ * RETURNS
+ *  Success: A handle to the loaded dll.
+ *  Failure: A NULL handle. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ * The HFILE parameter is not used and marked reserved in the SDK. I can
+ * only guess that it should force a file to be mapped, but I rather
+ * ignore the parameter because it would be extremely difficult to
+ * integrate this with different types of module representations.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExA(LPCSTR libname, HANDLE hfile, DWORD flags)
+{
+    WCHAR *libnameW;
+
+    if (!(libnameW = FILE_name_AtoW( libname, FALSE ))) return 0;
+    return LoadLibraryExW( libnameW, hfile, flags );
+}
+
+/***********************************************************************
+ *           LoadLibraryExW       (KERNEL32.@)
+ *
+ * Unicode version of LoadLibraryExA.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExW(LPCWSTR libnameW, HANDLE hfile, DWORD flags)
+{
+    UNICODE_STRING      wstr;
+    HMODULE             res;
+
+    if (!libnameW)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return 0;
+    }
+    RtlInitUnicodeString( &wstr, libnameW );
+    if (wstr.Buffer[wstr.Length/sizeof(WCHAR) - 1] != ' ')
+        return load_library( &wstr, flags );
+
+    /* Library name has trailing spaces */
+    RtlCreateUnicodeString( &wstr, libnameW );
+    while (wstr.Length > sizeof(WCHAR) &&
+           wstr.Buffer[wstr.Length/sizeof(WCHAR) - 1] == ' ')
+    {
+        wstr.Length -= sizeof(WCHAR);
+    }
+    wstr.Buffer[wstr.Length/sizeof(WCHAR)] = '\0';
+    res = load_library( &wstr, flags );
+    RtlFreeUnicodeString( &wstr );
+    return res;
+}
+
+/***********************************************************************
+ *           LoadLibraryA         (KERNEL32.@)
+ *
+ * Load a dll file into the process address space.
+ *
+ * PARAMS
+ *  libname [I] Name of the file to load
+ *
+ * RETURNS
+ *  Success: A handle to the loaded dll.
+ *  Failure: A NULL handle. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ * See LoadLibraryExA().
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryA(LPCSTR libname)
+{
+    return LoadLibraryExA(libname, 0, 0);
+}
+
+/***********************************************************************
+ *           LoadLibraryW         (KERNEL32.@)
+ *
+ * Unicode version of LoadLibraryA.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryW(LPCWSTR libnameW)
+{
+    return LoadLibraryExW(libnameW, 0, 0);
+}
+
+/***********************************************************************
+ *           FreeLibrary   (KERNEL32.@)
+ *
+ * Free a dll loaded into the process address space.
+ *
+ * PARAMS
+ *  hLibModule [I] Handle to the dll returned by LoadLibraryA().
+ *
+ * RETURNS
+ *  Success: TRUE. The dll is removed if it is not still in use.
+ *  Failure: FALSE. Use GetLastError() to determine the cause.
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary(HINSTANCE hLibModule)
+{
+    if (!hLibModule)
+    {
+        SetLastError( ERROR_INVALID_HANDLE );
+        return FALSE;
+    }
+
+    if ((ULONG_PTR)hLibModule & 3) /* this is a datafile module */
+    {
+        void *ptr = (void *)((ULONG_PTR)hLibModule & ~3);
+        if (!RtlImageNtHeader( ptr ))
+        {
+            SetLastError( ERROR_BAD_EXE_FORMAT );
+            return FALSE;
+        }
+        if ((ULONG_PTR)hLibModule & 1)
+        {
+            struct exclusive_datafile *file;
+            ULONG_PTR magic;
+
+            LdrLockLoaderLock( 0, NULL, &magic );
+            LIST_FOR_EACH_ENTRY( file, &exclusive_datafile_list, struct exclusive_datafile, entry )
+            {
+                if (file->module != hLibModule) continue;
+                TRACE( "closing %p for module %p\n", file->file, file->module );
+                CloseHandle( file->file );
+                list_remove( &file->entry );
+                HeapFree( GetProcessHeap(), 0, file );
+                break;
+            }
+            LdrUnlockLoaderLock( 0, magic );
+        }
+        return UnmapViewOfFile( ptr );
+    }
+
+    return set_ntstatus( LdrUnloadDll( hLibModule ));
+}
+
 /***********************************************************************
  *           GetProcAddress   		(KERNEL32.@)
  *
diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 2e96a24324..610ce1deb0 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -442,22 +442,11 @@ static HANDLE open_exe_file( const WCHAR *name, BOOL *is_64bit )
  */
 static BOOL find_exe_file( const WCHAR *name, WCHAR *buffer, int buflen, HANDLE *handle )
 {
-    WCHAR cur_dir[MAX_PATH];
-    WCHAR *load_path;
-    BOOL ret;
-
-    if (!set_ntstatus( RtlGetExePath( name, &load_path ))) return FALSE;
-
-    TRACE("looking for %s in %s\n", debugstr_w(name), debugstr_w(load_path) );
+    TRACE("looking for %s\n", debugstr_w(name) );
 
-    ret = (NeedCurrentDirectoryForExePathW( name ) && GetCurrentDirectoryW( MAX_PATH, cur_dir) &&
-           SearchPathW( cur_dir, name, exeW, buflen, buffer, NULL )) ||
-           /* not found in the working directory, try the system search path */
-           (SearchPathW( load_path, name, exeW, buflen, buffer, NULL ) ||
-           /* no builtin found, try native without extension in case it is a Unix app */
-           SearchPathW( load_path, name, NULL, buflen, buffer, NULL ));
-    RtlReleasePath( load_path );
-    if (!ret) return FALSE;
+    if (!SearchPathW( NULL, name, exeW, buflen, buffer, NULL ) &&
+        /* no builtin found, try native without extension in case it is a Unix app */
+        !SearchPathW( NULL, name, NULL, buflen, buffer, NULL )) return FALSE;
 
     TRACE( "Trying native exe %s\n", debugstr_w(buffer) );
     *handle = CreateFileW( buffer, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_DELETE,
@@ -1404,7 +1393,6 @@ void * CDECL __wine_kernel_init(void)
     RTL_USER_PROCESS_PARAMETERS *params = peb->ProcessParameters;
     HANDLE boot_events[2];
     BOOL got_environment = TRUE;
-    WCHAR *load_path, *dummy;
 
     /* Initialize everything */
 
@@ -1443,14 +1431,12 @@ void * CDECL __wine_kernel_init(void)
     {
         BOOL is_64bit;
 
-        RtlGetExePath( __wine_main_wargv[0], &load_path );
-        if (!SearchPathW( load_path, __wine_main_wargv[0], exeW, MAX_PATH, main_exe_name, NULL ) &&
+        if (!SearchPathW( NULL, __wine_main_wargv[0], exeW, MAX_PATH, main_exe_name, NULL ) &&
             !get_builtin_path( __wine_main_wargv[0], exeW, main_exe_name, MAX_PATH, &is_64bit ))
         {
             MESSAGE( "wine: cannot find '%s'\n", __wine_main_argv[0] );
             ExitProcess( GetLastError() );
         }
-        RtlReleasePath( load_path );
         update_library_argv0( main_exe_name );
         if (!build_command_line( __wine_main_wargv )) goto error;
         start_wineboot( boot_events );
@@ -1463,8 +1449,8 @@ void * CDECL __wine_kernel_init(void)
     TRACE( "starting process name=%s argv[0]=%s\n",
            debugstr_w(main_exe_name), debugstr_w(__wine_main_wargv[0]) );
 
-    LdrGetDllPath( main_exe_name, 0, &load_path, &dummy );
-    RtlInitUnicodeString( &NtCurrentTeb()->Peb->ProcessParameters->DllPath, load_path );
+    RtlInitUnicodeString( &NtCurrentTeb()->Peb->ProcessParameters->DllPath,
+                          MODULE_get_dll_load_path( main_exe_name, -1 ));
 
     if (boot_events[0])
     {
diff --git a/dlls/kernel32/tests/path.c b/dlls/kernel32/tests/path.c
index 11b5ea35f0..976993c922 100644
--- a/dlls/kernel32/tests/path.c
+++ b/dlls/kernel32/tests/path.c
@@ -73,15 +73,10 @@ static DWORD (WINAPI *pGetLongPathNameW)(LPWSTR,LPWSTR,DWORD);
 static BOOL  (WINAPI *pNeedCurrentDirectoryForExePathA)(LPCSTR);
 static BOOL  (WINAPI *pNeedCurrentDirectoryForExePathW)(LPCWSTR);
 
-static DLL_DIRECTORY_COOKIE (WINAPI *pAddDllDirectory)(const WCHAR*);
-static BOOL     (WINAPI *pRemoveDllDirectory)(DLL_DIRECTORY_COOKIE);
-static BOOL     (WINAPI *pSetSearchPathMode)(DWORD);
-static BOOL     (WINAPI *pSetDllDirectoryW)(LPCWSTR);
-static BOOL     (WINAPI *pSetDefaultDllDirectories)(DWORD);
-static NTSTATUS (WINAPI *pRtlGetExePath)(LPCWSTR,LPWSTR*);
+static BOOL  (WINAPI *pSetSearchPathMode)(DWORD);
+static BOOL  (WINAPI *pSetDllDirectoryA)(LPCSTR);
 static NTSTATUS (WINAPI *pRtlGetSearchPath)(LPWSTR*);
-static void     (WINAPI *pRtlReleasePath)(LPWSTR);
-static NTSTATUS (WINAPI *pLdrGetDllPath)(LPCWSTR,ULONG,LPWSTR*,LPWSTR*);
+static void (WINAPI *pRtlReleasePath)(LPWSTR);
 
 static BOOL   (WINAPI *pActivateActCtx)(HANDLE,ULONG_PTR*);
 static HANDLE (WINAPI *pCreateActCtxW)(PCACTCTXW);
@@ -2209,10 +2204,7 @@ static void init_pointers(void)
     MAKEFUNC(NeedCurrentDirectoryForExePathA);
     MAKEFUNC(NeedCurrentDirectoryForExePathW);
     MAKEFUNC(SetSearchPathMode);
-    MAKEFUNC(AddDllDirectory);
-    MAKEFUNC(RemoveDllDirectory);
-    MAKEFUNC(SetDllDirectoryW);
-    MAKEFUNC(SetDefaultDllDirectories);
+    MAKEFUNC(SetDllDirectoryA);
     MAKEFUNC(ActivateActCtx);
     MAKEFUNC(CreateActCtxW);
     MAKEFUNC(DeactivateActCtx);
@@ -2223,8 +2215,6 @@ static void init_pointers(void)
     MAKEFUNC(CreateSymbolicLinkW);
 
     mod = GetModuleHandleA("ntdll.dll");
-    MAKEFUNC(LdrGetDllPath);
-    MAKEFUNC(RtlGetExePath);
     MAKEFUNC(RtlGetSearchPath);
     MAKEFUNC(RtlReleasePath);
 
@@ -2486,23 +2476,12 @@ static void test_SetSearchPathMode(void)
 
 static const WCHAR pathW[] = {'P','A','T','H',0};
 
-static void build_search_path( WCHAR *buffer, UINT size, const WCHAR *dlldir, BOOL safe )
+static void build_search_path( WCHAR *buffer, UINT size, BOOL safe )
 {
     WCHAR *p;
     GetModuleFileNameW( NULL, buffer, size );
     if (!(p = wcsrchr( buffer, '\\' ))) return;
     *p++ = ';';
-    if (dlldir)
-    {
-        lstrcpyW( p, dlldir );
-        p += lstrlenW( p );
-        if (*dlldir) *p++ = ';';
-    }
-    else if (!safe)
-    {
-        *p++ = '.';
-        *p++ = ';';
-    }
     GetSystemDirectoryW( p, buffer + size - p );
     p = buffer + lstrlenW(buffer);
     *p++ = ';';
@@ -2512,7 +2491,7 @@ static void build_search_path( WCHAR *buffer, UINT size, const WCHAR *dlldir, BO
     GetWindowsDirectoryW( p, buffer + size - p );
     p = buffer + lstrlenW(buffer);
     *p++ = ';';
-    if (!dlldir && safe)
+    if (!safe)
     {
         *p++ = '.';
         *p++ = ';';
@@ -2528,7 +2507,7 @@ static BOOL path_equal( const WCHAR *path1, const WCHAR *path2 )
         if (*path1 && *path1 != '\\' && *path1 != ';') return FALSE;
         while (*path1 && (*path1 == '\\' || *path1 == ';')) path1++;
         while (*path2 && (*path2 == '\\' || *path2 == ';')) path2++;
-        if (!*path1 || !*path2) return !*path1 && !*path2;
+        if (!*path1 && !*path2) return TRUE;
     }
 }
 
@@ -2536,7 +2515,7 @@ static void test_RtlGetSearchPath(void)
 {
     NTSTATUS ret;
     WCHAR *path;
-    WCHAR buffer[2048], old_path[2048], dlldir[4];
+    WCHAR buffer[2048], old_path[2048];
 
     if (!pRtlGetSearchPath)
     {
@@ -2545,10 +2524,8 @@ static void test_RtlGetSearchPath(void)
     }
 
     GetEnvironmentVariableW( pathW, old_path, ARRAY_SIZE(old_path) );
-    GetWindowsDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    lstrcpynW( dlldir, buffer, ARRAY_SIZE(dlldir) );
 
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
+    build_search_path( buffer, ARRAY_SIZE(buffer), FALSE );
     path = (WCHAR *)0xdeadbeef;
     ret = pRtlGetSearchPath( &path );
     ok( !ret, "RtlGetSearchPath failed %x\n", ret );
@@ -2556,195 +2533,23 @@ static void test_RtlGetSearchPath(void)
     pRtlReleasePath( path );
 
     SetEnvironmentVariableA( "PATH", "foo" );
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
+    build_search_path( buffer, ARRAY_SIZE(buffer), FALSE );
     path = (WCHAR *)0xdeadbeef;
     ret = pRtlGetSearchPath( &path );
     ok( !ret, "RtlGetSearchPath failed %x\n", ret );
     ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
     pRtlReleasePath( path );
 
-    if (pSetDllDirectoryW)
+    if (pSetDllDirectoryA)
     {
-        ok( pSetDllDirectoryW( dlldir ), "SetDllDirectoryW failed\n" );
-        build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
+        ok( pSetDllDirectoryA( "c:\\" ), "SetDllDirectoryA failed\n" );
+        build_search_path( buffer, ARRAY_SIZE(buffer), FALSE );
         path = (WCHAR *)0xdeadbeef;
         ret = pRtlGetSearchPath( &path );
         ok( !ret, "RtlGetSearchPath failed %x\n", ret );
         ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
         pRtlReleasePath( path );
-        pSetDllDirectoryW( NULL );
-    }
-
-    SetEnvironmentVariableW( pathW, old_path );
-}
-
-static void test_RtlGetExePath(void)
-{
-    static const WCHAR fooW[] = {'\\','f','o','o',0};
-    static const WCHAR emptyW[1];
-    NTSTATUS ret;
-    WCHAR *path;
-    WCHAR buffer[2048], old_path[2048], dlldir[4];
-
-    if (!pRtlGetExePath)
-    {
-        win_skip( "RtlGetExePath isn't available\n" );
-        return;
-    }
-
-    GetEnvironmentVariableW( pathW, old_path, ARRAY_SIZE(old_path) );
-    GetWindowsDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    lstrcpynW( dlldir, buffer, ARRAY_SIZE(dlldir) );
-    SetEnvironmentVariableA( "NoDefaultCurrentDirectoryInExePath", NULL );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW + 1, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    SetEnvironmentVariableA( "NoDefaultCurrentDirectoryInExePath", "yes" );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), emptyW, TRUE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW + 1, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    SetEnvironmentVariableA( "PATH", "foo" );
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    if (pSetDllDirectoryW)
-    {
-        ok( pSetDllDirectoryW( dlldir ), "SetDllDirectoryW failed\n" );
-        build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-        path = (WCHAR *)0xdeadbeef;
-        ret = pRtlGetExePath( fooW, &path );
-        ok( !ret, "RtlGetExePath failed %x\n", ret );
-        ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-        pRtlReleasePath( path );
-        pSetDllDirectoryW( NULL );
-    }
-
-    SetEnvironmentVariableW( pathW, old_path );
-}
-
-static void test_LdrGetDllPath(void)
-{
-    static const WCHAR fooW[] = {'f','o','o',0};
-    NTSTATUS ret;
-    WCHAR *path, *unknown_ptr, *p;
-    WCHAR buffer[2048], old_path[2048], dlldir[4];
-
-    if (!pLdrGetDllPath)
-    {
-        win_skip( "LdrGetDllPath isn't available\n" );
-        return;
-    }
-    GetEnvironmentVariableW( pathW, old_path, ARRAY_SIZE(old_path) );
-    GetWindowsDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    lstrcpynW( dlldir, buffer, ARRAY_SIZE(dlldir) );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
-
-    path = unknown_ptr = (WCHAR *)0xdeadbeef;
-    ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    SetEnvironmentVariableA( "PATH", "foo" );
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
-    ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    if (pSetDllDirectoryW)
-    {
-        ok( pSetDllDirectoryW( dlldir ), "SetDllDirectoryW failed\n" );
-        build_search_path( buffer, ARRAY_SIZE(buffer), dlldir, TRUE );
-        ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-        ok( !ret, "LdrGetDllPath failed %x\n", ret );
-        ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-        ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-        pRtlReleasePath( path );
-        pSetDllDirectoryW( NULL );
-    }
-
-    ret = pLdrGetDllPath( 0, LOAD_LIBRARY_SEARCH_SYSTEM32, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    GetSystemDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    ret = pLdrGetDllPath( 0, LOAD_LIBRARY_SEARCH_APPLICATION_DIR, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    GetModuleFileNameW( NULL, buffer, ARRAY_SIZE(buffer) );
-    if ((p = wcsrchr( buffer, '\\' ))) *p = 0;
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    ret = pLdrGetDllPath( fooW, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR, &path, &unknown_ptr );
-    ok( ret == STATUS_INVALID_PARAMETER, "LdrGetDllPath failed %x\n", ret );
-
-    lstrcpyW( buffer, dlldir );
-    p = buffer + lstrlenW(buffer);
-    *p++ = '\\';
-    lstrcpyW( p, fooW );
-    ret = pLdrGetDllPath( buffer, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    ok( path_equal( path, dlldir ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(dlldir));
-    pRtlReleasePath( path );
-
-    if (pAddDllDirectory)
-    {
-        DLL_DIRECTORY_COOKIE cookie = pAddDllDirectory( dlldir );
-        ok( !!cookie, "AddDllDirectory failed\n" );
-        ret = pLdrGetDllPath( 0, LOAD_LIBRARY_SEARCH_USER_DIRS, &path, &unknown_ptr );
-        ok( !ret, "LdrGetDllPath failed %x\n", ret );
-        ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-        ok( path_equal( path, dlldir ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(dlldir));
-        pRtlReleasePath( path );
-        pRemoveDllDirectory( cookie );
-    }
-
-    if (pSetDefaultDllDirectories)
-    {
-        pSetDefaultDllDirectories( LOAD_LIBRARY_SEARCH_SYSTEM32 );
-        ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-        ok( !ret, "LdrGetDllPath failed %x\n", ret );
-        ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-        GetSystemDirectoryW( buffer, ARRAY_SIZE(buffer) );
-        ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-        pRtlReleasePath( path );
-        pSetDefaultDllDirectories( 0 );
+        pSetDllDirectoryA( NULL );
     }
 
     SetEnvironmentVariableW( pathW, old_path );
@@ -2874,7 +2679,5 @@ START_TEST(path)
     test_CheckNameLegalDOS8Dot3();
     test_SetSearchPathMode();
     test_RtlGetSearchPath();
-    test_RtlGetExePath();
-    test_LdrGetDllPath();
     test_CreateSymbolicLink();
 }
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index b64a1fc1ae..7d86399af5 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -19,7 +19,7 @@
 @ stdcall AddAuditAccessAce(ptr long long ptr long long)
 @ stdcall AddAuditAccessAceEx(ptr long long long ptr long long)
 @ stdcall AddAuditAccessObjectAce(ptr long long long ptr ptr ptr long long)
-@ stdcall AddDllDirectory(wstr)
+@ stdcall AddDllDirectory(wstr) kernel32.AddDllDirectory
 @ stdcall AddMandatoryAce(ptr long long long ptr)
 @ stdcall AddRefActCtx(ptr)
 # @ stub AddResourceAttributeAce
@@ -394,7 +394,7 @@
 @ stdcall FreeEnvironmentStringsW(ptr)
 # @ stub FreeGPOListInternalA
 # @ stub FreeGPOListInternalW
-@ stdcall FreeLibrary(long)
+@ stdcall FreeLibrary(long) kernel32.FreeLibrary
 @ stdcall FreeLibraryAndExitThread(long long)
 @ stdcall FreeLibraryWhenCallbackReturns(ptr ptr) ntdll.TpCallbackUnloadDllOnCompletion
 @ stdcall FreeResource(long)
@@ -618,7 +618,7 @@
 # @ stub GetPreviousFgPolicyRefreshInfoInternal
 @ stdcall GetPriorityClass(long)
 @ stdcall GetPrivateObjectSecurity(ptr long ptr long ptr)
-@ stdcall GetProcAddress(long str)
+@ stdcall GetProcAddress(long str) kernel32.GetProcAddress
 # @ stub GetProcAddressForCaller
 # @ stub GetProcessDefaultCpuSets
 # @ stub GetProcessGroupAffinity
@@ -922,10 +922,10 @@
 @ stdcall LeaveCriticalSectionWhenCallbackReturns(ptr ptr) ntdll.TpCallbackLeaveCriticalSectionOnCompletion
 # @ stub LoadAppInitDlls
 # @ stub LoadEnclaveData
-@ stdcall LoadLibraryA(str)
-@ stdcall LoadLibraryExA( str long long)
-@ stdcall LoadLibraryExW(wstr long long)
-@ stdcall LoadLibraryW(wstr)
+@ stdcall LoadLibraryA(str) kernel32.LoadLibraryA
+@ stdcall LoadLibraryExA( str long long) kernel32.LoadLibraryExA
+@ stdcall LoadLibraryExW(wstr long long) kernel32.LoadLibraryExW
+@ stdcall LoadLibraryW(wstr) kernel32.LoadLibraryW
 # @ stub LoadPackagedLibrary
 @ stdcall LoadResource(long long)
 @ stdcall LoadStringA(long long ptr long)
@@ -1333,7 +1333,7 @@
 @ stdcall RemapPredefinedHandleInternal(long long)
 @ stdcall RemoveDirectoryA(str) kernel32.RemoveDirectoryA
 @ stdcall RemoveDirectoryW(wstr) kernel32.RemoveDirectoryW
-@ stdcall RemoveDllDirectory(ptr)
+@ stdcall RemoveDllDirectory(ptr) kernel32.RemoveDllDirectory
 # @ stub RemovePackageStatus
 # @ stub RemovePackageStatusForUser
 @ stdcall RemoveVectoredContinueHandler(ptr) ntdll.RtlRemoveVectoredContinueHandler
@@ -1419,7 +1419,7 @@
 @ stdcall SetCriticalSectionSpinCount(ptr long) ntdll.RtlSetCriticalSectionSpinCount
 @ stdcall SetCurrentDirectoryA(str)
 @ stdcall SetCurrentDirectoryW(wstr)
-@ stdcall SetDefaultDllDirectories(long)
+@ stdcall SetDefaultDllDirectories(long) kernel32.SetDefaultDllDirectories
 # @ stub SetDynamicTimeZoneInformation
 @ stdcall SetEndOfFile(long)
 @ stub SetEnvironmentStringsW
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 4a3e0f4722..de46cc8c10 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -31,175 +31,17 @@
 #include "winnls.h"
 #include "winternl.h"
 #include "kernelbase.h"
-#include "wine/list.h"
-#include "wine/asm.h"
 #include "wine/debug.h"
 #include "wine/exception.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
 
-/* to keep track of LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE file handles */
-struct exclusive_datafile
-{
-    struct list entry;
-    HMODULE     module;
-    HANDLE      file;
-};
-static struct list exclusive_datafile_list = LIST_INIT( exclusive_datafile_list );
-
-
 /***********************************************************************
  * Modules
  ***********************************************************************/
 
 
-/******************************************************************
- *      get_proc_address
- */
-FARPROC WINAPI get_proc_address( HMODULE module, LPCSTR function )
-{
-    FARPROC proc;
-    ANSI_STRING str;
-
-    if (!module) module = NtCurrentTeb()->Peb->ImageBaseAddress;
-
-    if ((ULONG_PTR)function >> 16)
-    {
-        RtlInitAnsiString( &str, function );
-        if (!set_ntstatus( LdrGetProcedureAddress( module, &str, 0, (void**)&proc ))) return NULL;
-    }
-    else if (!set_ntstatus( LdrGetProcedureAddress( module, NULL, LOWORD(function), (void**)&proc )))
-        return NULL;
-
-    return proc;
-}
-
-
-/******************************************************************
- *      load_library_as_datafile
- */
-static BOOL load_library_as_datafile( LPCWSTR load_path, DWORD flags, LPCWSTR name, HMODULE *mod_ret )
-{
-    static const WCHAR dotDLL[] = {'.','d','l','l',0};
-
-    WCHAR filenameW[MAX_PATH];
-    HANDLE mapping, file = INVALID_HANDLE_VALUE;
-    HMODULE module = 0;
-    DWORD protect = PAGE_READONLY;
-
-    *mod_ret = 0;
-
-    if (flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE) protect |= SEC_IMAGE;
-
-    if (SearchPathW( load_path, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
-    {
-        file = CreateFileW( filenameW, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE,
-                            NULL, OPEN_EXISTING, 0, 0 );
-    }
-    if (file == INVALID_HANDLE_VALUE) return FALSE;
-
-    mapping = CreateFileMappingW( file, NULL, protect, 0, 0, NULL );
-    if (!mapping) goto failed;
-
-    module = MapViewOfFile( mapping, FILE_MAP_READ, 0, 0, 0 );
-    CloseHandle( mapping );
-    if (!module) goto failed;
-
-    if (!(flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE))
-    {
-        /* make sure it's a valid PE file */
-        if (!RtlImageNtHeader( module )) goto failed;
-        *mod_ret = (HMODULE)((char *)module + 1); /* set bit 0 for data file module */
-
-        if (flags & LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE)
-        {
-            struct exclusive_datafile *file = HeapAlloc( GetProcessHeap(), 0, sizeof(*file) );
-            if (!file) goto failed;
-            file->module = *mod_ret;
-            file->file   = file;
-            list_add_head( &exclusive_datafile_list, &file->entry );
-            TRACE( "delaying close %p for module %p\n", file->file, file->module );
-            return TRUE;
-        }
-    }
-    else *mod_ret = (HMODULE)((char *)module + 2); /* set bit 1 for image resource module */
-
-    CloseHandle( file );
-    return TRUE;
-
-failed:
-    if (module) UnmapViewOfFile( module );
-    CloseHandle( file );
-    return FALSE;
-}
-
-
-/******************************************************************
- *      load_library
- */
-static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
-{
-    const DWORD unsupported_flags = LOAD_IGNORE_CODE_AUTHZ_LEVEL | LOAD_LIBRARY_REQUIRE_SIGNED_TARGET;
-    NTSTATUS status;
-    HMODULE module;
-    WCHAR *load_path, *dummy;
-
-    if (flags & unsupported_flags) FIXME( "unsupported flag(s) used %#08x\n", flags );
-
-    if (!set_ntstatus( LdrGetDllPath( libname->Buffer, flags, &load_path, &dummy ))) return 0;
-
-    if (flags & (LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE |
-                 LOAD_LIBRARY_AS_IMAGE_RESOURCE))
-    {
-        ULONG_PTR magic;
-
-        LdrLockLoaderLock( 0, NULL, &magic );
-        if (!LdrGetDllHandle( load_path, flags, libname, &module ))
-        {
-            LdrAddRefDll( 0, module );
-            LdrUnlockLoaderLock( 0, magic );
-            goto done;
-        }
-        if (load_library_as_datafile( load_path, flags, libname->Buffer, &module ))
-        {
-            LdrUnlockLoaderLock( 0, magic );
-            goto done;
-        }
-        LdrUnlockLoaderLock( 0, magic );
-        flags |= DONT_RESOLVE_DLL_REFERENCES; /* Just in case */
-        /* Fallback to normal behaviour */
-    }
-
-    status = LdrLoadDll( load_path, flags, libname, &module );
-    if (status != STATUS_SUCCESS)
-    {
-        module = 0;
-        if (status == STATUS_DLL_NOT_FOUND && (GetVersion() & 0x80000000))
-            SetLastError( ERROR_DLL_NOT_FOUND );
-        else
-            SetLastError( RtlNtStatusToDosError( status ) );
-    }
-done:
-    RtlReleasePath( load_path );
-    return module;
-}
-
-
-/****************************************************************************
- *	AddDllDirectory   (kernelbase.@)
- */
-DLL_DIRECTORY_COOKIE WINAPI DECLSPEC_HOTPATCH AddDllDirectory( const WCHAR *dir )
-{
-    UNICODE_STRING str;
-    void *cookie;
-
-    RtlInitUnicodeString( &str, dir );
-    if (!set_ntstatus( LdrAddDllDirectory( &str, &cookie ))) return NULL;
-    return cookie;
-}
-
-
 /***********************************************************************
  *	DelayLoadFailureHook   (kernelbase.@)
  */
@@ -227,49 +69,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH DisableThreadLibraryCalls( HMODULE module )
 }
 
 
-/***********************************************************************
- *	FreeLibrary   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary( HINSTANCE module )
-{
-    if (!module)
-    {
-        SetLastError( ERROR_INVALID_HANDLE );
-        return FALSE;
-    }
-
-    if ((ULONG_PTR)module & 3) /* this is a datafile module */
-    {
-        void *ptr = (void *)((ULONG_PTR)module & ~3);
-        if (!RtlImageNtHeader( ptr ))
-        {
-            SetLastError( ERROR_BAD_EXE_FORMAT );
-            return FALSE;
-        }
-        if ((ULONG_PTR)module & 1)
-        {
-            struct exclusive_datafile *file;
-            ULONG_PTR magic;
-
-            LdrLockLoaderLock( 0, NULL, &magic );
-            LIST_FOR_EACH_ENTRY( file, &exclusive_datafile_list, struct exclusive_datafile, entry )
-            {
-                if (file->module != module) continue;
-                TRACE( "closing %p for module %p\n", file->file, file->module );
-                CloseHandle( file->file );
-                list_remove( &file->entry );
-                HeapFree( GetProcessHeap(), 0, file );
-                break;
-            }
-            LdrUnlockLoaderLock( 0, magic );
-        }
-        return UnmapViewOfFile( ptr );
-    }
-
-    return set_ntstatus( LdrUnloadDll( module ));
-}
-
-
 /***********************************************************************
  *	GetModuleFileNameA   (kernelbase.@)
  */
@@ -426,133 +225,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetModuleHandleExW( DWORD flags, LPCWSTR name, HMO
 }
 
 
-/***********************************************************************
- *	GetProcAddress   (kernelbase.@)
- */
-
-#ifdef __x86_64__
-/*
- * Work around a Delphi bug on x86_64.  When delay loading a symbol,
- * Delphi saves rcx, rdx, r8 and r9 to the stack.  It then calls
- * GetProcAddress(), pops the saved registers and calls the function.
- * This works fine if all of the parameters are ints.  However, since
- * it does not save xmm0 - 3, it relies on GetProcAddress() preserving
- * these registers if the function takes floating point parameters.
- * This wrapper saves xmm0 - 3 to the stack.
- */
-__ASM_GLOBAL_FUNC( GetProcAddress,
-                   ".byte 0x48\n\t"  /* hotpatch prolog */
-                   "pushq %rbp\n\t"
-                   __ASM_SEH(".seh_pushreg %rbp\n\t")
-                   __ASM_CFI(".cfi_adjust_cfa_offset 8\n\t")
-                   __ASM_CFI(".cfi_rel_offset %rbp,0\n\t")
-                   "movq %rsp,%rbp\n\t"
-                   __ASM_SEH(".seh_setframe %rbp,0\n\t")
-                   __ASM_CFI(".cfi_def_cfa_register %rbp\n\t")
-                   "subq $0x60,%rsp\n\t"
-                   __ASM_SEH(".seh_stackalloc 0x60\n\t")
-                   __ASM_SEH(".seh_endprologue\n\t")
-                   "movaps %xmm0,-0x10(%rbp)\n\t"
-                   "movaps %xmm1,-0x20(%rbp)\n\t"
-                   "movaps %xmm2,-0x30(%rbp)\n\t"
-                   "movaps %xmm3,-0x40(%rbp)\n\t"
-                   "call " __ASM_NAME("get_proc_address") "\n\t"
-                   "movaps -0x40(%rbp), %xmm3\n\t"
-                   "movaps -0x30(%rbp), %xmm2\n\t"
-                   "movaps -0x20(%rbp), %xmm1\n\t"
-                   "movaps -0x10(%rbp), %xmm0\n\t"
-                   "leaq 0(%rbp),%rsp\n\t"
-                   __ASM_CFI(".cfi_def_cfa_register %rsp\n\t")
-                   "popq %rbp\n\t"
-                   __ASM_CFI(".cfi_adjust_cfa_offset -8\n\t")
-                   __ASM_CFI(".cfi_same_value %rbp\n\t")
-                   "ret" )
-#else /* __x86_64__ */
-
-FARPROC WINAPI DECLSPEC_HOTPATCH GetProcAddress( HMODULE module, LPCSTR function )
-{
-    return get_proc_address( module, function );
-}
-
-#endif /* __x86_64__ */
-
-
-/***********************************************************************
- *	LoadLibraryA   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryA( LPCSTR name )
-{
-    return LoadLibraryExA( name, 0, 0 );
-}
-
-
-/***********************************************************************
- *	LoadLibraryW   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryW( LPCWSTR name )
-{
-    return LoadLibraryExW( name, 0, 0 );
-}
-
-
-/******************************************************************
- *	LoadLibraryExA   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExA( LPCSTR name, HANDLE file, DWORD flags )
-{
-    WCHAR *nameW;
-
-    if (!(nameW = file_name_AtoW( name, FALSE ))) return 0;
-    return LoadLibraryExW( nameW, file, flags );
-}
-
-
-/***********************************************************************
- *	LoadLibraryExW   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExW( LPCWSTR name, HANDLE file, DWORD flags )
-{
-    UNICODE_STRING str;
-    HMODULE module;
-
-    if (!name)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return 0;
-    }
-    RtlInitUnicodeString( &str, name );
-    if (str.Buffer[str.Length/sizeof(WCHAR) - 1] != ' ') return load_library( &str, flags );
-
-    /* library name has trailing spaces */
-    RtlCreateUnicodeString( &str, name );
-    while (str.Length > sizeof(WCHAR) && str.Buffer[str.Length/sizeof(WCHAR) - 1] == ' ')
-        str.Length -= sizeof(WCHAR);
-
-    str.Buffer[str.Length/sizeof(WCHAR)] = 0;
-    module = load_library( &str, flags );
-    RtlFreeUnicodeString( &str );
-    return module;
-}
-
-
-/****************************************************************************
- *	RemoveDllDirectory   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH RemoveDllDirectory( DLL_DIRECTORY_COOKIE cookie )
-{
-    return set_ntstatus( LdrRemoveDllDirectory( cookie ));
-}
-
-
-/*************************************************************************
- *	SetDefaultDllDirectories   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH SetDefaultDllDirectories( DWORD flags )
-{
-    return set_ntstatus( LdrSetDefaultDllDirectories( flags ));
-}
-
-
 /***********************************************************************
  * Resources
  ***********************************************************************/
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index de304d8cd5..8d435f7862 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -73,9 +73,7 @@ const WCHAR system_dir[] = {'C',':','\\','w','i','n','d','o','w','s','\\',
 static const WCHAR system_path[] =
     {'C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m','3','2',';',
      'C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m',';',
-     'C',':','\\','w','i','n','d','o','w','s',0};
-
-static const WCHAR dotW[] = {'.',0};
+     'C',':','\\','w','i','n','d','o','w','s',';',0};
 
 #define IS_OPTION_TRUE(ch) ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
 
@@ -84,17 +82,7 @@ static BOOL imports_fixup_done = FALSE;  /* set once the imports have been fixed
 static BOOL process_detaching = FALSE;  /* set on process detach to avoid deadlocks with thread detach */
 static int free_lib_count;   /* recursion depth of LdrUnloadDll calls */
 static ULONG path_safe_mode;  /* path mode set by RtlSetSearchPathMode */
-static ULONG dll_safe_mode = 1;  /* dll search mode */
 static UNICODE_STRING dll_directory;  /* extra path for LdrSetDllDirectory */
-static DWORD default_search_flags;  /* default flags set by LdrSetDefaultDllDirectories */
-
-struct dll_dir_entry
-{
-    struct list entry;
-    WCHAR       dir[1];
-};
-
-static struct list dll_dir_list = LIST_INIT( dll_dir_list );  /* extra dirs from LdrAddDllDirectory */
 
 static BOOL hide_wine_exports = FALSE;  /* try to hide ntdll wine exports from applications */
 
@@ -2249,54 +2237,25 @@ static BOOL is_valid_binary( HMODULE module, const pe_image_info_t *info )
 }
 
 
-/******************************************************************
- *		get_module_path_end
- *
- * Returns the end of the directory component of the module path.
- */
-static inline const WCHAR *get_module_path_end( const WCHAR *module )
-{
-    const WCHAR *p;
-    const WCHAR *mod_end = module;
-
-    if ((p = strrchrW( mod_end, '\\' ))) mod_end = p;
-    if ((p = strrchrW( mod_end, '/' ))) mod_end = p;
-    if (mod_end == module + 2 && module[1] == ':') mod_end++;
-    if (mod_end == module && module[0] && module[1] == ':') mod_end += 2;
-    return mod_end;
-}
-
-
-/******************************************************************
- *		append_path
- *
- * Append a counted string to the load path. Helper for get_dll_load_path.
- */
-static inline WCHAR *append_path( WCHAR *p, const WCHAR *str, int len )
-{
-    if (len == -1) len = strlenW(str);
-    if (!len) return p;
-    memcpy( p, str, len * sizeof(WCHAR) );
-    p[len] = ';';
-    return p + len + 1;
-}
-
-
 /******************************************************************
  *           get_dll_load_path
  */
-static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_mode, WCHAR **path )
+static NTSTATUS get_dll_load_path( LPCWSTR module, int safe_mode, WCHAR **path )
 {
     static const WCHAR pathW[] = {'P','A','T','H',0};
+    static const WCHAR dotW[] = {'.',';',0};
 
     const WCHAR *mod_end = module;
     UNICODE_STRING name, value;
     WCHAR *p, *ret;
-    int len = ARRAY_SIZE(system_path) + 1, path_len = 0;
+    int len = ARRAY_SIZE(system_path), path_len = 0;
 
     if (module)
     {
-        mod_end = get_module_path_end( module );
+        if ((p = strrchrW( mod_end, '\\' ))) mod_end = p;
+        if ((p = strrchrW( mod_end, '/' ))) mod_end = p;
+        if (mod_end == module + 2 && module[1] == ':') mod_end++;
+        if (mod_end == module && module[0] && module[1] == ':') mod_end += 2;
         len += (mod_end - module) + 1;
     }
 
@@ -2307,18 +2266,18 @@ static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_m
     if (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
         path_len = value.Length;
 
-    if (dll_dir) len += strlenW( dll_dir ) + 1;
-    else len += 2;  /* current directory */
-    if (!(p = ret = RtlAllocateHeap( GetProcessHeap(), 0, path_len + len * sizeof(WCHAR) )))
+    len += 2;  /* current directory */
+    if (!(ret = RtlAllocateHeap( GetProcessHeap(), 0, path_len + len * sizeof(WCHAR) )))
         return STATUS_NO_MEMORY;
-
-    p = append_path( p, module, mod_end - module );
-    if (dll_dir) p = append_path( p, dll_dir, -1 );
-    else if (!safe_mode) p = append_path( p, dotW, -1 );
-    p = append_path( p, system_path, -1 );
-    if (!dll_dir && safe_mode) p = append_path( p, dotW, -1 );
-
-    value.Buffer = p;
+    memcpy( ret, module, (mod_end - module) * sizeof(WCHAR) );
+    p = ret + (mod_end - module);
+    if (p > ret) *p++ = ';';
+    *p = 0;
+    if (!safe_mode) strcatW( ret, dotW );
+    strcatW( ret, system_path );
+    if (safe_mode) strcatW( ret, dotW );
+
+    value.Buffer = ret + strlenW(ret);
     value.MaximumLength = path_len;
 
     while (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
@@ -2342,69 +2301,6 @@ static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_m
 }
 
 
-/******************************************************************
- *		get_dll_load_path_search_flags
- */
-static NTSTATUS get_dll_load_path_search_flags( LPCWSTR module, DWORD flags, WCHAR **path )
-{
-    const WCHAR *image = NULL, *mod_end, *image_end;
-    struct dll_dir_entry *dir;
-    WCHAR *p, *ret;
-    int len = 1;
-
-    if (flags & LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)
-        flags |= (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
-                  LOAD_LIBRARY_SEARCH_USER_DIRS |
-                  LOAD_LIBRARY_SEARCH_SYSTEM32);
-
-    if (flags & LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR)
-    {
-        DWORD type = RtlDetermineDosPathNameType_U( module );
-        if (type != ABSOLUTE_DRIVE_PATH && type != ABSOLUTE_PATH)
-            return STATUS_INVALID_PARAMETER;
-        mod_end = get_module_path_end( module );
-        len += (mod_end - module) + 1;
-    }
-    else module = NULL;
-
-    if (flags & LOAD_LIBRARY_SEARCH_APPLICATION_DIR)
-    {
-        image = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-        image_end = get_module_path_end( image );
-        len += (image_end - image) + 1;
-    }
-
-    if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
-    {
-        LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
-            len += strlenW( dir->dir + 4 /* \??\ */ ) + 1;
-        if (dll_directory.Length) len += dll_directory.Length / sizeof(WCHAR) + 1;
-    }
-
-    if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) len += strlenW( system_dir );
-
-    if ((p = ret = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
-    {
-        if (module) p = append_path( p, module, mod_end - module );
-        if (image) p = append_path( p, image, image_end - image );
-        if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
-        {
-            LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
-                p = append_path( p, dir->dir + 4 /* \??\ */, -1 );
-            p = append_path( p, dll_directory.Buffer, dll_directory.Length / sizeof(WCHAR) );
-        }
-        if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) strcpyW( p, system_dir );
-        else
-        {
-            if (p > ret) p--;
-            *p = 0;
-        }
-    }
-    *path = ret;
-    return STATUS_SUCCESS;
-}
-
-
 /***********************************************************************
  *	open_dll_file
  *
@@ -4143,7 +4039,6 @@ static void load_global_options(void)
                                      'S','e','s','s','i','o','n',' ','M','a','n','a','g','e','r',0};
     static const WCHAR globalflagW[] = {'G','l','o','b','a','l','F','l','a','g',0};
     static const WCHAR safesearchW[] = {'S','a','f','e','P','r','o','c','e','s','s','S','e','a','r','c','h','M','o','d','e',0};
-    static const WCHAR safedllmodeW[] = {'S','a','f','e','D','l','l','S','e','a','r','c','h','M','o','d','e',0};
     static const WCHAR critsectW[] = {'C','r','i','t','i','c','a','l','S','e','c','t','i','o','n','T','i','m','e','o','u','t',0};
     static const WCHAR heapresW[] = {'H','e','a','p','S','e','g','m','e','n','t','R','e','s','e','r','v','e',0};
     static const WCHAR heapcommitW[] = {'H','e','a','p','S','e','g','m','e','n','t','C','o','m','m','i','t',0};
@@ -4167,7 +4062,6 @@ static void load_global_options(void)
 
     query_dword_option( hkey, globalflagW, &NtCurrentTeb()->Peb->NtGlobalFlag );
     query_dword_option( hkey, safesearchW, &path_safe_mode );
-    query_dword_option( hkey, safedllmodeW, &dll_safe_mode );
 
     if (!query_dword_option( hkey, critsectW, &value ))
         NtCurrentTeb()->Peb->CriticalSectionTimeout.QuadPart = (ULONGLONG)value * -10000000;
@@ -4320,124 +4214,6 @@ NTSTATUS WINAPI LdrSetDllDirectory( const UNICODE_STRING *dir )
 }
 
 
-/****************************************************************************
- *		LdrAddDllDirectory  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrAddDllDirectory( const UNICODE_STRING *dir, void **cookie )
-{
-    FILE_BASIC_INFORMATION info;
-    UNICODE_STRING nt_name;
-    NTSTATUS status;
-    OBJECT_ATTRIBUTES attr;
-    DWORD len;
-    struct dll_dir_entry *ptr;
-    DOS_PATHNAME_TYPE type = RtlDetermineDosPathNameType_U( dir->Buffer );
-
-    if (type != ABSOLUTE_PATH && type != ABSOLUTE_DRIVE_PATH)
-        return STATUS_INVALID_PARAMETER;
-
-    status = RtlDosPathNameToNtPathName_U_WithStatus( dir->Buffer, &nt_name, NULL, NULL );
-    if (status) return status;
-    len = nt_name.Length / sizeof(WCHAR);
-    if (!(ptr = RtlAllocateHeap( GetProcessHeap(), 0, offsetof(struct dll_dir_entry, dir[++len] ))))
-        return STATUS_NO_MEMORY;
-    memcpy( ptr->dir, nt_name.Buffer, len * sizeof(WCHAR) );
-
-    attr.Length = sizeof(attr);
-    attr.RootDirectory = 0;
-    attr.Attributes = OBJ_CASE_INSENSITIVE;
-    attr.ObjectName = &nt_name;
-    attr.SecurityDescriptor = NULL;
-    attr.SecurityQualityOfService = NULL;
-    status = NtQueryAttributesFile( &attr, &info );
-    RtlFreeUnicodeString( &nt_name );
-
-    if (!status)
-    {
-        TRACE( "%s\n", debugstr_w( ptr->dir ));
-        RtlEnterCriticalSection( &dlldir_section );
-        list_add_head( &dll_dir_list, &ptr->entry );
-        RtlLeaveCriticalSection( &dlldir_section );
-        *cookie = ptr;
-    }
-    else RtlFreeHeap( GetProcessHeap(), 0, ptr );
-    return status;
-}
-
-
-/****************************************************************************
- *		LdrRemoveDllDirectory  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrRemoveDllDirectory( void *cookie )
-{
-    struct dll_dir_entry *ptr = cookie;
-
-    TRACE( "%s\n", debugstr_w( ptr->dir ));
-
-    RtlEnterCriticalSection( &dlldir_section );
-    list_remove( &ptr->entry );
-    RtlFreeHeap( GetProcessHeap(), 0, ptr );
-    RtlLeaveCriticalSection( &dlldir_section );
-    return STATUS_SUCCESS;
-}
-
-
-/*************************************************************************
- *		LdrSetDefaultDllDirectories  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrSetDefaultDllDirectories( ULONG flags )
-{
-    /* LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR doesn't make sense in default dirs */
-    const ULONG load_library_search_flags = (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
-                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
-                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
-                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
-
-    if (!flags || (flags & ~load_library_search_flags)) return STATUS_INVALID_PARAMETER;
-    default_search_flags = flags;
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************
- *		LdrGetDllPath  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrGetDllPath( PCWSTR module, ULONG flags, PWSTR *path, PWSTR *unknown )
-{
-    NTSTATUS status;
-    const ULONG load_library_search_flags = (LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR |
-                                             LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
-                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
-                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
-                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
-
-    if (flags & LOAD_WITH_ALTERED_SEARCH_PATH)
-    {
-        if (flags & load_library_search_flags) return STATUS_INVALID_PARAMETER;
-        if (default_search_flags) flags |= default_search_flags | LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR;
-    }
-    else if (!(flags & load_library_search_flags)) flags |= default_search_flags;
-
-    RtlEnterCriticalSection( &dlldir_section );
-
-    if (flags & load_library_search_flags)
-    {
-        status = get_dll_load_path_search_flags( module, flags, path );
-    }
-    else
-    {
-        const WCHAR *dlldir = dll_directory.Length ? dll_directory.Buffer : NULL;
-        if (!(flags & LOAD_WITH_ALTERED_SEARCH_PATH))
-            module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-        status = get_dll_load_path( module, dlldir, dll_safe_mode, path );
-    }
-
-    RtlLeaveCriticalSection( &dlldir_section );
-    *unknown = NULL;
-    return status;
-}
-
-
 /*************************************************************************
  *		RtlSetSearchPathMode (NTDLL.@)
  */
@@ -4470,38 +4246,13 @@ NTSTATUS WINAPI RtlSetSearchPathMode( ULONG flags )
 }
 
 
-/******************************************************************
- *           RtlGetExePath   (NTDLL.@)
- */
-NTSTATUS WINAPI RtlGetExePath( PCWSTR name, PWSTR *path )
-{
-    static const WCHAR emptyW[1];
-    const WCHAR *dlldir = dotW;
-    const WCHAR *module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-
-    /* same check as NeedCurrentDirectoryForExePathW */
-    if (!strchrW( name, '\\' ))
-    {
-        static const WCHAR env_name[] = {'N','o','D','e','f','a','u','l','t','C','u','r','r','e','n','t',
-                                         'D','i','r','e','c','t','o','r','y','I','n',
-                                         'E','x','e','P','a','t','h',0};
-        UNICODE_STRING name, value = { 0 };
-
-        RtlInitUnicodeString( &name, env_name );
-        if (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) != STATUS_VARIABLE_NOT_FOUND)
-            dlldir = emptyW;
-    }
-    return get_dll_load_path( module, dlldir, FALSE, path );
-}
-
-
 /******************************************************************
  *           RtlGetSearchPath   (NTDLL.@)
  */
 NTSTATUS WINAPI RtlGetSearchPath( PWSTR *path )
 {
-    const WCHAR *module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-    return get_dll_load_path( module, NULL, path_safe_mode, path );
+    WCHAR *module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    return get_dll_load_path( module, path_safe_mode, path );
 }
 
 
diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 1881571b41..00332c7a20 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -71,7 +71,6 @@
 @ stub KiUserExceptionDispatcher
 # @ stub LdrAccessOutOfProcessResource
 @ stdcall LdrAccessResource(long ptr ptr ptr)
-@ stdcall LdrAddDllDirectory(ptr ptr)
 @ stdcall LdrAddRefDll(long ptr)
 # @ stub LdrAlternateResourcesEnabled
 # @ stub LdrCreateOutOfProcessImage
@@ -85,10 +84,9 @@
 # @ stub LdrFindResourceEx_U
 @ stdcall LdrFindResource_U(long ptr long ptr)
 @ stub LdrFlushAlternateResourceModules
-@ stdcall LdrGetDllDirectory(ptr)
 @ stdcall LdrGetDllHandle(wstr long ptr ptr)
 # @ stub LdrGetDllHandleEx
-@ stdcall LdrGetDllPath(wstr long ptr ptr)
+@ stdcall LdrGetDllDirectory(ptr)
 @ stdcall LdrGetProcedureAddress(ptr ptr long ptr)
 # @ stub LdrHotPatchRoutine
 @ stub LdrInitShimEngineDynamic
@@ -100,10 +98,8 @@
 @ stdcall LdrQueryImageFileExecutionOptions(ptr wstr long ptr long ptr)
 @ stdcall LdrQueryProcessModuleInformation(ptr long ptr)
 @ stdcall LdrRegisterDllNotification(long ptr ptr ptr)
-@ stdcall LdrRemoveDllDirectory(ptr)
 @ stdcall LdrResolveDelayLoadedAPI(ptr ptr ptr ptr ptr long)
 @ stub LdrSetAppCompatDllRedirectionCallback
-@ stdcall LdrSetDefaultDllDirectories(long)
 @ stdcall LdrSetDllDirectory(ptr)
 @ stub LdrSetDllManifestProber
 @ stdcall LdrShutdownProcess()
@@ -687,7 +683,6 @@
 @ stdcall RtlGetDaclSecurityDescriptor(ptr ptr ptr ptr)
 @ stub RtlGetElementGenericTable
 # @ stub RtlGetElementGenericTableAvl
-@ stdcall RtlGetExePath(wstr ptr)
 # @ stub RtlGetFirstRange
 @ stdcall RtlGetFrame()
 @ stdcall RtlGetFullPathName_U(wstr long ptr ptr)
diff --git a/include/winternl.h b/include/winternl.h
index e542d3cc90..0eb1fdd162 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -2421,7 +2421,6 @@ NTSYSAPI NTSTATUS  WINAPI DbgUiIssueRemoteBreakin(HANDLE);
 NTSYSAPI void      WINAPI DbgUiRemoteBreakin(void*);
 NTSYSAPI void      WINAPI DbgUserBreakPoint(void);
 NTSYSAPI NTSTATUS  WINAPI LdrAccessResource(HMODULE,const IMAGE_RESOURCE_DATA_ENTRY*,void**,PULONG);
-NTSYSAPI NTSTATUS  WINAPI LdrAddDllDirectory(const UNICODE_STRING*,void**);
 NTSYSAPI NTSTATUS  WINAPI LdrAddRefDll(ULONG,HMODULE);
 NTSYSAPI NTSTATUS  WINAPI LdrDisableThreadCalloutsForDll(HMODULE);
 NTSYSAPI NTSTATUS  WINAPI LdrFindEntryForAddress(const void*, PLDR_MODULE*);
@@ -2429,15 +2428,12 @@ NTSYSAPI NTSTATUS  WINAPI LdrFindResourceDirectory_U(HMODULE,const LDR_RESOURCE_
 NTSYSAPI NTSTATUS  WINAPI LdrFindResource_U(HMODULE,const LDR_RESOURCE_INFO*,ULONG,const IMAGE_RESOURCE_DATA_ENTRY**);
 NTSYSAPI NTSTATUS  WINAPI LdrGetDllDirectory(UNICODE_STRING*);
 NTSYSAPI NTSTATUS  WINAPI LdrGetDllHandle(LPCWSTR, ULONG, const UNICODE_STRING*, HMODULE*);
-NTSYSAPI NTSTATUS  WINAPI LdrGetDllPath(PCWSTR,ULONG,PWSTR*,PWSTR*);
 NTSYSAPI NTSTATUS  WINAPI LdrGetProcedureAddress(HMODULE, const ANSI_STRING*, ULONG, void**);
 NTSYSAPI NTSTATUS  WINAPI LdrLoadDll(LPCWSTR, DWORD, const UNICODE_STRING*, HMODULE*);
 NTSYSAPI NTSTATUS  WINAPI LdrLockLoaderLock(ULONG,ULONG*,ULONG_PTR*);
 IMAGE_BASE_RELOCATION * WINAPI LdrProcessRelocationBlock(void*,UINT,USHORT*,INT_PTR);
 NTSYSAPI NTSTATUS  WINAPI LdrQueryImageFileExecutionOptions(const UNICODE_STRING*,LPCWSTR,ULONG,void*,ULONG,ULONG*);
 NTSYSAPI NTSTATUS  WINAPI LdrQueryProcessModuleInformation(SYSTEM_MODULE_INFORMATION*, ULONG, ULONG*);
-NTSYSAPI NTSTATUS  WINAPI LdrRemoveDllDirectory(void*);
-NTSYSAPI NTSTATUS  WINAPI LdrSetDefaultDllDirectories(ULONG);
 NTSYSAPI NTSTATUS  WINAPI LdrSetDllDirectory(const UNICODE_STRING*);
 NTSYSAPI void      WINAPI LdrShutdownProcess(void);
 NTSYSAPI void      WINAPI LdrShutdownThread(void);
@@ -2837,7 +2833,6 @@ NTSYSAPI NTSTATUS  WINAPI RtlGetControlSecurityDescriptor(PSECURITY_DESCRIPTOR,
 NTSYSAPI ULONG     WINAPI RtlGetCurrentDirectory_U(ULONG, LPWSTR);
 NTSYSAPI PEB *     WINAPI RtlGetCurrentPeb(void);
 NTSYSAPI NTSTATUS  WINAPI RtlGetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR,PBOOLEAN,PACL *,PBOOLEAN);
-NTSYSAPI NTSTATUS  WINAPI RtlGetExePath(PCWSTR,PWSTR*);
 NTSYSAPI TEB_ACTIVE_FRAME * WINAPI RtlGetFrame(void);
 NTSYSAPI ULONG     WINAPI RtlGetFullPathName_U(PCWSTR,ULONG,PWSTR,PWSTR*);
 NTSYSAPI NTSTATUS  WINAPI RtlGetGroupSecurityDescriptor(PSECURITY_DESCRIPTOR,PSID *,PBOOLEAN);

From 743d5f207440ef2dc05ee58b72ad0d61d05eb4c0 Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Fri, 27 Sep 2019 10:40:58 +0200
Subject: Revert "kernel32: Move delay-load functions to kernelbase."

This reverts commit 0f5538b9e349fe7b5924b8c0b84ca8a917962701.

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index e051ac0e7a..eb5e0ef5b3 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -356,7 +356,7 @@
 @ stdcall DecodeSystemPointer(ptr) ntdll.RtlDecodeSystemPointer
 @ stdcall DefineDosDeviceA(long str str)
 @ stdcall DefineDosDeviceW(long wstr wstr)
-@ stdcall -import DelayLoadFailureHook(str str)
+@ stdcall DelayLoadFailureHook(str str)
 @ stdcall DeleteAtom(long)
 # @ stub DeleteBoundaryDescriptor
 @ stdcall DeleteCriticalSection(ptr) ntdll.RtlDeleteCriticalSection
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index ad6956d1ce..24fb9e33f5 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -1018,6 +1018,23 @@ FARPROC WINAPI GetProcAddress( HMODULE hModule, LPCSTR function )
     return get_proc_address_wrapper( hModule, function );
 }
 
+/***********************************************************************
+ *           DelayLoadFailureHook  (KERNEL32.@)
+ */
+FARPROC WINAPI DelayLoadFailureHook( LPCSTR name, LPCSTR function )
+{
+    ULONG_PTR args[2];
+
+    if ((ULONG_PTR)function >> 16)
+        ERR( "failed to delay load %s.%s\n", name, function );
+    else
+        ERR( "failed to delay load %s.%u\n", name, LOWORD(function) );
+    args[0] = (ULONG_PTR)name;
+    args[1] = (ULONG_PTR)function;
+    RaiseException( EXCEPTION_WINE_STUB, EH_NONCONTINUABLE, 2, args );
+    return NULL;
+}
+
 typedef struct _PEB32
 {
     BOOLEAN InheritedAddressSpace;
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index b582b3d092..eeb46952ea 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -244,7 +244,7 @@
 # @ stub DecodeRemotePointer
 @ stdcall DecodeSystemPointer(ptr) ntdll.RtlDecodeSystemPointer
 @ stdcall DefineDosDeviceW(long wstr wstr) kernel32.DefineDosDeviceW
-@ stdcall DelayLoadFailureHook(str str)
+@ stdcall DelayLoadFailureHook(str str) kernel32.DelayLoadFailureHook
 # @ stub DelayLoadFailureHookLookup
 @ stdcall DeleteAce(ptr long)
 # @ stub DeleteBoundaryDescriptor
@@ -1343,7 +1343,7 @@
 @ stdcall ResetEvent(long)
 # @ stub ResetState
 @ stdcall ResetWriteWatch(ptr long)
-@ stdcall -import ResolveDelayLoadedAPI(ptr ptr ptr ptr ptr long) LdrResolveDelayLoadedAPI
+@ stdcall ResolveDelayLoadedAPI(ptr ptr ptr ptr ptr long) kernel32.ResolveDelayLoadedAPI
 # @ stub ResolveDelayLoadsFromDll
 @ stdcall ResolveLocaleName(wstr ptr long)
 @ stdcall RestoreLastError(long) ntdll.RtlRestoreLastWin32Error
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 9d0486d8a6..34c8add910 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -42,24 +42,6 @@ WINE_DEFAULT_DEBUG_CHANNEL(module);
  ***********************************************************************/
 
 
-/***********************************************************************
- *	DelayLoadFailureHook   (kernelbase.@)
- */
-FARPROC WINAPI DECLSPEC_HOTPATCH DelayLoadFailureHook( LPCSTR name, LPCSTR function )
-{
-    ULONG_PTR args[2];
-
-    if ((ULONG_PTR)function >> 16)
-        ERR( "failed to delay load %s.%s\n", name, function );
-    else
-        ERR( "failed to delay load %s.%u\n", name, LOWORD(function) );
-    args[0] = (ULONG_PTR)name;
-    args[1] = (ULONG_PTR)function;
-    RaiseException( EXCEPTION_WINE_STUB, EH_NONCONTINUABLE, 2, args );
-    return NULL;
-}
-
-
 /****************************************************************************
  *	DisableThreadLibraryCalls   (kernelbase.@)
  */


From 8b947e5cc131821ec51434ee2446682a707e02cb Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Tue, 13 Aug 2019 05:16:50 +0200
Subject: Revert "kernel32: Move some module functions to kernelbase."

This reverts commit 05d00276c627753487c571c30fddfc56c02ad37e.

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 016c3022dc..bb496425aa 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -377,7 +377,7 @@
 @ stdcall DeleteVolumeMountPointW(wstr)
 @ stdcall -arch=x86_64 DequeueUmsCompletionListItems(ptr long ptr)
 @ stdcall DeviceIoControl(long long ptr long ptr long ptr ptr)
-@ stdcall -import DisableThreadLibraryCalls(long)
+@ stdcall DisableThreadLibraryCalls(long)
 @ stdcall -import DisconnectNamedPipe(long)
 @ stdcall DnsHostnameToComputerNameA (str ptr ptr)
 @ stdcall DnsHostnameToComputerNameW (wstr ptr ptr)
@@ -718,12 +718,12 @@
 @ stdcall GetMailslotInfo(long ptr ptr ptr ptr)
 @ stdcall GetMaximumProcessorCount(long)
 @ stdcall GetMaximumProcessorGroupCount()
-@ stdcall -import GetModuleFileNameA(long ptr long)
-@ stdcall -import GetModuleFileNameW(long ptr long)
-@ stdcall -import GetModuleHandleA(str)
-@ stdcall -import GetModuleHandleExA(long ptr ptr)
-@ stdcall -import GetModuleHandleExW(long ptr ptr)
-@ stdcall -import GetModuleHandleW(wstr)
+@ stdcall GetModuleFileNameA(long ptr long)
+@ stdcall GetModuleFileNameW(long ptr long)
+@ stdcall GetModuleHandleA(str)
+@ stdcall GetModuleHandleExA(long ptr ptr)
+@ stdcall GetModuleHandleExW(long ptr ptr)
+@ stdcall GetModuleHandleW(wstr)
 # @ stub GetNamedPipeAttribute
 # @ stub GetNamedPipeClientComputerNameA
 # @ stub GetNamedPipeClientComputerNameW
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index acfc365200..386a7c2239 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -233,6 +233,33 @@ BOOL WINAPI SetDefaultDllDirectories( DWORD flags )
 }
 
 
+/****************************************************************************
+ *              DisableThreadLibraryCalls (KERNEL32.@)
+ *
+ * Inform the module loader that thread notifications are not required for a dll.
+ *
+ * PARAMS
+ *  hModule [I] Module handle to skip calls for
+ *
+ * RETURNS
+ *  Success: TRUE. Thread attach and detach notifications will not be sent
+ *           to hModule.
+ *  Failure: FALSE. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ *  This is typically called from the dll entry point of a dll during process
+ *  attachment, for dlls that do not need to process thread notifications.
+ */
+BOOL WINAPI DisableThreadLibraryCalls( HMODULE hModule )
+{
+    NTSTATUS    nts = LdrDisableThreadCalloutsForDll( hModule );
+    if (nts == STATUS_SUCCESS) return TRUE;
+
+    SetLastError( RtlNtStatusToDosError( nts ) );
+    return FALSE;
+}
+
+
 /***********************************************************************
  *             GetBinaryTypeW                     [KERNEL32.@]
  *
@@ -375,6 +402,194 @@ BOOL WINAPI GetBinaryTypeA( LPCSTR lpApplicationName, LPDWORD lpBinaryType )
     return FALSE;
 }
 
+/***********************************************************************
+ *              GetModuleHandleExA         (KERNEL32.@)
+ */
+BOOL WINAPI GetModuleHandleExA( DWORD flags, LPCSTR name, HMODULE *module )
+{
+    WCHAR *nameW;
+
+    if (!name || (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS))
+        return GetModuleHandleExW( flags, (LPCWSTR)name, module );
+
+    if (!(nameW = FILE_name_AtoW( name, FALSE ))) return FALSE;
+    return GetModuleHandleExW( flags, nameW, module );
+}
+
+/***********************************************************************
+ *              GetModuleHandleExW         (KERNEL32.@)
+ */
+BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+    HMODULE ret;
+    ULONG_PTR magic;
+    BOOL lock;
+
+    if (!module)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
+
+    /* if we are messing with the refcount, grab the loader lock */
+    lock = (flags & GET_MODULE_HANDLE_EX_FLAG_PIN) || !(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT);
+    if (lock)
+        LdrLockLoaderLock( 0, NULL, &magic );
+
+    if (!name)
+    {
+        ret = NtCurrentTeb()->Peb->ImageBaseAddress;
+    }
+    else if (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS)
+    {
+        void *dummy;
+        if (!(ret = RtlPcToFileHeader( (void *)name, &dummy ))) status = STATUS_DLL_NOT_FOUND;
+    }
+    else
+    {
+        UNICODE_STRING wstr;
+        RtlInitUnicodeString( &wstr, name );
+        status = LdrGetDllHandle( NULL, 0, &wstr, &ret );
+    }
+
+    if (status == STATUS_SUCCESS)
+    {
+        if (flags & GET_MODULE_HANDLE_EX_FLAG_PIN)
+            LdrAddRefDll( LDR_ADDREF_DLL_PIN, ret );
+        else if (!(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT))
+            LdrAddRefDll( 0, ret );
+    }
+    else SetLastError( RtlNtStatusToDosError( status ) );
+
+    if (lock)
+        LdrUnlockLoaderLock( 0, magic );
+
+    if (status == STATUS_SUCCESS) *module = ret;
+    else *module = NULL;
+
+    return (status == STATUS_SUCCESS);
+}
+
+/***********************************************************************
+ *              GetModuleHandleA         (KERNEL32.@)
+ *
+ * Get the handle of a dll loaded into the process address space.
+ *
+ * PARAMS
+ *  module [I] Name of the dll
+ *
+ * RETURNS
+ *  Success: A handle to the loaded dll.
+ *  Failure: A NULL handle. Use GetLastError() to determine the cause.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleA(LPCSTR module)
+{
+    HMODULE ret;
+
+    GetModuleHandleExA( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
+    return ret;
+}
+
+/***********************************************************************
+ *		GetModuleHandleW (KERNEL32.@)
+ *
+ * Unicode version of GetModuleHandleA.
+ */
+HMODULE WINAPI GetModuleHandleW(LPCWSTR module)
+{
+    HMODULE ret;
+
+    GetModuleHandleExW( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
+    return ret;
+}
+
+
+/***********************************************************************
+ *              GetModuleFileNameA      (KERNEL32.@)
+ *
+ * Get the file name of a loaded module from its handle.
+ *
+ * RETURNS
+ *  Success: The length of the file name, excluding the terminating NUL.
+ *  Failure: 0. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ *  This function always returns the long path of hModule
+ *  The function doesn't write a terminating '\0' if the buffer is too 
+ *  small.
+ */
+DWORD WINAPI GetModuleFileNameA(
+	HMODULE hModule,	/* [in] Module handle (32 bit) */
+	LPSTR lpFileName,	/* [out] Destination for file name */
+        DWORD size )		/* [in] Size of lpFileName in characters */
+{
+    LPWSTR filenameW = HeapAlloc( GetProcessHeap(), 0, size * sizeof(WCHAR) );
+    DWORD len;
+
+    if (!filenameW)
+    {
+        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
+        return 0;
+    }
+    if ((len = GetModuleFileNameW( hModule, filenameW, size )))
+    {
+    	len = FILE_name_WtoA( filenameW, len, lpFileName, size );
+        if (len < size)
+            lpFileName[len] = '\0';
+        else
+            SetLastError( ERROR_INSUFFICIENT_BUFFER );
+    }
+    HeapFree( GetProcessHeap(), 0, filenameW );
+    return len;
+}
+
+/***********************************************************************
+ *              GetModuleFileNameW      (KERNEL32.@)
+ *
+ * Unicode version of GetModuleFileNameA.
+ */
+DWORD WINAPI GetModuleFileNameW( HMODULE hModule, LPWSTR lpFileName, DWORD size )
+{
+    ULONG len = 0;
+    ULONG_PTR magic;
+    LDR_MODULE *pldr;
+    NTSTATUS nts;
+    WIN16_SUBSYSTEM_TIB *win16_tib;
+
+    if (!hModule && ((win16_tib = NtCurrentTeb()->Tib.SubSystemTib)) && win16_tib->exe_name)
+    {
+        len = min(size, win16_tib->exe_name->Length / sizeof(WCHAR));
+        memcpy( lpFileName, win16_tib->exe_name->Buffer, len * sizeof(WCHAR) );
+        if (len < size) lpFileName[len] = '\0';
+        goto done;
+    }
+
+    LdrLockLoaderLock( 0, NULL, &magic );
+
+    if (!hModule) hModule = NtCurrentTeb()->Peb->ImageBaseAddress;
+    nts = LdrFindEntryForAddress( hModule, &pldr );
+    if (nts == STATUS_SUCCESS)
+    {
+        len = min(size, pldr->FullDllName.Length / sizeof(WCHAR));
+        memcpy(lpFileName, pldr->FullDllName.Buffer, len * sizeof(WCHAR));
+        if (len < size)
+        {
+            lpFileName[len] = '\0';
+            SetLastError( 0 );
+        }
+        else
+            SetLastError( ERROR_INSUFFICIENT_BUFFER );
+    }
+    else SetLastError( RtlNtStatusToDosError( nts ) );
+
+    LdrUnlockLoaderLock( 0, magic );
+done:
+    TRACE( "%s\n", debugstr_wn(lpFileName, len) );
+    return len;
+}
+
+
 /***********************************************************************
  *           get_dll_system_path
  */
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 4bb2b55cde..1b8c4cc236 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -263,7 +263,7 @@
 @ stdcall DestroyPrivateObjectSecurity(ptr)
 @ stdcall DeviceIoControl(long long ptr long ptr long ptr ptr) kernel32.DeviceIoControl
 @ stdcall DisablePredefinedHandleTableInternal(long)
-@ stdcall DisableThreadLibraryCalls(long)
+@ stdcall DisableThreadLibraryCalls(long) kernel32.DisableThreadLibraryCalls
 @ stdcall DisassociateCurrentThreadFromCallback(ptr) ntdll.TpDisassociateCallback
 # @ stub DiscardVirtualMemory
 @ stdcall DisconnectNamedPipe(long)
@@ -556,14 +556,14 @@
 # @ stub GetMemoryErrorHandlingCapabilities
 # @ stub GetModuleBaseNameA
 # @ stub GetModuleBaseNameW
-@ stdcall GetModuleFileNameA(long ptr long)
+@ stdcall GetModuleFileNameA(long ptr long) kernel32.GetModuleFileNameA
 # @ stub GetModuleFileNameExA
 # @ stub GetModuleFileNameExW
-@ stdcall GetModuleFileNameW(long ptr long)
-@ stdcall GetModuleHandleA(str)
-@ stdcall GetModuleHandleExA(long ptr ptr)
-@ stdcall GetModuleHandleExW(long ptr ptr)
-@ stdcall GetModuleHandleW(wstr)
+@ stdcall GetModuleFileNameW(long ptr long) kernel32.GetModuleFileNameW
+@ stdcall GetModuleHandleA(str) kernel32.GetModuleHandleA
+@ stdcall GetModuleHandleExA(long ptr ptr) kernel32.GetModuleHandleExA
+@ stdcall GetModuleHandleExW(long ptr ptr) kernel32.GetModuleHandleExW
+@ stdcall GetModuleHandleW(wstr) kernel32.GetModuleHandleW
 # @ stub GetModuleInformation
 @ stub GetNLSVersion
 @ stub GetNLSVersionEx
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 34c8add910..91daa4ec14 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -37,176 +37,6 @@
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
 
-/***********************************************************************
- * Modules
- ***********************************************************************/
-
-
-/****************************************************************************
- *	DisableThreadLibraryCalls   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH DisableThreadLibraryCalls( HMODULE module )
-{
-    return set_ntstatus( LdrDisableThreadCalloutsForDll( module ));
-}
-
-
-/***********************************************************************
- *	GetModuleFileNameA   (kernelbase.@)
- */
-DWORD WINAPI DECLSPEC_HOTPATCH GetModuleFileNameA( HMODULE module, LPSTR filename, DWORD size )
-{
-    LPWSTR filenameW = HeapAlloc( GetProcessHeap(), 0, size * sizeof(WCHAR) );
-    DWORD len;
-
-    if (!filenameW)
-    {
-        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
-        return 0;
-    }
-    if ((len = GetModuleFileNameW( module, filenameW, size )))
-    {
-    	len = file_name_WtoA( filenameW, len, filename, size );
-        if (len < size)
-            filename[len] = 0;
-        else
-            SetLastError( ERROR_INSUFFICIENT_BUFFER );
-    }
-    HeapFree( GetProcessHeap(), 0, filenameW );
-    return len;
-}
-
-
-/***********************************************************************
- *	GetModuleFileNameW   (kernelbase.@)
- */
-DWORD WINAPI DECLSPEC_HOTPATCH GetModuleFileNameW( HMODULE module, LPWSTR filename, DWORD size )
-{
-    ULONG len = 0;
-    ULONG_PTR magic;
-    LDR_MODULE *pldr;
-    WIN16_SUBSYSTEM_TIB *win16_tib;
-
-    if (!module && ((win16_tib = NtCurrentTeb()->Tib.SubSystemTib)) && win16_tib->exe_name)
-    {
-        len = min( size, win16_tib->exe_name->Length / sizeof(WCHAR) );
-        memcpy( filename, win16_tib->exe_name->Buffer, len * sizeof(WCHAR) );
-        if (len < size) filename[len] = 0;
-        goto done;
-    }
-
-    LdrLockLoaderLock( 0, NULL, &magic );
-
-    if (!module) module = NtCurrentTeb()->Peb->ImageBaseAddress;
-    if (set_ntstatus( LdrFindEntryForAddress( module, &pldr )))
-    {
-        len = min( size, pldr->FullDllName.Length / sizeof(WCHAR) );
-        memcpy( filename, pldr->FullDllName.Buffer, len * sizeof(WCHAR) );
-        if (len < size)
-        {
-            filename[len] = 0;
-            SetLastError( 0 );
-        }
-        else SetLastError( ERROR_INSUFFICIENT_BUFFER );
-    }
-
-    LdrUnlockLoaderLock( 0, magic );
-done:
-    TRACE( "%s\n", debugstr_wn(filename, len) );
-    return len;
-}
-
-
-/***********************************************************************
- *	GetModuleHandleA   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleA( LPCSTR module )
-{
-    HMODULE ret;
-
-    GetModuleHandleExA( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
-    return ret;
-}
-
-
-/***********************************************************************
- *	GetModuleHandleW   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleW( LPCWSTR module )
-{
-    HMODULE ret;
-
-    GetModuleHandleExW( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
-    return ret;
-}
-
-
-/***********************************************************************
- *	GetModuleHandleExA   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH GetModuleHandleExA( DWORD flags, LPCSTR name, HMODULE *module )
-{
-    WCHAR *nameW;
-
-    if (!name || (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS))
-        return GetModuleHandleExW( flags, (LPCWSTR)name, module );
-
-    if (!(nameW = file_name_AtoW( name, FALSE ))) return FALSE;
-    return GetModuleHandleExW( flags, nameW, module );
-}
-
-
-/***********************************************************************
- *	GetModuleHandleExW   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-    HMODULE ret = NULL;
-    ULONG_PTR magic;
-    BOOL lock;
-
-    if (!module)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return FALSE;
-    }
-
-    /* if we are messing with the refcount, grab the loader lock */
-    lock = (flags & GET_MODULE_HANDLE_EX_FLAG_PIN) || !(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT);
-    if (lock) LdrLockLoaderLock( 0, NULL, &magic );
-
-    if (!name)
-    {
-        ret = NtCurrentTeb()->Peb->ImageBaseAddress;
-    }
-    else if (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS)
-    {
-        void *dummy;
-        if (!(ret = RtlPcToFileHeader( (void *)name, &dummy ))) status = STATUS_DLL_NOT_FOUND;
-    }
-    else
-    {
-        UNICODE_STRING wstr;
-        RtlInitUnicodeString( &wstr, name );
-        status = LdrGetDllHandle( NULL, 0, &wstr, &ret );
-    }
-
-    if (status == STATUS_SUCCESS)
-    {
-        if (flags & GET_MODULE_HANDLE_EX_FLAG_PIN)
-            LdrAddRefDll( LDR_ADDREF_DLL_PIN, ret );
-        else if (!(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT))
-            LdrAddRefDll( 0, ret );
-    }
-
-    if (lock) LdrUnlockLoaderLock( 0, magic );
-
-    *module = ret;
-    return set_ntstatus( status );
-}
-
-
 /***********************************************************************
  * Resources
  ***********************************************************************/
@@ -259,7 +89,7 @@ static NTSTATUS get_res_nameW( LPCWSTR name, UNICODE_STRING *str )
 
 
 /**********************************************************************
- *	EnumResourceLanguagesExA	(kernelbase.@)
+ *	EnumResourceLanguagesExA	(KERNEL32.@)
  */
 BOOL WINAPI DECLSPEC_HOTPATCH EnumResourceLanguagesExA( HMODULE module, LPCSTR type, LPCSTR name,
                                                         ENUMRESLANGPROCA func, LONG_PTR param,
@@ -319,7 +149,7 @@ done:
 
 
 /**********************************************************************
- *	EnumResourceLanguagesExW	(kernelbase.@)
+ *	EnumResourceLanguagesExW	(KERNEL32.@)
  */
 BOOL WINAPI DECLSPEC_HOTPATCH EnumResourceLanguagesExW( HMODULE module, LPCWSTR type, LPCWSTR name,
                                                         ENUMRESLANGPROCW func, LONG_PTR param,


From aa88eb017be4c3615d0f8aab8a2e16769a6568ad Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 27 Dec 2017 13:31:59 -0600
Subject: [PATCH] loader: Set up Steam stuff in the registry

---
 loader/wine.inf.in | 19 ++++++++++++++++---
 1 file changed, 16 insertions(+), 3 deletions(-)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 5767b29887c..75d5f4a7216 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -75,7 +75,8 @@ AddReg=\
     Tapi,\
     Timezones,\
     VersionInfo,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient
 
 [DefaultInstall.ntamd64]
 RegisterDlls=RegisterDllsSection
@@ -103,7 +104,8 @@ AddReg=\
     Tapi,\
     Timezones,\
     VersionInfo.ntamd64,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient.ntamd64
 
 [Wow64Install]
 RegisterDlls=RegisterDllsSection
@@ -118,7 +120,8 @@ AddReg=\
     Misc,\
     Tapi,\
     VersionInfo.ntamd64,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient.ntamd64
 
 [DefaultInstall.Services]
 AddService=BITS,0,BITSService
@@ -3750,6 +3750,16 @@ HKLM,Software\Wine\LicenseInformation,"Shell-InBoxGames-Solitaire-EnableGame",0x
 HKLM,Software\Wine\LicenseInformation,"Shell-InBoxGames-SpiderSolitaire-EnableGame",0x10001,0x00000001
 HKLM,Software\Wine\LicenseInformation,"Shell-PremiumInBoxGames-Chess-EnableGame",0x10001,0x00000001
 
+[SteamClient]
+HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16422%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16422%\Steam"
+
+[SteamClient.ntamd64]
+HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"
+
 [DestinationDirs]
 l_intl_section = 11
 inf_section = 17

From bc614834ee153ce33449c06e697b4a30748e9257 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 27 Apr 2017 13:25:04 -0500
Subject: [PATCH] HACK kernelbase: Substitute the current pid for the Steam
 client pid

---
 dlls/kernelbase/process.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 85e0042024c..9c957f02c06 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -220,6 +220,22 @@ HANDLE WINAPI DECLSPEC_HOTPATCH OpenProcess( DWORD access, BOOL inherit, DWORD id )
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
 
+    if(id == 0xfffe)
+        /* STEAMOS HACK:
+         * On Windows, the Steam client puts its process ID into the registry
+         * at:
+         *
+         *   [HKCU\Software\Valve\Steam\ActiveProcess]
+         *   PID=dword:00000008
+         *
+         * Games get that pid from the registry and then query it with
+         * OpenProcess to ensure Steam is running. Since we aren't running the
+         * Windows Steam in Wine, instead we hack this magic number into the
+         * registry and then substitute the game's process itself in its place
+         * so it can query a valid process.
+         */
+        id = GetCurrentProcessId();
+
     cid.UniqueProcess = ULongToHandle(id);
     cid.UniqueThread  = 0;
 
From a277e32030a31abe90af9d38462f1159bc94b7b0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 11 May 2017 10:50:08 -0500
Subject: [PATCH] HACK: kernel32: Swap requests for steamclient.dll with
 lsteamclient

---
 dlls/kernel32/module.c | 63 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 118829895b7..cf3a0b5ed98 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -76,6 +76,23 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
+static HMODULE steamclient_hmod = NULL;
+static HMODULE lsteamclient_hmod = NULL;
+
+static WCHAR *strcasestrW( const WCHAR *str, const WCHAR *sub )
+{
+    while (*str)
+    {
+        const WCHAR *p1 = str, *p2 = sub;
+        while (*p1 && *p2 && tolowerW(*p1) == tolowerW(*p2)) { p1++; p2++; }
+        if (!*p2) return (WCHAR *)str;
+        str++;
+    }
+    return NULL;
+}
+
 /****************************************************************************
  *              GetDllDirectoryA   (KERNEL32.@)
  */
@@ -710,6 +727,10 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
     else
     {
         UNICODE_STRING wstr;
+        if(steamclient_hmod != NULL && strcasestrW(name, steamclientW)){
+            *module = steamclient_hmod;
+            return TRUE;
+        }
         RtlInitUnicodeString( &wstr, name );
         status = LdrGetDllHandle( NULL, 0, &wstr, &ret );
     }
@@ -818,6 +839,11 @@ DWORD WINAPI GetModuleFileNameW( HMODULE hModule, LPWSTR lpFileName, DWORD size
     NTSTATUS nts;
     WIN16_SUBSYSTEM_TIB *win16_tib;
 
+    if(steamclient_hmod != NULL && hModule == steamclient_hmod){
+        memcpy(lpFileName, steamclient_pathW, sizeof(steamclient_pathW));
+        return sizeof(steamclient_pathW)/sizeof(WCHAR);
+    }
+
     if (!hModule && ((win16_tib = NtCurrentTeb()->Tib.SubSystemTib)) && win16_tib->exe_name)
     {
         len = min(size, win16_tib->exe_name->Length / sizeof(WCHAR));
@@ -1194,6 +1220,7 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     NTSTATUS nts;
     HMODULE hModule;
     WCHAR *load_path;
+    const WCHAR *p;
     const DWORD load_library_search_flags = (LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR |
                                              LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
                                              LOAD_LIBRARY_SEARCH_USER_DIRS |
@@ -1207,6 +1234,36 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     if( flags & unsupported_flags)
         FIXME("unsupported flag(s) used (flags: 0x%08x)\n", flags);
 
+    if((p = strcasestrW(libname->Buffer, steamclientW)) &&
+            (p == libname->Buffer ||
+             *(p - 1) != 'l')){
+
+        if(!lsteamclient_hmod)
+            lsteamclient_hmod = LoadLibraryA("lsteamclient.dll");
+
+        if(!steamclient_hmod){
+            HANDLE f = CreateFileW(steamclient_pathW,
+                    GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                    NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+            if(f != INVALID_HANDLE_VALUE){
+                DWORD sz, readed;
+
+                sz = GetFileSize(f, NULL);
+
+                steamclient_hmod = HeapAlloc(GetProcessHeap(), 0, sz);
+                ReadFile(f, steamclient_hmod, sz, &readed, NULL);
+
+                CloseHandle(f);
+            }else{
+                /* this will fail DRM checks, but otherwise should work */
+                ERR("somehow failed to load steamclient\n");
+                steamclient_hmod = lsteamclient_hmod;
+            }
+        }
+
+        return steamclient_hmod;
+    }
+
     if (flags & load_library_search_flags)
         load_path = get_dll_load_path_search_flags( libname->Buffer, flags );
     else
@@ -1362,6 +1419,9 @@ BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary(HINSTANCE hLibModule)
         return FALSE;
     }
 
+    if(steamclient_hmod != NULL && hLibModule == steamclient_hmod)
+        return TRUE;
+
     if ((ULONG_PTR)hLibModule & 3) /* this is a datafile module */
     {
         if ((ULONG_PTR)hLibModule & 1)
@@ -1410,6 +1470,9 @@ FARPROC get_proc_address( HMODULE hModule, LPCSTR function )
 
     if (!hModule) hModule = NtCurrentTeb()->Peb->ImageBaseAddress;
 
+    if(steamclient_hmod != NULL && hModule == steamclient_hmod)
+        hModule = lsteamclient_hmod;
+
     if ((ULONG_PTR)function >> 16)
     {
         ANSI_STRING     str;

From acda0915ca65ea7e818fbb89bae14894602cf845 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 5 Jun 2017 14:41:28 -0500
Subject: [PATCH] HACK: kernel32: Load hard-coded Steam.dll path if relative
 load fails

Some games (Call of Duty is one example) try to just
LoadLibrary("Steam.dll") with no path. If that fails, it complains
"Failed to find Steam". This works on Windows because Steam sets the
PATH environment variable to include <C:\Program Files\Steam\>, which is
where Steam.dll lives, before launching the game. However, the Linux
Steam obviously doesn't do that. For this reason, we place Steam.dll in
there and this hack loads it correctly for the games.

TODO: is this enough? Should we put that path into PATH like on Windows,
in case it tries to load other binaries?
---
 dlls/kernel32/module.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index cf3a0b5ed98..6ca438d3ae2 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -77,6 +77,8 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
+static const WCHAR full_steamdllW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','S','t','e','a','m','.','d','l','l',0};
 static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
@@ -1302,6 +1304,12 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     }
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
+
+    if(!hModule && !strcmpiW(libname->Buffer, steamdllW))
+        /* tried and failed to load Steam.dll from PATH. try again
+         * with known-good path */
+        return LoadLibraryW(full_steamdllW);
+
     return hModule;
 }
 
From 183eac81ab4739735c4f49d25c1384d98f17655d Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 9 Jun 2017 10:31:27 -0500
Subject: [PATCH] HACK: kernel32: Return steamclient instead of lsteamclient
 during GetModuleHandleEx

Found a game which passes the result from GetProcAddress to this. Ugh.
---
 dlls/kernel32/module.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 6ca438d3ae2..a1a2b0e100c 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -725,6 +725,8 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
     {
         void *dummy;
         if (!(ret = RtlPcToFileHeader( (void *)name, &dummy ))) status = STATUS_DLL_NOT_FOUND;
+        if(steamclient_hmod != NULL && ret == lsteamclient_hmod)
+            ret = steamclient_hmod;
     }
     else
     {

From 3835eee939a9e8c6a8f29733307a8531053a3616 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 13 Jun 2017 12:35:56 -0500
Subject: [PATCH] HACK: kernel32: Put Steam program files dir into PATH

---
 dlls/kernel32/module.c | 23 +++++++++++++++++------
 1 file changed, 17 insertions(+), 6 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index a1a2b0e100c..ef0295081c8 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -78,7 +78,7 @@ static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
 static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
-static const WCHAR full_steamdllW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','S','t','e','a','m','.','d','l','l',0};
+static const DWORD steamdllW_len = 9;
 static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
@@ -890,12 +890,18 @@ static const WCHAR *get_dll_system_path(void)
 
     if (!cached_path)
     {
+        static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m',0};
+        static const DWORD steamProgramPathW_len = 22;
         WCHAR *p, *path;
-        int len = 1;
+        int len = 2;
 
+        len += steamProgramPathW_len;
         len += 2 * GetSystemDirectoryW( NULL, 0 );
         len += GetWindowsDirectoryW( NULL, 0 );
         p = path = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );
+        strcpyW(p, steamProgramPathW);
+        p += steamProgramPathW_len;
+        *p++ = ';';
         GetSystemDirectoryW( p, path + len - p);
         p += strlenW(p);
         /* if system directory ends in "32" add 16-bit version too */
@@ -1307,10 +1313,15 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
 
-    if(!hModule && !strcmpiW(libname->Buffer, steamdllW))
-        /* tried and failed to load Steam.dll from PATH. try again
-         * with known-good path */
-        return LoadLibraryW(full_steamdllW);
+    if(!hModule){
+        DWORD len = lstrlenW(libname->Buffer);
+        if(len > steamdllW_len &&
+                !strcmpiW(libname->Buffer + len - steamdllW_len, steamdllW)){
+            /* tried and failed to load some path ending in Steam.dll. try
+             * again without hard-coded path */
+            return LoadLibraryW(steamdllW);
+        }
+    }
 
     return hModule;
 }

From a2f9e2806acdd83aa9121baea4a8a908e2a9e909 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 28 Dec 2017 09:43:36 -0600
Subject: [PATCH] kernel32: Support steamclient64

---
 dlls/kernel32/module.c | 11 ++++++++---
 loader/wine.inf.in     |  1 +
 2 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index ef0295081c8..32f9ddf6718 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -76,10 +76,17 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+#if defined(__x86_64__)
+static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t','6','4',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','6','4','.','d','l','l',0};
+#else
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};
+#endif
+static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m',0};
+static const DWORD steamProgramPathW_len = 28;
 static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
 static const DWORD steamdllW_len = 9;
-static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
 
@@ -890,8 +897,6 @@ static const WCHAR *get_dll_system_path(void)
 
     if (!cached_path)
     {
-        static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m',0};
-        static const DWORD steamProgramPathW_len = 22;
         WCHAR *p, *path;
         int len = 2;
 
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 75d5f4a7216..7fe2f49dcd9 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3758,6 +3758,7 @@ HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16422%\Steam"
 [SteamClient.ntamd64]
 HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll64",,"%16426%\Steam\steamclient64.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"
 
 [DestinationDirs]

From bf02d103fde2c2e54a074b03021f47e4672d4b01 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 5 Nov 2018 18:45:57 +0300
Subject: [PATCH] Add missing InstallPath registry value.

So UPlay won't try to install Steam.
---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 5610c701d..3d71722ac 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3760,6 +3760,7 @@ HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll64",,"%16426%\Steam\steamclient64.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"
+HKLM,Software\Wow6432Node\Valve\Steam,"InstallPath",,"%16422%\Steam"
 
 [DestinationDirs]
 l_intl_section = 11

From bac899cd4531229baa7633d67578b74a2a98468f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 19 Mar 2018 11:34:35 -0500
Subject: [PATCH] kernel32: Don't force-load Steam.dll

This must fail for older DRM which walks up the FS tree searching for
Steam.dll to work correctly.
---
 dlls/kernel32/module.c | 10 ----------
 1 file changed, 10 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 32f9ddf6718..342e408b555 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -1318,16 +1318,6 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
 
-    if(!hModule){
-        DWORD len = lstrlenW(libname->Buffer);
-        if(len > steamdllW_len &&
-                !strcmpiW(libname->Buffer + len - steamdllW_len, steamdllW)){
-            /* tried and failed to load some path ending in Steam.dll. try
-             * again without hard-coded path */
-            return LoadLibraryW(steamdllW);
-        }
-    }
-
     return hModule;
 }
 
From 7bd039f34f5fc1123524ddb22769f6e16e7d9c88 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 11 May 2017 10:01:16 -0500
Subject: [PATCH] HACK: ws2_32: Fake success when trying to bind to an IPX
 address

---
 dlls/ws2_32/socket.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 164a48ce751..b9248c9bd5e 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3332,6 +3332,13 @@ int WINAPI WS_bind(SOCKET s, const struct WS_sockaddr* name, int namelen)
                     else if (interface_bind(s, fd, &uaddr.addr))
                         in4->sin_addr.s_addr = htonl(INADDR_ANY);
                 }
+
+                if(name->sa_family ==  WS_AF_IPX){
+                    /* Quake (and similar family) fails if we can't bind to an IPX address. This often
+                     * doesn't work on Linux, so just fake success. */
+                    return 0;
+                }
+
                 if (bind(fd, &uaddr.addr, uaddrlen) < 0)
                 {
                     int loc_errno = errno;

From 819b923a3b761944b094f5f20b881c501a522f20 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 19 Jan 2018 14:01:07 -0600
Subject: [PATCH] HACK: advapi32: Use steamuser as Wine username

---
 dlls/advapi32/advapi.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/advapi32/advapi.c b/dlls/advapi32/advapi.c
index 1c528ef7419..87792f4fbc9 100644
--- a/dlls/advapi32/advapi.c
+++ b/dlls/advapi32/advapi.c
@@ -84,7 +84,7 @@ GetUserNameA( LPSTR lpszName, LPDWORD lpSize )
 BOOL WINAPI
 GetUserNameW( LPWSTR lpszName, LPDWORD lpSize )
 {
-    const char *name = wine_get_user_name();
+    const char *name = "steamuser"/*wine_get_user_name()*/;
     DWORD i, len = MultiByteToWideChar( CP_UNIXCP, 0, name, -1, NULL, 0 );
     LPWSTR backslash;
 
From ec9e7190ea7045012b6e33e5ee64cd678bec68c9 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 22 Jan 2018 14:32:40 -0600
Subject: [PATCH] HACK: shell32: Never create links to the user's home dirs

---
 dlls/shell32/shellpath.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/dlls/shell32/shellpath.c b/dlls/shell32/shellpath.c
index f08474b3635..2f637f25537 100644
--- a/dlls/shell32/shellpath.c
+++ b/dlls/shell32/shellpath.c
@@ -4424,6 +4424,7 @@ static void _SHCreateSymbolicLinks(void)
     pszPersonal = wine_get_unix_file_name(wszTempPath);
     if (!pszPersonal) return;
 
+#if 0
     hr = XDG_UserDirLookup(xdg_dirs, num, &xdg_results);
     if (FAILED(hr)) xdg_results = NULL;
 
@@ -4477,6 +4478,7 @@ static void _SHCreateSymbolicLinks(void)
     }
     else
     {
+#endif
         /* '$HOME' doesn't exist. Create 'My Pictures', 'My Videos' and 'My Music' subdirs
          * in '%USERPROFILE%\\My Documents' or fail silently if they already exist. */
         pszHome = NULL;
@@ -4486,8 +4488,11 @@ static void _SHCreateSymbolicLinks(void)
             if (_SHAppendToUnixPath(szMyStuffTarget, MAKEINTRESOURCEW(aidsMyStuff[i])))
                 mkdir(szMyStuffTarget, 0777);
         }
+#if 0
     }
+#endif
 
+#if 0
     /* Create symbolic links for 'My Pictures', 'My Videos' and 'My Music'. */
     for (i=0; i < ARRAY_SIZE(aidsMyStuff); i++)
     {
@@ -4532,13 +4537,17 @@ static void _SHCreateSymbolicLinks(void)
         symlink(szMyStuffTarget, pszMyStuff);
         heap_free(pszMyStuff);
     }
+#endif
 
+#if 0
     /* Last but not least, the Desktop folder */
     if (pszHome)
         strcpy(szDesktopTarget, pszHome);
     else
         strcpy(szDesktopTarget, pszPersonal);
+#endif
     heap_free(pszPersonal);
+#if 0
 
     xdg_desktop_dir = xdg_results ? xdg_results[num - 1] : NULL;
     if (xdg_desktop_dir ||
@@ -4565,6 +4574,7 @@ static void _SHCreateSymbolicLinks(void)
             heap_free(xdg_results[i]);
         heap_free(xdg_results);
     }
+#endif
 }
 
 /******************************************************************************

From 134fa05a0e39b63bfec75d0823ebe49e4c9cae64 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 7 Jun 2018 14:37:03 -0500
Subject: [PATCH] HACK: winex11.drv: Disable XIM by default

libx11 has a race condition that causes XIM to crash with "double free
or corruption" errors, see winehq bug 35041. Disabling XIM works around
this, though special input methods (CJK, etc.) will no longer work.
---
 dlls/winex11.drv/x11drv_main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index db87d188236..81a63a20689 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -93,7 +93,7 @@ static void *err_callback_arg;               /* error callback argument */
 static int err_callback_result;              /* error callback result */
 static unsigned long err_serial;             /* serial number of first request */
 static int (*old_error_handler)( Display *, XErrorEvent * );
-static BOOL use_xim = TRUE;
+static BOOL use_xim = FALSE;
 static char input_style[20];
 
 #define IS_OPTION_TRUE(ch) \

From d012d137e4099d1b12079a49a8a5632d205e0a9f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 24 Sep 2018 12:37:49 -0500
Subject: [PATCH] HACK: dbghelp: Disable DWARF parsing

Patch by Zeb. Our DWARF parser has been known to crash winedbg in some
cases. Since probably no concerned parties are going to be using plain
winedbg, just don't bother parsing anything.
---
 dlls/dbghelp/dwarf.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/dbghelp/dwarf.c b/dlls/dbghelp/dwarf.c
index 31c008abb8f..ce689dbe6cf 100644
--- a/dlls/dbghelp/dwarf.c
+++ b/dlls/dbghelp/dwarf.c
@@ -3516,6 +3516,11 @@ BOOL dwarf2_parse(struct module* module, unsigned long load_offset,
     BOOL                ret = TRUE;
     struct module_format* dwarf2_modfmt;
 
+/* Our DWARF parser has been known to crash winedbg in some cases. Since
+ * probably no concerned parties are going to be using plain winedbg, just don't
+ * bother parsing anything. */
+return FALSE;
+
     dwarf2_init_section(&eh_frame,                fmap, ".eh_frame",     NULL,             &eh_frame_sect);
     dwarf2_init_section(&section[section_debug],  fmap, ".debug_info",   ".zdebug_info",   &debug_sect);
     dwarf2_init_section(&section[section_abbrev], fmap, ".debug_abbrev", ".zdebug_abbrev", &debug_abbrev_sect);

From a13270aea50af90aa6c721080b956870d67d81c2 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 30 Mar 2018 10:40:43 -0500
Subject: [PATCH] winedbg: When crash dialog is not shown, dump crash info to
 stderr

This way the backtrace and such will appear in the log file instead of
going to stdout, which we don't capture.
---
 programs/winedbg/tgt_active.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/programs/winedbg/tgt_active.c b/programs/winedbg/tgt_active.c
index f632ca0414d..72e63327831 100644
--- a/programs/winedbg/tgt_active.c
+++ b/programs/winedbg/tgt_active.c
@@ -874,6 +874,9 @@ enum dbg_start dbg_active_auto(int argc, char* argv[])
         if (event) thread = display_crash_details( event );
         if (thread) dbg_houtput = output = create_temp_file();
         break;
+    case TRUE:
+        dbg_houtput = GetStdHandle(STD_ERROR_HANDLE);
+        break;
     }
 
     input = parser_generate_command_file("echo Modules:", "info share",

From 1091eaf13692b16ed66328ceeebfc587075fec6c Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 25 Oct 2018 12:50:45 -0500
Subject: [PATCH] HACK: wined3d: Fake an AMD card in place of Nvidia cards

Some games assume they can load the nvapi library if the hardware is an
nvidia card. This obviously fails in Wine. So fake that all nvidia
hardware is actually an AMD card, so they don't try to load nvapi.
---
 dlls/wined3d/adapter_gl.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index b8a2060cf46..8259d92ebac 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -1009,6 +1009,14 @@ static const struct wined3d_gpu_description *query_gpu_description(const struct
         vendor = wined3d_settings.pci_vendor_id;
         TRACE("Overriding vendor PCI ID with 0x%04x.\n", vendor);
     }
+    else if(vendor == HW_VENDOR_NVIDIA)
+    {
+        /* XXX: Fake having an AMD card in order to avoid games trying to load
+         * the Windows-only nvapi library. */
+        WARN("Nvidia card detected. Faking an AMD RX 480!\n");
+        vendor = HW_VENDOR_AMD;
+        device = CARD_AMD_RADEON_RX_480;
+    }
 
     if (wined3d_settings.pci_device_id != PCI_DEVICE_NONE)
     {

From 29a2c4f1b8cad98e94c67e4c068d9096969074ee Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 20 Aug 2018 10:58:09 -0500
Subject: [PATCH] secur32: Return real Unix username from
 GetUserNameEx(NameDisplay)

---
 dlls/secur32/secur32.c | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/dlls/secur32/secur32.c b/dlls/secur32/secur32.c
index ec189fda104..1c662adf44b 100644
--- a/dlls/secur32/secur32.c
+++ b/dlls/secur32/secur32.c
@@ -34,6 +34,7 @@
 #include "thunks.h"
 #include "lmcons.h"
 
+#include "wine/library.h"
 #include "wine/list.h"
 #include "wine/debug.h"
 #include "wine/unicode.h"
@@ -1201,9 +1202,25 @@ BOOLEAN WINAPI GetUserNameExW(
             return FALSE;
         }
 
+    case NameDisplay:
+        {
+            const char *name = wine_get_user_name();
+            DWORD len = MultiByteToWideChar( CP_UNIXCP, 0, name, -1, NULL, 0 );
+
+            if (len > *nSize)
+            {
+                SetLastError( ERROR_MORE_DATA );
+                *nSize = len;
+                return FALSE;
+            }
+
+            *nSize = len - 1;
+            MultiByteToWideChar( CP_UNIXCP, 0, name, -1, lpNameBuffer, len );
+            return TRUE;
+        }
+
     case NameUnknown:
     case NameFullyQualifiedDN:
-    case NameDisplay:
     case NameUniqueId:
     case NameCanonical:
     case NameUserPrincipal:


From 63f934962cb97d69ed71604985716e7479f822b1 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 23 Oct 2018 16:18:20 +0300
Subject: [PATCH] wine.inf: Add font registry entries.

---
 loader/wine.inf.in | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 1f94c38d0c6..df2b43d9106 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -181,6 +181,7 @@ CurrentVersion="Software\Microsoft\Windows\CurrentVersion"
 CurrentVersionNT="Software\Microsoft\Windows NT\CurrentVersion"
 FontSubStr="Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes"
 Control="System\CurrentControlSet\Control"
+FontsNT="Software\Microsoft\Windows NT\CurrentVersion\Fonts"
 
 [Classes]
 HKCR,.chm,,2,"chm.file"
@@ -614,6 +615,10 @@ HKLM,%FontSubStr%,"Times New Roman CYR,204",,"Times New Roman,204"
 HKLM,%FontSubStr%,"Times New Roman Greek,161",,"Times New Roman,161"
 HKLM,%FontSubStr%,"Times New Roman TUR,162",,"Times New Roman,162"
 HKLM,System\CurrentControlSet\Hardware Profiles\Current\Software\Fonts,"LogPixels",0x10003,0x00000060
+HKLM,%FontsNT%,"Arial (TrueType)",,"arial.ttf"
+HKLM,%FontsNT%,"Arial Bold (TrueType)",,"arialbd.ttf"
+HKLM,%FontsNT%,"Times New Roman (TrueType)",,"times.ttf"
+HKLM,%FontsNT%,"Courier New (TrueType)",,"cour.ttf"
 
 [MCI]
 HKLM,%Mci32Str%,"AVIVideo",,"mciavi32.dll"
     
From 174d487bf8ef5bec22c3663f50a276ae59d0a931 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 30 Oct 2018 13:04:06 -0500
Subject: [PATCH] wine.inf: Substitute Times New Roman for Palatino Linotype

For AOE2HD launcher.
---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index df2b43d9106..44ce3cd6639 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -619,6 +619,7 @@ HKLM,%FontsNT%,"Arial (TrueType)",,"arial.ttf"
 HKLM,%FontsNT%,"Arial Bold (TrueType)",,"arialbd.ttf"
 HKLM,%FontsNT%,"Times New Roman (TrueType)",,"times.ttf"
 HKLM,%FontsNT%,"Courier New (TrueType)",,"cour.ttf"
+HKCU,Software\Wine\Fonts\Replacements,"Palatino Linotype",,"Times New Roman"
 
 [MCI]
 HKLM,%Mci32Str%,"AVIVideo",,"mciavi32.dll"

From aa7fa7ce94bd4e49e3843a8ea398d29882518e43 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 6 Aug 2018 08:06:03 -0500
Subject: [PATCH] server: Set default timeout to 0

The Steam client will be waiting for the wineserver to exit to set up
some environment variables, so make it wait as short as possible.
---
 server/main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/main.c b/server/main.c
index 20d3c48c4d9..aca8738c4c0 100644
--- a/server/main.c
+++ b/server/main.c
@@ -42,7 +42,7 @@
 /* command-line options */
 int debug_level = 0;
 int foreground = 0;
-timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
+timeout_t master_socket_timeout = 0; /* master socket timeout, default is 3 seconds */
 const char *server_argv0;
 
 /* parse-line args */

From 059a15a1d521a6ba79273b2ade923822b1532205 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 13 Jul 2018 10:40:27 -0500
Subject: [PATCH] HACK: mshtml: Don't install wine-gecko on prefix creation

We only want to install this on demand.
---
 dlls/mshtml/main.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/dlls/mshtml/main.c b/dlls/mshtml/main.c
index 6ce8198aee5..f84d92cc860 100644
--- a/dlls/mshtml/main.c
+++ b/dlls/mshtml/main.c
@@ -530,8 +530,6 @@ HRESULT WINAPI DllRegisterServer(void)
     hres = __wine_register_resources( hInst );
     if(SUCCEEDED(hres))
         hres = register_server(TRUE);
-    if(SUCCEEDED(hres))
-        load_gecko();
 
     return hres;
 }

From 1ef83da3b15171782dc009bb6649665769122aa5 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 15 Jan 2019 10:10:47 -0600
Subject: [PATCH] kernel32: Don't pass SDL_AUDIODRIVER from Linux environment

---
 dlls/kernel32/process.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 9c957f02c06..e14b514ccc1 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -137,6 +137,7 @@ static inline BOOL is_special_env_var( const char *var )
             !strncmp( var, "TEMP=", sizeof("TEMP=")-1 ) ||
             !strncmp( var, "TMP=", sizeof("TMP=")-1 ) ||
             !strncmp( var, "QT_", sizeof("QT_")-1 ) ||
+            !strncmp( var, "SDL_AUDIODRIVER=", sizeof("SDL_AUDIODRIVER=")-1 ) ||
             !strncmp( var, "VK_", sizeof("VK_")-1 ));
 }
 
From 971dc3c4225b33fb5346187cd37e8355f265800f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 18 Jun 2018 07:56:35 -0500
Subject: [PATCH] ntdll: Notice THREADNAME_INFO exceptions and set thread name
 on Linux

Patch by Zeb.
---
 dlls/ntdll/exception.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
index f85381079a2..ffe048de8c0 100644
--- a/dlls/ntdll/exception.c
+++ b/dlls/ntdll/exception.c
@@ -26,6 +26,9 @@
 #include <errno.h>
 #include <signal.h>
 #include <stdarg.h>
+#ifdef HAVE_PRCTL
+#include <sys/prctl.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -143,6 +146,16 @@ void wait_suspend( CONTEXT *context )
 }
 
 
+/* "How to: Set a Thread Name in Native Code"
+ * https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx */
+typedef struct tagTHREADNAME_INFO
+{
+   DWORD   dwType;     /* Must be 0x1000 */
+   LPCSTR  szName;     /* Pointer to name - limited to 9 bytes (8 characters + terminator) */
+   DWORD   dwThreadID; /* Thread ID (-1 = caller thread) */
+   DWORD   dwFlags;    /* Reserved for future use.  Must be zero. */
+} THREADNAME_INFO;
+
 /**********************************************************************
  *           send_debug_event
  *
@@ -162,6 +175,21 @@ NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, int first_chance, CONTEXT *con
     for (i = 0; i < min( rec->NumberParameters, EXCEPTION_MAXIMUM_PARAMETERS ); i++)
         params[i] = rec->ExceptionInformation[i];
 
+    if (rec->ExceptionCode == 0x406d1388)
+    {
+        const THREADNAME_INFO *threadname = (const THREADNAME_INFO *)rec->ExceptionInformation;
+
+        if (threadname->dwThreadID == -1)
+        {
+#ifdef HAVE_PRCTL
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+            prctl( PR_SET_NAME, threadname->szName );
+#endif
+        }
+    }
+
     context_to_server( &server_context, context );
 
     SERVER_START_REQ( queue_exception_event )

From a7542e9e279970c2ab3ac9c6c986b300135286a0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 28 Mar 2018 09:17:30 -0500
Subject: [PATCH] wine.inf: Don't show crash dialog by default

---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 7fe2f49dcd9..e72d0dcaba1 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -540,6 +540,7 @@ HKLM,%CurrentVersionNT%\AeDebug,"Debugger",2,"winedbg --auto %ld %ld"
 HKLM,%CurrentVersionNT%\AeDebug,"Auto",2,"1"
 HKCU,Software\Wine\Debug,"RelayExclude",2,"ntdll.RtlEnterCriticalSection;ntdll.RtlTryEnterCriticalSection;ntdll.RtlLeaveCriticalSection;kernel32.48;kernel32.49;kernel32.94;kernel32.95;kernel32.96;kernel32.97;kernel32.98;kernel32.TlsGetValue;kernel32.TlsSetValue;kernel32.FlsGetValue;kernel32.FlsSetValue;kernel32.SetLastError"
 HKCU,Software\Wine\Debug,"RelayFromExclude",2,"winex11.drv;winemac.drv;user32;gdi32;advapi32;kernel32"
+HKCU,Software\Wine\WineDbg,"ShowCrashDialog",0x00010003,0x00000000
 
 [DirectX]
 HKLM,Software\Microsoft\DirectX,"Version",,"4.09.00.0904"

From 71fce64369f2ace00bc0bb8018b549dd201a5764 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 9 Jan 2019 13:24:54 +0300
Subject: [PATCH] imm32: Automatically initialize COM on window activation.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/imm32/Makefile.in     |   2 +-
 dlls/imm32/imm.c           | 129 ++++++++++++++++++++++++++++++++++++-
 dlls/imm32/imm32.spec      |   1 +
 dlls/user32/focus.c        |   2 +
 dlls/user32/misc.c         |   2 +
 dlls/user32/user_private.h |   1 +
 6 files changed, 135 insertions(+), 2 deletions(-)

diff --git a/dlls/imm32/Makefile.in b/dlls/imm32/Makefile.in
index b190888659b..ad10fc2fa45 100644
--- a/dlls/imm32/Makefile.in
+++ b/dlls/imm32/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = imm32.dll
 IMPORTLIB = imm32
-IMPORTS   = user32 gdi32 advapi32
+IMPORTS   = user32 gdi32 advapi32 ole32
 
 C_SRCS = \
 	imm.c
diff --git a/dlls/imm32/imm.c b/dlls/imm32/imm.c
index 28eb00f355a..129f7e8cb53 100644
--- a/dlls/imm32/imm.c
+++ b/dlls/imm32/imm.c
@@ -19,6 +19,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#define COBJMACROS
+
 #include <stdarg.h>
 #include <stdio.h>
 
@@ -32,6 +34,8 @@
 #include "ddk/imm.h"
 #include "winnls.h"
 #include "winreg.h"
+#include "initguid.h"
+#include "objbase.h"
 #include "wine/list.h"
 #include "wine/unicode.h"
 
@@ -95,8 +99,16 @@ typedef struct _tagIMMThreadData {
     HWND hwndDefault;
     BOOL disableIME;
     DWORD windowRefs;
+    IInitializeSpy IInitializeSpy_iface;
+    ULARGE_INTEGER spy_cookie;
+    BOOL apt_initialized;
 } IMMThreadData;
 
+static inline IMMThreadData *impl_from_IInitializeSpy(IInitializeSpy *iface)
+{
+    return CONTAINING_RECORD(iface, IMMThreadData, IInitializeSpy_iface);
+}
+
 static struct list ImmHklList = LIST_INIT(ImmHklList);
 static struct list ImmThreadDataList = LIST_INIT(ImmThreadDataList);
 
@@ -227,6 +239,88 @@ static DWORD convert_candidatelist_AtoW(
     return ret;
 }
 
+static HRESULT WINAPI initializespy_QueryInterface(IInitializeSpy *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(&IID_IInitializeSpy, riid) ||
+            IsEqualIID(&IID_IUnknown, riid))
+    {
+        *obj = iface;
+        IInitializeSpy_AddRef(iface);
+        return S_OK;
+    }
+
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI initializespy_AddRef(IInitializeSpy *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI initializespy_Release(IInitializeSpy *iface)
+{
+    return 1;
+}
+
+static void imm_couninit_thread(IMMThreadData *thread_data)
+{
+    if (!thread_data->apt_initialized)
+        return;
+
+    thread_data->apt_initialized = FALSE;
+    CoUninitialize();
+}
+
+static HRESULT WINAPI initializespy_PreInitialize(IInitializeSpy *iface, DWORD coinit, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Application requested initialization of different apartment type. */
+    if (!(coinit & COINIT_APARTMENTTHREADED))
+        imm_couninit_thread(thread_data);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI initializespy_PostInitialize(IInitializeSpy *iface, HRESULT hr, DWORD coinit, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Explicit initialization call should return S_OK first time. */
+    if (thread_data->apt_initialized && hr == S_FALSE && refs == 2)
+        hr = S_OK;
+
+    return hr;
+}
+
+static HRESULT WINAPI initializespy_PreUninitialize(IInitializeSpy *iface, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Account for explicit uninitialization calls. */
+    if (thread_data->apt_initialized && refs == 1)
+        thread_data->apt_initialized = FALSE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI initializespy_PostUninitialize(IInitializeSpy *iface, DWORD refs)
+{
+    return S_OK;
+}
+
+static const IInitializeSpyVtbl initializespyvtbl =
+{
+    initializespy_QueryInterface,
+    initializespy_AddRef,
+    initializespy_Release,
+    initializespy_PreInitialize,
+    initializespy_PostInitialize,
+    initializespy_PreUninitialize,
+    initializespy_PostUninitialize,
+};
+
 static IMMThreadData *IMM_GetThreadData(HWND hwnd, DWORD thread)
 {
     IMMThreadData *data;
@@ -253,6 +347,7 @@ static IMMThreadData *IMM_GetThreadData(HWND hwnd, DWORD thread)
         if (data->threadID == thread) return data;
 
     data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data));
+    data->IInitializeSpy_iface.lpVtbl = &initializespyvtbl;
     data->threadID = thread;
     list_add_head(&ImmThreadDataList,&data->entry);
     TRACE("Thread Data Created (%x)\n",thread);
@@ -281,6 +376,7 @@ static void IMM_FreeThreadData(void)
             list_remove(&data->entry);
             LeaveCriticalSection(&threaddata_cs);
             IMM_DestroyContext(data->defaultContext);
+            imm_couninit_thread(data);
             HeapFree(GetProcessHeap(),0,data);
             TRACE("Thread Data Destroyed\n");
             return;
@@ -1627,6 +1723,32 @@ static BOOL needs_ime_window(HWND hwnd)
     return TRUE;
 }
 
+void WINAPI __wine_activate_window(HWND hwnd)
+{
+    IMMThreadData *thread_data;
+
+    TRACE("(%p)\n", hwnd);
+
+    if (!needs_ime_window(hwnd))
+        return;
+
+    thread_data = IMM_GetThreadData(hwnd, 0);
+    if (!thread_data)
+        return;
+
+    if (thread_data->disableIME || disable_ime)
+    {
+        TRACE("IME for this thread is disabled\n");
+        LeaveCriticalSection(&threaddata_cs);
+        return;
+    }
+
+    if (!thread_data->apt_initialized)
+        thread_data->apt_initialized = SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
+
+    LeaveCriticalSection(&threaddata_cs);
+}
+
 /***********************************************************************
  *		__wine_register_window (IMM32.@)
  */
@@ -1656,6 +1778,8 @@ BOOL WINAPI __wine_register_window(HWND hwnd)
     /* Create default IME window */
     if (thread_data->windowRefs == 1)
     {
+        CoRegisterInitializeSpy(&thread_data->IInitializeSpy_iface, &thread_data->spy_cookie);
+
         /* Do not create the window inside of a critical section */
         LeaveCriticalSection(&threaddata_cs);
         new = CreateWindowExW( 0, szwIME, szwDefaultIME,
@@ -1697,8 +1821,11 @@ void WINAPI __wine_unregister_window(HWND hwnd)
           thread_data->windowRefs, thread_data->hwndDefault);
 
     /* Destroy default IME window */
-    if (thread_data->windowRefs == 0 && thread_data->hwndDefault)
+    if (thread_data->windowRefs == 0)
     {
+        CoRevokeInitializeSpy(thread_data->spy_cookie);
+        thread_data->spy_cookie.QuadPart = 0;
+        imm_couninit_thread(thread_data);
         to_destroy = thread_data->hwndDefault;
         thread_data->hwndDefault = NULL;
     }
diff --git a/dlls/imm32/imm32.spec b/dlls/imm32/imm32.spec
index 4197bb81e21..d9cdc794e9e 100644
--- a/dlls/imm32/imm32.spec
+++ b/dlls/imm32/imm32.spec
@@ -117,3 +117,4 @@
 @ stdcall __wine_get_ui_window(ptr)
 @ stdcall __wine_register_window(long)
 @ stdcall __wine_unregister_window(long)
+@ stdcall __wine_activate_window(long)
diff --git a/dlls/user32/focus.c b/dlls/user32/focus.c
index f1c883167ed..50b3323ae9f 100644
--- a/dlls/user32/focus.c
+++ b/dlls/user32/focus.c
@@ -156,6 +156,8 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
 
         if (hwnd == GetForegroundWindow() && !IsIconic( hwnd ))
             USER_Driver->pSetActiveWindow( hwnd );
+
+        imm_activate_window( hwnd );
     }
 
     /* now change focus if necessary */
diff --git a/dlls/user32/misc.c b/dlls/user32/misc.c
index c26c02a3537..5cbcc7db67d 100644
--- a/dlls/user32/misc.c
+++ b/dlls/user32/misc.c
@@ -43,6 +43,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(win);
 static HWND (WINAPI *imm_get_ui_window)(HKL);
 BOOL (WINAPI *imm_register_window)(HWND) = NULL;
 void (WINAPI *imm_unregister_window)(HWND) = NULL;
+void (WINAPI *imm_activate_window)(HWND) = NULL;
 
 /* MSIME messages */
 static UINT WM_MSIME_SERVICE;
@@ -567,6 +568,7 @@ BOOL WINAPI User32InitializeImmEntryTable(DWORD magic)
     imm_get_ui_window = (void*)GetProcAddress(imm32, "__wine_get_ui_window");
     imm_register_window = (void*)GetProcAddress(imm32, "__wine_register_window");
     imm_unregister_window = (void*)GetProcAddress(imm32, "__wine_unregister_window");
+    imm_activate_window = (void*)GetProcAddress(imm32, "__wine_activate_window");
     if (!imm_get_ui_window)
         FIXME("native imm32.dll not supported\n");
     return TRUE;
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 514cf6753f4..b86831d7d95 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -197,6 +197,7 @@ C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo)
 extern INT global_key_state_counter DECLSPEC_HIDDEN;
 extern BOOL (WINAPI *imm_register_window)(HWND) DECLSPEC_HIDDEN;
 extern void (WINAPI *imm_unregister_window)(HWND) DECLSPEC_HIDDEN;
+extern void (WINAPI *imm_activate_window)(HWND) DECLSPEC_HIDDEN;
 
 struct user_key_state_info
 {

From 8a781a3ab721a14fed0a8c1aaccd357cdd71d0ac Mon Sep 17 00:00:00 2001
From: Jactry Zeng <jzeng@codeweavers.com>
Date: Thu, 13 Dec 2018 22:21:34 +0800
Subject: [PATCH] gdi32: Add CJK font replacements.

---
 dlls/gdi32/freetype.c | 172 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 171 insertions(+), 1 deletion(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 0fc41f39021..1d721f50760 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -513,11 +513,22 @@ static const WCHAR external_fonts_reg_key[] = {'S','o','f','t','w','a','r','e','
 static const WCHAR Lucida_Sans_Unicode[] = {'L','u','c','i','d','a',' ','S','a','n','s',' ','U','n','i','c','o','d','e',0};
 static const WCHAR Microsoft_Sans_Serif[] = {'M','i','c','r','o','s','o','f','t',' ','S','a','n','s',' ','S','e','r','i','f',0 };
 static const WCHAR Tahoma[] = {'T','a','h','o','m','a',0};
+/* Japanese fonts */
 static const WCHAR MS_UI_Gothic[] = {'M','S',' ','U','I',' ','G','o','t','h','i','c',0};
+static const WCHAR atMS_UI_Gothic[] = {'@','M','S',' ','U','I',' ','G','o','t','h','i','c',0};
+static const WCHAR MS_PGothic_cp932[]= {0x30fb,0xff6d,0x30fb,0xff73,' ',0x30fb,0xff70,0x7e67,0xff74,0x7e67,0xff77,0x7e5d,0x30fb,0x3051,0};
+/* Simplified Chinese fonts */
 static const WCHAR SimSun[] = {'S','i','m','S','u','n',0};
-static const WCHAR Gulim[] = {'G','u','l','i','m',0};
+static const WCHAR atSimSun[] = {'@','S','i','m','S','u','n',0};
+static const WCHAR Microsoft_YaHei[] = {'M','i','c','r','o','s','o','f','t',' ','Y','a','H','e','i',0};
+static const WCHAR LiSu[] = {'L','i','S','u',0};
+/* Traditional Chinese fonts */
 static const WCHAR PMingLiU[] = {'P','M','i','n','g','L','i','U',0};
+static const WCHAR atPMingLiU[] = {'@','P','M','i','n','g','L','i','U',0};
+/* Korean fonts */
 static const WCHAR Batang[] = {'B','a','t','a','n','g',0};
+static const WCHAR Gulim[] = {'G','u','l','i','m',0};
+static const WCHAR atGulim[] = {'@','G','u','l','i','m',0};
 
 static const WCHAR arial[] = {'A','r','i','a','l',0};
 static const WCHAR bitstream_vera_sans[] = {'B','i','t','s','t','r','e','a','m',' ','V','e','r','a',' ','S','a','n','s',0};
@@ -2365,6 +2376,113 @@ static BOOL map_font_family(const WCHAR *orig, const WCHAR *repl)
     return FALSE;
 }
 
+static const WCHAR new_sc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',0,
+    /* Popular open source Chinese font */
+    'W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR vertical_new_sc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',0,
+    /* popular open source Chinese font */
+    '@','W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR new_tc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',0,
+    /* popular open source Chinese font */
+    'W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR vertical_new_tc_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',0,
+    /* popular open source Chinese font */
+    '@','W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR new_jp_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',0,
+    0
+};
+
+static const WCHAR vertical_new_jp_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',0,
+    0
+};
+
+static const WCHAR new_kr_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',0,
+    0
+};
+
+static const WCHAR vertical_new_kr_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',0,
+    0
+};
+
+static struct font_replacements
+{
+    const WCHAR *replacements[4];
+    const int count;
+    const WCHAR *new_fonts;
+    const WCHAR *vertical_new_fonts;
+    BOOL *font_seen;
+} font_replacements_list[] =
+{
+    /* Simplified Chinese */
+    {
+        {
+            SimSun, atSimSun, Microsoft_YaHei, LiSu
+        }, 4, new_sc_fonts, vertical_new_sc_fonts, NULL
+    },
+    /* Traditional Chinese */
+    {
+        {
+            PMingLiU, atPMingLiU
+        }, 2, new_tc_fonts, vertical_new_tc_fonts, NULL
+    },
+    /* Japanese */
+    {
+        {
+            MS_UI_Gothic, atMS_UI_Gothic, MS_PGothic_cp932
+        }, 3, new_jp_fonts, vertical_new_jp_fonts, NULL
+    },
+    /* Korean */
+    {
+        {
+            Gulim, atGulim
+        }, 2, new_kr_fonts, vertical_new_kr_fonts, NULL
+    }
+};
+
 /***********************************************************
  * The replacement list is a way to map an entire font
  * family onto another family.  For example adding
@@ -2383,6 +2501,7 @@ static void LoadReplaceList(void)
     DWORD valuelen, datalen, i = 0, type, dlen, vlen;
     LPWSTR value;
     LPVOID data;
+    int replacement_count = sizeof(font_replacements_list)/sizeof(font_replacements_list[0]);
 
     /* @@ Wine registry key: HKCU\Software\Wine\Fonts\Replacements */
     if(RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Fonts\\Replacements", &hkey) == ERROR_SUCCESS)
@@ -2401,6 +2520,25 @@ static void LoadReplaceList(void)
             /* "NewName"="Oldname" */
             if(!find_family_from_any_name(value))
             {
+                int j;
+
+                for (j = 0; j < replacement_count; j++)
+                {
+                    int k;
+
+                    struct font_replacements *replacement = &font_replacements_list[j];
+
+                    replacement->font_seen = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                                                       replacement->count * sizeof(BOOL));
+                    for (k = 0; k < replacement->count; k++)
+                    {
+                        if (!replacement->font_seen[k] && !lstrcmpW(value, replacement->replacements[k]))
+                        {
+                            replacement->font_seen[k] = TRUE;
+                            break;
+                        }
+                    }
+                }
                 if (type == REG_MULTI_SZ)
                 {
                     WCHAR *replace = data;
@@ -2421,6 +2559,38 @@ static void LoadReplaceList(void)
 	    dlen = datalen;
 	    vlen = valuelen;
 	}
+
+        for (i = 0; i < replacement_count; i++)
+        {
+            int j;
+            struct font_replacements *replacement = &font_replacements_list[i];
+
+            for (j = 0; j < replacement->count; j++)
+            {
+                if (!replacement->font_seen ||
+                    (!replacement->font_seen[j] && !find_family_from_any_name(replacement->replacements[j])))
+                {
+                    const WCHAR *replace;
+
+                    if (replacement->replacements[j][0] == '@')
+                        replace = replacement->vertical_new_fonts;
+                    else
+                        replace = replacement->new_fonts;
+
+                    while (*replace)
+                    {
+                        if (map_font_family(replacement->replacements[j], replace))
+                        {
+                            TRACE("Replace %s with %s\n", wine_dbgstr_w(replacement->replacements[j]),
+                                  wine_dbgstr_w(replace));
+                            break;
+                        }
+                        replace += strlenW(replace) + 1;
+                    }
+                }
+            }
+            HeapFree(GetProcessHeap(), 0, replacement->font_seen);
+        }
 	HeapFree(GetProcessHeap(), 0, data);
 	HeapFree(GetProcessHeap(), 0, value);
 	RegCloseKey(hkey);

From 17d19e1b23bce6fc6ff5b4e61131c9c58fd57ae5 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 28 Mar 2018 09:21:41 -0500
Subject: [PATCH] HACK: Don't build winemenubuilder

---
 configure          | 2 --
 configure.ac       | 1 -
 loader/wine.inf.in | 1 -
 3 files changed, 4 deletions(-)

diff --git a/configure b/configure
index 649a8917f54..4581015d576 100755
--- a/configure
+++ b/configure
@@ -1746,7 +1746,6 @@ enable_wineconsole
 enable_winedbg
 enable_winedevice
 enable_winefile
-enable_winemenubuilder
 enable_winemine
 enable_winemsibuilder
 enable_winepath
@@ -20315,7 +20314,6 @@ wine_fn_config_makefile programs/wineconsole enable_wineconsole
 wine_fn_config_makefile programs/winedbg enable_winedbg
 wine_fn_config_makefile programs/winedevice enable_winedevice
 wine_fn_config_makefile programs/winefile enable_winefile
-wine_fn_config_makefile programs/winemenubuilder enable_winemenubuilder
 wine_fn_config_makefile programs/winemine enable_winemine
 wine_fn_config_makefile programs/winemsibuilder enable_winemsibuilder
 wine_fn_config_makefile programs/winepath enable_winepath
diff --git a/configure.ac b/configure.ac
index 704da15f404..d4168e410bc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3998,7 +3998,6 @@ WINE_CONFIG_MAKEFILE(programs/wineconsole)
 WINE_CONFIG_MAKEFILE(programs/winedbg)
 WINE_CONFIG_MAKEFILE(programs/winedevice)
 WINE_CONFIG_MAKEFILE(programs/winefile)
-WINE_CONFIG_MAKEFILE(programs/winemenubuilder)
 WINE_CONFIG_MAKEFILE(programs/winemine)
 WINE_CONFIG_MAKEFILE(programs/winemsibuilder)
 WINE_CONFIG_MAKEFILE(programs/winepath)
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 2b049eb91f8..e6948a73427 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3598,7 +3598,6 @@ HKR,Parameters,"ServiceDll",,"%11%\schedsvc.dll"
 HKLM,%CurrentVersionNT%\SvcHost,"netsvcs",0x00010008,"Schedule"
 
 [Services]
-HKLM,%CurrentVersion%\RunServices,"winemenubuilder",2,"%11%\winemenubuilder.exe -a -r"
 HKLM,"System\CurrentControlSet\Services\Eventlog\Application",,16
 HKLM,"System\CurrentControlSet\Services\Eventlog\System","Sources",0x10000,""
 HKLM,"System\CurrentControlSet\Services\Tcpip\Parameters","DataBasePath",2,"%11%\drivers"

From aef0f1638ce13db03a4d3c0fe53972f44443c854 Mon Sep 17 00:00:00 2001
From: Patryk Obara <dreamer.tan@gmail.com>
Date: Fri, 26 Apr 2019 20:40:31 +0200
Subject: [PATCH] winex11: Fill WM_CLASS based on Steam appid

Some desktop environments (Gnome 3, Cinnamon) decide on an application
icon in the following order:

 - If the first string in WM_CLASS property can be correlated to
  a name or StartupWMClass key in a .desktop entry file, then
  the associated icon will be used.
 - If the second string in WM_CLASS property can be correlated to
  a name or StartupWMClass key in a .desktop entry file, then
  the associated icon will be used.
 - If the application has indicated an icon resource through WM_HINTS
  property, then the associated X window or pixmaps will be used.

Upstream Wine usually deals with this by placing a .desktop file with
StartupWMClass filled to match first string in WM_CLASS property
(which is the name of exe file being run).

Wine in Proton does not do it, but still puts "Wine" as second string,
therefore desktop environment can't differentiate between Wine in
Proton and Wine installed in OS.

By replacing "Wine" with "steam_app_<appid>" we force DE to fallback
to icon indicated by WM_HINTS (ico file embedded in exe file).
Steam can override this behaviour by installing properly crafted
.desktop entry file.  If SteamAppId environment variable is missing,
then generic "steam_proton" name is used instead.
---
 dlls/winex11.drv/window.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 1ec7c706511..9ae3da3d4a2 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -870,10 +870,13 @@ static void set_initial_wm_hints( Display *display, Window window )
     /* class hints */
     if ((class_hints = XAllocClassHint()))
     {
-        static char wine[] = "Wine";
+        static char steam_proton[] = "steam_proton";
+        char proton_app_class[128];
+        const char *app_id = getenv("SteamAppId");
 
+        snprintf(proton_app_class, sizeof(proton_app_class), "steam_app_%s", app_id);
         class_hints->res_name = process_name;
-        class_hints->res_class = wine;
+        class_hints->res_class = app_id ? proton_app_class : steam_proton;
         XSetClassHint( display, window, class_hints );
         XFree( class_hints );
     }

From 7e91b897e69854cb3afe761f48ef7c9b496ecf95 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B3zef=20Kucia?= <jkucia@codeweavers.com>
Date: Wed, 1 May 2019 12:28:12 +0200
Subject: [PATCH] vulkan-1: Prefer built-in DLL.

Games may ship with their own Vulkan loader.
---
 dlls/vulkan-1/vulkan.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/dlls/vulkan-1/vulkan.c b/dlls/vulkan-1/vulkan.c
index d3b35603a17..4926cf9bf4f 100644
--- a/dlls/vulkan-1/vulkan.c
+++ b/dlls/vulkan-1/vulkan.c
@@ -32,10 +32,6 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, void *reserved)
 
     switch (reason)
     {
-        case DLL_WINE_PREATTACH:
-            /* Prefer native as it provides more functionality. */
-            return FALSE;
-
         case DLL_PROCESS_ATTACH:
             DisableThreadLibraryCalls(hinst);
             return TRUE;

From 90e3616c89ef7ed38763a3e3af3e9f0cd59697da Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Mar 2017 20:15:40 +0300
Subject: [PATCH] HACK: dwrite: Don't recommend outline rendering mode

---
 dlls/dwrite/font.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/dwrite/font.c b/dlls/dwrite/font.c
index e22559912c3..41ec809b727 100644
--- a/dlls/dwrite/font.c
+++ b/dlls/dwrite/font.c
@@ -740,7 +740,8 @@ static HRESULT WINAPI dwritefontface_GetRecommendedRenderingMode(IDWriteFontFace
 
     ppem = emSize * ppdip;
 
-    if (ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
+    /* HACK: disable outline rendering mode to workaround d2d issue */
+    if (0 && ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
         *mode = DWRITE_RENDERING_MODE_OUTLINE;
         return S_OK;
     }

From 5c59517008697ce74becddb59a3e6702a963bb49 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Fri, 16 Aug 2019 09:46:25 +0000
Subject: [PATCH] msctf: Use list to keep thread managers.

Thread managers were stored in thread local storage,
which have a major flaw that they can't not be released
by another thread.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/msctf/msctf.c          | 46 +++++++----------------
 dlls/msctf/msctf_internal.h |  1 -
 dlls/msctf/threadmgr.c      | 73 ++++++++++++++++++++++++++++++++-----
 3 files changed, 76 insertions(+), 44 deletions(-)

diff --git a/dlls/msctf/msctf.c b/dlls/msctf/msctf.c
index c6e3a2ca597..fd919295c5a 100644
--- a/dlls/msctf/msctf.c
+++ b/dlls/msctf/msctf.c
@@ -69,7 +69,6 @@ static UINT array_size;
 static struct list AtsList = LIST_INIT(AtsList);
 static UINT activated = 0;
 
-DWORD tlsIndex = 0;
 TfClientId processId = 0;
 ITfCompartmentMgr *globalCompartmentMgr = NULL;
 
@@ -397,23 +396,19 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
     ActivatedTextService *actsvr;
     ITfCategoryMgr *catmgr;
     AtsEntry *entry;
-    ITfThreadMgrEx *tm = TlsGetValue(tlsIndex);
+    ITfThreadMgr *tm;
     ITfClientId *clientid;
 
-    if (!tm) return E_UNEXPECTED;
+    if (FAILED(TF_GetThreadMgr(&tm))) return E_UNEXPECTED;
 
     actsvr = HeapAlloc(GetProcessHeap(),0,sizeof(ActivatedTextService));
-    if (!actsvr) return E_OUTOFMEMORY;
+    if (!actsvr) goto fail;
 
-    ITfThreadMgrEx_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
+    ITfThreadMgr_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
     ITfClientId_GetClientId(clientid, &lp->clsid, &actsvr->tid);
     ITfClientId_Release(clientid);
 
-    if (!actsvr->tid)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!actsvr->tid) goto fail;
 
     actsvr->pITfTextInputProcessor = NULL;
     actsvr->LanguageProfile = *lp;
@@ -440,20 +435,21 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
         deactivate_remove_conflicting_ts(&actsvr->LanguageProfile.catid);
 
     if (activated > 0)
-        activate_given_ts(actsvr, tm);
+        activate_given_ts(actsvr, (ITfThreadMgrEx *)tm);
 
     entry = HeapAlloc(GetProcessHeap(),0,sizeof(AtsEntry));
-
-    if (!entry)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!entry) goto fail;
 
     entry->ats = actsvr;
     list_add_head(&AtsList, &entry->entry);
 
+    ITfThreadMgr_Release(tm);
     return S_OK;
+
+fail:
+    ITfThreadMgr_Release(tm);
+    HeapFree(GetProcessHeap(), 0, actsvr);
+    return E_OUTOFMEMORY;
 }
 
 BOOL get_active_textservice(REFCLSID rclsid, TF_LANGUAGEPROFILE *profile)
@@ -560,11 +556,9 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD fdwReason, LPVOID fImpLoad)
             return FALSE;   /* prefer native version */
         case DLL_PROCESS_ATTACH:
             MSCTF_hinstance = hinst;
-            tlsIndex = TlsAlloc();
             break;
         case DLL_PROCESS_DETACH:
             if (fImpLoad) break;
-            TlsFree(tlsIndex);
             break;
     }
     return TRUE;
@@ -622,20 +616,6 @@ HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim)
     return ThreadMgr_Constructor(NULL,(IUnknown**)pptim);
 }
 
-/***********************************************************************
- *              TF_GetThreadMgr (MSCTF.@)
- */
-HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
-{
-    TRACE("\n");
-    *pptim = TlsGetValue(tlsIndex);
-
-    if (*pptim)
-        ITfThreadMgr_AddRef(*pptim);
-
-    return S_OK;
-}
-
 /***********************************************************************
  *              SetInputScope(MSCTF.@)
  */
diff --git a/dlls/msctf/msctf_internal.h b/dlls/msctf/msctf_internal.h
index 584bb1044ed..ace2bee23d9 100644
--- a/dlls/msctf/msctf_internal.h
+++ b/dlls/msctf/msctf_internal.h
@@ -35,7 +35,6 @@
 #define COOKIE_MAGIC_UIELEMENTSINK 0x00a0
 #define COOKIE_MAGIC_INPUTPROCESSORPROFILEACTIVATIONSINK 0x00b0
 
-extern DWORD tlsIndex DECLSPEC_HIDDEN;
 extern TfClientId processId DECLSPEC_HIDDEN;
 extern ITfCompartmentMgr *globalCompartmentMgr DECLSPEC_HIDDEN;
 
diff --git a/dlls/msctf/threadmgr.c b/dlls/msctf/threadmgr.c
index 2c208fbc04f..2119ea2193b 100644
--- a/dlls/msctf/threadmgr.c
+++ b/dlls/msctf/threadmgr.c
@@ -37,6 +37,17 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msctf);
 
+static CRITICAL_SECTION ThreadMgrCs;
+static CRITICAL_SECTION_DEBUG ThreadMgrCsDebug =
+{
+    0, 0, &ThreadMgrCs,
+    {&ThreadMgrCsDebug.ProcessLocksList,
+     &ThreadMgrCsDebug.ProcessLocksList },
+     0, 0, {(DWORD_PTR)(__FILE__ ": ThreadMgrCs")}
+};
+static CRITICAL_SECTION ThreadMgrCs = {&ThreadMgrCsDebug, -1, 0, 0, 0, 0};
+struct list ThreadMgrList = LIST_INIT(ThreadMgrList);
+
 typedef struct tagPreservedKey
 {
     struct list     entry;
@@ -98,6 +109,9 @@ typedef struct tagACLMulti {
     struct list     ThreadMgrEventSink;
     struct list     UIElementSink;
     struct list     InputProcessorProfileActivationSink;
+
+    DWORD threadId;
+    struct list entry;
 } ThreadMgr;
 
 typedef struct tagEnumTfDocumentMgr {
@@ -110,6 +124,11 @@ typedef struct tagEnumTfDocumentMgr {
 
 static HRESULT EnumTfDocumentMgr_Constructor(struct list* head, IEnumTfDocumentMgrs **ppOut);
 
+static inline ThreadMgr *impl_from_ITfThreadMgr(ITfThreadMgr *iface)
+{
+    return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
+}
+
 static inline ThreadMgr *impl_from_ITfThreadMgrEx(ITfThreadMgrEx *iface)
 {
     return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
@@ -155,6 +174,35 @@ static inline EnumTfDocumentMgr *impl_from_IEnumTfDocumentMgrs(IEnumTfDocumentMg
     return CONTAINING_RECORD(iface, EnumTfDocumentMgr, IEnumTfDocumentMgrs_iface);
 }
 
+/***********************************************************************
+ *              TF_GetThreadMgr (MSCTF.@)
+ */
+HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
+{
+    DWORD id = GetCurrentThreadId();
+    ThreadMgr *cursor;
+
+    TRACE("%p\n", pptim);
+
+    if (!pptim)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&ThreadMgrCs);
+    LIST_FOR_EACH_ENTRY(cursor, &ThreadMgrList, ThreadMgr, entry)
+    {
+        if (cursor->threadId == id)
+        {
+            ITfThreadMgrEx_AddRef(&cursor->ITfThreadMgrEx_iface);
+            *pptim = (ITfThreadMgr *)&cursor->ITfThreadMgrEx_iface;
+            LeaveCriticalSection(&ThreadMgrCs);
+            return S_OK;
+        }
+    }
+    LeaveCriticalSection(&ThreadMgrCs);
+    *pptim = NULL;
+    return E_FAIL;
+}
+
 static void ThreadMgr_Destructor(ThreadMgr *This)
 {
     struct list *cursor, *cursor2;
@@ -163,7 +211,9 @@ static void ThreadMgr_Destructor(ThreadMgr *This)
     if (This->focusHook)
         UnhookWindowsHookEx(This->focusHook);
 
-    TlsSetValue(tlsIndex,NULL);
+    EnterCriticalSection(&ThreadMgrCs);
+    list_remove(&This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
     TRACE("destroying %p\n", This);
     if (This->focus)
         ITfDocumentMgr_Release(This->focus);
@@ -386,17 +436,20 @@ static HRESULT WINAPI ThreadMgr_SetFocus(ITfThreadMgrEx *iface, ITfDocumentMgr *
 
 static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lParam)
 {
+    ITfThreadMgr *ThreadMgr_iface;
     ThreadMgr *This;
 
-    This = TlsGetValue(tlsIndex);
-    if (!This)
+    if (FAILED(TF_GetThreadMgr(&ThreadMgr_iface)))
     {
         ERR("Hook proc but no ThreadMgr for this thread. Serious Error\n");
         return 0;
     }
+
+    This = impl_from_ITfThreadMgr(ThreadMgr_iface);
     if (!This->focusHook)
     {
         ERR("Hook proc but no ThreadMgr focus Hook. Serious Error\n");
+        ITfThreadMgr_Release(ThreadMgr_iface);
         return 0;
     }
 
@@ -417,6 +470,7 @@ static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lPa
         }
     }
 
+    ITfThreadMgr_Release(ThreadMgr_iface);
     return CallNextHookEx(This->focusHook, nCode, wParam, lParam);
 }
 
@@ -1338,13 +1392,8 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
         return CLASS_E_NOAGGREGATION;
 
     /* Only 1 ThreadMgr is created per thread */
-    This = TlsGetValue(tlsIndex);
-    if (This)
-    {
-        ThreadMgr_AddRef(&This->ITfThreadMgrEx_iface);
-        *ppOut = (IUnknown*)&This->ITfThreadMgrEx_iface;
+    if (SUCCEEDED(TF_GetThreadMgr((ITfThreadMgr **)ppOut)))
         return S_OK;
-    }
 
     This = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(ThreadMgr));
     if (This == NULL)
@@ -1359,7 +1408,6 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     This->ITfUIElementMgr_iface.lpVtbl = &ThreadMgrUIElementMgrVtbl;
     This->ITfSourceSingle_iface.lpVtbl = &SourceSingleVtbl;
     This->refCount = 1;
-    TlsSetValue(tlsIndex,This);
 
     CompartmentMgr_Constructor((IUnknown*)&This->ITfThreadMgrEx_iface, &IID_IUnknown, (IUnknown**)&This->CompartmentMgr);
 
@@ -1376,6 +1424,11 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     list_init(&This->UIElementSink);
     list_init(&This->InputProcessorProfileActivationSink);
 
+    This->threadId = GetCurrentThreadId();
+    EnterCriticalSection(&ThreadMgrCs);
+    list_add_tail(&ThreadMgrList, &This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
+
     TRACE("returning %p\n", This);
     *ppOut = (IUnknown *)&This->ITfThreadMgrEx_iface;
     return S_OK;
From 57f18487fb073df1adf3fcdb0726175d530aa737 Mon Sep 17 00:00:00 2001
From: Juuso Alasuutari <juuso.alasuutari@gmail.com>
Date: Sun, 18 Aug 2019 09:27:13 +0300
Subject: [PATCH] kernel32: Ensure that the loader lock is released before
 returning from GetModuleHandleExW().

Signed-off-by: Juuso Alasuutari <juuso.alasuutari@gmail.com>
Reviewed-by: Richard Yao <ryao@gentoo.org>
---
 dlls/kernel32/module.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 9ae687cb840..4289f20d3c2 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -479,6 +479,8 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
         UNICODE_STRING wstr;
         if(steamclient_hmod != NULL && strcasestrW(name, steamclientW)){
             *module = steamclient_hmod;
+            if (lock)
+                LdrUnlockLoaderLock( 0, magic );
             return TRUE;
         }
         RtlInitUnicodeString( &wstr, name );

From ed04e35d3f7af02267fb4e21578b3ccb27703836 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 23 Sep 2019 13:29:16 -0500
Subject: [PATCH] dxdiag: Dump to stdout if no filename is given

---
 programs/dxdiag/main.c   |  8 +++++++-
 programs/dxdiag/output.c | 10 +++++++---
 2 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/programs/dxdiag/main.c b/programs/dxdiag/main.c
index 4533236f0f5..353e9f50fb9 100644
--- a/programs/dxdiag/main.c
+++ b/programs/dxdiag/main.c
@@ -71,7 +71,13 @@ static BOOL process_file_name(const WCHAR *cmdline, enum output_type output_type
         endptr = cmdline + lstrlenW(cmdline);
 
     len = endptr - cmdline;
-    if (len == 0 || len >= filename_len)
+    if (len == 0)
+    {
+        *filename = 0;
+        return TRUE;
+    }
+
+    if (len >= filename_len)
         return FALSE;
 
     memcpy(filename, cmdline, len * sizeof(WCHAR));
diff --git a/programs/dxdiag/output.c b/programs/dxdiag/output.c
index 50240fb2860..f0f6a6da0c3 100644
--- a/programs/dxdiag/output.c
+++ b/programs/dxdiag/output.c
@@ -169,8 +169,12 @@ static BOOL output_text_information(struct dxdiag_information *dxdiag_info, cons
 
     fill_system_text_output_table(dxdiag_info, output_table[0].fields);
 
-    hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
-                        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (filename && *filename)
+        hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    else
+        hFile = GetStdHandle(STD_OUTPUT_HANDLE);
+
     if (hFile == INVALID_HANDLE_VALUE)
     {
         WINE_ERR("File creation failed, last error %u\n", GetLastError());
@@ -227,7 +231,7 @@ static HRESULT save_xml_document(IXMLDOMDocument *xmldoc, const WCHAR *filename)
     VARIANT destVar;
     HRESULT hr;
 
-    if (!bstr)
+    if (!bstr || !filename || !*filename)
         return E_OUTOFMEMORY;
 
     V_VT(&destVar) = VT_BSTR;
From e485252dfad51a7e463643d56fe138129597e4b6 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 23 Sep 2019 08:56:04 -0500
Subject: [PATCH] ntdll: Always add a tail to heap allocations.

Fixes the Rockstar Games Launcher installer (and possibly other
NSIS-based installers) from crashing due to passing a too-small buffer
to GetWindowInfo().
---
 dlls/ntdll/heap.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index 6344157f384..6fefe5d6d80 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -118,9 +118,8 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
 #define HEAP_MIN_SHRINK_SIZE  (HEAP_MIN_DATA_SIZE+sizeof(ARENA_FREE))
 /* minimum size to start allocating large blocks */
 #define HEAP_MIN_LARGE_BLOCK_SIZE  0x7f000
-/* extra size to add at the end of block for tail checking */
-#define HEAP_TAIL_EXTRA_SIZE(flags) \
-    ((flags & HEAP_TAIL_CHECKING_ENABLED) || RUNNING_ON_VALGRIND ? ALIGNMENT : 0)
+/* extra size to add at the end of block to mitigate overruns and allow tail checking */
+#define HEAP_TAIL_EXTRA_SIZE ALIGNMENT
 
 /* size of the blocks on the free lists */
 #define HEAP_FREELIST_SIZE(index) \
@@ -800,7 +799,7 @@ static void HEAP_ShrinkBlock(SUBHEAP *subheap, ARENA_INUSE *pArena, SIZE_T size)
 static void *allocate_large_block( HEAP *heap, DWORD flags, SIZE_T size )
 {
     ARENA_LARGE *arena;
-    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     LPVOID address = NULL;
 
     if (block_size < size) return NULL;  /* overflow */
@@ -1814,7 +1813,7 @@ void * WINAPI DECLSPEC_HOTPATCH RtlAllocateHeap( HANDLE heap, ULONG flags, SIZE_
     if (!heapPtr) return NULL;
     flags &= HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY;
     flags |= heapPtr->flags;
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE( flags );
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size)  /* overflow */
     {
         if (flags & HEAP_GENERATE_EXCEPTIONS) RtlRaiseStatus( STATUS_NO_MEMORY );
@@ -1968,7 +1967,7 @@ PVOID WINAPI RtlReAllocateHeap( HANDLE heap, ULONG flags, PVOID ptr, SIZE_T size
     flags |= heapPtr->flags;
     if (!(flags & HEAP_NO_SERIALIZE)) RtlEnterCriticalSection( &heapPtr->critSection );
 
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size) goto oom;  /* overflow */
     if (rounded_size < HEAP_MIN_DATA_SIZE) rounded_size = HEAP_MIN_DATA_SIZE;
 

From 21b43e000eb18207eb7ee68267d8ef38da6ad1c0 Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:14 -0600
Subject: [PATCH] advapi32: Replace SERV_dup() with strdupAW()

The strdupAW() function in advapi32_misc.h behaves exactly the same as
SERV_dup(). Switching calls to strdupAW() will reduce the complexity
when moving the services RPC functions into sechost by allowing moving
the service.c file with few changes.

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 dlls/advapi32/advapi32_misc.h |  1 -
 dlls/advapi32/eventlog.c      | 12 +++----
 dlls/advapi32/security.c      | 22 ++++++-------
 dlls/advapi32/service.c       | 60 ++++++++++++-----------------------
 4 files changed, 38 insertions(+), 57 deletions(-)

diff --git a/dlls/advapi32/advapi32_misc.h b/dlls/advapi32/advapi32_misc.h
index 77b56420ba3..65bd8aa8529 100644
--- a/dlls/advapi32/advapi32_misc.h
+++ b/dlls/advapi32/advapi32_misc.h
@@ -31,7 +31,6 @@ BOOL ADVAPI_GetComputerSid(PSID sid) DECLSPEC_HIDDEN;
 
 BOOL lookup_local_wellknown_name(const LSA_UNICODE_STRING*, PSID, LPDWORD, LPWSTR, LPDWORD, PSID_NAME_USE, BOOL*) DECLSPEC_HIDDEN;
 BOOL lookup_local_user_name(const LSA_UNICODE_STRING*, PSID, LPDWORD, LPWSTR, LPDWORD, PSID_NAME_USE, BOOL*) DECLSPEC_HIDDEN;
-WCHAR *SERV_dup(const char *str) DECLSPEC_HIDDEN;
 const WCHAR *get_wellknown_privilege_name(const LUID *) DECLSPEC_HIDDEN;
 
 /* memory allocation functions */
diff --git a/dlls/advapi32/eventlog.c b/dlls/advapi32/eventlog.c
index 6f8d26b5161..4349408a007 100644
--- a/dlls/advapi32/eventlog.c
+++ b/dlls/advapi32/eventlog.c
@@ -57,7 +57,7 @@ BOOL WINAPI BackupEventLogA( HANDLE hEventLog, LPCSTR lpBackupFileName )
     LPWSTR backupW;
     BOOL ret;
 
-    backupW = SERV_dup(lpBackupFileName);
+    backupW = strdupAW(lpBackupFileName);
     ret = BackupEventLogW(hEventLog, backupW);
     heap_free(backupW);
 
@@ -114,7 +114,7 @@ BOOL WINAPI ClearEventLogA( HANDLE hEventLog, LPCSTR lpBackupFileName )
     LPWSTR backupW;
     BOOL ret;
 
-    backupW = SERV_dup(lpBackupFileName);
+    backupW = strdupAW(lpBackupFileName);
     ret = ClearEventLogW(hEventLog, backupW);
     heap_free(backupW);
 
@@ -430,8 +430,8 @@ HANDLE WINAPI OpenBackupEventLogA( LPCSTR lpUNCServerName, LPCSTR lpFileName )
     LPWSTR uncnameW, filenameW;
     HANDLE handle;
 
-    uncnameW = SERV_dup(lpUNCServerName);
-    filenameW = SERV_dup(lpFileName);
+    uncnameW = strdupAW(lpUNCServerName);
+    filenameW = strdupAW(lpFileName);
     handle = OpenBackupEventLogW(uncnameW, filenameW);
     heap_free(uncnameW);
     heap_free(filenameW);
@@ -489,8 +489,8 @@ HANDLE WINAPI OpenEventLogA( LPCSTR uncname, LPCSTR source )
     LPWSTR uncnameW, sourceW;
     HANDLE handle;
 
-    uncnameW = SERV_dup(uncname);
-    sourceW = SERV_dup(source);
+    uncnameW = strdupAW(uncname);
+    sourceW = strdupAW(source);
     handle = OpenEventLogW(uncnameW, sourceW);
     heap_free(uncnameW);
     heap_free(sourceW);
diff --git a/dlls/advapi32/security.c b/dlls/advapi32/security.c
index 74eda932826..326058e2f76 100644
--- a/dlls/advapi32/security.c
+++ b/dlls/advapi32/security.c
@@ -1020,7 +1020,7 @@ GetFileSecurityA( LPCSTR lpFileName,
     BOOL r;
     LPWSTR name;
 
-    name = SERV_dup(lpFileName);
+    name = strdupAW(lpFileName);
     r = GetFileSecurityW( name, RequestedInformation, pSecurityDescriptor,
                           nLength, lpnLengthNeeded );
     heap_free( name );
@@ -1049,7 +1049,7 @@ LookupAccountSidA(
     DWORD accountSizeW = *accountSize;
     DWORD domainSizeW = *domainSize;
 
-    systemW = SERV_dup(system);
+    systemW = strdupAW(system);
     if (account)
         accountW = heap_alloc( accountSizeW * sizeof(WCHAR) );
     if (domain)
@@ -1303,7 +1303,7 @@ BOOL WINAPI SetFileSecurityA( LPCSTR lpFileName,
     BOOL r;
     LPWSTR name;
 
-    name = SERV_dup(lpFileName);
+    name = strdupAW(lpFileName);
     r = SetFileSecurityW( name, RequestedInformation, pSecurityDescriptor );
     heap_free( name );
 
@@ -2251,7 +2251,7 @@ static DWORD trustee_name_A_to_W(TRUSTEE_FORM form, char *trustee_nameA, WCHAR *
     {
     case TRUSTEE_IS_NAME:
     {
-        *ptrustee_nameW = SERV_dup(trustee_nameA);
+        *ptrustee_nameW = strdupAW(trustee_nameA);
         return ERROR_SUCCESS;
     }
     case TRUSTEE_IS_OBJECTS_AND_NAME:
@@ -2266,9 +2266,9 @@ static DWORD trustee_name_A_to_W(TRUSTEE_FORM form, char *trustee_nameA, WCHAR *
 
             objW->ObjectsPresent = objA->ObjectsPresent;
             objW->ObjectType = objA->ObjectType;
-            objW->ObjectTypeName = SERV_dup(objA->ObjectTypeName);
-            objW->InheritedObjectTypeName = SERV_dup(objA->InheritedObjectTypeName);
-            objW->ptstrName = SERV_dup(objA->ptstrName);
+            objW->ObjectTypeName = strdupAW(objA->ObjectTypeName);
+            objW->InheritedObjectTypeName = strdupAW(objA->InheritedObjectTypeName);
+            objW->ptstrName = strdupAW(objA->ptstrName);
         }
 
         *ptrustee_nameW = (WCHAR *)objW;
@@ -2648,7 +2648,7 @@ DWORD WINAPI SetNamedSecurityInfoA(LPSTR pObjectName,
     TRACE("%s %d %d %p %p %p %p\n", debugstr_a(pObjectName), ObjectType,
            SecurityInfo, psidOwner, psidGroup, pDacl, pSacl);
 
-    wstr = SERV_dup(pObjectName);
+    wstr = strdupAW(pObjectName);
     r = SetNamedSecurityInfoW( wstr, ObjectType, SecurityInfo, psidOwner,
                            psidGroup, pDacl, pSacl );
 
@@ -3323,7 +3323,7 @@ BOOL WINAPI ConvertStringSecurityDescriptorToSecurityDescriptorA(
     if(!StringSecurityDescriptor)
         return FALSE;
 
-    StringSecurityDescriptorW = SERV_dup(StringSecurityDescriptor);
+    StringSecurityDescriptorW = strdupAW(StringSecurityDescriptor);
     ret = ConvertStringSecurityDescriptorToSecurityDescriptorW(StringSecurityDescriptorW,
                                                                StringSDRevision, SecurityDescriptor,
                                                                SecurityDescriptorSize);
@@ -3833,7 +3833,7 @@ BOOL WINAPI ConvertStringSidToSidA(LPCSTR StringSid, PSID* Sid)
         SetLastError(ERROR_INVALID_PARAMETER);
     else
     {
-        WCHAR *wStringSid = SERV_dup(StringSid);
+        WCHAR *wStringSid = strdupAW(StringSid);
         bret = ConvertStringSidToSidW(wStringSid, Sid);
         heap_free(wStringSid);
     }
@@ -4096,7 +4096,7 @@ DWORD WINAPI GetNamedSecurityInfoA(LPSTR pObjectName,
     TRACE("%s %d %d %p %p %p %p %p\n", pObjectName, ObjectType, SecurityInfo,
         ppsidOwner, ppsidGroup, ppDacl, ppSacl, ppSecurityDescriptor);
 
-    wstr = SERV_dup(pObjectName);
+    wstr = strdupAW(pObjectName);
     r = GetNamedSecurityInfoW( wstr, ObjectType, SecurityInfo, ppsidOwner,
                            ppsidGroup, ppDacl, ppSacl, ppSecurityDescriptor );
 
diff --git a/dlls/advapi32/service.c b/dlls/advapi32/service.c
index 2781a128239..3bf6fdfd47f 100644
--- a/dlls/advapi32/service.c
+++ b/dlls/advapi32/service.c
@@ -113,24 +113,6 @@ static BOOL stop_service;
 
 extern HANDLE CDECL __wine_make_process_system(void);
 
-/******************************************************************************
- * String management functions (same behaviour as strdup)
- * NOTE: the caller of those functions is responsible for calling HeapFree
- * in order to release the memory allocated by those functions.
- */
-LPWSTR SERV_dup( LPCSTR str )
-{
-    UINT len;
-    LPWSTR wstr;
-
-    if( !str )
-        return NULL;
-    len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
-    wstr = heap_alloc( len*sizeof (WCHAR) );
-    MultiByteToWideChar( CP_ACP, 0, str, -1, wstr, len );
-    return wstr;
-}
-
 static inline LPWSTR SERV_dupmulti(LPCSTR str)
 {
     UINT len = 0, n = 0;
@@ -884,8 +866,8 @@ SC_HANDLE WINAPI OpenSCManagerA( LPCSTR lpMachineName, LPCSTR lpDatabaseName,
     LPWSTR machineW, databaseW;
     SC_HANDLE ret;
 
-    machineW = SERV_dup(lpMachineName);
-    databaseW = SERV_dup(lpDatabaseName);
+    machineW = strdupAW(lpMachineName);
+    databaseW = strdupAW(lpDatabaseName);
     ret = OpenSCManagerW(machineW, databaseW, dwDesiredAccess);
     heap_free(databaseW);
     heap_free(machineW);
@@ -1037,7 +1019,7 @@ SC_HANDLE WINAPI OpenServiceA( SC_HANDLE hSCManager, LPCSTR lpServiceName,
 
     TRACE("%p %s 0x%08x\n", hSCManager, debugstr_a(lpServiceName), dwDesiredAccess);
 
-    lpServiceNameW = SERV_dup(lpServiceName);
+    lpServiceNameW = strdupAW(lpServiceName);
     ret = OpenServiceW( hSCManager, lpServiceNameW, dwDesiredAccess);
     heap_free(lpServiceNameW);
     return ret;
@@ -1171,13 +1153,13 @@ CreateServiceA( SC_HANDLE hSCManager, LPCSTR lpServiceName,
     TRACE("%p %s %s\n", hSCManager,
           debugstr_a(lpServiceName), debugstr_a(lpDisplayName));
 
-    lpServiceNameW = SERV_dup( lpServiceName );
-    lpDisplayNameW = SERV_dup( lpDisplayName );
-    lpBinaryPathNameW = SERV_dup( lpBinaryPathName );
-    lpLoadOrderGroupW = SERV_dup( lpLoadOrderGroup );
+    lpServiceNameW = strdupAW( lpServiceName );
+    lpDisplayNameW = strdupAW( lpDisplayName );
+    lpBinaryPathNameW = strdupAW( lpBinaryPathName );
+    lpLoadOrderGroupW = strdupAW( lpLoadOrderGroup );
     lpDependenciesW = SERV_dupmulti( lpDependencies );
-    lpServiceStartNameW = SERV_dup( lpServiceStartName );
-    lpPasswordW = SERV_dup( lpPassword );
+    lpServiceStartNameW = strdupAW( lpServiceStartName );
+    lpPasswordW = strdupAW( lpPassword );
 
     r = CreateServiceW( hSCManager, lpServiceNameW, lpDisplayNameW,
             dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl,
@@ -1269,7 +1251,7 @@ BOOL WINAPI StartServiceA( SC_HANDLE hService, DWORD dwNumServiceArgs,
         lpwstr = heap_alloc( dwNumServiceArgs*sizeof(LPWSTR) );
 
     for(i=0; i<dwNumServiceArgs; i++)
-        lpwstr[i]=SERV_dup(lpServiceArgVectors[i]);
+        lpwstr[i]=strdupAW(lpServiceArgVectors[i]);
 
     r = StartServiceW(hService, dwNumServiceArgs, (LPCWSTR *)lpwstr);
 
@@ -2108,7 +2090,7 @@ BOOL WINAPI GetServiceKeyNameA( SC_HANDLE hSCManager, LPCSTR lpDisplayName,
     TRACE("%p %s %p %p\n", hSCManager,
           debugstr_a(lpDisplayName), lpServiceName, lpcchBuffer);
 
-    lpDisplayNameW = SERV_dup(lpDisplayName);
+    lpDisplayNameW = strdupAW(lpDisplayName);
     if (lpServiceName)
         lpServiceNameW = heap_alloc(*lpcchBuffer * sizeof(WCHAR));
     else
@@ -2231,7 +2213,7 @@ BOOL WINAPI GetServiceDisplayNameA( SC_HANDLE hSCManager, LPCSTR lpServiceName,
     TRACE("%p %s %p %p\n", hSCManager,
           debugstr_a(lpServiceName), lpDisplayName, lpcchBuffer);
 
-    lpServiceNameW = SERV_dup(lpServiceName);
+    lpServiceNameW = strdupAW(lpServiceName);
     if (lpDisplayName)
         lpDisplayNameW = heap_alloc(*lpcchBuffer * sizeof(WCHAR));
     else
@@ -2374,12 +2356,12 @@ BOOL WINAPI ChangeServiceConfigA( SC_HANDLE hService, DWORD dwServiceType,
           lpdwTagId, lpDependencies, debugstr_a(lpServiceStartName),
           debugstr_a(lpPassword), debugstr_a(lpDisplayName) );
 
-    wBinaryPathName = SERV_dup( lpBinaryPathName );
-    wLoadOrderGroup = SERV_dup( lpLoadOrderGroup );
+    wBinaryPathName = strdupAW( lpBinaryPathName );
+    wLoadOrderGroup = strdupAW( lpLoadOrderGroup );
     wDependencies = SERV_dupmulti( lpDependencies );
-    wServiceStartName = SERV_dup( lpServiceStartName );
-    wPassword = SERV_dup( lpPassword );
-    wDisplayName = SERV_dup( lpDisplayName );
+    wServiceStartName = strdupAW( lpServiceStartName );
+    wPassword = strdupAW( lpPassword );
+    wDisplayName = strdupAW( lpDisplayName );
 
     r = ChangeServiceConfigW( hService, dwServiceType,
             dwStartType, dwErrorControl, wBinaryPathName,
@@ -2411,7 +2393,7 @@ BOOL WINAPI ChangeServiceConfig2A( SC_HANDLE hService, DWORD dwInfoLevel,
         LPSERVICE_DESCRIPTIONA sd = lpInfo;
         SERVICE_DESCRIPTIONW sdw;
 
-        sdw.lpDescription = SERV_dup( sd->lpDescription );
+        sdw.lpDescription = strdupAW( sd->lpDescription );
 
         r = ChangeServiceConfig2W( hService, dwInfoLevel, &sdw );
 
@@ -2423,8 +2405,8 @@ BOOL WINAPI ChangeServiceConfig2A( SC_HANDLE hService, DWORD dwInfoLevel,
         SERVICE_FAILURE_ACTIONSW faw;
 
         faw.dwResetPeriod = fa->dwResetPeriod;
-        faw.lpRebootMsg = SERV_dup( fa->lpRebootMsg );
-        faw.lpCommand = SERV_dup( fa->lpCommand );
+        faw.lpRebootMsg = strdupAW( fa->lpRebootMsg );
+        faw.lpCommand = strdupAW( fa->lpCommand );
         faw.cActions = fa->cActions;
         faw.lpsaActions = fa->lpsaActions;
 
@@ -2589,7 +2571,7 @@ SERVICE_STATUS_HANDLE WINAPI RegisterServiceCtrlHandlerExA( LPCSTR name, LPHANDL
     LPWSTR nameW;
     SERVICE_STATUS_HANDLE ret;
 
-    nameW = SERV_dup(name);
+    nameW = strdupAW(name);
     ret = RegisterServiceCtrlHandlerExW( nameW, handler, context );
     heap_free( nameW );
     return ret;

From 113bb7dc9b661b2ed1701266122d0e56c98562b0 Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:16 -0600
Subject: [PATCH] sechost: Implement I_ScRegisterDeviceNotification()

Implement I_ScRegisterDeviceNotification and
I_ScUnregisterDeviceNotification in sechost via RPC to services.exe

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 dlls/sechost/sechost.spec |   2 +
 dlls/sechost/service.c    | 141 ++++++++++++++++++++++++++++++++++++++
 include/wine/svcctl.idl   |  13 ++++
 include/winsvc.h          |  14 ++++
 programs/services/rpc.c   | 124 ++++++++++++++++++++++++++++++++-
 5 files changed, 293 insertions(+), 1 deletion(-)

diff --git a/dlls/sechost/sechost.spec b/dlls/sechost/sechost.spec
index 985f638f8ff..1deb3406195 100644
--- a/dlls/sechost/sechost.spec
+++ b/dlls/sechost/sechost.spec
@@ -17,6 +17,8 @@
 @ stdcall GetServiceDisplayNameW(ptr wstr ptr ptr)
 @ stdcall GetServiceKeyNameA(long str ptr ptr)
 @ stdcall GetServiceKeyNameW(long wstr ptr ptr)
+@ stdcall I_ScRegisterDeviceNotification(ptr ptr long)
+@ stdcall I_ScUnregisterDeviceNotification(ptr)
 @ stdcall LockServiceDatabase(ptr)
 @ stdcall NotifyServiceStatusChangeW(ptr long ptr)
 @ stdcall OpenSCManagerA(str str long)
diff --git a/dlls/sechost/service.c b/dlls/sechost/service.c
index 71eda08605a..ac9d8684999 100644
--- a/dlls/sechost/service.c
+++ b/dlls/sechost/service.c
@@ -96,6 +96,14 @@ typedef struct notify_data_t {
 
 static struct list notify_list = LIST_INIT(notify_list);
 
+struct device_notify_registration {
+    DEVICE_NOTIFICATION_DETAILS details;
+    struct list entry;
+};
+
+static struct list device_notify_list = LIST_INIT(device_notify_list);
+HANDLE device_notify_thread = NULL;
+
 static CRITICAL_SECTION service_cs;
 static CRITICAL_SECTION_DEBUG service_cs_debug =
 {
@@ -2767,3 +2775,136 @@ DWORD WINAPI NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask,
 
     return ERROR_SUCCESS;
 }
+
+static DWORD WINAPI device_notification_thread(void *user)
+{
+    DWORD err;
+    struct device_notify_registration *registration;
+    SC_DEV_NOTIFY_RPC_HANDLE handle = NULL;
+    DWORD code;
+    DWORD buf_size;
+    BYTE *buf;
+
+    __TRY
+    {
+        err = svcctl_OpenDeviceNotificationHandle(NULL, &handle);
+    }
+    __EXCEPT(rpc_filter)
+    {
+        err = map_exception_code(GetExceptionCode());
+    }
+    __ENDTRY
+
+    if (!handle)
+    {
+        WARN("OpenDeviceNotificationHandle server call failed: %d\n", err);
+        return 1;
+    }
+
+    for (;;)
+    {
+        buf = NULL;
+        __TRY
+        {
+            /* GetDeviceNotificationResults blocks until there is an event */
+            err = svcctl_GetDeviceNotificationResults(handle, &code, &buf, &buf_size);
+        }
+        __EXCEPT(rpc_filter)
+        {
+            err = map_exception_code(GetExceptionCode());
+        }
+        __ENDTRY
+
+        if (err != ERROR_SUCCESS)
+        {
+            WARN("GetDeviceNotificationResults server call failed: %d\n", err);
+            if (buf)
+                MIDL_user_free(buf);
+            Sleep(100);
+            continue;
+        }
+
+        EnterCriticalSection(&service_cs);
+        LIST_FOR_EACH_ENTRY(registration, &device_notify_list, struct device_notify_registration, entry)
+        {
+            registration->details.pNotificationCallback(registration->details.hRecipient,
+                    code, (DEV_BROADCAST_HDR *) buf);
+        }
+        LeaveCriticalSection(&service_cs);
+        MIDL_user_free(buf);
+    }
+}
+
+/******************************************************************************
+ * I_ScRegisterDeviceNotification [SECHOST.@]
+ */
+HDEVNOTIFY WINAPI I_ScRegisterDeviceNotification(DEVICE_NOTIFICATION_DETAILS *details, LPVOID filter, DWORD flags)
+{
+    struct device_notify_registration *registration;
+
+    TRACE("(%p)\n", details->hRecipient);
+
+    /* This implementation is not overly concerned with sending too many
+     * messages, so support for filters is not yet implemented.
+     */
+    if (filter)
+        FIXME("Notification filters are not yet implemented! All device notification events will be sent.\n");
+
+    if (!details || !details->pNotificationCallback)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return NULL;
+    }
+
+    registration = heap_alloc(sizeof(struct device_notify_registration));
+    if (!registration)
+    {
+        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+        return NULL;
+    }
+
+    memcpy(&registration->details, details, sizeof(DEVICE_NOTIFICATION_DETAILS));
+
+    EnterCriticalSection(&service_cs);
+    list_add_tail(&device_notify_list, &registration->entry);
+
+    if (!device_notify_thread)
+        device_notify_thread = CreateThread(NULL, 0, &device_notification_thread, NULL, 0, NULL);
+
+    LeaveCriticalSection(&service_cs);
+
+    return (HDEVNOTIFY) registration;
+}
+
+/******************************************************************************
+ * I_ScUnregisterDeviceNotification [SECHOST.@]
+ */
+BOOL WINAPI I_ScUnregisterDeviceNotification(HDEVNOTIFY notificationHandle)
+{
+    struct device_notify_registration *item, *registration = NULL;
+
+    TRACE("(%p)\n", notificationHandle);
+
+    EnterCriticalSection(&service_cs);
+    LIST_FOR_EACH_ENTRY(item, &device_notify_list, struct device_notify_registration, entry)
+    {
+        if (item == notificationHandle)
+        {
+            registration = item;
+            break;
+        }
+    }
+
+    if (registration)
+        list_remove(&registration->entry);
+    LeaveCriticalSection(&service_cs);
+
+    if (!registration)
+    {
+        SetLastError(ERROR_INVALID_HANDLE);
+        return FALSE;
+    }
+
+    heap_free(registration);
+    return TRUE;
+}
diff --git a/include/wine/svcctl.idl b/include/wine/svcctl.idl
index c14cd6bb50c..0d75cf73c4c 100644
--- a/include/wine/svcctl.idl
+++ b/include/wine/svcctl.idl
@@ -62,6 +62,7 @@ interface svcctl
     typedef [context_handle] void *SC_RPC_HANDLE;
     typedef [context_handle] void *SC_RPC_LOCK;
     typedef [context_handle] void *SC_NOTIFY_RPC_HANDLE;
+    typedef [context_handle] void *SC_DEV_NOTIFY_RPC_HANDLE;
 
     /* undocumented access rights */
     cpp_quote("#define SERVICE_SET_STATUS   0x8000")
@@ -805,4 +806,16 @@ typedef [switch_type(DWORD)] union _SC_RPC_SERVICE_CONTROL_OUT_PARAMSW {
         [in] DWORD info_level,
         [out] SC_RPC_CONFIG_INFOW *info
     );
+
+    /* Not compatible with Windows function 57 */
+    DWORD svcctl_OpenDeviceNotificationHandle(
+        [in, string, unique] SVCCTL_HANDLEW machinename,
+        [out] SC_DEV_NOTIFY_RPC_HANDLE *handle);
+
+    /* Not compatible with Windows function 58 */
+    DWORD svcctl_GetDeviceNotificationResults(
+        [in] SC_DEV_NOTIFY_RPC_HANDLE handle,
+        [out] DWORD *event_code,
+        [out, size_is(,*event_size)] BYTE **event,
+        [out] DWORD *event_size);
 }
diff --git a/include/winsvc.h b/include/winsvc.h
index aa5e9f1ae88..d420535447a 100644
--- a/include/winsvc.h
+++ b/include/winsvc.h
@@ -376,6 +376,18 @@ typedef struct _QUERY_SERVICE_LOCK_STATUSW
 
 DECL_WINELIB_TYPE_AW(QUERY_SERVICE_LOCK_STATUS)
 
+#ifndef HDEVNOTIFY
+typedef  PVOID           HDEVNOTIFY;
+#endif
+#include "dbt.h"
+typedef DWORD (CALLBACK *REGISTER_DEVICE_NOTIFY_CALLBACK)(HANDLE hRecipient,
+    DWORD flags, DEV_BROADCAST_HDR *);
+typedef struct _DEVICE_NOTIFICATION_DETAILS
+{
+    REGISTER_DEVICE_NOTIFY_CALLBACK pNotificationCallback;
+    HANDLE hRecipient;
+} DEVICE_NOTIFICATION_DETAILS;
+
 /* Service control handler function prototype */
 
 typedef VOID (WINAPI *LPHANDLER_FUNCTION)(DWORD);
@@ -445,6 +457,8 @@ WINADVAPI BOOL        WINAPI StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENT
 WINADVAPI BOOL        WINAPI StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW*);
 #define                      StartServiceCtrlDispatcher WINELIB_NAME_AW(StartServiceCtrlDispatcher)
 WINADVAPI BOOL        WINAPI UnlockServiceDatabase(SC_LOCK);
+WINADVAPI HDEVNOTIFY  WINAPI I_ScRegisterDeviceNotification(DEVICE_NOTIFICATION_DETAILS *details, LPVOID filter, DWORD flags);
+WINADVAPI BOOL        WINAPI I_ScUnregisterDeviceNotification(HDEVNOTIFY notificationHandle);
 
 #ifdef __cplusplus
 } /* extern "C" */
diff --git a/programs/services/rpc.c b/programs/services/rpc.c
index 41501024dac..d48438cebd9 100644
--- a/programs/services/rpc.c
+++ b/programs/services/rpc.c
@@ -59,7 +59,8 @@ typedef enum
     SC_HTYPE_DONT_CARE = 0,
     SC_HTYPE_MANAGER,
     SC_HTYPE_SERVICE,
-    SC_HTYPE_NOTIFY
+    SC_HTYPE_NOTIFY,
+    SC_HTYPE_DEV_NOTIFY
 } SC_HANDLE_TYPE;
 
 struct sc_handle
@@ -83,6 +84,23 @@ struct sc_notify_handle
     SC_RPC_NOTIFY_PARAMS_LIST *params_list;
 };
 
+struct devnotify_event
+{
+    struct list entry;
+    DWORD code;
+    BYTE *data;
+    DWORD data_size;
+};
+
+struct sc_dev_notify_handle
+{
+    struct sc_handle hdr;
+    struct list entry;
+    HANDLE event;
+    CRITICAL_SECTION cs;
+    struct list event_list;
+};
+
 struct sc_service_handle       /* service handle */
 {
     struct sc_handle hdr;
@@ -117,6 +135,9 @@ static const WCHAR emptyW[] = {0};
 static PTP_CLEANUP_GROUP cleanup_group;
 HANDLE exit_event;
 
+static struct list devnotify_listeners = LIST_INIT(devnotify_listeners);
+CRITICAL_SECTION device_notifications_cs;
+
 static void CALLBACK group_cancel_callback(void *object, void *userdata)
 {
     struct process_entry *process = object;
@@ -264,6 +285,15 @@ static DWORD validate_notify_handle(SC_RPC_HANDLE handle, DWORD needed_access, s
     return err;
 }
 
+static DWORD validate_dev_notify_handle(SC_RPC_HANDLE handle, DWORD needed_access, struct sc_dev_notify_handle **notify)
+{
+    struct sc_handle *hdr;
+    DWORD err = validate_context_handle(handle, SC_HTYPE_DEV_NOTIFY, needed_access, &hdr);
+    if (err == ERROR_SUCCESS)
+        *notify = (struct sc_dev_notify_handle *)hdr;
+    return err;
+}
+
 DWORD __cdecl svcctl_OpenSCManagerW(
     MACHINE_HANDLEW MachineName, /* Note: this parameter is ignored */
     LPCWSTR DatabaseName,
@@ -323,6 +353,28 @@ static void SC_RPC_HANDLE_destroy(SC_RPC_HANDLE handle)
             HeapFree(GetProcessHeap(), 0, service);
             break;
         }
+        case SC_HTYPE_DEV_NOTIFY:
+        {
+            struct devnotify_event *event, *next;
+            struct sc_dev_notify_handle *listener = (struct sc_dev_notify_handle *)hdr;
+
+            /* Destroy this handle and stop sending events to this caller */
+            EnterCriticalSection(&device_notifications_cs);
+            WINE_TRACE("Removing device notification listener from list (%p)\n", listener);
+            list_remove(&listener->entry);
+            LeaveCriticalSection(&device_notifications_cs);
+
+            LIST_FOR_EACH_ENTRY_SAFE(event, next, &listener->event_list, struct devnotify_event, entry)
+            {
+                list_remove(&event->entry);
+                MIDL_user_free(event->data);
+                HeapFree(GetProcessHeap(), 0, event);
+            }
+
+            CloseHandle(listener->event);
+            HeapFree(GetProcessHeap(), 0, listener);
+            break;
+        }
         default:
             WINE_ERR("invalid handle type %d\n", hdr->type);
             RpcRaiseException(ERROR_INVALID_HANDLE);
@@ -2129,12 +2181,78 @@ DWORD __cdecl svcctl_QueryServiceConfig2A(
     return ERROR_CALL_NOT_IMPLEMENTED;
 }
 
+DWORD __cdecl svcctl_OpenDeviceNotificationHandle(
+    MACHINE_HANDLEW MachineName, /* Note: this parameter is ignored */
+    SC_DEV_NOTIFY_RPC_HANDLE *handle)
+{
+    struct sc_dev_notify_handle *listener;
+
+    if (!(listener = HeapAlloc(GetProcessHeap(), 0, sizeof(*listener))))
+        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
+
+    listener->hdr.type = SC_HTYPE_DEV_NOTIFY;
+    listener->hdr.access = 0;
+
+    InitializeCriticalSection(&listener->cs);
+    listener->event = CreateEventW(NULL, TRUE, FALSE, NULL);
+    list_init(&listener->event_list);
+
+    WINE_TRACE("Adding listener to list (%p)\n", listener);
+    EnterCriticalSection(&device_notifications_cs);
+    list_add_tail(&devnotify_listeners, &listener->entry);
+    LeaveCriticalSection(&device_notifications_cs);
+
+    *handle = &listener->hdr;
+    return ERROR_SUCCESS;
+}
+
+DWORD __cdecl svcctl_GetDeviceNotificationResults(
+    SC_DEV_NOTIFY_RPC_HANDLE handle,
+    LPDWORD code,
+    BYTE **event_dest,
+    LPDWORD event_dest_size)
+{
+    struct devnotify_event *event;
+    struct sc_dev_notify_handle *listener;
+    DWORD err;
+
+    if ((err = validate_dev_notify_handle(handle, 0, &listener)) != 0)
+        return err;
+
+    if (!event_dest || !event_dest_size || !code)
+        return ERROR_INVALID_PARAMETER;
+
+    do
+    {
+        /* block until there is a result */
+        WaitForSingleObject(listener->event, INFINITE);
+
+        EnterCriticalSection(&listener->cs);
+        if ((event = LIST_ENTRY(list_head(&listener->event_list), struct devnotify_event, entry)))
+            list_remove(&event->entry);
+        else
+            ResetEvent(listener->event);
+        LeaveCriticalSection(&listener->cs);
+    } while (!event);
+
+    WINE_TRACE("Got an event (%p)\n", event);
+    *code = event->code;
+
+    *event_dest = event->data;
+    *event_dest_size = event->data_size;
+
+    HeapFree(GetProcessHeap(), 0, event);
+    return ERROR_SUCCESS;
+}
+
 DWORD RPC_Init(void)
 {
     WCHAR transport[] = SVCCTL_TRANSPORT;
     WCHAR endpoint[] = SVCCTL_ENDPOINT;
     DWORD err;
 
+    InitializeCriticalSection(&device_notifications_cs);
+
     if (!(cleanup_group = CreateThreadpoolCleanupGroup()))
     {
         WINE_ERR("CreateThreadpoolCleanupGroup failed with error %u\n", GetLastError());
@@ -2183,6 +2301,10 @@ void __RPC_USER SC_NOTIFY_RPC_HANDLE_rundown(SC_NOTIFY_RPC_HANDLE handle)
 {
 }
 
+void __RPC_USER SC_DEV_NOTIFY_RPC_HANDLE_rundown(SC_DEV_NOTIFY_RPC_HANDLE handle)
+{
+}
+
 void  __RPC_FAR * __RPC_USER MIDL_user_allocate(SIZE_T len)
 {
     return HeapAlloc(GetProcessHeap(), 0, len);

From ffad3279fca6ed9ab199a0ed735c715b77a4fe46 Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:17 -0600
Subject: [PATCH] ntoskrnl.exe: Implement sending of device notifications

Send device notifications via RPC to services.exe

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 dlls/ntoskrnl.exe/Makefile.in        |   4 +-
 dlls/ntoskrnl.exe/ntoskrnl_private.h |   5 +
 dlls/ntoskrnl.exe/pnp.c              |   1 +
 dlls/ntoskrnl.exe/rpc.c              | 182 +++++++++++++++++++++++++++
 dlls/ntoskrnl.exe/svcctl.idl         |   3 +
 include/wine/svcctl.idl              |   7 ++
 programs/services/rpc.c              |  45 +++++++
 7 files changed, 246 insertions(+), 1 deletion(-)
 create mode 100644 dlls/ntoskrnl.exe/rpc.c
 create mode 100644 dlls/ntoskrnl.exe/svcctl.idl

diff --git a/dlls/ntoskrnl.exe/Makefile.in b/dlls/ntoskrnl.exe/Makefile.in
index a75ca9768d9..441238177a2 100644
--- a/dlls/ntoskrnl.exe/Makefile.in
+++ b/dlls/ntoskrnl.exe/Makefile.in
@@ -1,7 +1,7 @@
 MODULE    = ntoskrnl.exe
 IMPORTLIB = ntoskrnl
 IMPORTS   = advapi32 hal
-DELAYIMPORTS = setupapi user32
+DELAYIMPORTS = setupapi user32 rpcrt4
 
 EXTRADLLFLAGS = -mno-cygwin
 
@@ -9,6 +9,8 @@ C_SRCS = \
 	instr.c \
 	ntoskrnl.c \
 	pnp.c \
+	rpc.c \
 	sync.c
+IDL_SRCS  = svcctl.idl
 
 RC_SRCS = ntoskrnl.rc
diff --git a/dlls/ntoskrnl.exe/ntoskrnl_private.h b/dlls/ntoskrnl.exe/ntoskrnl_private.h
index 2823a1cd4f1..69e5f60e7c6 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl_private.h
+++ b/dlls/ntoskrnl.exe/ntoskrnl_private.h
@@ -22,6 +22,8 @@
 #define __WINE_NTOSKRNL_PRIVATE_H
 
 #include "wine/asm.h"
+#include "winuser.h"
+#include "dbt.h"
 
 static inline LPCSTR debugstr_us( const UNICODE_STRING *us )
 {
@@ -82,6 +82,8 @@ static const WCHAR servicesW[] = {'\\','R','e','g','i','s','t','r','y',
                                   '\\','C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t',
                                   '\\','S','e','r','v','i','c','e','s',
                                   '\\',0};
+
+DWORD send_device_notification( DEV_BROADCAST_DEVICEINTERFACE_W *broadcast, BOOL enable );
 
 struct wine_device
 {
     DEVICE_OBJECT device_obj;
diff --git a/dlls/ntoskrnl.exe/pnp.c b/dlls/ntoskrnl.exe/pnp.c
index 9725b5a6e16..f874fc9b3b8 100644
--- a/dlls/ntoskrnl.exe/pnp.c
+++ b/dlls/ntoskrnl.exe/pnp.c
@@ -672,6 +672,7 @@ NTSTATUS WINAPI IoSetDeviceInterfaceState( UNICODE_STRING *name, BOOLEAN enable
         lstrcpynW( broadcast->dbcc_name, name->Buffer, namelen + 1 );
         BroadcastSystemMessageW( BSF_FORCEIFHUNG | BSF_QUERY, NULL, WM_DEVICECHANGE,
             enable ? DBT_DEVICEARRIVAL : DBT_DEVICEREMOVECOMPLETE, (LPARAM)broadcast );
+        send_device_notification( broadcast, enable );
 
         heap_free( broadcast );
     }
diff --git a/dlls/ntoskrnl.exe/rpc.c b/dlls/ntoskrnl.exe/rpc.c
new file mode 100644
index 00000000000..a4779a168a4
--- /dev/null
+++ b/dlls/ntoskrnl.exe/rpc.c
@@ -0,0 +1,182 @@
+/*
+ * RPC connection with services.exe
+ *
+ * Copyright 1995 Sven Verdoolaege
+ * Copyright 2005 Mike McCormack
+ * Copyright 2007 Rolf Kalbermatter
+ * Copyright 2019 Micah N Gorrell for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winreg.h"
+#include "winsvc.h"
+#include "winternl.h"
+#include "dbt.h"
+#include "svcctl.h"
+#include "wine/exception.h"
+#include "ddk/ntifs.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+#include "wine/rbtree.h"
+
+#include "ntoskrnl_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(plugplay);
+
+/******************************************************************************
+ * RPC connection with services.exe
+ */
+void __RPC_FAR * __RPC_USER MIDL_user_allocate(SIZE_T len)
+{
+    return heap_alloc(len);
+}
+
+void __RPC_USER MIDL_user_free(void __RPC_FAR * ptr)
+{
+    heap_free(ptr);
+}
+
+static handle_t rpc_wstr_bind(RPC_WSTR str)
+{
+    WCHAR transport[] = SVCCTL_TRANSPORT;
+    WCHAR endpoint[] = SVCCTL_ENDPOINT;
+    RPC_WSTR binding_str;
+    RPC_STATUS status;
+    handle_t rpc_handle;
+
+    status = RpcStringBindingComposeW(NULL, transport, str, endpoint, NULL, &binding_str);
+    if (status != RPC_S_OK)
+    {
+        ERR("RpcStringBindingComposeW failed (%d)\n", (DWORD)status);
+        return NULL;
+    }
+
+    status = RpcBindingFromStringBindingW(binding_str, &rpc_handle);
+    RpcStringFreeW(&binding_str);
+
+    if (status != RPC_S_OK)
+    {
+        ERR("Couldn't connect to services.exe: error code %u\n", (DWORD)status);
+        return NULL;
+    }
+
+    return rpc_handle;
+}
+
+static handle_t rpc_cstr_bind(RPC_CSTR str)
+{
+    RPC_CSTR transport = (RPC_CSTR)SVCCTL_TRANSPORTA;
+    RPC_CSTR endpoint = (RPC_CSTR)SVCCTL_ENDPOINTA;
+    RPC_CSTR binding_str;
+    RPC_STATUS status;
+    handle_t rpc_handle;
+
+    status = RpcStringBindingComposeA(NULL, transport, str, endpoint, NULL, &binding_str);
+    if (status != RPC_S_OK)
+    {
+        ERR("RpcStringBindingComposeW failed (%d)\n", (DWORD)status);
+        return NULL;
+    }
+
+    status = RpcBindingFromStringBindingA(binding_str, &rpc_handle);
+    RpcStringFreeA(&binding_str);
+
+    if (status != RPC_S_OK)
+    {
+        ERR("Couldn't connect to services.exe: error code %u\n", (DWORD)status);
+        return NULL;
+    }
+
+    return rpc_handle;
+}
+
+DECLSPEC_HIDDEN handle_t __RPC_USER MACHINE_HANDLEA_bind(MACHINE_HANDLEA MachineName)
+{
+    return rpc_cstr_bind((RPC_CSTR)MachineName);
+}
+
+DECLSPEC_HIDDEN void __RPC_USER MACHINE_HANDLEA_unbind(MACHINE_HANDLEA MachineName, handle_t h)
+{
+    RpcBindingFree(&h);
+}
+
+DECLSPEC_HIDDEN handle_t __RPC_USER MACHINE_HANDLEW_bind(MACHINE_HANDLEW MachineName)
+{
+    return rpc_wstr_bind((RPC_WSTR)MachineName);
+}
+
+DECLSPEC_HIDDEN void __RPC_USER MACHINE_HANDLEW_unbind(MACHINE_HANDLEW MachineName, handle_t h)
+{
+    RpcBindingFree(&h);
+}
+
+DECLSPEC_HIDDEN handle_t __RPC_USER SVCCTL_HANDLEW_bind(SVCCTL_HANDLEW MachineName)
+{
+    return rpc_wstr_bind((RPC_WSTR)MachineName);
+}
+
+DECLSPEC_HIDDEN void __RPC_USER SVCCTL_HANDLEW_unbind(SVCCTL_HANDLEW MachineName, handle_t h)
+{
+    RpcBindingFree(&h);
+}
+
+static LONG WINAPI rpc_filter(EXCEPTION_POINTERS *eptr)
+{
+    return I_RpcExceptionFilter(eptr->ExceptionRecord->ExceptionCode);
+}
+
+static DWORD map_exception_code(DWORD exception_code)
+{
+    switch (exception_code)
+    {
+    case RPC_X_NULL_REF_POINTER:
+        return ERROR_INVALID_ADDRESS;
+    case RPC_X_ENUM_VALUE_OUT_OF_RANGE:
+    case RPC_X_BYTE_COUNT_TOO_SMALL:
+        return ERROR_INVALID_PARAMETER;
+    case RPC_S_INVALID_BINDING:
+    case RPC_X_SS_IN_NULL_CONTEXT:
+        return ERROR_INVALID_HANDLE;
+    default:
+        return exception_code;
+    }
+}
+
+DWORD send_device_notification(DEV_BROADCAST_DEVICEINTERFACE_W *broadcast, BOOL enable)
+{
+    DWORD err;
+
+    __TRY
+    {
+        err = svcctl_SendDeviceNotification(NULL,
+                    enable ? DBT_DEVICEARRIVAL : DBT_DEVICEREMOVECOMPLETE,
+                    (const BYTE *) broadcast, broadcast->dbcc_size);
+    }
+    __EXCEPT(rpc_filter)
+    {
+        err = map_exception_code(GetExceptionCode());
+    }
+    __ENDTRY
+
+    TRACE("send result (%d)\n", err);
+    return err;
+}
diff --git a/dlls/ntoskrnl.exe/svcctl.idl b/dlls/ntoskrnl.exe/svcctl.idl
new file mode 100644
index 00000000000..b1bc8545d78
--- /dev/null
+++ b/dlls/ntoskrnl.exe/svcctl.idl
@@ -0,0 +1,3 @@
+#pragma makedep client
+
+#include "wine/svcctl.idl"
diff --git a/include/wine/svcctl.idl b/include/wine/svcctl.idl
index 0d75cf73c4c..2399f3f5fd6 100644
--- a/include/wine/svcctl.idl
+++ b/include/wine/svcctl.idl
@@ -818,4 +818,11 @@ typedef [switch_type(DWORD)] union _SC_RPC_SERVICE_CONTROL_OUT_PARAMSW {
         [out] DWORD *event_code,
         [out, size_is(,*event_size)] BYTE **event,
         [out] DWORD *event_size);
+
+    /* Not compatible with Windows function 59 */
+    DWORD svcctl_SendDeviceNotification(
+        [in, string, unique] SVCCTL_HANDLEW machinename,
+        [in] DWORD event_code,
+        [in, size_is(event_size)] const BYTE *event,
+        [in] DWORD event_size);
 }
diff --git a/programs/services/rpc.c b/programs/services/rpc.c
index d48438cebd9..a9a12a0565c 100644
--- a/programs/services/rpc.c
+++ b/programs/services/rpc.c
@@ -2245,6 +2245,51 @@ DWORD __cdecl svcctl_GetDeviceNotificationResults(
     return ERROR_SUCCESS;
 }
 
+DWORD __cdecl svcctl_SendDeviceNotification(
+    MACHINE_HANDLEW MachineName, /* Note: this parameter is ignored */
+    DWORD code,
+    const BYTE *event_buf,
+    DWORD event_buf_size)
+{
+    struct sc_dev_notify_handle *listener;
+    struct devnotify_event *event;
+
+    if (!event_buf)
+        return ERROR_INVALID_PARAMETER;
+
+    EnterCriticalSection(&device_notifications_cs);
+    LIST_FOR_EACH_ENTRY(listener, &devnotify_listeners, struct sc_dev_notify_handle, entry)
+    {
+        WINE_TRACE("Triggering listener %p\n", listener);
+
+        event = HeapAlloc(GetProcessHeap(), 0, sizeof(struct devnotify_event));
+        if (event)
+            event->data = MIDL_user_allocate(event_buf_size);
+
+        if (!event || !event->data)
+        {
+            HeapFree(GetProcessHeap(), 0, event);
+
+            LeaveCriticalSection(&device_notifications_cs);
+            return ERROR_NOT_ENOUGH_SERVER_MEMORY;
+        }
+
+        event->code = code;
+        memcpy(event->data, event_buf, event_buf_size);
+        event->data_size = event_buf_size;
+
+        EnterCriticalSection(&listener->cs);
+        list_add_tail(&listener->event_list, &event->entry);
+        LeaveCriticalSection(&listener->cs);
+
+        SetEvent(listener->event);
+    }
+    WINE_TRACE("Done triggering registrations\n");
+    LeaveCriticalSection(&device_notifications_cs);
+
+    return ERROR_SUCCESS;
+}
+
 DWORD RPC_Init(void)
 {
     WCHAR transport[] = SVCCTL_TRANSPORT;

From 0d3322b962c33f4fe603ba82af4f8cd2a7f23727 Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:18 -0600
Subject: [PATCH] user32: Implement RegisterDeviceNotification()

Implement RegisterDeviceNotification() and UnregisterDeviceNotification()
using I_ScRegisterDeviceNotification() and
I_ScUnregisterDeviceNotification() in sechost.dll

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 dlls/user32/Makefile.in |  2 +-
 dlls/user32/misc.c      | 73 +++++++++++++++++++++++++++++++++++------
 include/winuser.h       |  4 ++-
 3 files changed, 67 insertions(+), 12 deletions(-)

diff --git a/dlls/user32/Makefile.in b/dlls/user32/Makefile.in
index d420dcb45aa..bd3660331eb 100644
--- a/dlls/user32/Makefile.in
+++ b/dlls/user32/Makefile.in
@@ -1,7 +1,7 @@
 EXTRADEFS = -D_USER32_ -D_WINABLE_
 MODULE    = user32.dll
 IMPORTLIB = user32
-IMPORTS   = gdi32 version advapi32
+IMPORTS   = gdi32 version advapi32 sechost
 EXTRAINCL = $(PNG_CFLAGS)
 DELAYIMPORTS = hid imm32 setupapi usp10
 
diff --git a/dlls/user32/misc.c b/dlls/user32/misc.c
index 60d45dff471..8042c044059 100644
--- a/dlls/user32/misc.c
+++ b/dlls/user32/misc.c
@@ -4,6 +4,7 @@
  * Copyright 1995 Thomas Sandford
  * Copyright 1997 Marcus Meissner
  * Copyright 1998 Turchanov Sergey
+ * Copyright 2019 Micah N Gorrell for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -37,6 +38,7 @@
 #include "devguid.h"
 #include "setupapi.h"
 #include "user_private.h"
+#include "winsvc.h"
 
 #include "wine/unicode.h"
 #include "wine/debug.h"
@@ -602,17 +604,39 @@ DWORD WINAPI RegisterTasklist (DWORD x)
     return TRUE;
 }
 
+static DWORD CALLBACK devnotify_window_callback(HANDLE hRecipient, DWORD flags, DEV_BROADCAST_HDR *dbh)
+{
+    SendMessageTimeoutW(hRecipient, WM_DEVICECHANGE, flags,
+        (LPARAM) dbh, SMTO_ABORTIFHUNG, 2000, NULL);
+    return 0;
+}
+
+static DWORD CALLBACK devnotify_service_callback(HANDLE hRecipient, DWORD flags, DEV_BROADCAST_HDR *dbh)
+{
+    FIXME("Support for service handles is not yet implemented!\n");
+    ControlService(hRecipient, SERVICE_CONTROL_DEVICEEVENT, NULL);
+    return 0;
+}
+
+static DWORD CALLBACK devnotify_null_callback(HANDLE hRecipient, DWORD flags, DEV_BROADCAST_HDR *dbh)
+{
+    /* The WM_DEVICECHANGE event is broadcast directly from ntoskrnl.exe so
+     * nothing needs to be done here. */
+    return 0;
+}
 
 /***********************************************************************
  *		RegisterDeviceNotificationA (USER32.@)
  *
  * See RegisterDeviceNotificationW.
  */
-HDEVNOTIFY WINAPI RegisterDeviceNotificationA(HANDLE hnd, LPVOID notifyfilter, DWORD flags)
+HDEVNOTIFY WINAPI RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID pNotificationFilter, DWORD dwFlags)
 {
-    FIXME("(hwnd=%p, filter=%p,flags=0x%08x) returns a fake device notification handle!\n",
-          hnd,notifyfilter,flags );
-    return (HDEVNOTIFY) 0xcafecafe;
+    TRACE("(hwnd=%p, filter=%p,flags=0x%08x)\n",
+        hRecipient,pNotificationFilter,dwFlags);
+    if (pNotificationFilter)
+        FIXME("The notification filter will requires an A->W when filter support is implemented\n");
+    return RegisterDeviceNotificationW(hRecipient, pNotificationFilter, dwFlags);
 }
 
 /***********************************************************************
@@ -640,19 +664,48 @@ HDEVNOTIFY WINAPI RegisterDeviceNotificationA(HANDLE hnd, LPVOID notifyfilter, D
  */
 HDEVNOTIFY WINAPI RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID pNotificationFilter, DWORD dwFlags)
 {
-    FIXME("(hwnd=%p, filter=%p,flags=0x%08x) returns a fake device notification handle!\n",
-          hRecipient,pNotificationFilter,dwFlags );
-    return (HDEVNOTIFY) 0xcafeaffe;
+    DEVICE_NOTIFICATION_DETAILS details;
+
+    TRACE("(hwnd=%p, filter=%p,flags=0x%08x)\n",
+        hRecipient,pNotificationFilter,dwFlags);
+
+    if (dwFlags & DEVICE_NOTIFY_ALL_INTERFACE_CLASSES)
+    {
+        dwFlags &= ~DEVICE_NOTIFY_ALL_INTERFACE_CLASSES;
+        pNotificationFilter = NULL;
+    }
+
+    details.hRecipient = hRecipient;
+
+    switch (dwFlags) {
+    case DEVICE_NOTIFY_WINDOW_HANDLE:
+        details.pNotificationCallback = devnotify_window_callback;
+        break;
+
+    case DEVICE_NOTIFY_SERVICE_HANDLE:
+        details.pNotificationCallback = devnotify_service_callback;
+        break;
+
+    default:
+        SetLastError(ERROR_INVALID_FLAGS);
+        return 0;
+    }
+
+    if (!hRecipient)
+        details.pNotificationCallback = devnotify_null_callback;
+
+    return I_ScRegisterDeviceNotification(&details, pNotificationFilter, 0);
 }
 
 /***********************************************************************
  *		UnregisterDeviceNotification (USER32.@)
  *
  */
-BOOL  WINAPI UnregisterDeviceNotification(HDEVNOTIFY hnd)
+BOOL WINAPI UnregisterDeviceNotification(HDEVNOTIFY hnd)
 {
-    FIXME("(handle=%p), STUB!\n", hnd);
-    return TRUE;
+    TRACE("(hnd=%p)\n", hnd);
+
+    return I_ScUnregisterDeviceNotification(hnd);
 }
 
 /***********************************************************************
diff --git a/include/winuser.h b/include/winuser.h
index 60bc473225b..165f835b7df 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -3088,7 +3088,9 @@ typedef struct tagTRACKMOUSEEVENT {
 typedef  PVOID           HDEVNOTIFY;
 typedef  HDEVNOTIFY     *PHDEVNOTIFY;
 
-#define DEVICE_NOTIFY_WINDOW_HANDLE     0x00000000
+#define DEVICE_NOTIFY_WINDOW_HANDLE         0x00000000
+#define DEVICE_NOTIFY_SERVICE_HANDLE        0x00000001
+#define DEVICE_NOTIFY_ALL_INTERFACE_CLASSES 0x00000004
 
 /* used for GetWindowInfo() */
 

From 5211a69e640010b6c151ef9b3a004af20ff9da74 Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:19 -0600
Subject: [PATCH] user32/tests: Add test for RegisterDeviceNotification()

Add test for API usage of RegisterDeviceNotification() and
UnregisterDeviceNotification(). Unfortunately an automated way of
triggering the actual notifications has not been found, so this test is
not complete.

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 dlls/user32/tests/input.c | 70 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 69 insertions(+), 1 deletion(-)

diff --git a/dlls/user32/tests/input.c b/dlls/user32/tests/input.c
index 4a9be550bdc..6eaf812e8d8 100644
--- a/dlls/user32/tests/input.c
+++ b/dlls/user32/tests/input.c
@@ -54,6 +54,9 @@
 #include "winbase.h"
 #include "winuser.h"
 #include "winnls.h"
+#include "dbt.h"
+#include "initguid.h"
+#include "ddk/hidclass.h"
 
 #include "wine/test.h"
 
@@ -2827,10 +2830,73 @@ static void test_GetPointerType(void)
     ok(type == PT_MOUSE, " type %d\n", type );
 }
 
+static void test_RegisterDeviceNotification(void)
+{
+    static const WCHAR mainwindowclassW[] = {'M','a','i','n','W','i','n','d','o','w','C','l','a','s','s',0};
+    static const WCHAR message_windowW[] = {'m','e','s','s','a','g','e',' ','w','i','n','d','o','w',0};
+
+    HDEVNOTIFY hnotify1, hnotify2;
+    DEV_BROADCAST_DEVICEINTERFACE_W dbh;
+    HWND hwnd;
+    WNDCLASSEXW cls;
+    BOOL ret;
+
+    memset(&cls, 0, sizeof(cls));
+    cls.cbSize = sizeof(cls);
+    cls.hInstance = 0;
+    cls.lpszClassName = mainwindowclassW;
+    cls.lpfnWndProc = DefWindowProcW;
+
+    RegisterClassExW(&cls);
+
+    hwnd = CreateWindowExW(0, mainwindowclassW, message_windowW, 0,
+                           0, 0, 0, 0, HWND_MESSAGE, 0, 0, NULL);
+    ok(hwnd != 0, "CreateWindowExW with parent HWND_MESSAGE failed\n");
+
+    memset(&dbh, 0, sizeof(dbh));
+
+    dbh.dbcc_size = sizeof(dbh);
+    dbh.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
+    dbh.dbcc_classguid = GUID_DEVINTERFACE_HID;
+
+    /* Test RegisterDeviceNotification behavior */
+
+    /* Prior to Windows 8 a NULL recipient handle caused a failure, but more
+     * recent versions of windows allow it.
+     */
+    hnotify1 = RegisterDeviceNotificationW(NULL, &dbh, DEVICE_NOTIFY_WINDOW_HANDLE);
+    /* ok(hnotify1 != 0, "RegisterDeviceNotificationW failed when called with a NULL recipient window handle\n"); */
+    if (hnotify1 != 0)
+    {
+        ret = UnregisterDeviceNotification(hnotify1);
+        ok(ret, "UnregisterDeviceNotification failed with a valid handle\n");
+    }
+
+    hnotify1 = RegisterDeviceNotificationW(hwnd, &dbh, DEVICE_NOTIFY_WINDOW_HANDLE);
+    ok(hnotify1 != 0, "RegisterDeviceNotificationW failed when called with a message only window as recipient\n");
+
+    hnotify2 = RegisterDeviceNotificationW(hwnd, &dbh, DEVICE_NOTIFY_WINDOW_HANDLE);
+    ok(hnotify2 != 0, "RegisterDeviceNotificationW failed when called with a window that has already been registered as a recipient\n");
+
+    ret = UnregisterDeviceNotification(hnotify1);
+    ok(ret, "UnregisterDeviceNotification failed with a valid handle\n");
+    ret = UnregisterDeviceNotification(hnotify2);
+    ok(ret, "UnregisterDeviceNotification failed with a valid handle\n");
+    ret = UnregisterDeviceNotification(hnotify1);
+    ok(!ret, "UnregisterDeviceNotification succeeded with an already released handle\n");
+    ret = UnregisterDeviceNotification(NULL);
+    ok(!ret, "UnregisterDeviceNotification succeeded with NULL handle\n");
+
+    hnotify1 = RegisterDeviceNotificationW(hwnd, &dbh, 0xffff);
+    ok(hnotify1 == 0, "RegisterDeviceNotificationW accepted invalid flags\n");
+
+    /* FIXME: Find a way to trigger a device notification for testing */
+    DestroyWindow(hwnd);
+}
+
 START_TEST(input)
 {
     POINT pos;
-
     init_function_pointers();
     GetCursorPos( &pos );
 
@@ -2877,4 +2943,6 @@ START_TEST(input)
         test_GetPointerType();
     else
         win_skip("GetPointerType is not available\n");
+
+    test_RegisterDeviceNotification();
 }

From 0e73cb52ebe360bbe7810f8b627ce7328e498a6a Mon Sep 17 00:00:00 2001
From: Micah N Gorrell <mgorrell@codeweavers.com>
Date: Thu, 12 Sep 2019 12:03:20 -0600
Subject: [PATCH] sechost/tests: Add test for I_ScRegisterDeviceNotification()

Signed-off-by: Micah N Gorrell <mgorrell@codeweavers.com>
---
 configure                      |   1 +
 configure.ac                   |   1 +
 dlls/sechost/tests/Makefile.in |   5 ++
 dlls/sechost/tests/devnotify.c | 102 +++++++++++++++++++++++++++++++++
 4 files changed, 109 insertions(+)
 create mode 100644 dlls/sechost/tests/Makefile.in
 create mode 100644 dlls/sechost/tests/devnotify.c

diff --git a/configure b/configure
index 31ad9f73349..5cfba68cac7 100755
--- a/configure
+++ b/configure
@@ -20703,6 +20703,7 @@ wine_fn_config_makefile dlls/scrrun enable_scrrun
 wine_fn_config_makefile dlls/scrrun/tests enable_tests
 wine_fn_config_makefile dlls/scsiport.sys enable_scsiport_sys
 wine_fn_config_makefile dlls/sechost enable_sechost
+wine_fn_config_makefile dlls/sechost/tests enable_tests
 wine_fn_config_makefile dlls/secur32 enable_secur32
 wine_fn_config_makefile dlls/secur32/tests enable_tests
 wine_fn_config_makefile dlls/security enable_security
diff --git a/configure.ac b/configure.ac
index 9844cae70d7..4a0b6e49c21 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3623,6 +3623,7 @@ WINE_CONFIG_MAKEFILE(dlls/scrrun)
 WINE_CONFIG_MAKEFILE(dlls/scrrun/tests)
 WINE_CONFIG_MAKEFILE(dlls/scsiport.sys)
 WINE_CONFIG_MAKEFILE(dlls/sechost)
+WINE_CONFIG_MAKEFILE(dlls/sechost/tests)
 WINE_CONFIG_MAKEFILE(dlls/secur32)
 WINE_CONFIG_MAKEFILE(dlls/secur32/tests)
 WINE_CONFIG_MAKEFILE(dlls/security)
diff --git a/dlls/sechost/tests/Makefile.in b/dlls/sechost/tests/Makefile.in
new file mode 100644
index 00000000000..603bc77bb0a
--- /dev/null
+++ b/dlls/sechost/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL   = sechost.dll
+IMPORTS   = sechost
+
+C_SRCS = \
+	devnotify.c
diff --git a/dlls/sechost/tests/devnotify.c b/dlls/sechost/tests/devnotify.c
new file mode 100644
index 00000000000..7231f86b722
--- /dev/null
+++ b/dlls/sechost/tests/devnotify.c
@@ -0,0 +1,102 @@
+/* Test device notification registration via sechost
+ *
+ * Copyright 2019 Micah N Gorrell for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <assert.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "winnls.h"
+#include "dbt.h"
+#include "initguid.h"
+#include "ddk/hidclass.h"
+
+#include "wine/test.h"
+
+typedef DWORD (CALLBACK *REGISTER_DEVICE_NOTIFY_CALLBACK)(HANDLE hRecipient, DWORD flags,
+    DEV_BROADCAST_HDR *);
+
+typedef struct
+{
+    REGISTER_DEVICE_NOTIFY_CALLBACK pNotificationCallback;
+    HWND                            hRecipient;
+} REGISTER_DEVICE_NOTIFY;
+
+static HDEVNOTIFY (WINAPI * pI_ScRegisterDeviceNotification)(REGISTER_DEVICE_NOTIFY *data, LPVOID filter, DWORD flags);
+static DWORD (WINAPI * pI_ScUnregisterDeviceNotification)(HDEVNOTIFY notify);
+
+static void init_function_pointers(void)
+{
+    HMODULE hdll = LoadLibraryA("sechost.dll");
+
+#define GET_PROC(func) \
+    if (!(p ## func = (void*)GetProcAddress(hdll, #func))) \
+      trace("GetProcAddress(%s) failed\n", #func)
+
+    GET_PROC(I_ScRegisterDeviceNotification);
+    GET_PROC(I_ScUnregisterDeviceNotification);
+#undef GET_PROC
+}
+
+static DWORD CALLBACK change_callback(HANDLE hRecipient, DWORD flags, DEV_BROADCAST_HDR *dbh)
+{
+    return 0;
+}
+
+static void test_RegisterDeviceNotification(void)
+{
+    HDEVNOTIFY hnotify;
+    REGISTER_DEVICE_NOTIFY data;
+    DEV_BROADCAST_DEVICEINTERFACE_W dbh;
+    BOOL ret;
+
+    memset(&dbh, 0, sizeof(dbh));
+
+    dbh.dbcc_size = sizeof(dbh);
+    dbh.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
+    dbh.dbcc_classguid = GUID_DEVINTERFACE_HID;
+
+    data.pNotificationCallback = change_callback;
+    data.hRecipient = NULL;
+
+    /* Test I_ScRegisterDeviceNotification behavior */
+    /* FIXME: Behavior of other flags hasn't yet been learned */
+    hnotify = pI_ScRegisterDeviceNotification(&data, &dbh, 2);
+    ok(hnotify != 0, "I_ScRegisterDeviceNotification failed\n");
+
+    ret = pI_ScUnregisterDeviceNotification(hnotify);
+    ok(ret, "I_ScUnregisterDeviceNotification failed with a valid handle\n");
+    ret = pI_ScUnregisterDeviceNotification(hnotify);
+    ok(!ret, "I_ScUnregisterDeviceNotification succeeded with an already released handle\n");
+    ret = pI_ScUnregisterDeviceNotification(NULL);
+    ok(!ret, "I_ScUnregisterDeviceNotification succeeded with a NULL handle\n");
+
+    /* FIXME: Find a way to trigger a device notification for testing */
+}
+
+START_TEST(devnotify)
+{
+    init_function_pointers();
+
+    if (pI_ScRegisterDeviceNotification && pI_ScUnregisterDeviceNotification)
+        test_RegisterDeviceNotification();
+    else
+        win_skip("I_ScRegisterDeviceNotification is not available\n");
+}
