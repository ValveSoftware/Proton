From 5b72eb081757521ee2f86aad97c36ed751733b1d Mon Sep 17 00:00:00 2001
From: Derek Lesho <dereklesho52@Gmail.com>
Date: Tue, 25 Jun 2019 16:23:02 -0400
Subject: [PATCH 01/11] user32: Add support for RIDEV_NOLEGACY flag.

Signed-off-by: Derek Lesho <dereklesho52@Gmail.com>
---
 dlls/user32/rawinput.c | 2 +-
 server/queue.c         | 9 +++++++++
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index 49cf9f73a0d..58480b8ae7e 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -271,7 +271,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH RegisterRawInputDevices(RAWINPUTDEVICE *devices, U
         TRACE("device %u: page %#x, usage %#x, flags %#x, target %p.\n",
                 i, devices[i].usUsagePage, devices[i].usUsage,
                 devices[i].dwFlags, devices[i].hwndTarget);
-        if (devices[i].dwFlags & ~RIDEV_REMOVE)
+        if (devices[i].dwFlags & ~(RIDEV_REMOVE|RIDEV_NOLEGACY))
             FIXME("Unhandled flags %#x for device %u.\n", devices[i].dwFlags, i);
 
         d[i].usage_page = devices[i].usUsagePage;
diff --git a/server/queue.c b/server/queue.c
index 96587d11d1e..40a566a2b73 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -372,6 +372,9 @@ static void set_cursor_pos( struct desktop *desktop, int x, int y )
     static const struct hw_msg_source source = { IMDT_UNAVAILABLE, IMO_SYSTEM };
     struct message *msg;
 
+    if (current->process->rawinput_mouse &&
+        current->process->rawinput_mouse->flags & RIDEV_NOLEGACY) return;
+
     if (!(msg = alloc_hardware_message( 0, source, get_tick_count() ))) return;
 
     msg->msg = WM_MOUSEMOVE;
@@ -1670,6 +1673,9 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         queue_hardware_message( desktop, msg, 0 );
     }
 
+    if (device && device->flags & RIDEV_NOLEGACY)
+        return FALSE;
+
     for (i = 0; i < ARRAY_SIZE( messages ); i++)
     {
         if (!messages[i]) continue;
@@ -1795,6 +1801,9 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         queue_hardware_message( desktop, msg, 0 );
     }
 
+    if (device && device->flags & RIDEV_NOLEGACY)
+        return FALSE;
+
     if (!(msg = alloc_hardware_message( input->kbd.info, source, time ))) return 0;
     msg_data = msg->data;
 

From 8cd2c66e39dee6edb4dda9faef5601785a8eb9eb Mon Sep 17 00:00:00 2001
From: Derek Lesho <dereklesho52@Gmail.com>
Date: Tue, 25 Jun 2019 20:47:20 -0400
Subject: [PATCH 02/11] server: Move mouse raw-input message faking from user32
 to wineserver.

Signed-off-by: Derek Lesho <dereklesho52@Gmail.com>
---
 dlls/user32/message.c | 46 +++----------------------------------------
 server/protocol.def   |  9 +++++----
 server/queue.c        | 46 +++++++++++++++++++++++++++++++++++++++++--
 3 files changed, 52 insertions(+), 49 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 43ce77c2dd6..b6dd7d59321 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2295,54 +2295,14 @@ static BOOL process_rawinput_message( MSG *msg, const struct hardware_msg_data *
     rawinput->header.dwType = msg_data->rawinput.type;
     if (msg_data->rawinput.type == RIM_TYPEMOUSE)
     {
-        static const unsigned int button_flags[] =
-        {
-            0,                              /* MOUSEEVENTF_MOVE */
-            RI_MOUSE_LEFT_BUTTON_DOWN,      /* MOUSEEVENTF_LEFTDOWN */
-            RI_MOUSE_LEFT_BUTTON_UP,        /* MOUSEEVENTF_LEFTUP */
-            RI_MOUSE_RIGHT_BUTTON_DOWN,     /* MOUSEEVENTF_RIGHTDOWN */
-            RI_MOUSE_RIGHT_BUTTON_UP,       /* MOUSEEVENTF_RIGHTUP */
-            RI_MOUSE_MIDDLE_BUTTON_DOWN,    /* MOUSEEVENTF_MIDDLEDOWN */
-            RI_MOUSE_MIDDLE_BUTTON_UP,      /* MOUSEEVENTF_MIDDLEUP */
-        };
-        unsigned int i;
-
         rawinput->header.dwSize  = FIELD_OFFSET(RAWINPUT, data) + sizeof(RAWMOUSE);
         rawinput->header.hDevice = WINE_MOUSE_HANDLE;
         rawinput->header.wParam  = 0;
 
         rawinput->data.mouse.usFlags           = MOUSE_MOVE_RELATIVE;
-        rawinput->data.mouse.u.s.usButtonFlags = 0;
-        rawinput->data.mouse.u.s.usButtonData  = 0;
-        for (i = 1; i < ARRAY_SIZE(button_flags); ++i)
-        {
-            if (msg_data->flags & (1 << i))
-                rawinput->data.mouse.u.s.usButtonFlags |= button_flags[i];
-        }
-        if (msg_data->flags & MOUSEEVENTF_WHEEL)
-        {
-            rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_WHEEL;
-            rawinput->data.mouse.u.s.usButtonData   = msg_data->rawinput.mouse.data;
-        }
-        if (msg_data->flags & MOUSEEVENTF_HWHEEL)
-        {
-            rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_HORIZONTAL_WHEEL;
-            rawinput->data.mouse.u.s.usButtonData   = msg_data->rawinput.mouse.data;
-        }
-        if (msg_data->flags & MOUSEEVENTF_XDOWN)
-        {
-            if (msg_data->rawinput.mouse.data == XBUTTON1)
-                rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_BUTTON_4_DOWN;
-            else if (msg_data->rawinput.mouse.data == XBUTTON2)
-                rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_BUTTON_5_DOWN;
-        }
-        if (msg_data->flags & MOUSEEVENTF_XUP)
-        {
-            if (msg_data->rawinput.mouse.data == XBUTTON1)
-                rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_BUTTON_4_UP;
-            else if (msg_data->rawinput.mouse.data == XBUTTON2)
-                rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_BUTTON_5_UP;
-        }
+
+        rawinput->data.mouse.u.s.usButtonFlags = msg_data->rawinput.mouse.button_flags;
+        rawinput->data.mouse.u.s.usButtonData = msg_data->rawinput.mouse.button_data;
 
         rawinput->data.mouse.ulRawButtons       = 0;
         rawinput->data.mouse.lLastX             = msg_data->rawinput.mouse.x;
diff --git a/server/protocol.def b/server/protocol.def
index 8157199f2fa..f7e0008b04f 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -304,10 +304,11 @@ struct hardware_msg_data
         } kbd;
         struct
         {
-            int            type;    /* RIM_TYPEMOUSE */
-            int            x;       /* x coordinate */
-            int            y;       /* y coordinate */
-            unsigned int   data;    /* mouse data */
+            int            type;            /* RIM_TYPEMOUSE */
+            int            x;               /* x coordinate */
+            int            y;               /* y coordinate */
+            unsigned short button_flags;    /* mouse button */
+            unsigned short button_data;     /* event details */
         } mouse;
     } rawinput;
 };
diff --git a/server/queue.c b/server/queue.c
index 40a566a2b73..b58dfd52134 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -1627,6 +1627,16 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         WM_MOUSEHWHEEL   /* 0x1000 = MOUSEEVENTF_HWHEEL */
     };
 
+    static const unsigned int raw_button_flags[] =     {
+        0,                            /* 0x0001 = MOUSEEVENTF_MOVE */
+        RI_MOUSE_LEFT_BUTTON_DOWN,    /* 0x0002 = MOUSEEVENTF_LEFTDOWN */
+        RI_MOUSE_LEFT_BUTTON_UP,      /* 0x0004 = MOUSEEVENTF_LEFTUP */
+        RI_MOUSE_RIGHT_BUTTON_DOWN,   /* 0x0008 = MOUSEEVENTF_RIGHTDOWN */
+        RI_MOUSE_RIGHT_BUTTON_UP,     /* 0x0010 = MOUSEEVENTF_RIGHTUP */
+        RI_MOUSE_MIDDLE_BUTTON_DOWN,  /* 0x0020 = MOUSEEVENTF_MIDDLEDOWN */
+        RI_MOUSE_MIDDLE_BUTTON_UP,    /* 0x0040 = MOUSEEVENTF_MIDDLEUP */
+    };
+
     desktop->cursor.last_change = get_tick_count();
     flags = input->mouse.flags;
     time  = input->mouse.time;
@@ -1664,11 +1674,43 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         msg->wparam    = RIM_INPUT;
         msg->lparam    = 0;
 
-        msg_data->flags               = flags;
+        msg_data->flags               = 0;
         msg_data->rawinput.type       = RIM_TYPEMOUSE;
         msg_data->rawinput.mouse.x    = x - desktop->cursor.x;
         msg_data->rawinput.mouse.y    = y - desktop->cursor.y;
-        msg_data->rawinput.mouse.data = input->mouse.data;
+        msg_data->rawinput.mouse.button_flags = 0;
+        msg_data->rawinput.mouse.button_data = 0;
+
+        for (i = 1; i < ARRAY_SIZE(raw_button_flags); ++i)
+        {
+            if (flags & (1 << i))
+                msg_data->rawinput.mouse.button_flags |= raw_button_flags[i];
+        }
+
+        if (flags & MOUSEEVENTF_WHEEL)
+        {
+            msg_data->rawinput.mouse.button_flags |= RI_MOUSE_WHEEL;
+            msg_data->rawinput.mouse.button_data   = input->mouse.data;
+        }
+        if (flags & MOUSEEVENTF_HWHEEL)
+        {
+            msg_data->rawinput.mouse.button_flags |= RI_MOUSE_HORIZONTAL_WHEEL;
+            msg_data->rawinput.mouse.button_data   = input->mouse.data;
+        }
+        if (flags & MOUSEEVENTF_XDOWN)
+        {
+            if (input->mouse.data == XBUTTON1)
+                msg_data->rawinput.mouse.button_flags |= RI_MOUSE_BUTTON_4_DOWN;
+            else if (input->mouse.data == XBUTTON2)
+                msg_data->rawinput.mouse.button_flags |= RI_MOUSE_BUTTON_5_DOWN;
+        }
+        if (flags & MOUSEEVENTF_XUP)
+        {
+            if (input->mouse.data == XBUTTON1)
+                msg_data->rawinput.mouse.button_flags |= RI_MOUSE_BUTTON_4_UP;
+            else if (input->mouse.data == XBUTTON2)
+                msg_data->rawinput.mouse.button_flags |= RI_MOUSE_BUTTON_5_UP;
+        }
 
         queue_hardware_message( desktop, msg, 0 );
     }

From 2fd717d14d73b529d09aa786346cc2d205f29137 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dereklesho52@Gmail.com>
Date: Tue, 25 Jun 2019 21:24:12 -0400
Subject: [PATCH 03/11] server: Add request for sending native raw-input
 messages.

Signed-off-by: Derek Lesho <dereklesho52@Gmail.com>
---
 dlls/user32/message.c |  2 +-
 server/protocol.def   | 51 +++++++++++++++++++++++++++----------------
 server/queue.c        | 49 +++++++++++++++++++++++++++++++++++++++++
 server/trace.c        | 21 ++++++++++++++++++
 tools/make_requests   |  1 +
 5 files changed, 104 insertions(+), 20 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index b6dd7d59321..4c8d485954d 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2299,7 +2299,7 @@ static BOOL process_rawinput_message( MSG *msg, const struct hardware_msg_data *
         rawinput->header.hDevice = WINE_MOUSE_HANDLE;
         rawinput->header.wParam  = 0;
 
-        rawinput->data.mouse.usFlags           = MOUSE_MOVE_RELATIVE;
+        rawinput->data.mouse.usFlags            = msg_data->rawinput.mouse.flags;
 
         rawinput->data.mouse.u.s.usButtonFlags = msg_data->rawinput.mouse.button_flags;
         rawinput->data.mouse.u.s.usButtonData = msg_data->rawinput.mouse.button_data;
diff --git a/server/protocol.def b/server/protocol.def
index f7e0008b04f..009e0b2593f 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -286,31 +286,39 @@ struct hw_msg_source
     unsigned int    origin;        /* source origin (IMO_* values) */
 };
 
+typedef union
+{
+    int type;
+    struct
+    {
+        int            type;    /* RIM_TYPEKEYBOARD */
+        unsigned int   message; /* message generated by this rawinput event */
+        unsigned short vkey;    /* virtual key code */
+        unsigned short scan;    /* scan code */
+    } kbd;
+    struct
+    {
+        int            type;            /* RIM_TYPEMOUSE */
+        unsigned short flags;           /* event flags */
+        int            x;               /* x coordinate */
+        int            y;               /* y coordinate */
+        unsigned short button_flags;    /* mouse button */
+        unsigned short button_data;     /* event details */
+    } mouse;
+    struct
+    {
+        int type; /* RIM_TYPEHID */
+        /* TODO: fill this in if/when necessary */
+    } hid;
+} hw_rawinput_t;
+
 struct hardware_msg_data
 {
     lparam_t             info;      /* extra info */
     unsigned int         hw_id;     /* unique id */
     unsigned int         flags;     /* hook flags */
     struct hw_msg_source source;    /* message source */
-    union
-    {
-        int type;
-        struct
-        {
-            int            type;    /* RIM_TYPEKEYBOARD */
-            unsigned int   message; /* message generated by this rawinput event */
-            unsigned short vkey;    /* virtual key code */
-            unsigned short scan;    /* scan code */
-        } kbd;
-        struct
-        {
-            int            type;            /* RIM_TYPEMOUSE */
-            int            x;               /* x coordinate */
-            int            y;               /* y coordinate */
-            unsigned short button_flags;    /* mouse button */
-            unsigned short button_data;     /* event details */
-        } mouse;
-    } rawinput;
+    hw_rawinput_t        rawinput;
 };
 
 struct callback_msg_data
@@ -2318,6 +2326,11 @@ enum message_type
 #define SEND_HWMSG_INJECTED    0x01
 
 
+@REQ(send_rawinput_message)
+    hw_rawinput_t input;
+@END
+
+
 /* Get a message from the current queue */
 @REQ(get_message)
     unsigned int    flags;     /* PM_* flags */
diff --git a/server/queue.c b/server/queue.c
index b58dfd52134..246fcffd238 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2421,6 +2421,55 @@ DECL_HANDLER(send_hardware_message)
     release_object( desktop );
 }
 
+/* send a hardware rawinput message to the queue thread */
+DECL_HANDLER(send_rawinput_message)
+{
+    const struct rawinput_device *device;
+    struct hardware_msg_data *msg_data;
+    struct message *msg;
+    struct desktop *desktop;
+    struct hw_msg_source source = { IMDT_MOUSE, IMO_HARDWARE };
+
+    desktop = get_thread_desktop( current, 0 );
+
+    switch (req->input.type)
+    {
+    case RIM_TYPEMOUSE:
+        if ((device = current->process->rawinput_mouse))
+        {
+            struct thread *thread = device->target ? get_window_thread( device->target ) : NULL;
+            if ((current->queue->input != desktop->foreground_input) || (thread && thread != current))
+                goto done;
+
+            if (!(msg = alloc_hardware_message( 0, source, 0 ))) goto done;
+            msg_data = msg->data;
+
+            msg->win       = device->target;
+            msg->msg       = WM_INPUT;
+            msg->wparam    = RIM_INPUT;
+            msg->lparam    = 0;
+
+            msg_data->flags               = 0;
+            msg_data->rawinput.type       = RIM_TYPEMOUSE;
+            msg_data->rawinput.mouse.x    = req->input.mouse.x;
+            msg_data->rawinput.mouse.y    = req->input.mouse.y;
+            msg_data->rawinput.mouse.button_flags = req->input.mouse.button_flags;
+            msg_data->rawinput.mouse.button_data = req->input.mouse.button_data;
+            msg_data->rawinput.mouse.flags = req->input.mouse.flags;
+
+            queue_hardware_message( desktop, msg, 0 );
+
+            done:
+            if (thread) release_object( thread );
+        }
+        break;
+    default:
+        set_error( STATUS_INVALID_PARAMETER );
+    }
+
+    release_object(desktop);
+}
+
 /* post a quit message to the current queue */
 DECL_HANDLER(post_quit_message)
 {
diff --git a/server/trace.c b/server/trace.c
index 0df649ea295..4fbfee88c8e 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -405,6 +405,27 @@ static void dump_hw_input( const char *prefix, const hw_input_t *input )
     }
 }
 
+static void dump_hw_rawinput( const char *prefix, const hw_rawinput_t *rawinput )
+{
+    switch (rawinput->type)
+    {
+    case RIM_TYPEMOUSE:
+        fprintf( stderr, "%s{type=MOUSE,flags=%04hx,x=%d,y=%d,button_flags=%04hx,button_data=%04hx}",
+                 prefix, rawinput->mouse.flags, rawinput->mouse.x, rawinput->mouse.y,
+                 rawinput->mouse.button_flags, rawinput->mouse.button_data);
+        break;
+    case RIM_TYPEKEYBOARD:
+        fprintf( stderr, "%s{type=KEYBOARD}\n", prefix);
+        break;
+    case RIM_TYPEHID:
+        fprintf( stderr, "%s{type=HID}\n", prefix);
+        break;
+    default:
+        fprintf( stderr, "%s{type=%04x}", prefix, rawinput->type);
+        break;
+    }
+}
+
 static void dump_luid( const char *prefix, const luid_t *luid )
 {
     fprintf( stderr, "%s%d.%u", prefix, luid->high_part, luid->low_part );
diff --git a/tools/make_requests b/tools/make_requests
index faeabe5852d..a6f12af0414 100755
--- a/tools/make_requests
+++ b/tools/make_requests
@@ -53,6 +53,7 @@ my %formats =
     "ioctl_code_t"  => [  4,   4,  "&dump_ioctl_code" ],
     "client_cpu_t"  => [  4,   4,  "&dump_client_cpu" ],
     "hw_input_t"    => [  32,  8,  "&dump_hw_input" ],
+    "hw_rawinput_t" => [  20,  4,  "&dump_hw_rawinput" ]
 );
 
 my @requests = ();

From 1f278c6a5f906910c08e6e122850c7df00f30b7a Mon Sep 17 00:00:00 2001
From: Derek Lesho <dereklesho52@Gmail.com>
Date: Tue, 25 Jun 2019 21:28:54 -0400
Subject: [PATCH 04/11] user32: Add helper for input drivers to submit native
 rawinput msgs.

Signed-off-by: Derek Lesho <dereklesho52@Gmail.com>
---
 dlls/user32/input.c     | 30 ++++++++++++++++++++++++++++++
 dlls/user32/user32.spec |  1 +
 include/winuser.h       |  1 +
 3 files changed, 32 insertions(+)

diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index 8b2ae805aa7..9b9cc4f0d76 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -33,6 +33,7 @@
 #include <assert.h>
 
 #define NONAMELESSUNION
+#define NONAMELESSSTRUCT
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -129,6 +130,35 @@ BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input )
     return !status;
 }
 
+BOOL CDECL __wine_send_raw_input( const RAWINPUT *raw_input )
+{
+    NTSTATUS status;
+
+    SERVER_START_REQ( send_rawinput_message )
+    {
+        req->input.type = raw_input->header.dwType;
+        switch (raw_input->header.dwType)
+        {
+        case RIM_TYPEMOUSE:
+            if (raw_input->data.mouse.ulRawButtons ||
+                raw_input->data.mouse.ulExtraInformation)
+                FIXME("Unhandled parameters\n");
+
+            req->input.mouse.flags = raw_input->data.mouse.usFlags;
+            req->input.mouse.x = raw_input->data.mouse.lLastX;
+            req->input.mouse.y = raw_input->data.mouse.lLastY;
+            req->input.mouse.button_flags = raw_input->data.mouse.u.s.usButtonFlags;
+            req->input.mouse.button_data = raw_input->data.mouse.u.s.usButtonData;
+            break;
+        }
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (status) SetLastError( RtlNtStatusToDosError(status) );
+    return !status;
+}
+
 
 /***********************************************************************
  *		update_mouse_coords
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index f9a4ae26df4..3311dcd6856 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -833,4 +833,5 @@
 # or 'wine_' (for user-visible functions) to avoid namespace conflicts.
 #
 @ cdecl __wine_send_input(long ptr)
+@ cdecl __wine_send_raw_input(ptr)
 @ cdecl __wine_set_pixel_format(long long)
diff --git a/include/winuser.h b/include/winuser.h
index 51c73d25c2f..259db275c49 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -4390,6 +4390,7 @@ WORD        WINAPI SYSTEM_KillSystemTimer( WORD );
 
 #ifdef __WINESRC__
 WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input );
+WINUSERAPI BOOL CDECL __wine_send_raw_input( const RAWINPUT *raw_input );
 #endif
 
 #ifdef __cplusplus

From d7343cb3d9c68873003bbf92315dad23808221c4 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dereklesho52@Gmail.com>
Date: Tue, 25 Jun 2019 21:58:34 -0400
Subject: [PATCH 05/11] server: Don't emulate rawinput mouse events if native
 exist.

Signed-off-by: Derek Lesho <dereklesho52@Gmail.com>
---
 server/queue.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/server/queue.c b/server/queue.c
index 246fcffd238..c9446f7f4b1 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -1599,6 +1599,8 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
     return 1;
 }
 
+static int emulate_raw_mouse = 1;
+
 /* queue a hardware message for a mouse event */
 static int queue_mouse_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
                                 unsigned int origin, struct msg_queue *sender )
@@ -1664,7 +1666,8 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         y = desktop->cursor.y;
     }
 
-    if ((device = current->process->rawinput_mouse))
+    device = current->process->rawinput_mouse;
+    if (device && emulate_raw_mouse)
     {
         if (!(msg = alloc_hardware_message( input->mouse.info, source, time ))) return 0;
         msg_data = msg->data;
@@ -2435,6 +2438,7 @@ DECL_HANDLER(send_rawinput_message)
     switch (req->input.type)
     {
     case RIM_TYPEMOUSE:
+        emulate_raw_mouse = 0;
         if ((device = current->process->rawinput_mouse))
         {
             struct thread *thread = device->target ? get_window_thread( device->target ) : NULL;

From 7bc3e25b06e580c82ca1289f1758a980cfd51543 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 23 Jul 2019 14:10:44 +0200
Subject: [PATCH 06/11] winex11.drv: Directly listen to master XInput2 devices
 if supported

Under XInput2 protocol version < 2.1, raw events should not be received
if pointer grab is active. However slave device events are still
received regardless of this specification and Wine implemented a
workaround to get raw events during pointer grabs by listening to these
slave device events.

By advertising to support XInput2 protocol version >= 2.1, where raw
events are sent even during pointer grabs, it is possible to simplify
the code by listening to master device events only.

Signed-off-by: Derek Lesho <dereklesho52@Gmail.com>
---
 dlls/winex11.drv/event.c | 42 +-----------------------------
 dlls/winex11.drv/mouse.c | 56 +++++++++++++++++++++++++++++-----------
 2 files changed, 42 insertions(+), 56 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 5c465aa0335..1e64f0d2a3b 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -271,46 +271,6 @@ enum event_merge_action
     MERGE_IGNORE    /* ignore the new event, keep the old one */
 };
 
-/***********************************************************************
- *           merge_raw_motion_events
- */
-#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
-static enum event_merge_action merge_raw_motion_events( XIRawEvent *prev, XIRawEvent *next )
-{
-    int i, j, k;
-    unsigned char mask;
-
-    if (!prev->valuators.mask_len) return MERGE_HANDLE;
-    if (!next->valuators.mask_len) return MERGE_HANDLE;
-
-    mask = prev->valuators.mask[0] | next->valuators.mask[0];
-    if (mask == next->valuators.mask[0])  /* keep next */
-    {
-        for (i = j = k = 0; i < 8; i++)
-        {
-            if (XIMaskIsSet( prev->valuators.mask, i ))
-                next->valuators.values[j] += prev->valuators.values[k++];
-            if (XIMaskIsSet( next->valuators.mask, i )) j++;
-        }
-        TRACE( "merging duplicate GenericEvent\n" );
-        return MERGE_DISCARD;
-    }
-    if (mask == prev->valuators.mask[0])  /* keep prev */
-    {
-        for (i = j = k = 0; i < 8; i++)
-        {
-            if (XIMaskIsSet( next->valuators.mask, i ))
-                prev->valuators.values[j] += next->valuators.values[k++];
-            if (XIMaskIsSet( prev->valuators.mask, i )) j++;
-        }
-        TRACE( "merging duplicate GenericEvent\n" );
-        return MERGE_IGNORE;
-    }
-    /* can't merge events with disjoint masks */
-    return MERGE_HANDLE;
-}
-#endif
-
 /***********************************************************************
  *           merge_events
  *
@@ -362,7 +322,7 @@ static enum event_merge_action merge_events( XEvent *prev, XEvent *next )
             if (next->xcookie.extension != xinput2_opcode) break;
             if (next->xcookie.evtype != XI_RawMotion) break;
             if (x11drv_thread_data()->warp_serial) break;
-            return merge_raw_motion_events( prev->xcookie.data, next->xcookie.data );
+            return MERGE_HANDLE;
 #endif
         }
         break;
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index f737a306a56..90fd11831bb 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -130,6 +130,8 @@ static Cursor create_cursor( HANDLE handle );
 
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
 static BOOL xinput2_available;
+static int xinput2_version_major = 2;
+static int xinput2_version_minor = 1;
 static BOOL broken_rawevents;
 #define MAKE_FUNCPTR(f) static typeof(f) * p##f
 MAKE_FUNCPTR(XIGetClientPointer);
@@ -301,8 +303,11 @@ static void enable_xinput2(void)
 
     if (data->xi2_state == xi_unknown)
     {
-        int major = 2, minor = 0;
-        if (!pXIQueryVersion( data->display, &major, &minor )) data->xi2_state = xi_disabled;
+        if (!pXIQueryVersion( data->display, &xinput2_version_major, &xinput2_version_minor ))
+        {
+            TRACE( "XInput2 v%d.%d available\n", xinput2_version_major, xinput2_version_minor );
+            data->xi2_state = xi_disabled;
+        }
         else
         {
             data->xi2_state = xi_unavailable;
@@ -314,11 +319,19 @@ static void enable_xinput2(void)
 
     mask.mask     = mask_bits;
     mask.mask_len = sizeof(mask_bits);
-    mask.deviceid = XIAllDevices;
+    mask.deviceid = XIAllMasterDevices;
     memset( mask_bits, 0, sizeof(mask_bits) );
-    XISetMask( mask_bits, XI_DeviceChanged );
     XISetMask( mask_bits, XI_RawMotion );
     XISetMask( mask_bits, XI_ButtonPress );
+    XISetMask( mask_bits, XI_DeviceChanged );
+
+    /* XInput 2.0 has a problematic behavior where master pointer will
+     * not send raw events to the root window whenever a grab is active
+     */
+    if (xinput2_version_major == 2 && xinput2_version_minor == 0)
+    {
+        mask.deviceid = XIAllDevices;
+    }
 
     pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
 
@@ -333,7 +346,7 @@ static void enable_xinput2(void)
      * safe to be obtained statically at enable_xinput2() time.
      */
     if (data->xi2_devices) pXIFreeDeviceInfo( data->xi2_devices );
-    data->xi2_devices = pXIQueryDevice( data->display, XIAllDevices, &data->xi2_device_count );
+    data->xi2_devices = pXIQueryDevice( data->display, mask.deviceid, &data->xi2_device_count );
     data->xi2_current_slave = 0;
 
     data->xi2_state = xi_enabled;
@@ -356,7 +369,13 @@ static void disable_xinput2(void)
 
     mask.mask = NULL;
     mask.mask_len = 0;
-    mask.deviceid = XIAllDevices;
+    mask.deviceid = XIAllMasterDevices;
+
+    /* XInput 2.0 has a problematic behavior where master pointer will
+     * not send raw events to the root window whenever a grab is active
+     */
+    if (xinput2_version_major == 2 && xinput2_version_minor == 0)
+        mask.deviceid = XIAllDevices;
 
     pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
     pXIFreeDeviceInfo( data->xi2_devices );
@@ -1735,25 +1754,32 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
     if (!event->valuators.mask_len) return FALSE;
     if (thread_data->xi2_state != xi_enabled) return FALSE;
 
-    /* If there is no slave currently detected, no previous motion nor device
-     * change events were received. Look it up now on the device list in this
-     * case.
-     */
-    if (!thread_data->xi2_current_slave)
+    if (xinput2_version_major == 2 && xinput2_version_minor == 0)
     {
         XIDeviceInfo *devices = thread_data->xi2_devices;
 
-        for (i = 0; i < thread_data->xi2_device_count; i++)
+        /* If there is no slave currently detected, no previous motion nor device
+         * change events were received. Look it up now on the device list in this
+         * case.
+         */
+        for (i = 0; !thread_data->xi2_current_slave && i < thread_data->xi2_device_count; i++)
         {
             if (devices[i].use != XISlavePointer) continue;
             if (devices[i].deviceid != event->deviceid) continue;
             if (devices[i].attachment != thread_data->xi2_core_pointer) continue;
             thread_data->xi2_current_slave = event->deviceid;
-            break;
         }
-    }
 
-    if (event->deviceid != thread_data->xi2_current_slave) return FALSE;
+        /* Only listen to slave device events on XInput == 2.0 */
+        if (event->deviceid != thread_data->xi2_current_slave)
+            return FALSE;
+    }
+    else
+    {
+        /* Only listen to master device events on XInput >= 2.1 */
+        if (event->deviceid != thread_data->xi2_core_pointer)
+            return FALSE;
+    }
 
     x_rel = &thread_data->x_rel_valuator;
     y_rel = &thread_data->y_rel_valuator;

From 2fade590228a8718c89b568ca8a290992d6124c0 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dereklesho52@Gmail.com>
Date: Tue, 25 Jun 2019 22:37:34 -0400
Subject: [PATCH 07/11] winex11.drv: Implement native mouse-movement raw-input
 using RawMotion.

Signed-off-by: Derek Lesho <dereklesho52@Gmail.com>

Tmp
---
 dlls/winex11.drv/mouse.c       | 102 +++++++++++++++++++++++++++------
 dlls/winex11.drv/x11drv.h      |   8 ++-
 dlls/winex11.drv/x11drv_main.c |   6 ++
 3 files changed, 97 insertions(+), 19 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 90fd11831bb..472ba77d0a8 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -259,6 +259,8 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
 
     thread_data->x_rel_valuator.number = -1;
     thread_data->y_rel_valuator.number = -1;
+    thread_data->x_abs_valuator.number = -1;
+    thread_data->y_abs_valuator.number = -1;
 
     for (i = 0; i < n_valuators; i++)
     {
@@ -276,6 +278,16 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
         {
             valuator_data = &thread_data->y_rel_valuator;
         }
+        else if (class->label == x11drv_atom( Abs_X ) ||
+                 (!class->label && class->number == 0 && class->mode == XIModeAbsolute))
+        {
+            valuator_data = &thread_data->x_abs_valuator;
+        }
+        else if (class->label == x11drv_atom( Abs_Y ) ||
+                 (!class->label && class->number == 1 && class->mode == XIModeAbsolute))
+        {
+            valuator_data = &thread_data->y_abs_valuator;
+        }
 
         if (valuator_data) {
             valuator_data->number = class->number;
@@ -288,9 +300,9 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
 
 
 /***********************************************************************
- *              enable_xinput2
+ *              X11DRV_XInput2_Enable
  */
-static void enable_xinput2(void)
+void X11DRV_XInput2_Enable(void)
 {
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
     struct x11drv_thread_data *data = x11drv_thread_data();
@@ -321,8 +333,8 @@ static void enable_xinput2(void)
     mask.mask_len = sizeof(mask_bits);
     mask.deviceid = XIAllMasterDevices;
     memset( mask_bits, 0, sizeof(mask_bits) );
+    XISetMask( mask_bits, XI_DeviceChanged );
     XISetMask( mask_bits, XI_RawMotion );
-    XISetMask( mask_bits, XI_ButtonPress );
     XISetMask( mask_bits, XI_DeviceChanged );
 
     /* XInput 2.0 has a problematic behavior where master pointer will
@@ -354,15 +366,15 @@ static void enable_xinput2(void)
 }
 
 /***********************************************************************
- *              disable_xinput2
+ *              X11DRV_XInput2_Disable
  */
-static void disable_xinput2(void)
+void X11DRV_XInput2_Disable(void)
 {
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
     struct x11drv_thread_data *data = x11drv_thread_data();
     XIEventMask mask;
 
-    if (data->xi2_state != xi_enabled) return;
+    if (data->xi2_state < xi_enabled) return;
 
     TRACE( "disabling\n" );
     data->xi2_state = xi_disabled;
@@ -387,6 +399,21 @@ static void disable_xinput2(void)
 #endif
 }
 
+static void use_xinput2_path(void)
+{
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+
+    if (thread_data->xi2_state == xi_enabled)
+        thread_data->xi2_state = xi_extra;
+}
+
+static void disable_xinput2_path(void)
+{
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+
+    if (thread_data->xi2_state == xi_extra)
+        thread_data->xi2_state = xi_enabled;
+}
 
 /***********************************************************************
  *		grab_clipping_window
@@ -412,9 +439,9 @@ static BOOL grab_clipping_window( const RECT *clip )
         return TRUE;
 
     /* enable XInput2 unless we are already clipping */
-    if (!data->clip_hwnd) enable_xinput2();
+    if (!data->clip_hwnd) use_xinput2_path();
 
-    if (data->xi2_state != xi_enabled)
+    if (data->xi2_state < xi_extra)
     {
         WARN( "XInput2 not supported, refusing to clip to %s\n", wine_dbgstr_rect(clip) );
         DestroyWindow( msg_hwnd );
@@ -442,7 +469,7 @@ static BOOL grab_clipping_window( const RECT *clip )
 
     if (!clipping_cursor)
     {
-        disable_xinput2();
+        disable_xinput2_path();
         DestroyWindow( msg_hwnd );
         return FALSE;
     }
@@ -508,7 +535,7 @@ LRESULT clip_cursor_notify( HWND hwnd, HWND new_clip_hwnd )
         TRACE( "clip hwnd reset from %p\n", hwnd );
         data->clip_hwnd = 0;
         data->clip_reset = GetTickCount();
-        disable_xinput2();
+        disable_xinput2_path();
         DestroyWindow( hwnd );
     }
     else if (hwnd == GetForegroundWindow())  /* request to clip */
@@ -1743,16 +1770,20 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
 {
     XIRawEvent *event = xev->data;
     const double *values = event->valuators.values;
+    const double *raw_values = event->raw_values;
     RECT virtual_rect;
     INPUT input;
+    RAWINPUT raw_input;
     int i;
-    double dx = 0, dy = 0, val;
+    double dx = 0, dy = 0, raw_x = 0, raw_y = 0, val, raw_val;
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
-    struct x11drv_valuator_data *x_rel, *y_rel;
+    struct x11drv_valuator_data *x_rel, *y_rel, *x_abs, *y_abs;
+
+    if ((thread_data->x_rel_valuator.number < 0 || thread_data->y_rel_valuator.number < 0) &&
+        (thread_data->x_abs_valuator.number < 0 || thread_data->y_abs_valuator.number < 0) return FALSE;
 
-    if (thread_data->x_rel_valuator.number < 0 || thread_data->y_rel_valuator.number < 0) return FALSE;
     if (!event->valuators.mask_len) return FALSE;
-    if (thread_data->xi2_state != xi_enabled) return FALSE;
+    if (thread_data->xi2_state < xi_enabled) return FALSE;
 
     if (xinput2_version_major == 2 && xinput2_version_minor == 0)
     {
@@ -1783,7 +1814,10 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
 
     x_rel = &thread_data->x_rel_valuator;
     y_rel = &thread_data->y_rel_valuator;
+    x_abs = &thread_data->x_abs_valuator;
+    y_abs = &thread_data->y_abs_valuator;
 
+    input.type = INPUT_MOUSE;
     input.u.mi.mouseData   = 0;
     input.u.mi.dwFlags     = MOUSEEVENTF_MOVE;
     input.u.mi.time        = EVENT_x11_time_to_win32_time( event->time );
@@ -1791,18 +1825,31 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
     input.u.mi.dx          = 0;
     input.u.mi.dy          = 0;
 
+    raw_input.header.dwType = RIM_TYPEMOUSE;
+    raw_input.data.mouse.u.usButtonFlags = 0;
+    raw_input.data.mouse.u.usButtonData = 0;
+    raw_input.data.mouse.ulExtraInformation = 0;
+    raw_input.data.mouse.ulRawButtons = 0;
+    raw_input.data.mouse.usFlags = 0;
+    raw_input.data.mouse.lLastX = 0;
+    raw_input.data.mouse.lLastY = 0;
+
     virtual_rect = get_virtual_screen_rect();
 
-    for (i = 0; i <= max ( x_rel->number, y_rel->number ); i++)
+    for (i = 0; i <= max(max(max( x_abs->number, y_abs->number), x_rel->number), y_rel->number); i++)
     {
         if (!XIMaskIsSet( event->valuators.mask, i )) continue;
         val = *values++;
+        raw_val = *raw_values++;
         if (i == x_rel->number)
         {
             input.u.mi.dx = dx = val;
             if (x_rel->min < x_rel->max)
                 input.u.mi.dx = val * (virtual_rect.right - virtual_rect.left)
                                     / (x_rel->max - x_rel->min);
+
+            raw_input.data.mouse.usFlags = MOUSE_MOVE_RELATIVE;
+            raw_input.data.mouse.lLastX = raw_x = raw_val;
         }
         if (i == y_rel->number)
         {
@@ -1810,6 +1857,19 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
             if (y_rel->min < y_rel->max)
                 input.u.mi.dy = val * (virtual_rect.bottom - virtual_rect.top)
                                     / (y_rel->max - y_rel->min);
+
+            raw_input.data.mouse.usFlags = MOUSE_MOVE_RELATIVE;
+            raw_input.data.mouse.lLastY = raw_y = raw_val;
+        }
+        if (i == x_abs->number)
+        {
+            raw_input.data.mouse.usFlags = MOUSE_MOVE_ABSOLUTE | MOUSE_VIRTUAL_DESKTOP;
+            raw_input.data.mouse.lLastX = raw_x = raw_val * (65536 / (x_abs->max - x_abs->min));
+        }
+        if (i == y_abs->number)
+        {
+            raw_input.data.mouse.usFlags = MOUSE_MOVE_ABSOLUTE | MOUSE_VIRTUAL_DESKTOP;
+            raw_input.data.mouse.lLastY = raw_y = raw_val * (65536 / (y_abs->max - y_abs->min));
         }
     }
 
@@ -1819,10 +1879,16 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
         return FALSE;
     }
 
-    TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
+    if (thread_data->xi2_state == xi_extra)
+    {
+        TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
+        __wine_send_input( 0, &input );
+    }
+
+    TRACE("raw %s event %f,%f\n",
+        raw_input.data.mouse.usFlags ? "absolute" : "relative", raw_x, raw_y);
+    __wine_send_raw_input( &raw_input );
 
-    input.type = INPUT_MOUSE;
-    __wine_send_input( 0, &input );
     return TRUE;
 }
 
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 0d3695bdcf8..2c59f19815e 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -194,6 +194,8 @@ extern BOOL CDECL X11DRV_UnrealizePalette( HPALETTE hpal ) DECLSPEC_HIDDEN;
 
 extern void X11DRV_Xcursor_Init(void) DECLSPEC_HIDDEN;
 extern void X11DRV_XInput2_Init(void) DECLSPEC_HIDDEN;
+extern void X11DRV_XInput2_Enable(void) DECLSPEC_HIDDEN;
+extern void X11DRV_XInput2_Disable(void) DECLSPEC_HIDDEN;
 
 extern DWORD copy_image_bits( BITMAPINFO *info, BOOL is_r8g8b8, XImage *image,
                               const struct gdi_image_bits *src_bits, struct gdi_image_bits *dst_bits,
@@ -335,11 +337,13 @@ struct x11drv_thread_data
     HWND     clip_hwnd;            /* message window stored in desktop while clipping is active */
     DWORD    clip_reset;           /* time when clipping was last reset */
     HKL      kbd_layout;           /* active keyboard layout */
-    enum { xi_unavailable = -1, xi_unknown, xi_disabled, xi_enabled } xi2_state; /* XInput2 state */
+    enum { xi_unavailable = -1, xi_unknown, xi_disabled, xi_enabled, xi_extra } xi2_state; /* XInput2 state */
     void    *xi2_devices;          /* list of XInput2 devices (valid when state is enabled) */
     int      xi2_device_count;
     struct x11drv_valuator_data x_rel_valuator;
     struct x11drv_valuator_data y_rel_valuator;
+    struct x11drv_valuator_data x_abs_valuator;
+    struct x11drv_valuator_data y_abs_valuator;
     int      xi2_core_pointer;     /* XInput2 core pointer id */
     int      xi2_current_slave;    /* Current slave driving the Core pointer */
 };
@@ -425,6 +429,8 @@ enum x11drv_atoms
     XATOM_RAW_CAP_HEIGHT,
     XATOM_Rel_X,
     XATOM_Rel_Y,
+    XATOM_Abs_X,
+    XATOM_Abs_Y,
     XATOM_WM_PROTOCOLS,
     XATOM_WM_DELETE_WINDOW,
     XATOM_WM_STATE,
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 21807af3f18..fb25a45ae2f 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -120,6 +120,8 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "RAW_CAP_HEIGHT",
     "Rel X",
     "Rel Y",
+    "Abs X",
+    "Abs Y",
     "WM_PROTOCOLS",
     "WM_DELETE_WINDOW",
     "WM_STATE",
@@ -611,6 +613,8 @@ void CDECL X11DRV_ThreadDetach(void)
 
     if (data)
     {
+        X11DRV_XInput2_Disable();
+
         if (data->xim) XCloseIM( data->xim );
         if (data->font_set) XFreeFontSet( data->display, data->font_set );
         XCloseDisplay( data->display );
@@ -681,6 +685,8 @@ struct x11drv_thread_data *x11drv_init_thread_data(void)
 
     if (use_xim) X11DRV_SetupXIM();
 
+    X11DRV_XInput2_Enable();
+
     return data;
 }
 

From 900ce00b0684edb5548573914995e0760cbc75d9 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dereklesho52@Gmail.com>
Date: Fri, 26 Jul 2019 17:37:19 -0400
Subject: [PATCH 08/11] winex11.drv: Implement native mouse-button raw-input
 using RawButton*.

Signed-off-by: Derek Lesho <dereklesho52@Gmail.com>
---
 dlls/winex11.drv/mouse.c       | 97 +++++++++++++++++++++++++++++++---
 dlls/winex11.drv/x11drv.h      |  3 ++
 dlls/winex11.drv/x11drv_main.c |  1 +
 3 files changed, 95 insertions(+), 6 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 472ba77d0a8..65b1b500d00 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -261,12 +261,21 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
     thread_data->y_rel_valuator.number = -1;
     thread_data->x_abs_valuator.number = -1;
     thread_data->y_abs_valuator.number = -1;
+    thread_data->wheel_valuator.number = -1;
+
+    thread_data->xi2_wheel_multiplier = 0;
 
     for (i = 0; i < n_valuators; i++)
     {
         XIValuatorClassInfo *class = (XIValuatorClassInfo *)valuators[i];
+        XIScrollClassInfo *scroll_class = (XIScrollClassInfo *)valuators[i];
         struct x11drv_valuator_data *valuator_data = NULL;
 
+        if (valuators[i]->type == XIScrollClass)
+        {
+            if (scroll_class->scroll_type == XIScrollTypeVertical)
+                thread_data->xi2_wheel_multiplier = WHEEL_DELTA / scroll_class->increment;
+        }
         if (valuators[i]->type != XIValuatorClass) continue;
         if (class->label == x11drv_atom( Rel_X ) ||
             (!class->label && class->number == 0 && class->mode == XIModeRelative))
@@ -288,6 +297,11 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
         {
             valuator_data = &thread_data->y_abs_valuator;
         }
+        else if (class->label == x11drv_atom( Rel_Vert_Scroll ) ||
+                 (!class->label && class->number == 3 && class->mode == XIModeRelative))
+        {
+            valuator_data = &thread_data->wheel_valuator;
+        }
 
         if (valuator_data) {
             valuator_data->number = class->number;
@@ -336,6 +350,8 @@ void X11DRV_XInput2_Enable(void)
     XISetMask( mask_bits, XI_DeviceChanged );
     XISetMask( mask_bits, XI_RawMotion );
     XISetMask( mask_bits, XI_DeviceChanged );
+    XISetMask( mask_bits, XI_RawButtonPress );
+    XISetMask( mask_bits, XI_RawButtonRelease );
 
     /* XInput 2.0 has a problematic behavior where master pointer will
      * not send raw events to the root window whenever a grab is active
@@ -393,6 +409,7 @@ void X11DRV_XInput2_Disable(void)
     pXIFreeDeviceInfo( data->xi2_devices );
     data->x_rel_valuator.number = -1;
     data->y_rel_valuator.number = -1;
+    data->wheel_valuator.number = -1;
     data->xi2_devices = NULL;
     data->xi2_core_pointer = 0;
     data->xi2_current_slave = 0;
@@ -1775,12 +1792,13 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
     INPUT input;
     RAWINPUT raw_input;
     int i;
-    double dx = 0, dy = 0, raw_x = 0, raw_y = 0, val, raw_val;
+    double dx = 0, dy = 0, raw_x = 0, raw_y = 0, raw_dwheel = 0, val, raw_val;
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
-    struct x11drv_valuator_data *x_rel, *y_rel, *x_abs, *y_abs;
+    struct x11drv_valuator_data *x_rel, *y_rel, *x_abs, *y_abs, *wheel;
 
     if ((thread_data->x_rel_valuator.number < 0 || thread_data->y_rel_valuator.number < 0) &&
-        (thread_data->x_abs_valuator.number < 0 || thread_data->y_abs_valuator.number < 0) return FALSE;
+        (thread_data->x_abs_valuator.number < 0 || thread_data->y_abs_valuator.number < 0) &&
+         thread_data->wheel_valuator.number < 0) return FALSE;
 
     if (!event->valuators.mask_len) return FALSE;
     if (thread_data->xi2_state < xi_enabled) return FALSE;
@@ -1816,6 +1834,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
     y_rel = &thread_data->y_rel_valuator;
     x_abs = &thread_data->x_abs_valuator;
     y_abs = &thread_data->y_abs_valuator;
+    wheel = &thread_data->wheel_valuator;
 
     input.type = INPUT_MOUSE;
     input.u.mi.mouseData   = 0;
@@ -1836,7 +1855,7 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
 
     virtual_rect = get_virtual_screen_rect();
 
-    for (i = 0; i <= max(max(max( x_abs->number, y_abs->number), x_rel->number), y_rel->number); i++)
+    for (i = 0; i <= max(max(max(max(x_abs->number, y_abs->number), x_rel->number), y_rel->number), wheel->number); i++)
     {
         if (!XIMaskIsSet( event->valuators.mask, i )) continue;
         val = *values++;
@@ -1871,6 +1890,10 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
             raw_input.data.mouse.usFlags = MOUSE_MOVE_ABSOLUTE | MOUSE_VIRTUAL_DESKTOP;
             raw_input.data.mouse.lLastY = raw_y = raw_val * (65536 / (y_abs->max - y_abs->min));
         }
+        if (i == wheel->number)
+        {
+            raw_dwheel = raw_val * thread_data->xi2_wheel_multiplier;
+        }
     }
 
     if (broken_rawevents && is_old_motion_event( xev->serial ))
@@ -1885,13 +1908,70 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
         __wine_send_input( 0, &input );
     }
 
-    TRACE("raw %s event %f,%f\n",
-        raw_input.data.mouse.usFlags ? "absolute" : "relative", raw_x, raw_y);
+    if (raw_dwheel)
+    {
+        raw_input.data.mouse.u.usButtonFlags = RI_MOUSE_WHEEL;
+        raw_input.data.mouse.u.usButtonData  = raw_dwheel;
+    }
+
+    TRACE("raw %s event %f,%f + %f\n",
+        raw_input.data.mouse.usFlags ? "absolute" : "relative", raw_x, raw_y, raw_dwheel);
     __wine_send_raw_input( &raw_input );
 
     return TRUE;
 }
 
+/***********************************************************************
+ *           X11DRV_RawButton
+ */
+static BOOL X11DRV_RawButton( XGenericEventCookie *xev )
+{
+    RAWINPUT ri;
+
+    static const unsigned short raw_button_press_flags[] = {
+        0,                              /* 0 = unused */
+        RI_MOUSE_LEFT_BUTTON_DOWN,      /* 1 */
+        RI_MOUSE_MIDDLE_BUTTON_DOWN,    /* 2 */
+        RI_MOUSE_RIGHT_BUTTON_DOWN,     /* 3 */
+        0,                              /* 4 = unknown */
+        0,                              /* 5 = unknown */
+        0,                              /* 6 = unknown */
+        0,                              /* 7 = unknown */
+        RI_MOUSE_BUTTON_4_DOWN,         /* 8 */
+        RI_MOUSE_BUTTON_5_DOWN          /* 9 */
+    };
+
+    static const unsigned short raw_button_release_flags[] = {
+        0,                            /* 0 = unused */
+        RI_MOUSE_LEFT_BUTTON_UP,      /* 1 */
+        RI_MOUSE_MIDDLE_BUTTON_UP,    /* 2 */
+        RI_MOUSE_RIGHT_BUTTON_UP,     /* 3 */
+        0,                            /* 4 = unknown */
+        0,                            /* 5 = unknown */
+        0,                            /* 6 = unknown */
+        0,                            /* 7 = unknown */
+        RI_MOUSE_BUTTON_4_UP,         /* 8 */
+        RI_MOUSE_BUTTON_5_UP          /* 9 */
+    };
+
+    int detail = ((XIRawEvent*)xev->data)->detail;
+    if (detail > 9) return TRUE;
+
+    ri.header.dwType = RIM_TYPEMOUSE;
+    ri.data.mouse.u.usButtonFlags = xev->evtype == XI_RawButtonPress ? raw_button_press_flags[detail] : raw_button_release_flags[detail] ;
+    ri.data.mouse.u.usButtonData = 0;
+    ri.data.mouse.lLastX = 0;
+    ri.data.mouse.lLastY = 0;
+    ri.data.mouse.usFlags = 0;
+    ri.data.mouse.ulRawButtons = 0;
+    ri.data.mouse.ulExtraInformation = 0;
+
+    if (ri.data.mouse.u.usButtonFlags)
+        __wine_send_raw_input( &ri );
+
+    return TRUE;
+}
+
 #endif /* HAVE_X11_EXTENSIONS_XINPUT2_H */
 
 
@@ -1956,6 +2036,11 @@ BOOL X11DRV_GenericEvent( HWND hwnd, XEvent *xev )
     case XI_RawMotion:
         ret = X11DRV_RawMotion( event );
         break;
+    case XI_RawButtonPress:
+        /* fall through */
+    case XI_RawButtonRelease:
+        ret = X11DRV_RawButton( event );
+        break;
 
     default:
         TRACE( "Unhandled event %#x\n", event->evtype );
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 2c59f19815e..928f8589248 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -344,6 +344,8 @@ struct x11drv_thread_data
     struct x11drv_valuator_data y_rel_valuator;
     struct x11drv_valuator_data x_abs_valuator;
     struct x11drv_valuator_data y_abs_valuator;
+    struct x11drv_valuator_data wheel_valuator;
+    double   xi2_wheel_multiplier;
     int      xi2_core_pointer;     /* XInput2 core pointer id */
     int      xi2_current_slave;    /* Current slave driving the Core pointer */
 };
@@ -431,6 +433,7 @@ enum x11drv_atoms
     XATOM_Rel_Y,
     XATOM_Abs_X,
     XATOM_Abs_Y,
+    XATOM_Rel_Vert_Scroll,
     XATOM_WM_PROTOCOLS,
     XATOM_WM_DELETE_WINDOW,
     XATOM_WM_STATE,
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index fb25a45ae2f..05a445a9c1c 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -122,6 +122,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "Rel Y",
     "Abs X",
     "Abs Y",
+    "Rel Vert Scroll",
     "WM_PROTOCOLS",
     "WM_DELETE_WINDOW",
     "WM_STATE",

From de688bbd0d4d3e8777d0be6b6c34c6580f894cbd Mon Sep 17 00:00:00 2001
From: Jordan Galby <gravemind2a+wine@gmail.com>
Date: Tue, 16 Jul 2019 00:34:38 -0400
Subject: [PATCH 09/11] winex11.drv: Don't react to small slow mouse movements.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=42631
From: Jordan Galby <gravemind2a+wine@gmail.com>
Signed-off-by: Derek Lesho <dereklesho52@Gmail.com>
---
 dlls/winex11.drv/mouse.c  | 51 +++++++++++++++++++++++++++++++--------
 dlls/winex11.drv/x11drv.h |  1 +
 2 files changed, 42 insertions(+), 10 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 65b1b500d00..4d5b0a45ffa 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -263,6 +263,10 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
     thread_data->y_abs_valuator.number = -1;
     thread_data->wheel_valuator.number = -1;
 
+    thread_data->x_rel_valuator.accum = 0;
+    thread_data->y_rel_valuator.accum = 0;
+    thread_data->wheel_valuator.accum = 0;
+
     thread_data->xi2_wheel_multiplier = 0;
 
     for (i = 0; i < n_valuators; i++)
@@ -1862,9 +1866,9 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
         raw_val = *raw_values++;
         if (i == x_rel->number)
         {
-            input.u.mi.dx = dx = val;
+            dx = val;
             if (x_rel->min < x_rel->max)
-                input.u.mi.dx = val * (virtual_rect.right - virtual_rect.left)
+                dx = val * (virtual_rect.right - virtual_rect.left)
                                     / (x_rel->max - x_rel->min);
 
             raw_input.data.mouse.usFlags = MOUSE_MOVE_RELATIVE;
@@ -1872,9 +1876,9 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
         }
         if (i == y_rel->number)
         {
-            input.u.mi.dy = dy = val;
+            dy = val;
             if (y_rel->min < y_rel->max)
-                input.u.mi.dy = val * (virtual_rect.bottom - virtual_rect.top)
+                dy = val * (virtual_rect.bottom - virtual_rect.top)
                                     / (y_rel->max - y_rel->min);
 
             raw_input.data.mouse.usFlags = MOUSE_MOVE_RELATIVE;
@@ -1898,20 +1902,47 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
 
     if (broken_rawevents && is_old_motion_event( xev->serial ))
     {
-        TRACE( "pos %d,%d old serial %lu, ignoring\n", input.u.mi.dx, input.u.mi.dy, xev->serial );
+        TRACE( "pos %d,%d old serial %lu, ignoring\n", (LONG) dx, (LONG) dy, xev->serial );
         return FALSE;
     }
 
-    if (thread_data->xi2_state == xi_extra)
+    /* Accumulate the fractional parts so they aren't lost after casting
+     *  successive motion values to integral fields.
+     *
+     * Note: It looks like raw_dx and raw_dy are already integral values
+     * but that may be wrong.
+     */
+
+    x_rel->accum += dx;
+    y_rel->accum += dy;
+    if ((dy || dy) && fabs(x_rel->accum) < 1.0 && fabs(y_rel->accum) < 1.0)
+    {
+        TRACE( "accumulating raw motion (event %f,%f, accum %f,%f)\n", dx, dy, x_rel->accum, y_rel->accum );
+    }
+    else
     {
-        TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
-        __wine_send_input( 0, &input );
+        input.u.mi.dx = x_rel->accum;
+        input.u.mi.dy = y_rel->accum;
+        x_rel->accum -= input.u.mi.dx;
+        y_rel->accum -= input.u.mi.dy;
+
+        if (thread_data->xi2_state == xi_extra)
+        {
+            TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
+            __wine_send_input( 0, &input );
+        }
     }
 
-    if (raw_dwheel)
+    wheel->accum += raw_dwheel;
+    if (raw_dwheel && fabs(wheel->accum) < 1.0)
+    {
+        TRACE("accumulating wheel motion (event %f, accum %f)\n", raw_dwheel, wheel->accum);
+    }
+    else
     {
         raw_input.data.mouse.u.usButtonFlags = RI_MOUSE_WHEEL;
-        raw_input.data.mouse.u.usButtonData  = raw_dwheel;
+        raw_input.data.mouse.u.usButtonData  = wheel->accum;
+        wheel->accum -= raw_dwheel;
     }
 
     TRACE("raw %s event %f,%f + %f\n",
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 928f8589248..206473fde9f 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -320,6 +320,7 @@ struct x11drv_valuator_data
     double min;
     double max;
     int number;
+    double accum;
 };
 
 struct x11drv_thread_data

From 0704e8813645dbb33192b635b41c9b2c8ec24fd6 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dereklesho52@Gmail.com>
Date: Sat, 10 Aug 2019 12:20:59 -0400
Subject: [PATCH 10/11] server: Implement RIDEV_INPUTSINK flag

Signed-off-by: Derek Lesho <dereklesho52@Gmail.com>
---
 dlls/user32/rawinput.c | 2 +-
 server/queue.c         | 4 +++-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index 58480b8ae7e..c231e2059cb 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -271,7 +271,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH RegisterRawInputDevices(RAWINPUTDEVICE *devices, U
         TRACE("device %u: page %#x, usage %#x, flags %#x, target %p.\n",
                 i, devices[i].usUsagePage, devices[i].usUsage,
                 devices[i].dwFlags, devices[i].hwndTarget);
-        if (devices[i].dwFlags & ~(RIDEV_REMOVE|RIDEV_NOLEGACY))
+        if (devices[i].dwFlags & ~(RIDEV_REMOVE|RIDEV_NOLEGACY|RIDEV_INPUTSINK))
             FIXME("Unhandled flags %#x for device %u.\n", devices[i].dwFlags, i);
 
         d[i].usage_page = devices[i].usUsagePage;
diff --git a/server/queue.c b/server/queue.c
index c9446f7f4b1..2596925aca1 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2442,7 +2442,9 @@ DECL_HANDLER(send_rawinput_message)
         if ((device = current->process->rawinput_mouse))
         {
             struct thread *thread = device->target ? get_window_thread( device->target ) : NULL;
-            if ((current->queue->input != desktop->foreground_input) || (thread && thread != current))
+            if ((current->queue->input != desktop->foreground_input && !(device->flags & RIDEV_INPUTSINK))
+             || (thread && thread != current)
+             || (!thread && device->flags & RIDEV_INPUTSINK))
                 goto done;
 
             if (!(msg = alloc_hardware_message( 0, source, 0 ))) goto done;

From 670973417d576dec16c610f2fde25350a9638dca Mon Sep 17 00:00:00 2001
From: Derek Lesho <dereklesho52@Gmail.com>
Date: Wed, 4 Sep 2019 10:07:39 -0500
Subject: [PATCH 11/11] winex11.drv: [HACK] XWayland workaround.

---
 dlls/winex11.drv/mouse.c | 36 ++++++++++++++++++++++++++++++++----
 1 file changed, 32 insertions(+), 4 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 4d5b0a45ffa..178e7171313 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -25,6 +25,7 @@
 #include <X11/Xlib.h>
 #include <X11/cursorfont.h>
 #include <stdarg.h>
+#include <stdlib.h>
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
 #include <X11/extensions/XInput2.h>
 #endif
@@ -1784,6 +1785,17 @@ static BOOL X11DRV_DeviceChanged( XGenericEventCookie *xev )
     return TRUE;
 }
 
+/* XWayland only reports normalized absolute values and raw relative values,
+ * all under an absolute valuator.
+ */
+static inline int xwayland_workaround(void)
+{
+    static int workaround = -1;
+    if (workaround != -1) return workaround;
+    workaround = !!getenv("WAYLAND_DISPLAY");
+    return workaround;
+}
+
 /***********************************************************************
  *           X11DRV_RawMotion
  */
@@ -1886,13 +1898,29 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
         }
         if (i == x_abs->number)
         {
-            raw_input.data.mouse.usFlags = MOUSE_MOVE_ABSOLUTE | MOUSE_VIRTUAL_DESKTOP;
-            raw_input.data.mouse.lLastX = raw_x = raw_val * (65536 / (x_abs->max - x_abs->min));
+            if (xwayland_workaround())
+            {
+                raw_input.data.mouse.usFlags = MOUSE_MOVE_RELATIVE;
+                raw_input.data.mouse.lLastX = raw_x = raw_val;
+            }
+            else
+            {
+                raw_input.data.mouse.usFlags = MOUSE_MOVE_ABSOLUTE | MOUSE_VIRTUAL_DESKTOP;
+                raw_input.data.mouse.lLastX = raw_x = raw_val * (65536 / (x_abs->max - x_abs->min));
+            }
         }
         if (i == y_abs->number)
         {
-            raw_input.data.mouse.usFlags = MOUSE_MOVE_ABSOLUTE | MOUSE_VIRTUAL_DESKTOP;
-            raw_input.data.mouse.lLastY = raw_y = raw_val * (65536 / (y_abs->max - y_abs->min));
+            if (xwayland_workaround())
+            {
+                raw_input.data.mouse.usFlags = MOUSE_MOVE_RELATIVE;
+                raw_input.data.mouse.lLastY = raw_y = raw_val;
+            }
+            else
+            {
+                raw_input.data.mouse.usFlags = MOUSE_MOVE_ABSOLUTE | MOUSE_VIRTUAL_DESKTOP;
+                raw_input.data.mouse.lLastY = raw_y = raw_val * (65536 / (y_abs->max - y_abs->min));
+            }
         }
         if (i == wheel->number)
         {
