From 5309b8511de4ecceaf1c3123343216981a243cc6 Mon Sep 17 00:00:00 2001
From: Robin <robin.kertels@outlook.com>
Date: Wed, 30 Jan 2019 19:27:49 +0100
Subject: [PATCH 1/4] [dxbc] Bound-check dynamically indexed constant buffer
 reads

Fixes an issue in Dark Souls Remastered caused by constant
buffer access with an undefined index value (#405).
---
 src/dxbc/dxbc_compiler.cpp | 89 +++++++++++++++++++++++---------------
 src/dxbc/dxbc_compiler.h   |  4 ++
 2 files changed, 58 insertions(+), 35 deletions(-)

diff --git a/src/dxbc/dxbc_compiler.cpp b/src/dxbc/dxbc_compiler.cpp
index c8dd616e..4fc86179 100644
--- a/src/dxbc/dxbc_compiler.cpp
+++ b/src/dxbc/dxbc_compiler.cpp
@@ -4587,35 +4587,6 @@ namespace dxvk {
   }
   
   
-  DxbcRegisterPointer DxbcCompiler::emitGetConstBufPtr(
-    const DxbcRegister&           operand) {
-    // Constant buffers take a two-dimensional index:
-    //    (0) register index (immediate)
-    //    (1) constant offset (relative)
-    DxbcRegisterInfo info;
-    info.type.ctype   = DxbcScalarType::Float32;
-    info.type.ccount  = 4;
-    info.type.alength = 0;
-    info.sclass = spv::StorageClassUniform;
-    
-    const uint32_t regId = operand.idx[0].offset;
-    const DxbcRegisterValue constId = emitIndexLoad(operand.idx[1]);
-    
-    const uint32_t ptrTypeId = getPointerTypeId(info);
-    
-    const std::array<uint32_t, 2> indices =
-      {{ m_module.consti32(0), constId.id }};
-    
-    DxbcRegisterPointer result;
-    result.type.ctype  = info.type.ctype;
-    result.type.ccount = info.type.ccount;
-    result.id = m_module.opAccessChain(ptrTypeId,
-      m_constantBuffers.at(regId).varId,
-      indices.size(), indices.data());
-    return result;
-  }
-  
-  
   DxbcRegisterPointer DxbcCompiler::emitGetImmConstBufPtr(
     const DxbcRegister&           operand) {
     const DxbcRegisterValue constId
@@ -4677,9 +4648,6 @@ namespace dxvk {
       case DxbcOperandType::Output:
         return emitGetOutputPtr(operand);
       
-      case DxbcOperandType::ConstantBuffer:
-        return emitGetConstBufPtr(operand);
-      
       case DxbcOperandType::ImmediateConstantBuffer:
         return emitGetImmConstBufPtr(operand);
       
@@ -5236,12 +5204,48 @@ namespace dxvk {
     const DxbcRegister&           reg) {
     return emitValueLoad(emitGetOperandPtr(reg));
   }
-  
-  
+
+  DxbcRegisterValue DxbcCompiler::emitIndexBoundCheck(
+          DxbcRegisterValue       index,
+          DxbcRegisterValue       count) {
+    index = emitRegisterBitcast(index, DxbcScalarType::Uint32);
+    count = emitRegisterBitcast(count, DxbcScalarType::Uint32);
+
+    DxbcRegisterValue result;
+    result.type.ctype  = DxbcScalarType::Bool;
+    result.type.ccount = index.type.ccount;
+    result.id = m_module.opULessThan(
+      getVectorTypeId(result.type),
+      index.id, count.id);
+    return result;
+  }
+
   DxbcRegisterValue DxbcCompiler::emitConstantBufferLoad(
     const DxbcRegister&           reg,
           DxbcRegMask             writeMask) {
-    DxbcRegisterPointer ptr = emitGetOperandPtr(reg);
+    // Constant buffers take a two-dimensional index:
+    //    (0) register index (immediate)
+    //    (1) constant offset (relative)
+    DxbcRegisterInfo info;
+    info.type.ctype   = DxbcScalarType::Float32;
+    info.type.ccount  = 4;
+    info.type.alength = 0;
+    info.sclass = spv::StorageClassUniform;
+    
+    const uint32_t regId = reg.idx[0].offset;
+    const DxbcRegisterValue constId = emitIndexLoad(reg.idx[1]);
+    
+    const uint32_t ptrTypeId = getPointerTypeId(info);
+    
+    const std::array<uint32_t, 2> indices =
+      {{ m_module.consti32(0), constId.id }};
+    
+    DxbcRegisterPointer ptr;
+    ptr.type.ctype  = info.type.ctype;
+    ptr.type.ccount = info.type.ccount;
+    ptr.id = m_module.opAccessChain(ptrTypeId,
+      m_constantBuffers.at(regId).varId,
+      indices.size(), indices.data());
 
     std::array<uint32_t, 4> ccomps = { 0, 0, 0, 0 };
     std::array<uint32_t, 4> scomps = { 0, 0, 0, 0 };
@@ -5283,8 +5287,23 @@ namespace dxvk {
         scount, scomps.data());
     }
 
+    // For dynamically indexed constant buffers, we should
+    // return a vec4(0.0f) if the index is out of bounds
+    if (reg.idx[1].relReg != nullptr) {
+      DxbcRegisterValue cbSize;
+      cbSize.type = { DxbcScalarType::Uint32, 1 };
+      cbSize.id   = m_module.constu32(m_constantBuffers.at(regId).size);
+      DxbcRegisterValue inBounds = emitRegisterExtend(emitIndexBoundCheck(constId, cbSize), 4);
+
+      result.type = ptr.type;
+      result.id = m_module.opSelect(
+        getVectorTypeId(result.type), inBounds.id, result.id,
+        m_module.constvec4f32(0.0f, 0.0f, 0.0f, 0.0f));
+    }
+
     result = emitRegisterBitcast(result, reg.dataType);
     result = emitSrcOperandModifiers(result, reg.modifiers);
+
     return result;
   }
   
diff --git a/src/dxbc/dxbc_compiler.h b/src/dxbc/dxbc_compiler.h
index 3b717169..1380a99e 100644
--- a/src/dxbc/dxbc_compiler.h
+++ b/src/dxbc/dxbc_compiler.h
@@ -958,6 +958,10 @@ namespace dxvk {
     
     //////////////////////////////
     // Operand load/store methods
+    DxbcRegisterValue emitIndexBoundCheck(
+          DxbcRegisterValue       index,
+            DxbcRegisterValue       count);
+
     DxbcRegisterValue emitIndexLoad(
             DxbcRegIndex            index);
     

From 326cdd3d8e1d508735e3f0b4319fa06063f0666e Mon Sep 17 00:00:00 2001
From: Robin <robin.kertels@outlook.com>
Date: Wed, 30 Jan 2019 19:39:36 +0100
Subject: [PATCH 2/4] [d3d11] Add config option to check const buffer bounds

---
 src/d3d11/d3d11_options.cpp |  1 +
 src/d3d11/d3d11_options.h   | 15 +++++++++++----
 src/dxbc/dxbc_compiler.cpp  |  6 +++---
 src/dxbc/dxbc_options.cpp   |  5 +++--
 src/dxbc/dxbc_options.h     |  7 +++++--
 5 files changed, 23 insertions(+), 11 deletions(-)

diff --git a/src/d3d11/d3d11_options.cpp b/src/d3d11/d3d11_options.cpp
index ebcdd5ad..bbbe7c55 100644
--- a/src/d3d11/d3d11_options.cpp
+++ b/src/d3d11/d3d11_options.cpp
@@ -10,6 +10,7 @@ namespace dxvk {
     this->strictDivision          = config.getOption<bool>("d3d11.strictDivision", false);
     this->zeroInitWorkgroupMemory = config.getOption<bool>("d3d11.zeroInitWorkgroupMemory", false);
     this->relaxedBarriers       = config.getOption<bool>("d3d11.relaxedBarriers", false);
+    this->checkConstantBufferBounds = config.getOption<bool>("d3d11.checkConstantBufferBounds", false);
     this->maxTessFactor         = config.getOption<int32_t>("d3d11.maxTessFactor", 0);
     this->samplerAnisotropy     = config.getOption<int32_t>("d3d11.samplerAnisotropy", -1);
     this->deferSurfaceCreation  = config.getOption<bool>("dxgi.deferSurfaceCreation", false);
diff --git a/src/d3d11/d3d11_options.h b/src/d3d11/d3d11_options.h
index 4b738de8..e8413cfb 100644
--- a/src/d3d11/d3d11_options.h
+++ b/src/d3d11/d3d11_options.h
@@ -7,11 +7,11 @@
 #include "d3d11_include.h"
 
 namespace dxvk {
-  
+
   struct D3D11Options {
     D3D11Options(const Config& config);
     /// Handle D3D11_MAP_FLAG_DO_NOT_WAIT properly.
-    /// 
+    ///
     /// This can offer substantial speedups, but some games
     /// (The Witcher 3, Elder Scrolls Online, possibly others)
     /// seem to make incorrect assumptions about when a map
@@ -42,6 +42,13 @@ namespace dxvk {
     /// but might also cause rendering issues.
     bool relaxedBarriers;
 
+    /// Check dynamic constant buffer index bounds
+    ///
+    /// Comes with a performance penalty and is not
+    /// completely accurate to D3D11 but fixes an
+    /// issue in Dark Souls Remastered
+    bool checkConstantBufferBounds = false;
+
     /// Maximum tessellation factor.
     ///
     /// Limits tessellation factors in tessellation
@@ -54,7 +61,7 @@ namespace dxvk {
     /// Enforces anisotropic filtering with the
     /// given anisotropy value for all samplers.
     int32_t samplerAnisotropy;
-    
+
     /// Back buffer count for the Vulkan swap chain.
     /// Overrides DXGI_SWAP_CHAIN_DESC::BufferCount.
     int32_t numBackBuffers;
@@ -72,5 +79,5 @@ namespace dxvk {
     /// for a single window that may interfere with each other.
     bool deferSurfaceCreation;
   };
-  
+
 }
\ No newline at end of file
diff --git a/src/dxbc/dxbc_compiler.cpp b/src/dxbc/dxbc_compiler.cpp
index 4fc86179..b69ed42e 100644
--- a/src/dxbc/dxbc_compiler.cpp
+++ b/src/dxbc/dxbc_compiler.cpp
@@ -5236,7 +5236,7 @@ namespace dxvk {
     const DxbcRegisterValue constId = emitIndexLoad(reg.idx[1]);
     
     const uint32_t ptrTypeId = getPointerTypeId(info);
-    
+
     const std::array<uint32_t, 2> indices =
       {{ m_module.consti32(0), constId.id }};
     
@@ -5289,12 +5289,12 @@ namespace dxvk {
 
     // For dynamically indexed constant buffers, we should
     // return a vec4(0.0f) if the index is out of bounds
-    if (reg.idx[1].relReg != nullptr) {
+    if (m_moduleInfo.options.checkConstantBufferBounds && reg.idx[1].relReg != nullptr) {
       DxbcRegisterValue cbSize;
       cbSize.type = { DxbcScalarType::Uint32, 1 };
       cbSize.id   = m_module.constu32(m_constantBuffers.at(regId).size);
-      DxbcRegisterValue inBounds = emitRegisterExtend(emitIndexBoundCheck(constId, cbSize), 4);
 
+      DxbcRegisterValue inBounds = emitRegisterExtend(emitIndexBoundCheck(constId, cbSize), 4);
       result.type = ptr.type;
       result.id = m_module.opSelect(
         getVectorTypeId(result.type), inBounds.id, result.id,
diff --git a/src/dxbc/dxbc_options.cpp b/src/dxbc/dxbc_options.cpp
index cce1391..5bb08aa 100644
--- a/src/dxbc/dxbc_options.cpp
+++ b/src/dxbc/dxbc_options.cpp
@@ -27,10 +27,12 @@ namespace dxvk {
       = (devInfo.core.properties.limits.minStorageBufferOffsetAlignment <= sizeof(uint32_t));
     useSdivForBufferIndex
       = adapter->matchesDriver(DxvkGpuVendor::Nvidia, VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR, 0, 0);
-    
+
     strictDivision          = options.strictDivision;
     zeroInitWorkgroupMemory = options.zeroInitWorkgroupMemory;
-    
+    if (adapter->matchesDriver(DxvkGpuVendor::Nvidia, VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR, 0, 0))
+      checkConstantBufferBounds = options.checkConstantBufferBounds;
+
     // Disable early discard on RADV due to GPU hangs
     // Disable early discard on Nvidia because it may hurt performance
     if (adapter->matchesDriver(DxvkGpuVendor::Amd,    VK_DRIVER_ID_MESA_RADV_KHR,          0, 0)
diff --git a/src/dxbc/dxbc_options.h b/src/dxbc/dxbc_options.h
index 9fdf554c..228df786 100644
--- a/src/dxbc/dxbc_options.h
+++ b/src/dxbc/dxbc_options.h
@@ -5,7 +5,7 @@
 namespace dxvk {
 
   struct D3D11Options;
-  
+
   struct DxbcOptions {
     DxbcOptions();
     DxbcOptions(const Rc<DxvkDevice>& device, const D3D11Options& options);
@@ -34,6 +34,9 @@ namespace dxvk {
 
     /// Clear thread-group shared memory to zero
     bool zeroInitWorkgroupMemory = false;
+
+    /// Check dynamic constant buffer index bounds
+    bool checkConstantBufferBounds = false;
   };
-  
+
 }
\ No newline at end of file

From 2fcc6d2d486be73f7de8133bc356b33f25c7b3d4 Mon Sep 17 00:00:00 2001
From: Robin <robin.kertels@outlook.com>
Date: Wed, 30 Jan 2019 19:40:26 +0100
Subject: [PATCH 3/4] [util] Enable constant buffer bounds check for Dark Souls
 Remastered

---
 src/util/config/config.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/util/config/config.cpp b/src/util/config/config.cpp
index 6fe6aca1..c39e4e27 100644
--- a/src/util/config/config.cpp
+++ b/src/util/config/config.cpp
@@ -118,6 +118,10 @@ namespace dxvk {
     { "starwarsbattlefronttrial.exe", {{
       { "dxgi.nvapiHack",                   "False" },
     }} },
+    /* Dark Souls Remastered                      */
+    { "DarkSoulsRemastered.exe", {{
+      { "d3d11.checkConstantBufferBounds",  "True" },
+    }} },
   }};
 
 

From 8008ac9e851435fd904f33d86980768583319cfd Mon Sep 17 00:00:00 2001
From: Robin <robin.kertels@outlook.com>
Date: Thu, 28 Mar 2019 12:40:33 +0100
Subject: [PATCH 4/4]  [util] Enable constant buffer bounds check for Grim Dawn

---
 src/util/config/config.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/util/config/config.cpp b/src/util/config/config.cpp
index c39e4e27..db261435 100644
--- a/src/util/config/config.cpp
+++ b/src/util/config/config.cpp
@@ -122,6 +122,10 @@ namespace dxvk {
     { "DarkSoulsRemastered.exe", {{
       { "d3d11.checkConstantBufferBounds",  "True" },
     }} },
+    /* Grim Dawn                                  */
+    { "Grim Dawn.exe", {{
+      { "d3d11.checkConstantBufferBounds",  "True" },
+    }} },
   }};
 
 
