#!/usr/bin/env python3

#script to launch Wine with the correct environment

import fcntl
import array
import fnmatch
import os
import shutil
import errno
import platform
import resource
import stat
import subprocess
import sys
import shlex

from ctypes import CDLL
from ctypes import CFUNCTYPE
from ctypes import POINTER
from ctypes import Structure
from ctypes import addressof
from ctypes import cast
from ctypes import get_errno
from ctypes import sizeof
from ctypes import c_int
from ctypes import c_int64
from ctypes import c_uint
from ctypes import c_long
from ctypes import c_char_p
from ctypes import c_void_p
from ctypes import c_size_t
from ctypes import c_ssize_t

from filelock import FileLock
from random import randrange

#To enable debug logging, copy "user_settings.sample.py" to "user_settings.py"
#and edit it if needed.

CURRENT_PREFIX_VERSION="9.0-202"

PFX="Proton: "
ld_path_var = "LD_LIBRARY_PATH"

def file_exists(s, *, follow_symlinks):
    if follow_symlinks:
        #'exists' returns False on broken symlinks
        return os.path.exists(s)
    #'lexists' returns True on broken symlinks
    return os.path.lexists(s)

def nonzero(s):
    return len(s) > 0 and s != "0"

def prepend_to_env_str(env, variable, prepend_str, separator):
    if variable not in env:
        env[variable] = prepend_str
    else:
        env[variable] = prepend_str + separator + env[variable]

def append_to_env_str(env, variable, append_str, separator):
    if variable not in env:
        env[variable] = append_str
    else:
        env[variable] = env[variable] + separator + append_str

def log(msg):
    try:
        sys.stderr.write(PFX + msg + os.linesep)
        sys.stderr.flush()
    except OSError:
        # e.g. see https://github.com/ValveSoftware/Proton/issues/6277
        # There's not much we can usefully do about this: printing a
        # warning to stderr isn't going to work any better the second time
        pass

def file_is_wine_builtin_dll(path):
    if os.path.islink(path):
        contents = os.readlink(path)
        if os.path.dirname(contents).endswith((
                    '/lib/wine',
                    '/lib64/wine',
                    '/lib/wine/fakedlls',
                    '/lib64/wine/fakedlls',
                    '/lib/wine/i386-unix',
                    '/lib/wine/i386-windows',
                    '/lib64/wine/x86_64-unix',
                    '/lib64/wine/x86_64-windows'
                )):
            # This may be a broken link to a dll in a removed Proton install
            return True
    if not file_exists(path, follow_symlinks=True):
        return False
    try:
        sfile = open(path, "rb")
        sfile.seek(0x40)
        tag = sfile.read(20)
        return tag.startswith((b"Wine placeholder DLL", b"Wine builtin DLL"))
    except IOError:
        return False

def makedirs(path):
    try:
        #replace broken symlinks with a new directory
        if os.path.islink(path) and not file_exists(path, follow_symlinks=True):
            os.remove(path)
        os.makedirs(path)
    except OSError:
        #already exists
        pass

def merge_user_dir(src, dst):
    extant_dirs = []
    for src_dir, dirs, files in os.walk(src):
        dst_dir = src_dir.replace(src, dst, 1)

        #as described below, avoid merging game save subdirs, too
        child_of_extant_dir = False
        for dir_ in extant_dirs:
            if dir_ in dst_dir:
                child_of_extant_dir = True
                break
        if child_of_extant_dir:
            continue

        #we only want to copy into directories which don't already exist. games
        #may not react well to two save directory instances being merged.
        if not file_exists(dst_dir, follow_symlinks=True) or os.path.samefile(dst_dir, dst):
            makedirs(dst_dir)
            for dir_ in dirs:
                src_file = os.path.join(src_dir, dir_)
                dst_file = os.path.join(dst_dir, dir_)
                if os.path.islink(src_file) and not file_exists(dst_file, follow_symlinks=True):
                    try_copy(src_file, dst_file, copy_metadata=True, follow_symlinks=False)
            for file_ in files:
                src_file = os.path.join(src_dir, file_)
                dst_file = os.path.join(dst_dir, file_)
                if not file_exists(dst_file, follow_symlinks=True):
                    try_copy(src_file, dst_file, copy_metadata=True, follow_symlinks=False)
        else:
            extant_dirs += dst_dir

def try_copy(src, dst, prefix=None, add_write_perm=True, copy_metadata=False, optional=False,
             follow_symlinks=True, track_file=None, link_debug=False):
    try:
        if prefix is not None:
            dst = os.path.join(prefix, dst)

        if os.path.isdir(dst):
            dst = os.path.join(dst, os.path.basename(src))

        if file_exists(dst, follow_symlinks=False):
            os.remove(dst)
        elif track_file and prefix is not None:
            track_file.write(os.path.relpath(dst, prefix) + '\n')

        if os.path.islink(src) and not follow_symlinks:
            shutil.copyfile(src, dst, follow_symlinks=False)
        else:
            copyfile(src, dst)

        if copy_metadata:
            shutil.copystat(src, dst, follow_symlinks=follow_symlinks)
        else:
            shutil.copymode(src, dst, follow_symlinks=follow_symlinks)

        if add_write_perm:
            new_mode = os.lstat(dst).st_mode | stat.S_IWUSR | stat.S_IWGRP
            os.chmod(dst, new_mode)

        if not file_exists(src + '.debug', follow_symlinks=True):
            link_debug = False

        if file_exists(dst + '.debug', follow_symlinks=False):
            os.remove(dst + '.debug')
        elif link_debug and track_file:
            track_file.write(os.path.relpath(dst + '.debug', prefix) + '\n')

        if link_debug:
            os.symlink(src + '.debug', dst + '.debug')

    except FileNotFoundError as e:
        if optional:
            log('Error while copying to \"' + dst + '\": ' + e.strerror)
        else:
            raise

    except PermissionError as e:
        if e.errno == errno.EPERM:
            #be forgiving about permissions errors; if it's a real problem, things will explode later anyway
            log('Error while copying to \"' + dst + '\": ' + e.strerror)
        else:
            raise

# copy_file_range implementation for old Python versions
__syscall__copy_file_range = None

def copy_file_range_ctypes(fd_in, fd_out, count):
    "Copy data using the copy_file_range syscall through ctypes, assuming x86_64 Linux"
    global __syscall__copy_file_range
    __NR_copy_file_range = 326

    if __syscall__copy_file_range is None:
        c_int64_p = POINTER(c_int64)
        prototype = CFUNCTYPE(c_ssize_t, c_long, c_int, c_int64_p,
            c_int, c_int64_p, c_size_t, c_uint, use_errno=True)
        __syscall__copy_file_range = prototype(('syscall', CDLL(None, use_errno=True)))

    while True:
        ret = __syscall__copy_file_range(__NR_copy_file_range, fd_in, None, fd_out, None, count, 0)
        if ret >= 0 or get_errno() != errno.EINTR:
            break

    if ret < 0:
        raise OSError(get_errno(), errno.errorcode.get(get_errno(), 'unknown'))

    return ret

def copyfile_reflink(srcname, dstname):
    "Copy srcname to dstname, making reflink if possible"
    global copyfile
    with open(srcname, 'rb', buffering=0) as src:
        bytes_to_copy = os.fstat(src.fileno()).st_size
        try:
            with open(dstname, 'wb', buffering=0) as dst:
                while bytes_to_copy > 0:
                    bytes_to_copy -= copy_file_range(src.fileno(), dst.fileno(), bytes_to_copy)
        except OSError as e:
            if e.errno not in (errno.EXDEV, errno.ENOSYS, errno.EINVAL, errno.EOPNOTSUPP):
                raise e
            if e.errno == errno.ENOSYS or e.errno == errno.EOPNOTSUPP:
                copyfile = shutil.copyfile
            shutil.copyfile(srcname, dstname)

if hasattr(os, 'copy_file_range'):
    copyfile = copyfile_reflink
    copy_file_range = os.copy_file_range
elif sys.platform == 'linux' and platform.machine() == 'x86_64' and sizeof(c_void_p) == 8:
    copyfile = copyfile_reflink
    copy_file_range = copy_file_range_ctypes
else:
    copyfile = shutil.copyfile

def try_copyfile(src, dst):
    try:
        if os.path.isdir(dst):
            dst = dst + "/" + os.path.basename(src)
        if file_exists(dst, follow_symlinks=False):
            os.remove(dst)
        copyfile(src, dst)
    except PermissionError as e:
        if e.errno == errno.EPERM:
            #be forgiving about permissions errors; if it's a real problem, things will explode later anyway
            log('Error while copying to \"' + dst + '\": ' + e.strerror)
        else:
            raise

def getmtimestr(*path_fragments):
    path = os.path.join(*path_fragments)
    try:
        return str(os.path.getmtime(path))
    except IOError:
        return "0"

def try_get_game_library_dir():
    if "STEAM_COMPAT_INSTALL_PATH" not in g_session.env or \
            "STEAM_COMPAT_LIBRARY_PATHS" not in g_session.env:
        return None

    #find library path which is a subset of the game path
    library_paths = g_session.env["STEAM_COMPAT_LIBRARY_PATHS"].split(":")
    for path in library_paths:
        if path in g_session.env["STEAM_COMPAT_INSTALL_PATH"]:
            return path

    return None

def try_get_steam_dir():
    if "STEAM_COMPAT_CLIENT_INSTALL_PATH" not in g_session.env:
        return None

    return g_session.env["STEAM_COMPAT_CLIENT_INSTALL_PATH"]

def setup_dir_drive(compat_option, drive_name, dest_dir):
        drive_path = g_compatdata.prefix_dir + "dosdevices/" + drive_name
        if compat_option in g_session.compat_config:
            if not dest_dir:
                if file_exists(drive_path, follow_symlinks=False):
                    os.remove(drive_path)
            else:
                if file_exists(drive_path, follow_symlinks=False):
                    cur_tgt = os.readlink(drive_path)
                    if cur_tgt != dest_dir:
                        os.remove(drive_path)
                        os.symlink(dest_dir, drive_path)
                else:
                    os.symlink(dest_dir, drive_path)
        elif file_exists(drive_path, follow_symlinks=False):
            os.remove(drive_path)

def setup_game_dir_drive():
        setup_dir_drive("gamedrive", "s:", try_get_game_library_dir())

def setup_steam_dir_drive():
        setup_dir_drive("steamdrive", "t:", try_get_steam_dir())

# Function to find the installed location of DLL files for use by Wine/Proton
# from the NVIDIA Linux driver
#
# See https://gitlab.steamos.cloud/steamrt/steam-runtime-tools/-/issues/71 for
# background on the chosen method of DLL discovery.
#
# On success, returns a str() of the absolute-path to the directory at which DLL
# files are stored
#
# On failure, returns None
def find_nvidia_wine_dll_dir():
    try:
        libdl = CDLL("libdl.so.2")
    except (OSError):
        return None

    try:
        libglx_nvidia = CDLL("libGLX_nvidia.so.0")
    except OSError:
        return None

    # from dlinfo(3)
    #
    # struct link_map {
    #     ElfW(Addr) l_addr;  /* Difference between the
    #                            address in the ELF file and
    #                            the address in memory */
    #     char      *l_name;  /* Absolute pathname where
    #                            object was found */
    #     ElfW(Dyn) *l_ld;    /* Dynamic section of the
    #                            shared object */
    #     struct link_map *l_next, *l_prev;
    #                         /* Chain of loaded objects */
    #
    #     /* Plus additional fields private to the
    #        implementation */
    # };
    RTLD_DI_LINKMAP = 2
    class link_map(Structure):
        _fields_ = [("l_addr", c_void_p), ("l_name", c_char_p), ("l_ld", c_void_p)]

    # from dlinfo(3)
    #
    # int dlinfo (void *restrict handle, int request, void *restrict info)
    dlinfo_func = libdl.dlinfo
    dlinfo_func.argtypes = c_void_p, c_int, c_void_p
    dlinfo_func.restype = c_int

    # Allocate a link_map object
    glx_nvidia_info_ptr = POINTER(link_map)()

    # Run dlinfo(3) on the handle to libGLX_nvidia.so.0, storing results at the
    # address represented by glx_nvidia_info_ptr
    if dlinfo_func(libglx_nvidia._handle,
                   RTLD_DI_LINKMAP,
                   addressof(glx_nvidia_info_ptr)) != 0:
        return None

    # Grab the contents our of our pointer
    glx_nvidia_info = cast(glx_nvidia_info_ptr, POINTER(link_map)).contents

    # Decode the path to our library to a str()
    if glx_nvidia_info.l_name is None:
        return None
    try:
        libglx_nvidia_path = os.fsdecode(glx_nvidia_info.l_name)
    except UnicodeDecodeError:
        return None

    # Follow any symlinks to the actual file
    libglx_nvidia_realpath = os.path.realpath(libglx_nvidia_path)

    # Go to the relative path ./nvidia/wine from our library
    nvidia_wine_dir = os.path.join(os.path.dirname(libglx_nvidia_realpath), "nvidia", "wine")

    # Check that nvngx.dll exists here, or fail
    if file_exists(os.path.join(nvidia_wine_dir, "nvngx.dll"), follow_symlinks=True):
        return nvidia_wine_dir

    return None

EXT2_IOC_GETFLAGS = 0x80086601
EXT2_IOC_SETFLAGS = 0x40086602

EXT4_CASEFOLD_FL = 0x40000000

def set_dir_casefold_bit(dir_path):
    dr = os.open(dir_path, 0o644)
    if dr < 0:
        return
    try:
        dat = array.array('I', [0])
        if fcntl.ioctl(dr, EXT2_IOC_GETFLAGS, dat, True) >= 0:
            dat[0] = dat[0] | EXT4_CASEFOLD_FL
            fcntl.ioctl(dr, EXT2_IOC_SETFLAGS, dat, False)
    except (OSError, IOError):
        #no problem
        pass
    os.close(dr)

class Proton:
    def __init__(self, base_dir):
        self.base_dir = base_dir + "/"
        self.dist_dir = self.path("files/")
        self.bin_dir = self.path("files/bin/")
        self.lib_dir = self.path("files/lib/")
        self.lib64_dir = self.path("files/lib64/")
        self.fonts_dir = self.path("files/share/fonts/")
        self.media_dir = self.path("files/share/media/")
        self.wine_fonts_dir = self.path("files/share/wine/fonts/")
        self.wine_inf = self.path("files/share/wine/wine.inf")
        self.version_file = self.path("version")
        self.default_pfx_dir = self.path("files/share/default_pfx/")
        self.user_settings_file = self.path("user_settings.py")
        self.wine_bin = self.bin_dir + "wine"
        self.wine64_bin = self.bin_dir + "wine64"
        self.wineserver_bin = self.bin_dir + "wineserver"
        self.dist_lock = FileLock(self.path("dist.lock"), timeout=-1)

    def path(self, d):
        return self.base_dir + d

    def cleanup_legacy_dist(self):
        old_dist_dir = self.path("dist/")
        if file_exists(old_dist_dir, follow_symlinks=True):
            with self.dist_lock:
                if file_exists(old_dist_dir, follow_symlinks=True):
                    shutil.rmtree(old_dist_dir)

    def do_steampipe_fixups(self):
        fixups_json = self.path("steampipe_fixups.json")
        fixups_mtime = self.path("files/steampipe_fixups_mtime")

        if file_exists(fixups_json, follow_symlinks=True):
            with self.dist_lock:
                import steampipe_fixups

                current_fixup_mtime = None
                if file_exists(fixups_mtime, follow_symlinks=True):
                    with open(fixups_mtime, "r") as f:
                        current_fixup_mtime = f.readline().strip()

                new_fixup_mtime = getmtimestr(fixups_json)

                if current_fixup_mtime != new_fixup_mtime:
                    result_code = steampipe_fixups.do_restore(self.base_dir, fixups_json)

                    if result_code == 0:
                        with open(fixups_mtime, "w") as f:
                            f.write(new_fixup_mtime + "\n")

    def missing_default_prefix(self):
        '''Check if the default prefix dir is missing. Returns true if missing, false if present'''
        return not os.path.isdir(self.default_pfx_dir)

    def make_default_prefix(self):
        with self.dist_lock:
            local_env = dict(g_session.env)
            if self.missing_default_prefix():
                #make default prefix
                local_env["WINEPREFIX"] = self.default_pfx_dir
                local_env["WINEDEBUG"] = "-all"
                g_session.run_proc([self.wine_bin, "wineboot"], local_env)
                g_session.run_proc([self.wineserver_bin, "-w"], local_env)

class CompatData:
    def __init__(self, compatdata):
        self.base_dir = compatdata + "/"
        self.prefix_dir = self.path("pfx/")
        self.version_file = self.path("version")
        self.config_info_file = self.path("config_info")
        self.tracked_files_file = self.path("tracked_files")
        self.prefix_lock = FileLock(self.path("pfx.lock"), timeout=-1)

    def path(self, d):
        return self.base_dir + d

    def remove_tracked_files(self):
        if not file_exists(self.tracked_files_file, follow_symlinks=True):
            log("Prefix has no tracked_files??")
            return

        with open(self.tracked_files_file, "r") as tracked_files:
            dirs = []
            for f in tracked_files:
                path = self.prefix_dir + f.strip()
                if file_exists(path, follow_symlinks=False):
                    if os.path.isfile(path) or os.path.islink(path):
                        os.remove(path)
                    else:
                        dirs.append(path)
            for d in dirs:
                try:
                    os.rmdir(d)
                except OSError:
                    #not empty
                    pass

        os.remove(self.tracked_files_file)
        os.remove(self.version_file)

    def upgrade_pfx(self, old_ver):
        if old_ver == CURRENT_PREFIX_VERSION:
            return

        log("Upgrading prefix from " + str(old_ver) + " to " + CURRENT_PREFIX_VERSION + " (" + self.base_dir + ")")

        if old_ver is None:
            return

        if '-' not in old_ver:
            #How can this happen??
            log("Prefix has an invalid version?! You may want to back up user files and delete this prefix.")
            #If it does, just let the Wine upgrade happen and hope it works...
            return

        try:
            old_proton_ver, old_prefix_ver = old_ver.split('-')
            old_proton_maj, old_proton_min = old_proton_ver.split('.')
            new_proton_ver, _              = CURRENT_PREFIX_VERSION.split('-')
            new_proton_maj, new_proton_min = new_proton_ver.split('.')

            if int(new_proton_maj) < int(old_proton_maj) or \
                    (int(new_proton_maj) == int(old_proton_maj) and \
                     int(new_proton_min) < int(old_proton_min)):
                log("Removing newer prefix")
                if old_proton_ver == "3.7" and not file_exists(self.tracked_files_file, follow_symlinks=True):
                    #proton 3.7 did not generate tracked_files, so copy it into place first
                    try_copy(g_proton.path("proton_3.7_tracked_files"), self.tracked_files_file)
                self.remove_tracked_files()
                path = self.prefix_dir + "/drive_c/Program Files (x86)/Ubisoft/Ubisoft Game Launcher/version.txt"
                if file_exists(path, follow_symlinks=False) and os.path.isfile(path):
                    os.remove(path)
                return

            if old_proton_ver == "3.7" and old_prefix_ver == "1":
                if not file_exists(self.prefix_dir + "/drive_c/windows/syswow64/kernel32.dll", follow_symlinks=True):
                    #shipped a busted 64-bit-only installation on 20180822. detect and wipe clean
                    log("Detected broken 64-bit-only installation, re-creating prefix.")
                    shutil.rmtree(self.prefix_dir)
                    return

            #replace broken .NET installations with wine-mono support
            if file_exists(self.prefix_dir + "/drive_c/windows/Microsoft.NET/NETFXRepair.exe", follow_symlinks=True) and \
                    file_is_wine_builtin_dll(self.prefix_dir + "/drive_c/windows/system32/mscoree.dll"):
                log("Broken .NET installation detected, switching to wine-mono.")
                #deleting this directory allows wine-mono to work
                shutil.rmtree(self.prefix_dir + "/drive_c/windows/Microsoft.NET")

            #prior to prefix version 4.11-2, all controllers were xbox controllers. wipe out the old registry entries.
            if (int(old_proton_maj) < 4 or (int(old_proton_maj) == 4 and int(old_proton_min) == 11)) and \
                    int(old_prefix_ver) < 2:
                log("Removing old xinput registry entries.")
                with open(self.prefix_dir + "system.reg", "r") as reg_in:
                    with open(self.prefix_dir + "system.reg.new", "w") as reg_out:
                        for line in reg_in:
                            if line[0] == '[' and "CurrentControlSet" in line and "IG_" in line:
                                if "DeviceClasses" in line:
                                    reg_out.write(line.replace("DeviceClasses", "DeviceClasses_old"))
                                elif "Enum" in line:
                                    reg_out.write(line.replace("Enum", "Enum_old"))
                            else:
                                reg_out.write(line)
                try:
                    os.rename(self.prefix_dir + "system.reg", self.prefix_dir + "system.reg.old")
                except OSError:
                    os.remove(self.prefix_dir + "system.reg")
                    pass

                try:
                    os.rename(self.prefix_dir + "system.reg.new", self.prefix_dir + "system.reg")
                except OSError:
                    log("Unable to write new registry file to " + self.prefix_dir + "system.reg")
                    pass

            # Prior to prefix version 6.3-3, ShellExecute* APIs used DDE.
            # Wipe out old registry entries.
            if int(old_proton_maj) < 6 or (int(old_proton_maj) == 6 and int(old_proton_min) < 3) or \
                    (int(old_proton_maj) == 6 and int(old_proton_min) == 3 and int(old_prefix_ver) < 3):
                delete_keys = {
                    "[Software\\\\Classes\\\\htmlfile\\\\shell\\\\open\\\\ddeexec",
                    "[Software\\\\Classes\\\\pdffile\\\\shell\\\\open\\\\ddeexec",
                    "[Software\\\\Classes\\\\xmlfile\\\\shell\\\\open\\\\ddeexec",
                    "[Software\\\\Classes\\\\ftp\\\\shell\\\\open\\\\ddeexec",
                    "[Software\\\\Classes\\\\http\\\\shell\\\\open\\\\ddeexec",
                    "[Software\\\\Classes\\\\https\\\\shell\\\\open\\\\ddeexec",
                }
                dde_wb = '@="\\"C:\\\\windows\\\\system32\\\\winebrowser.exe\\" -nohome"'

                sysreg_fp = self.prefix_dir + "system.reg"
                new_sysreg_fp = self.prefix_dir + "system.reg.new"

                log("Removing ShellExecute DDE registry entries.")

                with open(sysreg_fp, "r") as reg_in:
                    with open(new_sysreg_fp, "w") as reg_out:
                        for line in reg_in:
                            if line[:line.find("ddeexec")+len("ddeexec")] in delete_keys:
                                reg_out.write(line.replace("ddeexec", "ddeexec_old", 1))
                            elif line.rstrip() == dde_wb:
                                reg_out.write(line.replace("-nohome", "%1"))
                            else:
                                reg_out.write(line)

                # Slightly randomize backup file name to avoid colliding with
                # other backups.
                backup_sysreg_fp = "{}system.reg.{:x}.old".format(self.prefix_dir, randrange(16 ** 8))

                try:
                    os.rename(sysreg_fp, backup_sysreg_fp)
                except OSError:
                    log("Failed to back up old system.reg. Simply deleting it.")
                    os.remove(sysreg_fp)
                    pass

                try:
                    os.rename(new_sysreg_fp, sysreg_fp)
                except OSError:
                    log("Unable to write new registry file to " + sysreg_fp)
                    pass

            stale_builtins = [self.prefix_dir + "/drive_c/windows/system32/amd_ags_x64.dll",
                              self.prefix_dir + "/drive_c/windows/syswow64/amd_ags_x64.dll",
                              self.prefix_dir + "/drive_c/windows/system32/ir50_32.dll",
                              self.prefix_dir + "/drive_c/windows/syswow64/ir50_32.dll" ]
            for builtin in stale_builtins:
                if file_exists(builtin, follow_symlinks=False) and file_is_wine_builtin_dll(builtin):
                    log("Removing stale builtin " + builtin)
                    os.remove(builtin)

        except ValueError:
            log("Prefix has an invalid version?! You may want to back up user files and delete this prefix.")
            #Just let the Wine upgrade happen and hope it works...
            return

    def pfx_copy(self, src, dst, dll_copy=False):
        if os.path.islink(src):
            contents = os.readlink(src)
            if os.path.dirname(contents).endswith(('/lib/wine/i386-unix', '/lib/wine/i386-windows', '/lib64/wine/x86_64-unix', '/lib64/wine/x86_64-windows')):
                # wine builtin dll
                # make the destination an absolute symlink
                contents = os.path.normpath(os.path.join(os.path.dirname(src), contents))
            if dll_copy:
                try_copyfile(src, dst)
            else:
                os.symlink(contents, dst)
        else:
            try_copyfile(src, dst)

    def copy_pfx(self):
        with open(self.tracked_files_file, "w") as tracked_files:
            for src_dir, dirs, files in os.walk(g_proton.default_pfx_dir):
                rel_dir = src_dir.replace(g_proton.default_pfx_dir, "", 1).lstrip('/')
                if len(rel_dir) > 0:
                    rel_dir = rel_dir + "/"
                dst_dir = src_dir.replace(g_proton.default_pfx_dir, self.prefix_dir, 1)
                if not file_exists(dst_dir, follow_symlinks=True):
                    makedirs(dst_dir)
                    tracked_files.write(rel_dir + "\n")
                for dir_ in dirs:
                    src_file = os.path.join(src_dir, dir_)
                    dst_file = os.path.join(dst_dir, dir_)
                    if os.path.islink(src_file) and not file_exists(dst_file, follow_symlinks=True):
                        self.pfx_copy(src_file, dst_file)
                for file_ in files:
                    src_file = os.path.join(src_dir, file_)
                    dst_file = os.path.join(dst_dir, file_)
                    if not file_exists(dst_file, follow_symlinks=True):
                        self.pfx_copy(src_file, dst_file)
                        tracked_files.write(rel_dir + file_ + "\n")
        # Set .update-timestamp so Wine doesn't try to update the prefix.
        # This is needed in case the mtime of wine.inf has changed in distribution.
        with open(os.path.join(self.prefix_dir, '.update-timestamp'), 'w') as update_timestamp:
            mtime = int(os.stat(g_proton.wine_inf).st_mtime)
            update_timestamp.write(str(mtime))

    def update_builtin_libs(self, dll_copy_patterns):
        dll_copy_patterns = dll_copy_patterns.split(',')
        prev_tracked_files = set()
        with open(self.tracked_files_file, "r") as tracked_files:
            for line in tracked_files:
                prev_tracked_files.add(line.strip())
        with open(self.tracked_files_file, "a") as tracked_files:
            for src_dir, _, files in os.walk(g_proton.default_pfx_dir):
                rel_dir = src_dir.replace(g_proton.default_pfx_dir, "", 1).lstrip('/')
                if len(rel_dir) > 0:
                    rel_dir = rel_dir + "/"
                dst_dir = src_dir.replace(g_proton.default_pfx_dir, self.prefix_dir, 1)
                if not file_exists(dst_dir, follow_symlinks=True):
                    makedirs(dst_dir)
                    tracked_files.write(rel_dir + "\n")
                for file_ in files:
                    src_file = os.path.join(src_dir, file_)
                    dst_file = os.path.join(dst_dir, file_)
                    if not file_is_wine_builtin_dll(src_file):
                        # Not a builtin library
                        continue
                    if file_is_wine_builtin_dll(dst_file):
                        os.unlink(dst_file)
                    elif file_exists(dst_file, follow_symlinks=False):
                        # builtin library was replaced
                        continue
                    else:
                        os.makedirs(dst_dir, exist_ok=True)
                    dll_copy = any(fnmatch.fnmatch(file_, pattern) for pattern in dll_copy_patterns)
                    self.pfx_copy(src_file, dst_file, dll_copy)
                    tracked_name = rel_dir + file_
                    if tracked_name not in prev_tracked_files:
                        tracked_files.write(tracked_name + "\n")

    def create_symlink(self, lname, fname):
        if file_exists(lname, follow_symlinks=False):
            if os.path.islink(lname):
                os.remove(lname)
                os.symlink(fname, lname)
        else:
            os.symlink(fname, lname)

    def create_fonts_symlinks(self):
        ALTERNATIVES = {
            ('1313860', 'arial.ttf'),    # FIFA 21
            ('1506830', 'arial.ttf'),    # FIFA 22
        }
        windowsfonts = self.prefix_dir + "/drive_c/windows/Fonts"
        makedirs(windowsfonts)
        sgi = os.environ.get('SteamGameId', '')
        for fonts_dir in [g_proton.fonts_dir, g_proton.wine_fonts_dir]:
            for font in os.listdir(fonts_dir):
                if not font.endswith('.ttf') and not font.endswith('.ttc'):
                    continue
                lname = os.path.join(windowsfonts, font)
                fname = os.path.join(fonts_dir, font)
                if (sgi, font) in ALTERNATIVES:
                    fname = os.path.join(fonts_dir, 'alt', font)
                self.create_symlink(lname, fname)

    def migrate_user_paths(self):
        #move winxp-style paths to vista+ paths. we can't do this in
        #upgrade_pfx because Steam may drop cloud files here at any time.
        for (old, new, link) in \
                [
                    ("drive_c/users/steamuser/Local Settings/Application Data",
                        self.prefix_dir + "drive_c/users/steamuser/AppData/Local",
                        "../AppData/Local"),
                    ("drive_c/users/steamuser/Application Data",
                        self.prefix_dir + "drive_c/users/steamuser/AppData/Roaming",
                        "./AppData/Roaming"),
                    ("drive_c/users/steamuser/My Documents",
                        self.prefix_dir + "drive_c/users/steamuser/Documents",
                        "./Documents"),
                ]:

            #running unofficial Proton/Wine builds against a Proton prefix could
            #create an infinite symlink loop. detect this and clean it up.
            if file_exists(new, follow_symlinks=False) and os.path.islink(new) and os.readlink(new).endswith(old):
                os.remove(new)

            old = self.prefix_dir + old

            if file_exists(old, follow_symlinks=False) and not os.path.islink(old):
                merge_user_dir(src=old, dst=new)
                os.rename(old, old + " BACKUP")
            if not file_exists(old, follow_symlinks=False):
                makedirs(os.path.dirname(old))
                os.symlink(src=link, dst=old)
            elif os.path.islink(old) and not (os.readlink(old) == link):
                os.remove(old)
                os.symlink(src=link, dst=old)

    def setup_prefix(self):
        with self.prefix_lock:
            if file_exists(self.version_file, follow_symlinks=True):
                with open(self.version_file, "r") as f:
                    old_ver = f.readline().strip()
            else:
                old_ver = None

            self.upgrade_pfx(old_ver)

            if not file_exists(self.prefix_dir, follow_symlinks=True):
                makedirs(self.prefix_dir + "/drive_c")
                set_dir_casefold_bit(self.prefix_dir + "/drive_c")

            if not file_exists(self.prefix_dir + "/user.reg", follow_symlinks=True):
                self.copy_pfx()

            self.migrate_user_paths()

            if not file_exists(self.prefix_dir + "/dosdevices/c:", follow_symlinks=False):
                os.symlink("../drive_c", self.prefix_dir + "/dosdevices/c:")

            if not file_exists(self.prefix_dir + "/dosdevices/z:", follow_symlinks=False):
                os.symlink("/", self.prefix_dir + "/dosdevices/z:")

            # collect configuration info
            steamdir = os.environ["STEAM_COMPAT_CLIENT_INSTALL_PATH"]

            use_wined3d = "wined3d" in g_session.compat_config
            use_dxvk_dxgi = not use_wined3d and \
                    not ("WINEDLLOVERRIDES" in g_session.env and "dxgi=b" in g_session.env["WINEDLLOVERRIDES"])
            use_nvapi = 'disablenvapi' not in g_session.compat_config or 'forcenvapi' in g_session.compat_config
            use_dxvk_d3d8 = "dxvkd3d8" in g_session.compat_config

            builtin_dll_copy = os.environ.get("PROTON_DLL_COPY",
                    #dxsetup redist
                    "d3dcompiler_*.dll," +
                    "d3dcsx*.dll," +
                    "d3dx*.dll," +
                    "dx8vb.dll," +
                    "x3daudio*.dll," +
                    "xactengine*.dll," +
                    "xapofx*.dll," +
                    "xaudio*.dll," +
                    "xinput*.dll," +

                    #vcruntime redist
                    "atl*.dll," +
                    "concrt*.dll," +
                    "msvcp*.dll," +
                    "msvcr*.dll," +
                    "msvcm*.dll," +
                    "vcamp1*.dll," +
                    "vcomp1*.dll," +
                    "vccorlib1*.dll," +
                    "vcruntime1*.dll," +

                    #some games balk at ntdll symlink(?)
                    "ntdll.dll," +

                    #some games require official vulkan loader
                    "vulkan-1.dll," +

                    #let the games install native
                    "ir50_32.dll"
                    )

            # If any of this info changes, we must rerun the tasks below
            prefix_info = '\n'.join((
                CURRENT_PREFIX_VERSION,
                g_proton.fonts_dir,
                g_proton.lib_dir,
                g_proton.lib64_dir,
                steamdir,
                getmtimestr(steamdir, 'legacycompat', 'steamclient.dll'),
                getmtimestr(steamdir, 'legacycompat', 'steamclient64.dll'),
                getmtimestr(steamdir, 'legacycompat', 'Steam.dll'),
                g_proton.default_pfx_dir,
                getmtimestr(g_proton.default_pfx_dir, 'system.reg'),
                str(use_wined3d),
                str(use_dxvk_dxgi),
                builtin_dll_copy,
                str(use_nvapi),
                str(use_dxvk_d3d8),
            ))

            # check whether any prefix config has changed
            try:
                with open(self.config_info_file, "r") as f:
                    old_prefix_info = f.read()
            except IOError:
                old_prefix_info = ""

            if old_ver != CURRENT_PREFIX_VERSION or old_prefix_info != prefix_info:
                # update builtin dll symlinks or copies
                self.update_builtin_libs(builtin_dll_copy)

                with open(self.config_info_file, "w") as f:
                    f.write(prefix_info)

            with open(self.version_file, "w") as f:
                f.write(CURRENT_PREFIX_VERSION + "\n")

            #create font files symlinks
            self.create_fonts_symlinks()

            with open(self.tracked_files_file, "a") as tracked_files:
                #copy steam files into place
                steam_dir = "drive_c/Program Files (x86)/Steam/"
                makedirs(self.prefix_dir + steam_dir)
                filestocopy = [("steamclient.dll", "steamclient.dll"),
                               ("steamclient64.dll", "steamclient64.dll"),
                               ("GameOverlayRenderer64.dll", "GameOverlayRenderer64.dll"),
                               ("SteamService.exe", "steam.exe"),
                               ("Steam.dll", "Steam.dll")]
                for (src,tgt) in filestocopy:
                    srcfile = steamdir + '/legacycompat/' + src
                    if os.path.isfile(srcfile):
                        try_copy(srcfile, steam_dir + tgt, prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)

                filestocopy = [("steamclient64.dll", "steamclient64.dll"),
                               ("GameOverlayRenderer.dll", "GameOverlayRenderer.dll"),
                               ("GameOverlayRenderer64.dll", "GameOverlayRenderer64.dll")]
                for (src,tgt) in filestocopy:
                    srcfile = g_proton.path(src)
                    if os.path.isfile(srcfile):
                        try_copy(srcfile, steam_dir + tgt, prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)

                #copy openvr files into place
                makedirs(self.prefix_dir + "/drive_c/vrclient/bin")
                try_copy(g_proton.lib_dir + "wine/i386-windows/vrclient.dll", "drive_c/vrclient/bin",
                        prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                try_copy(g_proton.lib64_dir + "wine/x86_64-windows/vrclient_x64.dll", "drive_c/vrclient/bin",
                        prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)

                try_copy(g_proton.lib_dir + "wine/dxvk/openvr_api_dxvk.dll", "drive_c/windows/syswow64",
                        prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                try_copy(g_proton.lib64_dir + "wine/dxvk/openvr_api_dxvk.dll", "drive_c/windows/system32",
                        prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)

                makedirs(self.prefix_dir + "/drive_c/openxr")
                try_copy(g_proton.default_pfx_dir + "drive_c/openxr/wineopenxr64.json", "drive_c/openxr",
                        prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)

                #copy vkd3d files into place
                try_copy(g_proton.lib64_dir + "vkd3d/libvkd3d-1.dll", "drive_c/windows/system32",
                        prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                try_copy(g_proton.lib_dir + "vkd3d/libvkd3d-1.dll", "drive_c/windows/syswow64",
                        prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                try_copy(g_proton.lib64_dir + "vkd3d/libvkd3d-shader-1.dll", "drive_c/windows/system32",
                        prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                try_copy(g_proton.lib_dir + "vkd3d/libvkd3d-shader-1.dll", "drive_c/windows/syswow64",
                        prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)

                if use_wined3d:
                    dxvkfiles = []
                    vkd3d_protonfiles = []
                    wined3dfiles = ["d3d12", "d3d11", "d3d10", "d3d10core", "d3d10_1", "d3d9"]
                else:
                    dxvkfiles = ["d3d11", "d3d10core", "d3d9"]
                    vkd3d_protonfiles = ["d3d12", "d3d12core"]
                    wined3dfiles = []

                if use_dxvk_dxgi:
                    dxvkfiles.append("dxgi")
                else:
                    wined3dfiles.append("dxgi")

                if use_dxvk_d3d8:
                    dxvkfiles.append("d3d8")
                else:
                    wined3dfiles.append("d3d8")

                for f in wined3dfiles:
                    try_copy(g_proton.default_pfx_dir + "drive_c/windows/system32/" + f + ".dll", "drive_c/windows/system32",
                            prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                    try_copy(g_proton.default_pfx_dir + "drive_c/windows/syswow64/" + f + ".dll", "drive_c/windows/syswow64",
                            prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)

                for f in dxvkfiles:
                    try_copy(g_proton.lib64_dir + "wine/dxvk/" + f + ".dll", "drive_c/windows/system32",
                            prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                    try_copy(g_proton.lib_dir + "wine/dxvk/" + f + ".dll", "drive_c/windows/syswow64",
                            prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                    g_session.dlloverrides[f] = "n"

                for f in vkd3d_protonfiles:
                    try_copy(g_proton.lib64_dir + "wine/vkd3d-proton/" + f + ".dll", "drive_c/windows/system32",
                            prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                    try_copy(g_proton.lib_dir + "wine/vkd3d-proton/" + f + ".dll", "drive_c/windows/syswow64",
                            prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                    g_session.dlloverrides[f] = "n"

                # If the user requested the NVAPI be available, copy it into place.
                # If they didn't, clean up any stray nvapi DLLs.
                if use_nvapi:
                    try_copy(g_proton.lib64_dir + "wine/nvapi/nvapi64.dll", "drive_c/windows/system32",
                            prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                    try_copy(g_proton.lib_dir + "wine/nvapi/nvapi.dll", "drive_c/windows/syswow64",
                            prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)
                    g_session.dlloverrides["nvapi64"] = "n"
                    g_session.dlloverrides["nvapi"] = "n"
                    g_session.dlloverrides["nvcuda"] = "b"
                else:
                    nvapi64_dll = self.prefix_dir + "drive_c/windows/system32/nvapi64.dll"
                    nvapi32_dll = self.prefix_dir + "drive_c/windows/syswow64/nvapi.dll"
                    if file_exists(nvapi64_dll, follow_symlinks=False):
                        os.unlink(nvapi64_dll)
                    if file_exists(nvapi64_dll + '.debug', follow_symlinks=False):
                        os.unlink(nvapi64_dll + '.debug')
                    if file_exists(nvapi32_dll, follow_symlinks=False):
                        os.unlink(nvapi32_dll)
                    if file_exists(nvapi32_dll + '.debug', follow_symlinks=False):
                        os.unlink(nvapi32_dll + '.debug')

                # Try to detect known DLLs that ship with the NVIDIA Linux Driver
                # and add them into the prefix
                nvidia_wine_dll_dir = find_nvidia_wine_dll_dir()
                if nvidia_wine_dll_dir:
                    for dll in ["_nvngx.dll", "nvngx.dll"]:
                        try_copy(nvidia_wine_dll_dir + "/" + dll, "drive_c/windows/system32", optional=True,
                                 prefix=self.prefix_dir, track_file=tracked_files, link_debug=True)

            setup_game_dir_drive()
            setup_steam_dir_drive()

            # add Steam ffmpeg libraries to path
            use_ffmpeg = "PROTON_NO_STEAM_FFMPEG" not in os.environ or not nonzero(os.environ["PROTON_NO_STEAM_FFMPEG"])
            if use_ffmpeg and 'nosteamffmpeg' not in g_session.compat_config:
                prepend_to_env_str(g_session.env, ld_path_var, steamdir + "/ubuntu12_64/video/:" + steamdir + "/ubuntu12_32/video/", ":")

def comma_escaped(s):
    escaped = False
    idx = -1
    while s[idx] == '\\':
        escaped = not escaped
        idx = idx - 1
    return escaped

#hopefully short-lived, app-specific workarounds for Proton bugs
def default_compat_config():
    ret = set()
    if "SteamAppId" in os.environ:
        appid = os.environ["SteamAppId"]
        if appid in [
                #affected by CW bug 19126
                "536280", #Disintegration
                "707030", #POSTAL 4: No Regerts
                "1331440", #FUSER
                "1359980", #POSTAL: Brain Damaged
                "1766430", #POSTAL Brain Damaged Demo
                "692890", #Roboquest

                #affected by CW bug 19741
                "1017900", #Age of Empires: Definitive Edition

                #CW bug 23986
                "1928420",
                ]:
            ret.add("nomfdxgiman")

        if appid in [
                # OPWR may be causing text input delays in login windows in these games on Wayland due to
                # blit happening before presentation
                "1172620", #Sea of Thieves
                "962130", #Grounded
                "495420", #State of Decay 2: Juggernaut Edition
                "976730", #Halo: The Master Chief Collection
                "1017900", #Age of Empires: Definitive Edition
                "1056090", #Ori and the Will of the Wisps
                "1293830", #Forza Horizon 4
                "1551360", #Forza Horizon 5
                "271590", #Grand Theft Auto V
                "5699", #Grand Theft Auto V Premium Edition
                "1174180", #Red Dead Redemption 2
                "1404210", #Red Dead Online
                "12210", #Grand Theft Auto IV: Complete Edition
                "204100", #Max Payne 3
                "110800", #L.A. Noire
                "12200", #Bully: Scholarship Edition
                "12120", #Grand Theft Auto: San Andreas
                "12110", #Grand Theft Auto: Vice City
                "12100", #Grand Theft Auto III
                "722230", #L.A. Noire: The VR Case Files
                "813780", #Age of Empires II: Definitive Edition
                "933110", #Age of Empires III: Definitive Edition
                "1466860", #Age of Empires IV
                "1097840", #Gears 5
                "1244950", #Battletoads
                "1189800", #Bleeding Edge
                "1184050", #Gears Tactics
                "1240440", #Halo Infinite
                "1250410", #Microsoft Flight Simulator
                "1672970", #Minecraft Dungeons
                "1180660", #Tell Me Why
                "1238430", #Tell Me Why Chapter 2
                "1266670", #Tell Me Why Chapter 3
                # Other issues arising from OWPR code path in apps, e. g., hitting unimplemented bits in
                # d3dcompiler.
                "230410", #Warframe
                ]:
            ret.add("noopwr")

        if appid == "1621680":
            ret.add("noforcelgadd")

        if appid in [
                "257420", #Serious Sam 4
                ]:
            ret.add("hidevggpu")

        if appid in [
                "1341820", #As Dusk falls
                "280790", #Creativerse
                "306130", #The Elder Scrolls Online
                "24010", #Train Simulator
                "374320", #DARK SOULS III
                "65500", #Aura: Fate of the Ages
                "4000", #Garry's Mod
                "383120", #Empyrion - Galactic Survival
                "2371630", #Sword Art Online: Integral Factor
                "460790", #Bayonetta
                "273590", #Descent 3
                "834530", #Yakuza Kiwami
                "714010", #Aimlabs
                "2249070", #Strip Fighter ZERO
                ]:
            ret.add("gamedrive")

        if appid in [
                "202990", #Call of Duty: Black Ops II - Multiplayer
                "212910", #Call of Duty: Black Ops II - Zombies
                "499100", #Dark Parables: The Exiled Prince Collector's Edition (499100)
                "1404090", #Trivia Tricks
                "2052410", #WITCH ON THE HOLY NIGHT
                "789910", #Planet of the Apes: Last Frontier
                ]:
            ret.add("heapdelayfree")

        if appid in [
                "21980", #Call of Juarez: Bound in Blood
                "553850", #Helldivers 2
                "2055290", #Sonic Colors: Ultimate
                ]:
            ret.add("heapzeromemory")

        if appid in [
                "2630", #Call of Duty 2
                "1060210", #Disaster Report 4: Summer Memories
                "414740", #RAID: World War II
                ]:
            ret.add("nofsync")
            ret.add("noesync")

        if appid in [
                # disable dxvknvapi for titles which dislike it
                "1088850", #Marvel's Guardians of the Galaxy
                "1418100", #Swords of Legends Online
                "2080180", #Go Home Annie Demo
                "1939100", #Go Home Annie
                "108710", #Alan Wake
                "435150", #Divinity: Original Sin 2 - Definitive Edition
                "505170", #Carmageddon: Max Damage
                "109600", #Neverwinter
                "9900", #Star Trek Online
                "9880", #Champions Online
                "202750", #Alan Wake's American Nightmare
                "255220", #GRID Autosport
                "44350", #GRID 2
                ]:
            ret.add("disablenvapi")

        if appid in [
                "2395210" #Tony Hawk's Pro Skater 1 + 2
                ]:
            ret.add("forcenvapi")

        if appid in [
                "1252330" #Deathloop
                ]:
            ret.add("hideapu")

    if "STEAM_COMPAT_APP_ID" in os.environ:
        appid = os.environ["STEAM_COMPAT_APP_ID"]
        if appid in [
                "7000", # Tomb Raider: Legend
                "8000", # Tomb Raider: Anniversary
                "22300", # Fallout 3
                "22370", # Fallout 3: Game of the Year Edition
                "72850", # The Elder Scrolls V: Skyrim
                "377160", # Fallout 4
                "397950", # Clustertruck
                "489830", # The Elder Scrolls V: Skyrim Special Edition
                "712180", # Mugsters
                "1818750", # MultiVersus
                ]:
            ret.add("xalia")

        if appid in [
                "255960", #Bad Mojo Redux
                ]:
            ret.add("gamedrive")

    return ret

default_cpu_limit = {
    "19900"     :  16,  # Far Cry 2
    "298110"    :  16,  # Far Cry 4
    "20920"     :  16,  # The Witcher 2: Assassins of Kings Enchanced Edition
    "35130"     :  16,  # Lara Croft and the Guardian of Light
    "55150"     :  16,  # Warhammer 40,000: Space Marine
    "204450"    :  16,  # Call of Juarez: Gunslinger
    "15620"     :  8,   # Warhammer 40,000: Dawn of War II
    "20570"     :  8,   # Warhammer 40,000: Dawn of War II - Chaos Rising
    "56400"     :  8,   # Warhammer 40,000: Dawn of War II - Retribution
    "618970"    :  4,   # Outcast - Second Contact
    "10150"     :  8,   # Prototype
    "2229830"   :  1,   # Command & Conquer and The Covert Operations
}

class Session:
    def __init__(self):
        self.log_file = None
        self.env = dict(os.environ)
        self.dlloverrides = {
                "steam.exe": "b", #always use our special built-in steam.exe
                "dotnetfx35.exe": "b", #replace the broken installer, as does Windows
                "dotnetfx35setup.exe": "b",
                "beclient.dll": "b,n",
                "beclient_x64.dll": "b,n",
        }

        # CW Bug 21737. Locoland executable happens to be steam.exe.
        if os.environ.get("SteamGameId", 0) == "352130":
            del self.dlloverrides["steam.exe"]

        self.compat_config = default_compat_config()
        self.cmdlineappend = []

        if "STEAM_COMPAT_CONFIG" in os.environ:
            config = os.environ["STEAM_COMPAT_CONFIG"]

            while config:
                (cur, _, config) = config.partition(',')
                if cur.startswith("cmdlineappend:"):
                    while comma_escaped(cur):
                        (a, _, c) = config.partition(',')
                        cur = cur[:-1] + ',' + a
                        config = c
                    self.cmdlineappend.append(cur[14:].replace('\\\\','\\'))
                else:
                    self.compat_config.add(cur)

        #turn forcelgadd on by default unless it is disabled in compat config
        if "noforcelgadd" not in self.compat_config:
            self.compat_config.add("forcelgadd")

        appid = os.environ.get("SteamGameId", 0)
        if "PROTON_CPU_TOPOLOGY" in self.env:
            self.env["WINE_CPU_TOPOLOGY"] = self.env["PROTON_CPU_TOPOLOGY"]
        elif appid in default_cpu_limit:
            self.env["WINE_CPU_TOPOLOGY"] = str(default_cpu_limit[appid])

    def init_wine(self):
        if "HOST_LC_ALL" in self.env and len(self.env["HOST_LC_ALL"]) > 0:
            #steam sets LC_ALL=C to help some games, but Wine requires the real value
            #in order to do path conversion between win32 and host. steam sets
            #HOST_LC_ALL to allow us to use the real value.
            self.env["LC_ALL"] = self.env["HOST_LC_ALL"]
        else:
            self.env.pop("LC_ALL", "")

        # CW-Bug-Id: #23185 Enable the new SDL 2.30 Steam Input integration.
        if "SteamVirtualGamepadInfo_Proton" in self.env and "SteamVirtualGamepadInfo" not in self.env:
            self.env["SteamVirtualGamepadInfo"] = self.env["SteamVirtualGamepadInfo_Proton"]

        self.env.pop("WINEARCH", "")

        if 'ORIG_'+ld_path_var not in os.environ:
            # Allow wine to restore this when calling an external app.
            self.env['ORIG_'+ld_path_var] = os.environ.get(ld_path_var, '')

        prepend_to_env_str(self.env, ld_path_var, g_proton.lib64_dir + ":" + g_proton.lib_dir, ":")

        self.env["WINEDLLPATH"] = g_proton.lib64_dir + "/wine:" + g_proton.lib_dir + "/wine"

        self.env["GST_PLUGIN_SYSTEM_PATH_1_0"] = g_proton.lib64_dir + "gstreamer-1.0" + ":" + g_proton.lib_dir + "gstreamer-1.0"
        self.env["WINE_GST_REGISTRY_DIR"] = g_compatdata.path("gstreamer-1.0/")

        if "STEAM_COMPAT_MEDIA_PATH" in os.environ:
            old_audiofoz_path = os.environ["STEAM_COMPAT_MEDIA_PATH"] + "/audio.foz"
            if file_exists(old_audiofoz_path, follow_symlinks=False):
                os.remove(old_audiofoz_path)
            self.env["MEDIACONV_AUDIO_DUMP_FILE"] = os.environ["STEAM_COMPAT_MEDIA_PATH"] + "/audiov2.foz"
            self.env["MEDIACONV_VIDEO_DUMP_FILE"] = os.environ["STEAM_COMPAT_MEDIA_PATH"] + "/video.foz"

        if "STEAM_COMPAT_TRANSCODED_MEDIA_PATH" in os.environ:
            self.env["MEDIACONV_AUDIO_TRANSCODED_FILE"] = os.environ["STEAM_COMPAT_TRANSCODED_MEDIA_PATH"] + "/transcoded_audio.foz"
            self.env["MEDIACONV_VIDEO_TRANSCODED_FILE"] = os.environ["STEAM_COMPAT_TRANSCODED_MEDIA_PATH"] + "/transcoded_video.foz"

        self.env["MEDIACONV_BLANK_VIDEO_FILE"] = g_proton.media_dir + "blank.mkv"
        self.env["MEDIACONV_BLANK_AUDIO_FILE"] = g_proton.media_dir + "blank.ptna"

        prepend_to_env_str(self.env, "PATH", g_proton.bin_dir, ":")

    def check_environment(self, env_name, config_name):
        if env_name not in self.env:
            return False
        if nonzero(self.env[env_name]):
            self.compat_config.add(config_name)
        else:
            self.compat_config.discard(config_name)
        return True

    def try_log_slr_versions(self):
        try:
            if "PRESSURE_VESSEL_RUNTIME_BASE" in self.env:
                with open(self.env["PRESSURE_VESSEL_RUNTIME_BASE"] + "/VERSIONS.txt", "r") as f:
                    for line in f:
                        line = line.strip()
                        if len(line) > 0 and not line.startswith("#"):
                            cleaned = line.split("#")[0].strip().replace("\t", " ")
                            split = cleaned.split(" ", maxsplit=1)
                            self.log_file.write(split[0] + ": " + split[1] + "\n")
        except (OSError, IOError, TypeError, KeyError):
            pass

    def setup_logging(self, *, append_forever):
        basedir = self.env.get("PROTON_LOG_DIR", os.environ["HOME"])

        if append_forever:
            #SteamGameId is not always available
            lfile_path = basedir + "/steam-proton.log"
        else:
            if "SteamGameId" not in os.environ:
                return False

            lfile_path = basedir + "/steam-" + os.environ["SteamGameId"] + ".log"

            if file_exists(lfile_path, follow_symlinks=False):
                os.remove(lfile_path)

        makedirs(basedir)
        self.log_file = open(lfile_path, "a")
        return True

    def init_session(self, update_prefix_files):
        self.env["WINEPREFIX"] = g_compatdata.prefix_dir

        #load environment overrides
        used_user_settings = {}
        if file_exists(g_proton.user_settings_file, follow_symlinks=True):
            try:
                import user_settings # pyright: ignore [reportMissingImports]
                for key, value in user_settings.user_settings.items():
                    if key not in self.env:
                        self.env[key] = value
                        used_user_settings[key] = value
            except Exception:
                log("************************************************")
                log("THERE IS AN ERROR IN YOUR user_settings.py FILE:")
                log("%s" % sys.exc_info()[1])
                log("************************************************")

        if "PROTON_LOG" in self.env and nonzero(self.env["PROTON_LOG"]):
            self.env.setdefault("WINEDEBUG", "+timestamp,+pid,+tid,+seh,+unwind,+threadname,+debugstr,+loaddll,+mscoree")
            self.env.setdefault("DXVK_LOG_LEVEL", "info")
            self.env.setdefault("DXVK_NVAPI_LOG_LEVEL", "info")
            self.env.setdefault("VKD3D_DEBUG", "warn")
            self.env.setdefault("VKD3D_SHADER_DEBUG", "fixme")
            self.env.setdefault("WINE_MONO_TRACE", "E:System.NotImplementedException")

            if self.env["PROTON_LOG"] != "1":
                append_to_env_str(self.env, "WINEDEBUG", self.env["PROTON_LOG"], ",")

        #for performance, logging is disabled by default; override with user_settings.py
        self.env.setdefault("WINEDEBUG", "-all")
        self.env.setdefault("DXVK_LOG_LEVEL", "none")
        self.env.setdefault("VKD3D_DEBUG", "none")
        self.env.setdefault("VKD3D_SHADER_DEBUG", "none")

        #disable XIM support until libx11 >= 1.7 is widespread
        self.env.setdefault("WINE_ALLOW_XIM", "0")

        if "wined3d11" in self.compat_config:
            self.compat_config.add("wined3d")

        if not self.check_environment("PROTON_USE_WINED3D", "wined3d"):
            self.check_environment("PROTON_USE_WINED3D11", "wined3d")
        self.check_environment("PROTON_DXVK_D3D8", "dxvkd3d8")
        self.check_environment("PROTON_NO_D3D11", "nod3d11")
        self.check_environment("PROTON_NO_D3D10", "nod3d10")
        self.check_environment("PROTON_NO_ESYNC", "noesync")
        self.check_environment("PROTON_NO_FSYNC", "nofsync")
        self.check_environment("PROTON_FORCE_LARGE_ADDRESS_AWARE", "forcelgadd")
        self.check_environment("PROTON_OLD_GL_STRING", "oldglstr")
        self.check_environment("PROTON_HIDE_NVIDIA_GPU", "hidenvgpu")
        self.check_environment("PROTON_HIDE_VANGOGH_GPU", "hidevggpu")
        self.check_environment("PROTON_SET_GAME_DRIVE", "gamedrive")
        self.check_environment("PROTON_SET_STEAM_DRIVE", "steamdrive")
        self.check_environment("PROTON_NO_XIM", "noxim")
        self.check_environment("PROTON_HEAP_DELAY_FREE", "heapdelayfree")
        self.check_environment("PROTON_HEAP_ZERO_MEMORY", "heapzeromemory")
        self.check_environment("PROTON_DISABLE_NVAPI", "disablenvapi")
        self.check_environment("PROTON_FORCE_NVAPI", "forcenvapi")
        self.check_environment("PROTON_HIDE_APU", "hideapu")

        if "noesync" in self.compat_config:
            self.env.pop("WINEESYNC", "")
        else:
            self.env["WINEESYNC"] = "1"

        if "noxim" not in self.compat_config:
            self.env.pop("WINE_ALLOW_XIM")

        if "nofsync" in self.compat_config:
            self.env.pop("WINEFSYNC", "")
        else:
            self.env["WINEFSYNC"] = "1"

        if "oldglstr" in self.compat_config:
            #mesa override
            self.env["MESA_EXTENSION_MAX_YEAR"] = "2003"
            #nvidia override
            self.env["__GL_ExtensionStringVersion"] = "17700"

        if os.environ.get("SteamGameId", 0) == "444930":
            self.env["MESA_EXTENSION_OVERRIDE"] = "-GL_ARB_bindless_texture"

        if os.environ.get("SteamGameId", 0) == "500810":
            self.dlloverrides["ddraw"] = "n,b"

        if "forcelgadd" in self.compat_config:
            self.env["WINE_LARGE_ADDRESS_AWARE"] = "1"
        else:
            if "noforcelgadd" in self.compat_config:
                self.env["WINE_LARGE_ADDRESS_AWARE"] = "0"

        if "heapdelayfree" in self.compat_config:
            self.env["WINE_HEAP_DELAY_FREE"] = "1"

        if "heapzeromemory" in self.compat_config:
            self.env["WINE_HEAP_ZERO_MEMORY"] = "1"

        if "vkd3dbindlesstb" in self.compat_config:
            append_to_env_str(self.env, "VKD3D_CONFIG", "force_bindless_texel_buffer", ",")

        if "vkd3dfl12" in self.compat_config:
            if "VKD3D_FEATURE_LEVEL" not in self.env:
                self.env["VKD3D_FEATURE_LEVEL"] = "12_0"

        if "hidevggpu" in self.compat_config:
            self.env["WINE_HIDE_VANGOGH_GPU"] = "1"

        if "hidenvgpu" in self.compat_config and "forcenvapi" not in self.compat_config:
            self.env["WINE_HIDE_NVIDIA_GPU"] = "1"

        if "hideapu" in self.compat_config:
            self.env["WINE_HIDE_APU"] = "1"

        if "usenativexinput13" in self.compat_config:
            self.dlloverrides["xinput1_3"] = "n"

        if "disablelibglesv2" in self.compat_config:
            self.dlloverrides["libglesv2"] = "d"

        if "nomfdxgiman" in self.compat_config:
            self.env["WINE_DO_NOT_CREATE_DXGI_DEVICE_MANAGER"] = "1"

        if "noopwr" in self.compat_config:
            self.env["WINE_DISABLE_VULKAN_OPWR"] = "1"

        if "xalia" in self.compat_config and "PROTON_USE_XALIA" not in self.env:
            self.env["PROTON_USE_XALIA"] = "1"

        if "PROTON_CRASH_REPORT_DIR" in self.env:
            self.env["WINE_CRASH_REPORT_DIR"] = self.env["PROTON_CRASH_REPORT_DIR"]

        if "PROTON_LOG" in self.env and nonzero(self.env["PROTON_LOG"]):
            if self.setup_logging(append_forever=False):
                self.log_file.write("======================\n")
                with open(g_proton.version_file, "r") as f:
                    self.log_file.write("Proton: " + f.readline().strip() + "\n")
                if "SteamGameId" in self.env:
                    self.log_file.write("SteamGameId: " + self.env["SteamGameId"] + "\n")
                self.log_file.write("Command: " + str(sys.argv[2:] + self.cmdlineappend) + "\n")
                self.log_file.write("Options: " + str(self.compat_config) + "\n")

                self.try_log_slr_versions()

                try:
                    uname = os.uname()
                    kernel_version = f"{uname.sysname} {uname.release} {uname.version} {uname.machine}"
                except OSError:
                    kernel_version = "unknown"

                self.log_file.write(f"Kernel: {kernel_version}\n")
                self.log_file.write("Language: LC_ALL " + str(self.env.get("HOST_LC_ALL", None)) +
                                    ", LC_MESSAGES " + str(self.env.get("LC_MESSAGES", None)) +
                                    ", LC_CTYPE " + str(self.env.get("LC_CTYPE", None)) + "\n")

                #dump some important variables into the log header
                for var in ["WINEDLLOVERRIDES", "WINEDEBUG"]:
                    if var in os.environ:
                        self.log_file.write("System " + var + ": " + os.environ[var] + "\n")
                    if var in used_user_settings:
                        self.log_file.write("User settings " + var + ": " + used_user_settings[var] + "\n")
                    if var in self.env:
                        self.log_file.write("Effective " + var + ": " + self.env[var] + "\n")

                # check for low fd limit
                _soft_limit, hard_limit = resource.getrlimit(resource.RLIMIT_NOFILE)
                if hard_limit < 524288:
                    self.log_file.write(f"WARNING: Low file descriptor limit: {hard_limit}\n")

                self.log_file.write("======================\n")
                self.log_file.flush()
            else:
                self.env["WINEDEBUG"] = "-all"

        if "PROTON_REMOTE_DEBUG_CMD" in self.env:
            self.remote_debug_cmd = shlex.split(self.env["PROTON_REMOTE_DEBUG_CMD"])
        else:
            self.remote_debug_cmd = None

        if update_prefix_files:
            g_compatdata.setup_prefix()

        if "nod3d11" in self.compat_config:
            self.dlloverrides["d3d11"] = ""
            if "dxgi" in self.dlloverrides:
                del self.dlloverrides["dxgi"]

        if "nod3d10" in self.compat_config:
            self.dlloverrides["d3d10_1"] = ""
            self.dlloverrides["d3d10"] = ""
            self.dlloverrides["dxgi"] = ""

        if "nativevulkanloader" in self.compat_config:
            self.dlloverrides["vulkan-1"] = "n"

        if "disablenvapi" not in self.compat_config or "forcenvapi" in self.compat_config:
            self.env["DXVK_ENABLE_NVAPI"] = "1"

        if "forcenvapi" in self.compat_config:
            self.env["DXVK_NVAPI_ALLOW_OTHER_DRIVERS"] = "1"
            self.env["DXVK_NVAPI_DRIVER_VERSION"] = "99999"
            self.env["WINE_HIDE_AMD_GPU"] = "1"

        s = ""
        for dll in self.dlloverrides:
            setting = self.dlloverrides[dll]
            if len(s) > 0:
                s = s + ";" + dll + "=" + setting
            else:
                s = dll + "=" + setting
        append_to_env_str(self.env, "WINEDLLOVERRIDES", s, ";")

    def run_proc(self, args, local_env=None):
        if local_env is None:
            local_env = self.env
        return subprocess.call(args, env=local_env, stderr=self.log_file, stdout=self.log_file)

    def run(self):
        if shutil.which('steam-runtime-launcher-interface-0') is not None:
            adverb = ['steam-runtime-launcher-interface-0', 'proton']
        else:
            adverb = []

        if self.remote_debug_cmd:
            remote_debug_cmd = self.remote_debug_cmd
            if not os.path.isabs(remote_debug_cmd[0]):
                remote_debug_cmd[0] = g_proton.path(remote_debug_cmd[0])
            remote_debug_proc = subprocess.Popen([g_proton.wine_bin] + self.remote_debug_cmd,
                                                 env=self.env, stderr=self.log_file, stdout=self.log_file)
        else:
            remote_debug_proc = None

        # CoD: Black Ops 3 workaround
        if os.environ.get("SteamGameId", 0) == "311210":
            argv = [g_proton.wine_bin, "c:\\Program Files (x86)\\Steam\\steam.exe"]
        else:
            argv = [g_proton.wine64_bin, "c:\\windows\\system32\\steam.exe"]

        rc = self.run_proc(adverb + argv + sys.argv[2:] + self.cmdlineappend)

        if remote_debug_proc:
            remote_debug_proc.kill()
            try:
                remote_debug_proc.communicate(timeout=2)
            except subprocess.TimeoutExpired:
                log("terminate remote debugger")
                remote_debug_proc.terminate()
                remote_debug_proc.communicate()

        return rc

if __name__ == "__main__":
    if "STEAM_COMPAT_DATA_PATH" not in os.environ:
        log("No compat data path?")
        sys.exit(1)

    g_proton = Proton(os.path.dirname(sys.argv[0]))

    g_proton.cleanup_legacy_dist()
    g_proton.do_steampipe_fixups()

    g_compatdata = CompatData(os.environ["STEAM_COMPAT_DATA_PATH"])

    g_session = Session()

    g_session.init_wine()

    if g_proton.missing_default_prefix():
        g_proton.make_default_prefix()

    g_session.init_session(sys.argv[1] != "runinprefix")

    #determine mode
    rc = 0
    if sys.argv[1] == "run":
        #start target app
        setup_game_dir_drive()
        setup_steam_dir_drive()
        rc = g_session.run()
    elif sys.argv[1] == "waitforexitandrun":
        #wait for wineserver to shut down
        g_session.run_proc([g_proton.wineserver_bin, "-w"])
        #then run
        rc = g_session.run()
    elif sys.argv[1] == "runinprefix":
        rc = g_session.run_proc([g_proton.wine_bin] + sys.argv[2:])
    elif sys.argv[1] == "destroyprefix":
        g_compatdata.remove_tracked_files()
    elif sys.argv[1] == "getcompatpath":
        #linux -> windows path
        path = subprocess.check_output([g_proton.wine_bin, "winepath", "-w", sys.argv[2]], env=g_session.env, stderr=g_session.log_file)
        sys.stdout.buffer.write(path)
    elif sys.argv[1] == "getnativepath":
        #windows -> linux path
        path = subprocess.check_output([g_proton.wine_bin, "winepath", sys.argv[2]], env=g_session.env, stderr=g_session.log_file)
        sys.stdout.buffer.write(path)
    else:
        log("Need a verb.")
        sys.exit(1)

    sys.exit(rc)

#pylint --disable=C0301,C0326,C0330,C0111,C0103,R0902,C1801,R0914,R0912,R0915
# vim: set syntax=python:
